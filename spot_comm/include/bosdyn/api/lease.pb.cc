// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/lease.proto

#include "bosdyn/api/lease.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2flease_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Lease_bosdyn_2fapi_2flease_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2flease_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2flease_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_LeaseResource_bosdyn_2fapi_2flease_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2flease_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_LeaseUseResult_bosdyn_2fapi_2flease_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fheader_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RequestHeader_bosdyn_2fapi_2fheader_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fheader_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_ResponseHeader_bosdyn_2fapi_2fheader_2eproto;
namespace bosdyn {
namespace api {
class LeaseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Lease> _instance;
} _Lease_default_instance_;
class LeaseOwnerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LeaseOwner> _instance;
} _LeaseOwner_default_instance_;
class LeaseUseResultDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LeaseUseResult> _instance;
} _LeaseUseResult_default_instance_;
class AcquireLeaseRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AcquireLeaseRequest> _instance;
} _AcquireLeaseRequest_default_instance_;
class AcquireLeaseResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AcquireLeaseResponse> _instance;
} _AcquireLeaseResponse_default_instance_;
class TakeLeaseRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TakeLeaseRequest> _instance;
} _TakeLeaseRequest_default_instance_;
class TakeLeaseResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TakeLeaseResponse> _instance;
} _TakeLeaseResponse_default_instance_;
class ReturnLeaseRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ReturnLeaseRequest> _instance;
} _ReturnLeaseRequest_default_instance_;
class ReturnLeaseResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ReturnLeaseResponse> _instance;
} _ReturnLeaseResponse_default_instance_;
class ListLeasesRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ListLeasesRequest> _instance;
} _ListLeasesRequest_default_instance_;
class LeaseResourceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LeaseResource> _instance;
} _LeaseResource_default_instance_;
class ListLeasesResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ListLeasesResponse> _instance;
} _ListLeasesResponse_default_instance_;
class RetainLeaseRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RetainLeaseRequest> _instance;
} _RetainLeaseRequest_default_instance_;
class RetainLeaseResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RetainLeaseResponse> _instance;
} _RetainLeaseResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
static void InitDefaultsscc_info_AcquireLeaseRequest_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_AcquireLeaseRequest_default_instance_;
    new (ptr) ::bosdyn::api::AcquireLeaseRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::AcquireLeaseRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_AcquireLeaseRequest_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_AcquireLeaseRequest_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_RequestHeader_bosdyn_2fapi_2fheader_2eproto.base,}};

static void InitDefaultsscc_info_AcquireLeaseResponse_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_AcquireLeaseResponse_default_instance_;
    new (ptr) ::bosdyn::api::AcquireLeaseResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::AcquireLeaseResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_AcquireLeaseResponse_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_AcquireLeaseResponse_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_ResponseHeader_bosdyn_2fapi_2fheader_2eproto.base,
      &scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base,
      &scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto.base,}};

static void InitDefaultsscc_info_Lease_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_Lease_default_instance_;
    new (ptr) ::bosdyn::api::Lease();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::Lease::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Lease_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Lease_bosdyn_2fapi_2flease_2eproto}, {}};

static void InitDefaultsscc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_LeaseOwner_default_instance_;
    new (ptr) ::bosdyn::api::LeaseOwner();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::LeaseOwner::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto}, {}};

static void InitDefaultsscc_info_LeaseResource_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_LeaseResource_default_instance_;
    new (ptr) ::bosdyn::api::LeaseResource();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::LeaseResource::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_LeaseResource_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_LeaseResource_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base,
      &scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto.base,}};

static void InitDefaultsscc_info_LeaseUseResult_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_LeaseUseResult_default_instance_;
    new (ptr) ::bosdyn::api::LeaseUseResult();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::LeaseUseResult::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_LeaseUseResult_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_LeaseUseResult_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto.base,
      &scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base,}};

static void InitDefaultsscc_info_ListLeasesRequest_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_ListLeasesRequest_default_instance_;
    new (ptr) ::bosdyn::api::ListLeasesRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::ListLeasesRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ListLeasesRequest_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ListLeasesRequest_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_RequestHeader_bosdyn_2fapi_2fheader_2eproto.base,}};

static void InitDefaultsscc_info_ListLeasesResponse_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_ListLeasesResponse_default_instance_;
    new (ptr) ::bosdyn::api::ListLeasesResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::ListLeasesResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ListLeasesResponse_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ListLeasesResponse_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_ResponseHeader_bosdyn_2fapi_2fheader_2eproto.base,
      &scc_info_LeaseResource_bosdyn_2fapi_2flease_2eproto.base,}};

static void InitDefaultsscc_info_RetainLeaseRequest_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_RetainLeaseRequest_default_instance_;
    new (ptr) ::bosdyn::api::RetainLeaseRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::RetainLeaseRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_RetainLeaseRequest_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_RetainLeaseRequest_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_RequestHeader_bosdyn_2fapi_2fheader_2eproto.base,
      &scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base,}};

static void InitDefaultsscc_info_RetainLeaseResponse_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_RetainLeaseResponse_default_instance_;
    new (ptr) ::bosdyn::api::RetainLeaseResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::RetainLeaseResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_RetainLeaseResponse_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_RetainLeaseResponse_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_ResponseHeader_bosdyn_2fapi_2fheader_2eproto.base,
      &scc_info_LeaseUseResult_bosdyn_2fapi_2flease_2eproto.base,}};

static void InitDefaultsscc_info_ReturnLeaseRequest_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_ReturnLeaseRequest_default_instance_;
    new (ptr) ::bosdyn::api::ReturnLeaseRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::ReturnLeaseRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_ReturnLeaseRequest_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_ReturnLeaseRequest_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_RequestHeader_bosdyn_2fapi_2fheader_2eproto.base,
      &scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base,}};

static void InitDefaultsscc_info_ReturnLeaseResponse_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_ReturnLeaseResponse_default_instance_;
    new (ptr) ::bosdyn::api::ReturnLeaseResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::ReturnLeaseResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ReturnLeaseResponse_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ReturnLeaseResponse_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_ResponseHeader_bosdyn_2fapi_2fheader_2eproto.base,}};

static void InitDefaultsscc_info_TakeLeaseRequest_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_TakeLeaseRequest_default_instance_;
    new (ptr) ::bosdyn::api::TakeLeaseRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::TakeLeaseRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TakeLeaseRequest_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TakeLeaseRequest_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_RequestHeader_bosdyn_2fapi_2fheader_2eproto.base,}};

static void InitDefaultsscc_info_TakeLeaseResponse_bosdyn_2fapi_2flease_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::bosdyn::api::_TakeLeaseResponse_default_instance_;
    new (ptr) ::bosdyn::api::TakeLeaseResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::bosdyn::api::TakeLeaseResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_TakeLeaseResponse_bosdyn_2fapi_2flease_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_TakeLeaseResponse_bosdyn_2fapi_2flease_2eproto}, {
      &scc_info_ResponseHeader_bosdyn_2fapi_2fheader_2eproto.base,
      &scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base,
      &scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_bosdyn_2fapi_2flease_2eproto[14];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_bosdyn_2fapi_2flease_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_bosdyn_2fapi_2flease_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_bosdyn_2fapi_2flease_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::Lease, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::Lease, resource_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::Lease, epoch_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::Lease, sequence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseOwner, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseOwner, client_name_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseOwner, user_name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseUseResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseUseResult, status_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseUseResult, owner_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseUseResult, attempted_lease_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseUseResult, previous_lease_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::AcquireLeaseRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::AcquireLeaseRequest, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::AcquireLeaseRequest, resource_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::AcquireLeaseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::AcquireLeaseResponse, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::AcquireLeaseResponse, status_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::AcquireLeaseResponse, lease_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::AcquireLeaseResponse, lease_owner_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::TakeLeaseRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::TakeLeaseRequest, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::TakeLeaseRequest, resource_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::TakeLeaseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::TakeLeaseResponse, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::TakeLeaseResponse, status_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::TakeLeaseResponse, lease_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::TakeLeaseResponse, lease_owner_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ReturnLeaseRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ReturnLeaseRequest, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ReturnLeaseRequest, lease_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ReturnLeaseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ReturnLeaseResponse, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ReturnLeaseResponse, status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ListLeasesRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ListLeasesRequest, header_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseResource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseResource, resource_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseResource, lease_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::LeaseResource, lease_owner_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ListLeasesResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ListLeasesResponse, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::ListLeasesResponse, resources_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::RetainLeaseRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::RetainLeaseRequest, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::RetainLeaseRequest, lease_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::RetainLeaseResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::RetainLeaseResponse, header_),
  PROTOBUF_FIELD_OFFSET(::bosdyn::api::RetainLeaseResponse, lease_use_result_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::bosdyn::api::Lease)},
  { 8, -1, sizeof(::bosdyn::api::LeaseOwner)},
  { 15, -1, sizeof(::bosdyn::api::LeaseUseResult)},
  { 24, -1, sizeof(::bosdyn::api::AcquireLeaseRequest)},
  { 31, -1, sizeof(::bosdyn::api::AcquireLeaseResponse)},
  { 40, -1, sizeof(::bosdyn::api::TakeLeaseRequest)},
  { 47, -1, sizeof(::bosdyn::api::TakeLeaseResponse)},
  { 56, -1, sizeof(::bosdyn::api::ReturnLeaseRequest)},
  { 63, -1, sizeof(::bosdyn::api::ReturnLeaseResponse)},
  { 70, -1, sizeof(::bosdyn::api::ListLeasesRequest)},
  { 76, -1, sizeof(::bosdyn::api::LeaseResource)},
  { 84, -1, sizeof(::bosdyn::api::ListLeasesResponse)},
  { 91, -1, sizeof(::bosdyn::api::RetainLeaseRequest)},
  { 98, -1, sizeof(::bosdyn::api::RetainLeaseResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_Lease_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_LeaseOwner_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_LeaseUseResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_AcquireLeaseRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_AcquireLeaseResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_TakeLeaseRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_TakeLeaseResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_ReturnLeaseRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_ReturnLeaseResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_ListLeasesRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_LeaseResource_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_ListLeasesResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_RetainLeaseRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::bosdyn::api::_RetainLeaseResponse_default_instance_),
};

const char descriptor_table_protodef_bosdyn_2fapi_2flease_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026bosdyn/api/lease.proto\022\nbosdyn.api\032\027bo"
  "sdyn/api/header.proto\":\n\005Lease\022\020\n\010resour"
  "ce\030\001 \001(\t\022\r\n\005epoch\030\002 \001(\t\022\020\n\010sequence\030\003 \003("
  "\r\"4\n\nLeaseOwner\022\023\n\013client_name\030\001 \001(\t\022\021\n\t"
  "user_name\030\002 \001(\t\"\335\002\n\016LeaseUseResult\0221\n\006st"
  "atus\030\001 \001(\0162!.bosdyn.api.LeaseUseResult.S"
  "tatus\022%\n\005owner\030\002 \001(\0132\026.bosdyn.api.LeaseO"
  "wner\022*\n\017attempted_lease\030\003 \001(\0132\021.bosdyn.a"
  "pi.Lease\022)\n\016previous_lease\030\004 \001(\0132\021.bosdy"
  "n.api.Lease\"\231\001\n\006Status\022\022\n\016STATUS_UNKNOWN"
  "\020\000\022\r\n\tSTATUS_OK\020\001\022\030\n\024STATUS_INVALID_LEAS"
  "E\020\002\022\020\n\014STATUS_OLDER\020\003\022\022\n\016STATUS_REVOKED\020"
  "\004\022\024\n\020STATUS_UNMANAGED\020\005\022\026\n\022STATUS_WRONG_"
  "EPOCH\020\006\"R\n\023AcquireLeaseRequest\022)\n\006header"
  "\030\001 \001(\0132\031.bosdyn.api.RequestHeader\022\020\n\010res"
  "ource\030\002 \001(\t\"\340\002\n\024AcquireLeaseResponse\022*\n\006"
  "header\030\001 \001(\0132\032.bosdyn.api.ResponseHeader"
  "\0227\n\006status\030\002 \001(\0162\'.bosdyn.api.AcquireLea"
  "seResponse.Status\022 \n\005lease\030\003 \001(\0132\021.bosdy"
  "n.api.Lease\022+\n\013lease_owner\030\004 \001(\0132\026.bosdy"
  "n.api.LeaseOwner\"\223\001\n\006Status\022\022\n\016STATUS_UN"
  "KNOWN\020\000\022\r\n\tSTATUS_OK\020\001\022#\n\037STATUS_RESOURC"
  "E_ALREADY_CLAIMED\020\002\022\033\n\027STATUS_INVALID_RE"
  "SOURCE\020\003\022$\n STATUS_NOT_AUTHORITATIVE_SER"
  "VICE\020\004\"O\n\020TakeLeaseRequest\022)\n\006header\030\001 \001"
  "(\0132\031.bosdyn.api.RequestHeader\022\020\n\010resourc"
  "e\030\002 \001(\t\"\264\002\n\021TakeLeaseResponse\022*\n\006header\030"
  "\001 \001(\0132\032.bosdyn.api.ResponseHeader\0224\n\006sta"
  "tus\030\002 \001(\0162$.bosdyn.api.TakeLeaseResponse"
  ".Status\022 \n\005lease\030\003 \001(\0132\021.bosdyn.api.Leas"
  "e\022+\n\013lease_owner\030\004 \001(\0132\026.bosdyn.api.Leas"
  "eOwner\"n\n\006Status\022\022\n\016STATUS_UNKNOWN\020\000\022\r\n\t"
  "STATUS_OK\020\001\022\033\n\027STATUS_INVALID_RESOURCE\020\002"
  "\022$\n STATUS_NOT_AUTHORITATIVE_SERVICE\020\003\"a"
  "\n\022ReturnLeaseRequest\022)\n\006header\030\001 \001(\0132\031.b"
  "osdyn.api.RequestHeader\022 \n\005lease\030\002 \001(\0132\021"
  ".bosdyn.api.Lease\"\207\002\n\023ReturnLeaseRespons"
  "e\022*\n\006header\030\001 \001(\0132\032.bosdyn.api.ResponseH"
  "eader\0226\n\006status\030\002 \001(\0162&.bosdyn.api.Retur"
  "nLeaseResponse.Status\"\213\001\n\006Status\022\022\n\016STAT"
  "US_UNKNOWN\020\000\022\r\n\tSTATUS_OK\020\001\022\033\n\027STATUS_IN"
  "VALID_RESOURCE\020\002\022\033\n\027STATUS_NOT_ACTIVE_LE"
  "ASE\020\003\022$\n STATUS_NOT_AUTHORITATIVE_SERVIC"
  "E\020\004\">\n\021ListLeasesRequest\022)\n\006header\030\001 \001(\013"
  "2\031.bosdyn.api.RequestHeader\"p\n\rLeaseReso"
  "urce\022\020\n\010resource\030\001 \001(\t\022 \n\005lease\030\002 \001(\0132\021."
  "bosdyn.api.Lease\022+\n\013lease_owner\030\003 \001(\0132\026."
  "bosdyn.api.LeaseOwner\"n\n\022ListLeasesRespo"
  "nse\022*\n\006header\030\001 \001(\0132\032.bosdyn.api.Respons"
  "eHeader\022,\n\tresources\030\002 \003(\0132\031.bosdyn.api."
  "LeaseResource\"a\n\022RetainLeaseRequest\022)\n\006h"
  "eader\030\001 \001(\0132\031.bosdyn.api.RequestHeader\022 "
  "\n\005lease\030\002 \001(\0132\021.bosdyn.api.Lease\"w\n\023Reta"
  "inLeaseResponse\022*\n\006header\030\001 \001(\0132\032.bosdyn"
  ".api.ResponseHeader\0224\n\020lease_use_result\030"
  "\002 \001(\0132\032.bosdyn.api.LeaseUseResultB\014B\nLea"
  "seProtob\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_bosdyn_2fapi_2flease_2eproto_deps[1] = {
  &::descriptor_table_bosdyn_2fapi_2fheader_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_bosdyn_2fapi_2flease_2eproto_sccs[14] = {
  &scc_info_AcquireLeaseRequest_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_AcquireLeaseResponse_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_LeaseResource_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_LeaseUseResult_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_ListLeasesRequest_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_ListLeasesResponse_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_RetainLeaseRequest_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_RetainLeaseResponse_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_ReturnLeaseRequest_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_ReturnLeaseResponse_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_TakeLeaseRequest_bosdyn_2fapi_2flease_2eproto.base,
  &scc_info_TakeLeaseResponse_bosdyn_2fapi_2flease_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_bosdyn_2fapi_2flease_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2flease_2eproto = {
  false, false, descriptor_table_protodef_bosdyn_2fapi_2flease_2eproto, "bosdyn/api/lease.proto", 2255,
  &descriptor_table_bosdyn_2fapi_2flease_2eproto_once, descriptor_table_bosdyn_2fapi_2flease_2eproto_sccs, descriptor_table_bosdyn_2fapi_2flease_2eproto_deps, 14, 1,
  schemas, file_default_instances, TableStruct_bosdyn_2fapi_2flease_2eproto::offsets,
  file_level_metadata_bosdyn_2fapi_2flease_2eproto, 14, file_level_enum_descriptors_bosdyn_2fapi_2flease_2eproto, file_level_service_descriptors_bosdyn_2fapi_2flease_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_bosdyn_2fapi_2flease_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_bosdyn_2fapi_2flease_2eproto)), true);
namespace bosdyn {
namespace api {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LeaseUseResult_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bosdyn_2fapi_2flease_2eproto);
  return file_level_enum_descriptors_bosdyn_2fapi_2flease_2eproto[0];
}
bool LeaseUseResult_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr LeaseUseResult_Status LeaseUseResult::STATUS_UNKNOWN;
constexpr LeaseUseResult_Status LeaseUseResult::STATUS_OK;
constexpr LeaseUseResult_Status LeaseUseResult::STATUS_INVALID_LEASE;
constexpr LeaseUseResult_Status LeaseUseResult::STATUS_OLDER;
constexpr LeaseUseResult_Status LeaseUseResult::STATUS_REVOKED;
constexpr LeaseUseResult_Status LeaseUseResult::STATUS_UNMANAGED;
constexpr LeaseUseResult_Status LeaseUseResult::STATUS_WRONG_EPOCH;
constexpr LeaseUseResult_Status LeaseUseResult::Status_MIN;
constexpr LeaseUseResult_Status LeaseUseResult::Status_MAX;
constexpr int LeaseUseResult::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AcquireLeaseResponse_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bosdyn_2fapi_2flease_2eproto);
  return file_level_enum_descriptors_bosdyn_2fapi_2flease_2eproto[1];
}
bool AcquireLeaseResponse_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse::STATUS_UNKNOWN;
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse::STATUS_OK;
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse::STATUS_RESOURCE_ALREADY_CLAIMED;
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse::STATUS_INVALID_RESOURCE;
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse::STATUS_NOT_AUTHORITATIVE_SERVICE;
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse::Status_MIN;
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse::Status_MAX;
constexpr int AcquireLeaseResponse::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TakeLeaseResponse_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bosdyn_2fapi_2flease_2eproto);
  return file_level_enum_descriptors_bosdyn_2fapi_2flease_2eproto[2];
}
bool TakeLeaseResponse_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TakeLeaseResponse_Status TakeLeaseResponse::STATUS_UNKNOWN;
constexpr TakeLeaseResponse_Status TakeLeaseResponse::STATUS_OK;
constexpr TakeLeaseResponse_Status TakeLeaseResponse::STATUS_INVALID_RESOURCE;
constexpr TakeLeaseResponse_Status TakeLeaseResponse::STATUS_NOT_AUTHORITATIVE_SERVICE;
constexpr TakeLeaseResponse_Status TakeLeaseResponse::Status_MIN;
constexpr TakeLeaseResponse_Status TakeLeaseResponse::Status_MAX;
constexpr int TakeLeaseResponse::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReturnLeaseResponse_Status_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_bosdyn_2fapi_2flease_2eproto);
  return file_level_enum_descriptors_bosdyn_2fapi_2flease_2eproto[3];
}
bool ReturnLeaseResponse_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse::STATUS_UNKNOWN;
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse::STATUS_OK;
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse::STATUS_INVALID_RESOURCE;
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse::STATUS_NOT_ACTIVE_LEASE;
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse::STATUS_NOT_AUTHORITATIVE_SERVICE;
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse::Status_MIN;
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse::Status_MAX;
constexpr int ReturnLeaseResponse::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void Lease::InitAsDefaultInstance() {
}
class Lease::_Internal {
 public:
};

Lease::Lease(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  sequence_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.Lease)
}
Lease::Lease(const Lease& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      sequence_(from.sequence_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_resource().empty()) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_resource(),
      GetArena());
  }
  epoch_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_epoch().empty()) {
    epoch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_epoch(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.Lease)
}

void Lease::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base);
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  epoch_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

Lease::~Lease() {
  // @@protoc_insertion_point(destructor:bosdyn.api.Lease)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Lease::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  resource_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  epoch_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Lease::ArenaDtor(void* object) {
  Lease* _this = reinterpret_cast< Lease* >(object);
  (void)_this;
}
void Lease::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Lease::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Lease& Lease::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Lease_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void Lease::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.Lease)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sequence_.Clear();
  resource_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  epoch_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Lease::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string resource = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_resource();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bosdyn.api.Lease.resource"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string epoch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_epoch();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bosdyn.api.Lease.epoch"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 sequence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_sequence(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24) {
          _internal_add_sequence(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Lease::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.Lease)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string resource = 1;
  if (this->resource().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_resource().data(), static_cast<int>(this->_internal_resource().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bosdyn.api.Lease.resource");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_resource(), target);
  }

  // string epoch = 2;
  if (this->epoch().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_epoch().data(), static_cast<int>(this->_internal_epoch().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bosdyn.api.Lease.epoch");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_epoch(), target);
  }

  // repeated uint32 sequence = 3;
  {
    int byte_size = _sequence_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_sequence(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.Lease)
  return target;
}

size_t Lease::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.Lease)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 sequence = 3;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->sequence_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _sequence_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string resource = 1;
  if (this->resource().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resource());
  }

  // string epoch = 2;
  if (this->epoch().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_epoch());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Lease::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.Lease)
  GOOGLE_DCHECK_NE(&from, this);
  const Lease* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Lease>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.Lease)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.Lease)
    MergeFrom(*source);
  }
}

void Lease::MergeFrom(const Lease& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.Lease)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sequence_.MergeFrom(from.sequence_);
  if (from.resource().size() > 0) {
    _internal_set_resource(from._internal_resource());
  }
  if (from.epoch().size() > 0) {
    _internal_set_epoch(from._internal_epoch());
  }
}

void Lease::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.Lease)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Lease::CopyFrom(const Lease& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.Lease)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lease::IsInitialized() const {
  return true;
}

void Lease::InternalSwap(Lease* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  sequence_.InternalSwap(&other->sequence_);
  resource_.Swap(&other->resource_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  epoch_.Swap(&other->epoch_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata Lease::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LeaseOwner::InitAsDefaultInstance() {
}
class LeaseOwner::_Internal {
 public:
};

LeaseOwner::LeaseOwner(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.LeaseOwner)
}
LeaseOwner::LeaseOwner(const LeaseOwner& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_client_name().empty()) {
    client_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_client_name(),
      GetArena());
  }
  user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_user_name().empty()) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_user_name(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.LeaseOwner)
}

void LeaseOwner::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto.base);
  client_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

LeaseOwner::~LeaseOwner() {
  // @@protoc_insertion_point(destructor:bosdyn.api.LeaseOwner)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LeaseOwner::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  client_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LeaseOwner::ArenaDtor(void* object) {
  LeaseOwner* _this = reinterpret_cast< LeaseOwner* >(object);
  (void)_this;
}
void LeaseOwner::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LeaseOwner::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LeaseOwner& LeaseOwner::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LeaseOwner_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void LeaseOwner::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.LeaseOwner)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  user_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseOwner::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string client_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_client_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bosdyn.api.LeaseOwner.client_name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_user_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bosdyn.api.LeaseOwner.user_name"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LeaseOwner::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.LeaseOwner)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string client_name = 1;
  if (this->client_name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_client_name().data(), static_cast<int>(this->_internal_client_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bosdyn.api.LeaseOwner.client_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_name(), target);
  }

  // string user_name = 2;
  if (this->user_name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bosdyn.api.LeaseOwner.user_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.LeaseOwner)
  return target;
}

size_t LeaseOwner::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.LeaseOwner)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string client_name = 1;
  if (this->client_name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_name());
  }

  // string user_name = 2;
  if (this->user_name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LeaseOwner::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.LeaseOwner)
  GOOGLE_DCHECK_NE(&from, this);
  const LeaseOwner* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LeaseOwner>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.LeaseOwner)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.LeaseOwner)
    MergeFrom(*source);
  }
}

void LeaseOwner::MergeFrom(const LeaseOwner& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.LeaseOwner)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.client_name().size() > 0) {
    _internal_set_client_name(from._internal_client_name());
  }
  if (from.user_name().size() > 0) {
    _internal_set_user_name(from._internal_user_name());
  }
}

void LeaseOwner::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.LeaseOwner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaseOwner::CopyFrom(const LeaseOwner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.LeaseOwner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseOwner::IsInitialized() const {
  return true;
}

void LeaseOwner::InternalSwap(LeaseOwner* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  client_name_.Swap(&other->client_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  user_name_.Swap(&other->user_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseOwner::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LeaseUseResult::InitAsDefaultInstance() {
  ::bosdyn::api::_LeaseUseResult_default_instance_._instance.get_mutable()->owner_ = const_cast< ::bosdyn::api::LeaseOwner*>(
      ::bosdyn::api::LeaseOwner::internal_default_instance());
  ::bosdyn::api::_LeaseUseResult_default_instance_._instance.get_mutable()->attempted_lease_ = const_cast< ::bosdyn::api::Lease*>(
      ::bosdyn::api::Lease::internal_default_instance());
  ::bosdyn::api::_LeaseUseResult_default_instance_._instance.get_mutable()->previous_lease_ = const_cast< ::bosdyn::api::Lease*>(
      ::bosdyn::api::Lease::internal_default_instance());
}
class LeaseUseResult::_Internal {
 public:
  static const ::bosdyn::api::LeaseOwner& owner(const LeaseUseResult* msg);
  static const ::bosdyn::api::Lease& attempted_lease(const LeaseUseResult* msg);
  static const ::bosdyn::api::Lease& previous_lease(const LeaseUseResult* msg);
};

const ::bosdyn::api::LeaseOwner&
LeaseUseResult::_Internal::owner(const LeaseUseResult* msg) {
  return *msg->owner_;
}
const ::bosdyn::api::Lease&
LeaseUseResult::_Internal::attempted_lease(const LeaseUseResult* msg) {
  return *msg->attempted_lease_;
}
const ::bosdyn::api::Lease&
LeaseUseResult::_Internal::previous_lease(const LeaseUseResult* msg) {
  return *msg->previous_lease_;
}
LeaseUseResult::LeaseUseResult(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.LeaseUseResult)
}
LeaseUseResult::LeaseUseResult(const LeaseUseResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner()) {
    owner_ = new ::bosdyn::api::LeaseOwner(*from.owner_);
  } else {
    owner_ = nullptr;
  }
  if (from._internal_has_attempted_lease()) {
    attempted_lease_ = new ::bosdyn::api::Lease(*from.attempted_lease_);
  } else {
    attempted_lease_ = nullptr;
  }
  if (from._internal_has_previous_lease()) {
    previous_lease_ = new ::bosdyn::api::Lease(*from.previous_lease_);
  } else {
    previous_lease_ = nullptr;
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.LeaseUseResult)
}

void LeaseUseResult::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LeaseUseResult_bosdyn_2fapi_2flease_2eproto.base);
  ::memset(&owner_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&owner_)) + sizeof(status_));
}

LeaseUseResult::~LeaseUseResult() {
  // @@protoc_insertion_point(destructor:bosdyn.api.LeaseUseResult)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LeaseUseResult::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete owner_;
  if (this != internal_default_instance()) delete attempted_lease_;
  if (this != internal_default_instance()) delete previous_lease_;
}

void LeaseUseResult::ArenaDtor(void* object) {
  LeaseUseResult* _this = reinterpret_cast< LeaseUseResult* >(object);
  (void)_this;
}
void LeaseUseResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LeaseUseResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LeaseUseResult& LeaseUseResult::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LeaseUseResult_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void LeaseUseResult::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.LeaseUseResult)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
  if (GetArena() == nullptr && attempted_lease_ != nullptr) {
    delete attempted_lease_;
  }
  attempted_lease_ = nullptr;
  if (GetArena() == nullptr && previous_lease_ != nullptr) {
    delete previous_lease_;
  }
  previous_lease_ = nullptr;
  status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseUseResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.LeaseUseResult.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::bosdyn::api::LeaseUseResult_Status>(val));
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.LeaseOwner owner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.Lease attempted_lease = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_attempted_lease(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.Lease previous_lease = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_previous_lease(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LeaseUseResult::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.LeaseUseResult)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.LeaseUseResult.Status status = 1;
  if (this->status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // .bosdyn.api.LeaseOwner owner = 2;
  if (this->has_owner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::owner(this), target, stream);
  }

  // .bosdyn.api.Lease attempted_lease = 3;
  if (this->has_attempted_lease()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::attempted_lease(this), target, stream);
  }

  // .bosdyn.api.Lease previous_lease = 4;
  if (this->has_previous_lease()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::previous_lease(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.LeaseUseResult)
  return target;
}

size_t LeaseUseResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.LeaseUseResult)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bosdyn.api.LeaseOwner owner = 2;
  if (this->has_owner()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *owner_);
  }

  // .bosdyn.api.Lease attempted_lease = 3;
  if (this->has_attempted_lease()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *attempted_lease_);
  }

  // .bosdyn.api.Lease previous_lease = 4;
  if (this->has_previous_lease()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *previous_lease_);
  }

  // .bosdyn.api.LeaseUseResult.Status status = 1;
  if (this->status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LeaseUseResult::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.LeaseUseResult)
  GOOGLE_DCHECK_NE(&from, this);
  const LeaseUseResult* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LeaseUseResult>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.LeaseUseResult)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.LeaseUseResult)
    MergeFrom(*source);
  }
}

void LeaseUseResult::MergeFrom(const LeaseUseResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.LeaseUseResult)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_owner()) {
    _internal_mutable_owner()->::bosdyn::api::LeaseOwner::MergeFrom(from._internal_owner());
  }
  if (from.has_attempted_lease()) {
    _internal_mutable_attempted_lease()->::bosdyn::api::Lease::MergeFrom(from._internal_attempted_lease());
  }
  if (from.has_previous_lease()) {
    _internal_mutable_previous_lease()->::bosdyn::api::Lease::MergeFrom(from._internal_previous_lease());
  }
  if (from.status() != 0) {
    _internal_set_status(from._internal_status());
  }
}

void LeaseUseResult::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.LeaseUseResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaseUseResult::CopyFrom(const LeaseUseResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.LeaseUseResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseUseResult::IsInitialized() const {
  return true;
}

void LeaseUseResult::InternalSwap(LeaseUseResult* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseUseResult, status_)
      + sizeof(LeaseUseResult::status_)
      - PROTOBUF_FIELD_OFFSET(LeaseUseResult, owner_)>(
          reinterpret_cast<char*>(&owner_),
          reinterpret_cast<char*>(&other->owner_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseUseResult::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AcquireLeaseRequest::InitAsDefaultInstance() {
  ::bosdyn::api::_AcquireLeaseRequest_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::RequestHeader*>(
      ::bosdyn::api::RequestHeader::internal_default_instance());
}
class AcquireLeaseRequest::_Internal {
 public:
  static const ::bosdyn::api::RequestHeader& header(const AcquireLeaseRequest* msg);
};

const ::bosdyn::api::RequestHeader&
AcquireLeaseRequest::_Internal::header(const AcquireLeaseRequest* msg) {
  return *msg->header_;
}
void AcquireLeaseRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
AcquireLeaseRequest::AcquireLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.AcquireLeaseRequest)
}
AcquireLeaseRequest::AcquireLeaseRequest(const AcquireLeaseRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_resource().empty()) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_resource(),
      GetArena());
  }
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::RequestHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.AcquireLeaseRequest)
}

void AcquireLeaseRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AcquireLeaseRequest_bosdyn_2fapi_2flease_2eproto.base);
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  header_ = nullptr;
}

AcquireLeaseRequest::~AcquireLeaseRequest() {
  // @@protoc_insertion_point(destructor:bosdyn.api.AcquireLeaseRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AcquireLeaseRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  resource_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete header_;
}

void AcquireLeaseRequest::ArenaDtor(void* object) {
  AcquireLeaseRequest* _this = reinterpret_cast< AcquireLeaseRequest* >(object);
  (void)_this;
}
void AcquireLeaseRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AcquireLeaseRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AcquireLeaseRequest& AcquireLeaseRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AcquireLeaseRequest_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void AcquireLeaseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.AcquireLeaseRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  resource_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AcquireLeaseRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string resource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_resource();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bosdyn.api.AcquireLeaseRequest.resource"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AcquireLeaseRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.AcquireLeaseRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // string resource = 2;
  if (this->resource().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_resource().data(), static_cast<int>(this->_internal_resource().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bosdyn.api.AcquireLeaseRequest.resource");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_resource(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.AcquireLeaseRequest)
  return target;
}

size_t AcquireLeaseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.AcquireLeaseRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string resource = 2;
  if (this->resource().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resource());
  }

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AcquireLeaseRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.AcquireLeaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const AcquireLeaseRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AcquireLeaseRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.AcquireLeaseRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.AcquireLeaseRequest)
    MergeFrom(*source);
  }
}

void AcquireLeaseRequest::MergeFrom(const AcquireLeaseRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.AcquireLeaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.resource().size() > 0) {
    _internal_set_resource(from._internal_resource());
  }
  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::RequestHeader::MergeFrom(from._internal_header());
  }
}

void AcquireLeaseRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.AcquireLeaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AcquireLeaseRequest::CopyFrom(const AcquireLeaseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.AcquireLeaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcquireLeaseRequest::IsInitialized() const {
  return true;
}

void AcquireLeaseRequest::InternalSwap(AcquireLeaseRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  resource_.Swap(&other->resource_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(header_, other->header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AcquireLeaseRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AcquireLeaseResponse::InitAsDefaultInstance() {
  ::bosdyn::api::_AcquireLeaseResponse_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::ResponseHeader*>(
      ::bosdyn::api::ResponseHeader::internal_default_instance());
  ::bosdyn::api::_AcquireLeaseResponse_default_instance_._instance.get_mutable()->lease_ = const_cast< ::bosdyn::api::Lease*>(
      ::bosdyn::api::Lease::internal_default_instance());
  ::bosdyn::api::_AcquireLeaseResponse_default_instance_._instance.get_mutable()->lease_owner_ = const_cast< ::bosdyn::api::LeaseOwner*>(
      ::bosdyn::api::LeaseOwner::internal_default_instance());
}
class AcquireLeaseResponse::_Internal {
 public:
  static const ::bosdyn::api::ResponseHeader& header(const AcquireLeaseResponse* msg);
  static const ::bosdyn::api::Lease& lease(const AcquireLeaseResponse* msg);
  static const ::bosdyn::api::LeaseOwner& lease_owner(const AcquireLeaseResponse* msg);
};

const ::bosdyn::api::ResponseHeader&
AcquireLeaseResponse::_Internal::header(const AcquireLeaseResponse* msg) {
  return *msg->header_;
}
const ::bosdyn::api::Lease&
AcquireLeaseResponse::_Internal::lease(const AcquireLeaseResponse* msg) {
  return *msg->lease_;
}
const ::bosdyn::api::LeaseOwner&
AcquireLeaseResponse::_Internal::lease_owner(const AcquireLeaseResponse* msg) {
  return *msg->lease_owner_;
}
void AcquireLeaseResponse::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
AcquireLeaseResponse::AcquireLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.AcquireLeaseResponse)
}
AcquireLeaseResponse::AcquireLeaseResponse(const AcquireLeaseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::ResponseHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_lease()) {
    lease_ = new ::bosdyn::api::Lease(*from.lease_);
  } else {
    lease_ = nullptr;
  }
  if (from._internal_has_lease_owner()) {
    lease_owner_ = new ::bosdyn::api::LeaseOwner(*from.lease_owner_);
  } else {
    lease_owner_ = nullptr;
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.AcquireLeaseResponse)
}

void AcquireLeaseResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AcquireLeaseResponse_bosdyn_2fapi_2flease_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&header_)) + sizeof(status_));
}

AcquireLeaseResponse::~AcquireLeaseResponse() {
  // @@protoc_insertion_point(destructor:bosdyn.api.AcquireLeaseResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void AcquireLeaseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete lease_;
  if (this != internal_default_instance()) delete lease_owner_;
}

void AcquireLeaseResponse::ArenaDtor(void* object) {
  AcquireLeaseResponse* _this = reinterpret_cast< AcquireLeaseResponse* >(object);
  (void)_this;
}
void AcquireLeaseResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AcquireLeaseResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AcquireLeaseResponse& AcquireLeaseResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AcquireLeaseResponse_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void AcquireLeaseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.AcquireLeaseResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
  if (GetArena() == nullptr && lease_owner_ != nullptr) {
    delete lease_owner_;
  }
  lease_owner_ = nullptr;
  status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AcquireLeaseResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.AcquireLeaseResponse.Status status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::bosdyn::api::AcquireLeaseResponse_Status>(val));
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.Lease lease = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.LeaseOwner lease_owner = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease_owner(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AcquireLeaseResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.AcquireLeaseResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // .bosdyn.api.AcquireLeaseResponse.Status status = 2;
  if (this->status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // .bosdyn.api.Lease lease = 3;
  if (this->has_lease()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::lease(this), target, stream);
  }

  // .bosdyn.api.LeaseOwner lease_owner = 4;
  if (this->has_lease_owner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::lease_owner(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.AcquireLeaseResponse)
  return target;
}

size_t AcquireLeaseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.AcquireLeaseResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  // .bosdyn.api.Lease lease = 3;
  if (this->has_lease()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_);
  }

  // .bosdyn.api.LeaseOwner lease_owner = 4;
  if (this->has_lease_owner()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_owner_);
  }

  // .bosdyn.api.AcquireLeaseResponse.Status status = 2;
  if (this->status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AcquireLeaseResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.AcquireLeaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const AcquireLeaseResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AcquireLeaseResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.AcquireLeaseResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.AcquireLeaseResponse)
    MergeFrom(*source);
  }
}

void AcquireLeaseResponse::MergeFrom(const AcquireLeaseResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.AcquireLeaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::ResponseHeader::MergeFrom(from._internal_header());
  }
  if (from.has_lease()) {
    _internal_mutable_lease()->::bosdyn::api::Lease::MergeFrom(from._internal_lease());
  }
  if (from.has_lease_owner()) {
    _internal_mutable_lease_owner()->::bosdyn::api::LeaseOwner::MergeFrom(from._internal_lease_owner());
  }
  if (from.status() != 0) {
    _internal_set_status(from._internal_status());
  }
}

void AcquireLeaseResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.AcquireLeaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AcquireLeaseResponse::CopyFrom(const AcquireLeaseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.AcquireLeaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcquireLeaseResponse::IsInitialized() const {
  return true;
}

void AcquireLeaseResponse::InternalSwap(AcquireLeaseResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AcquireLeaseResponse, status_)
      + sizeof(AcquireLeaseResponse::status_)
      - PROTOBUF_FIELD_OFFSET(AcquireLeaseResponse, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AcquireLeaseResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TakeLeaseRequest::InitAsDefaultInstance() {
  ::bosdyn::api::_TakeLeaseRequest_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::RequestHeader*>(
      ::bosdyn::api::RequestHeader::internal_default_instance());
}
class TakeLeaseRequest::_Internal {
 public:
  static const ::bosdyn::api::RequestHeader& header(const TakeLeaseRequest* msg);
};

const ::bosdyn::api::RequestHeader&
TakeLeaseRequest::_Internal::header(const TakeLeaseRequest* msg) {
  return *msg->header_;
}
void TakeLeaseRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
TakeLeaseRequest::TakeLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.TakeLeaseRequest)
}
TakeLeaseRequest::TakeLeaseRequest(const TakeLeaseRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_resource().empty()) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_resource(),
      GetArena());
  }
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::RequestHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.TakeLeaseRequest)
}

void TakeLeaseRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TakeLeaseRequest_bosdyn_2fapi_2flease_2eproto.base);
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  header_ = nullptr;
}

TakeLeaseRequest::~TakeLeaseRequest() {
  // @@protoc_insertion_point(destructor:bosdyn.api.TakeLeaseRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TakeLeaseRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  resource_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete header_;
}

void TakeLeaseRequest::ArenaDtor(void* object) {
  TakeLeaseRequest* _this = reinterpret_cast< TakeLeaseRequest* >(object);
  (void)_this;
}
void TakeLeaseRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TakeLeaseRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TakeLeaseRequest& TakeLeaseRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TakeLeaseRequest_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void TakeLeaseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.TakeLeaseRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  resource_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TakeLeaseRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string resource = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_resource();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bosdyn.api.TakeLeaseRequest.resource"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TakeLeaseRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.TakeLeaseRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // string resource = 2;
  if (this->resource().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_resource().data(), static_cast<int>(this->_internal_resource().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bosdyn.api.TakeLeaseRequest.resource");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_resource(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.TakeLeaseRequest)
  return target;
}

size_t TakeLeaseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.TakeLeaseRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string resource = 2;
  if (this->resource().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resource());
  }

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TakeLeaseRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.TakeLeaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const TakeLeaseRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TakeLeaseRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.TakeLeaseRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.TakeLeaseRequest)
    MergeFrom(*source);
  }
}

void TakeLeaseRequest::MergeFrom(const TakeLeaseRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.TakeLeaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.resource().size() > 0) {
    _internal_set_resource(from._internal_resource());
  }
  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::RequestHeader::MergeFrom(from._internal_header());
  }
}

void TakeLeaseRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.TakeLeaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TakeLeaseRequest::CopyFrom(const TakeLeaseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.TakeLeaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TakeLeaseRequest::IsInitialized() const {
  return true;
}

void TakeLeaseRequest::InternalSwap(TakeLeaseRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  resource_.Swap(&other->resource_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(header_, other->header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TakeLeaseRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TakeLeaseResponse::InitAsDefaultInstance() {
  ::bosdyn::api::_TakeLeaseResponse_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::ResponseHeader*>(
      ::bosdyn::api::ResponseHeader::internal_default_instance());
  ::bosdyn::api::_TakeLeaseResponse_default_instance_._instance.get_mutable()->lease_ = const_cast< ::bosdyn::api::Lease*>(
      ::bosdyn::api::Lease::internal_default_instance());
  ::bosdyn::api::_TakeLeaseResponse_default_instance_._instance.get_mutable()->lease_owner_ = const_cast< ::bosdyn::api::LeaseOwner*>(
      ::bosdyn::api::LeaseOwner::internal_default_instance());
}
class TakeLeaseResponse::_Internal {
 public:
  static const ::bosdyn::api::ResponseHeader& header(const TakeLeaseResponse* msg);
  static const ::bosdyn::api::Lease& lease(const TakeLeaseResponse* msg);
  static const ::bosdyn::api::LeaseOwner& lease_owner(const TakeLeaseResponse* msg);
};

const ::bosdyn::api::ResponseHeader&
TakeLeaseResponse::_Internal::header(const TakeLeaseResponse* msg) {
  return *msg->header_;
}
const ::bosdyn::api::Lease&
TakeLeaseResponse::_Internal::lease(const TakeLeaseResponse* msg) {
  return *msg->lease_;
}
const ::bosdyn::api::LeaseOwner&
TakeLeaseResponse::_Internal::lease_owner(const TakeLeaseResponse* msg) {
  return *msg->lease_owner_;
}
void TakeLeaseResponse::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
TakeLeaseResponse::TakeLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.TakeLeaseResponse)
}
TakeLeaseResponse::TakeLeaseResponse(const TakeLeaseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::ResponseHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_lease()) {
    lease_ = new ::bosdyn::api::Lease(*from.lease_);
  } else {
    lease_ = nullptr;
  }
  if (from._internal_has_lease_owner()) {
    lease_owner_ = new ::bosdyn::api::LeaseOwner(*from.lease_owner_);
  } else {
    lease_owner_ = nullptr;
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.TakeLeaseResponse)
}

void TakeLeaseResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TakeLeaseResponse_bosdyn_2fapi_2flease_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&header_)) + sizeof(status_));
}

TakeLeaseResponse::~TakeLeaseResponse() {
  // @@protoc_insertion_point(destructor:bosdyn.api.TakeLeaseResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TakeLeaseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete lease_;
  if (this != internal_default_instance()) delete lease_owner_;
}

void TakeLeaseResponse::ArenaDtor(void* object) {
  TakeLeaseResponse* _this = reinterpret_cast< TakeLeaseResponse* >(object);
  (void)_this;
}
void TakeLeaseResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TakeLeaseResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TakeLeaseResponse& TakeLeaseResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TakeLeaseResponse_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void TakeLeaseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.TakeLeaseResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
  if (GetArena() == nullptr && lease_owner_ != nullptr) {
    delete lease_owner_;
  }
  lease_owner_ = nullptr;
  status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TakeLeaseResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.TakeLeaseResponse.Status status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::bosdyn::api::TakeLeaseResponse_Status>(val));
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.Lease lease = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.LeaseOwner lease_owner = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease_owner(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TakeLeaseResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.TakeLeaseResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // .bosdyn.api.TakeLeaseResponse.Status status = 2;
  if (this->status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // .bosdyn.api.Lease lease = 3;
  if (this->has_lease()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::lease(this), target, stream);
  }

  // .bosdyn.api.LeaseOwner lease_owner = 4;
  if (this->has_lease_owner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::lease_owner(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.TakeLeaseResponse)
  return target;
}

size_t TakeLeaseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.TakeLeaseResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  // .bosdyn.api.Lease lease = 3;
  if (this->has_lease()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_);
  }

  // .bosdyn.api.LeaseOwner lease_owner = 4;
  if (this->has_lease_owner()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_owner_);
  }

  // .bosdyn.api.TakeLeaseResponse.Status status = 2;
  if (this->status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TakeLeaseResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.TakeLeaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const TakeLeaseResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TakeLeaseResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.TakeLeaseResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.TakeLeaseResponse)
    MergeFrom(*source);
  }
}

void TakeLeaseResponse::MergeFrom(const TakeLeaseResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.TakeLeaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::ResponseHeader::MergeFrom(from._internal_header());
  }
  if (from.has_lease()) {
    _internal_mutable_lease()->::bosdyn::api::Lease::MergeFrom(from._internal_lease());
  }
  if (from.has_lease_owner()) {
    _internal_mutable_lease_owner()->::bosdyn::api::LeaseOwner::MergeFrom(from._internal_lease_owner());
  }
  if (from.status() != 0) {
    _internal_set_status(from._internal_status());
  }
}

void TakeLeaseResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.TakeLeaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TakeLeaseResponse::CopyFrom(const TakeLeaseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.TakeLeaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TakeLeaseResponse::IsInitialized() const {
  return true;
}

void TakeLeaseResponse::InternalSwap(TakeLeaseResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TakeLeaseResponse, status_)
      + sizeof(TakeLeaseResponse::status_)
      - PROTOBUF_FIELD_OFFSET(TakeLeaseResponse, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TakeLeaseResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ReturnLeaseRequest::InitAsDefaultInstance() {
  ::bosdyn::api::_ReturnLeaseRequest_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::RequestHeader*>(
      ::bosdyn::api::RequestHeader::internal_default_instance());
  ::bosdyn::api::_ReturnLeaseRequest_default_instance_._instance.get_mutable()->lease_ = const_cast< ::bosdyn::api::Lease*>(
      ::bosdyn::api::Lease::internal_default_instance());
}
class ReturnLeaseRequest::_Internal {
 public:
  static const ::bosdyn::api::RequestHeader& header(const ReturnLeaseRequest* msg);
  static const ::bosdyn::api::Lease& lease(const ReturnLeaseRequest* msg);
};

const ::bosdyn::api::RequestHeader&
ReturnLeaseRequest::_Internal::header(const ReturnLeaseRequest* msg) {
  return *msg->header_;
}
const ::bosdyn::api::Lease&
ReturnLeaseRequest::_Internal::lease(const ReturnLeaseRequest* msg) {
  return *msg->lease_;
}
void ReturnLeaseRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
ReturnLeaseRequest::ReturnLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.ReturnLeaseRequest)
}
ReturnLeaseRequest::ReturnLeaseRequest(const ReturnLeaseRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::RequestHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_lease()) {
    lease_ = new ::bosdyn::api::Lease(*from.lease_);
  } else {
    lease_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.ReturnLeaseRequest)
}

void ReturnLeaseRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ReturnLeaseRequest_bosdyn_2fapi_2flease_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lease_) -
      reinterpret_cast<char*>(&header_)) + sizeof(lease_));
}

ReturnLeaseRequest::~ReturnLeaseRequest() {
  // @@protoc_insertion_point(destructor:bosdyn.api.ReturnLeaseRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ReturnLeaseRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete lease_;
}

void ReturnLeaseRequest::ArenaDtor(void* object) {
  ReturnLeaseRequest* _this = reinterpret_cast< ReturnLeaseRequest* >(object);
  (void)_this;
}
void ReturnLeaseRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReturnLeaseRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ReturnLeaseRequest& ReturnLeaseRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ReturnLeaseRequest_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void ReturnLeaseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.ReturnLeaseRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReturnLeaseRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.Lease lease = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ReturnLeaseRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.ReturnLeaseRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // .bosdyn.api.Lease lease = 2;
  if (this->has_lease()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::lease(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.ReturnLeaseRequest)
  return target;
}

size_t ReturnLeaseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.ReturnLeaseRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  // .bosdyn.api.Lease lease = 2;
  if (this->has_lease()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReturnLeaseRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.ReturnLeaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const ReturnLeaseRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ReturnLeaseRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.ReturnLeaseRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.ReturnLeaseRequest)
    MergeFrom(*source);
  }
}

void ReturnLeaseRequest::MergeFrom(const ReturnLeaseRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.ReturnLeaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::RequestHeader::MergeFrom(from._internal_header());
  }
  if (from.has_lease()) {
    _internal_mutable_lease()->::bosdyn::api::Lease::MergeFrom(from._internal_lease());
  }
}

void ReturnLeaseRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.ReturnLeaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReturnLeaseRequest::CopyFrom(const ReturnLeaseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.ReturnLeaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReturnLeaseRequest::IsInitialized() const {
  return true;
}

void ReturnLeaseRequest::InternalSwap(ReturnLeaseRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReturnLeaseRequest, lease_)
      + sizeof(ReturnLeaseRequest::lease_)
      - PROTOBUF_FIELD_OFFSET(ReturnLeaseRequest, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReturnLeaseRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ReturnLeaseResponse::InitAsDefaultInstance() {
  ::bosdyn::api::_ReturnLeaseResponse_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::ResponseHeader*>(
      ::bosdyn::api::ResponseHeader::internal_default_instance());
}
class ReturnLeaseResponse::_Internal {
 public:
  static const ::bosdyn::api::ResponseHeader& header(const ReturnLeaseResponse* msg);
};

const ::bosdyn::api::ResponseHeader&
ReturnLeaseResponse::_Internal::header(const ReturnLeaseResponse* msg) {
  return *msg->header_;
}
void ReturnLeaseResponse::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
ReturnLeaseResponse::ReturnLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.ReturnLeaseResponse)
}
ReturnLeaseResponse::ReturnLeaseResponse(const ReturnLeaseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::ResponseHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.ReturnLeaseResponse)
}

void ReturnLeaseResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ReturnLeaseResponse_bosdyn_2fapi_2flease_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&header_)) + sizeof(status_));
}

ReturnLeaseResponse::~ReturnLeaseResponse() {
  // @@protoc_insertion_point(destructor:bosdyn.api.ReturnLeaseResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ReturnLeaseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
}

void ReturnLeaseResponse::ArenaDtor(void* object) {
  ReturnLeaseResponse* _this = reinterpret_cast< ReturnLeaseResponse* >(object);
  (void)_this;
}
void ReturnLeaseResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ReturnLeaseResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ReturnLeaseResponse& ReturnLeaseResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ReturnLeaseResponse_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void ReturnLeaseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.ReturnLeaseResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  status_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReturnLeaseResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.ReturnLeaseResponse.Status status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_status(static_cast<::bosdyn::api::ReturnLeaseResponse_Status>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ReturnLeaseResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.ReturnLeaseResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // .bosdyn.api.ReturnLeaseResponse.Status status = 2;
  if (this->status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.ReturnLeaseResponse)
  return target;
}

size_t ReturnLeaseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.ReturnLeaseResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  // .bosdyn.api.ReturnLeaseResponse.Status status = 2;
  if (this->status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReturnLeaseResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.ReturnLeaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const ReturnLeaseResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ReturnLeaseResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.ReturnLeaseResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.ReturnLeaseResponse)
    MergeFrom(*source);
  }
}

void ReturnLeaseResponse::MergeFrom(const ReturnLeaseResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.ReturnLeaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::ResponseHeader::MergeFrom(from._internal_header());
  }
  if (from.status() != 0) {
    _internal_set_status(from._internal_status());
  }
}

void ReturnLeaseResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.ReturnLeaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReturnLeaseResponse::CopyFrom(const ReturnLeaseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.ReturnLeaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReturnLeaseResponse::IsInitialized() const {
  return true;
}

void ReturnLeaseResponse::InternalSwap(ReturnLeaseResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReturnLeaseResponse, status_)
      + sizeof(ReturnLeaseResponse::status_)
      - PROTOBUF_FIELD_OFFSET(ReturnLeaseResponse, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReturnLeaseResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ListLeasesRequest::InitAsDefaultInstance() {
  ::bosdyn::api::_ListLeasesRequest_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::RequestHeader*>(
      ::bosdyn::api::RequestHeader::internal_default_instance());
}
class ListLeasesRequest::_Internal {
 public:
  static const ::bosdyn::api::RequestHeader& header(const ListLeasesRequest* msg);
};

const ::bosdyn::api::RequestHeader&
ListLeasesRequest::_Internal::header(const ListLeasesRequest* msg) {
  return *msg->header_;
}
void ListLeasesRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
ListLeasesRequest::ListLeasesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.ListLeasesRequest)
}
ListLeasesRequest::ListLeasesRequest(const ListLeasesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::RequestHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.ListLeasesRequest)
}

void ListLeasesRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ListLeasesRequest_bosdyn_2fapi_2flease_2eproto.base);
  header_ = nullptr;
}

ListLeasesRequest::~ListLeasesRequest() {
  // @@protoc_insertion_point(destructor:bosdyn.api.ListLeasesRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ListLeasesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
}

void ListLeasesRequest::ArenaDtor(void* object) {
  ListLeasesRequest* _this = reinterpret_cast< ListLeasesRequest* >(object);
  (void)_this;
}
void ListLeasesRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListLeasesRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ListLeasesRequest& ListLeasesRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ListLeasesRequest_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void ListLeasesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.ListLeasesRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListLeasesRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ListLeasesRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.ListLeasesRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.ListLeasesRequest)
  return target;
}

size_t ListLeasesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.ListLeasesRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListLeasesRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.ListLeasesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const ListLeasesRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ListLeasesRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.ListLeasesRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.ListLeasesRequest)
    MergeFrom(*source);
  }
}

void ListLeasesRequest::MergeFrom(const ListLeasesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.ListLeasesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::RequestHeader::MergeFrom(from._internal_header());
  }
}

void ListLeasesRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.ListLeasesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ListLeasesRequest::CopyFrom(const ListLeasesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.ListLeasesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListLeasesRequest::IsInitialized() const {
  return true;
}

void ListLeasesRequest::InternalSwap(ListLeasesRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(header_, other->header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListLeasesRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LeaseResource::InitAsDefaultInstance() {
  ::bosdyn::api::_LeaseResource_default_instance_._instance.get_mutable()->lease_ = const_cast< ::bosdyn::api::Lease*>(
      ::bosdyn::api::Lease::internal_default_instance());
  ::bosdyn::api::_LeaseResource_default_instance_._instance.get_mutable()->lease_owner_ = const_cast< ::bosdyn::api::LeaseOwner*>(
      ::bosdyn::api::LeaseOwner::internal_default_instance());
}
class LeaseResource::_Internal {
 public:
  static const ::bosdyn::api::Lease& lease(const LeaseResource* msg);
  static const ::bosdyn::api::LeaseOwner& lease_owner(const LeaseResource* msg);
};

const ::bosdyn::api::Lease&
LeaseResource::_Internal::lease(const LeaseResource* msg) {
  return *msg->lease_;
}
const ::bosdyn::api::LeaseOwner&
LeaseResource::_Internal::lease_owner(const LeaseResource* msg) {
  return *msg->lease_owner_;
}
LeaseResource::LeaseResource(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.LeaseResource)
}
LeaseResource::LeaseResource(const LeaseResource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_resource().empty()) {
    resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_resource(),
      GetArena());
  }
  if (from._internal_has_lease()) {
    lease_ = new ::bosdyn::api::Lease(*from.lease_);
  } else {
    lease_ = nullptr;
  }
  if (from._internal_has_lease_owner()) {
    lease_owner_ = new ::bosdyn::api::LeaseOwner(*from.lease_owner_);
  } else {
    lease_owner_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.LeaseResource)
}

void LeaseResource::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LeaseResource_bosdyn_2fapi_2flease_2eproto.base);
  resource_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&lease_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lease_owner_) -
      reinterpret_cast<char*>(&lease_)) + sizeof(lease_owner_));
}

LeaseResource::~LeaseResource() {
  // @@protoc_insertion_point(destructor:bosdyn.api.LeaseResource)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LeaseResource::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  resource_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete lease_;
  if (this != internal_default_instance()) delete lease_owner_;
}

void LeaseResource::ArenaDtor(void* object) {
  LeaseResource* _this = reinterpret_cast< LeaseResource* >(object);
  (void)_this;
}
void LeaseResource::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LeaseResource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LeaseResource& LeaseResource::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LeaseResource_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void LeaseResource::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.LeaseResource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  resource_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
  if (GetArena() == nullptr && lease_owner_ != nullptr) {
    delete lease_owner_;
  }
  lease_owner_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeaseResource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string resource = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_resource();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "bosdyn.api.LeaseResource.resource"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.Lease lease = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.LeaseOwner lease_owner = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease_owner(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LeaseResource::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.LeaseResource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string resource = 1;
  if (this->resource().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_resource().data(), static_cast<int>(this->_internal_resource().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "bosdyn.api.LeaseResource.resource");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_resource(), target);
  }

  // .bosdyn.api.Lease lease = 2;
  if (this->has_lease()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::lease(this), target, stream);
  }

  // .bosdyn.api.LeaseOwner lease_owner = 3;
  if (this->has_lease_owner()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::lease_owner(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.LeaseResource)
  return target;
}

size_t LeaseResource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.LeaseResource)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string resource = 1;
  if (this->resource().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_resource());
  }

  // .bosdyn.api.Lease lease = 2;
  if (this->has_lease()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_);
  }

  // .bosdyn.api.LeaseOwner lease_owner = 3;
  if (this->has_lease_owner()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_owner_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LeaseResource::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.LeaseResource)
  GOOGLE_DCHECK_NE(&from, this);
  const LeaseResource* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LeaseResource>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.LeaseResource)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.LeaseResource)
    MergeFrom(*source);
  }
}

void LeaseResource::MergeFrom(const LeaseResource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.LeaseResource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.resource().size() > 0) {
    _internal_set_resource(from._internal_resource());
  }
  if (from.has_lease()) {
    _internal_mutable_lease()->::bosdyn::api::Lease::MergeFrom(from._internal_lease());
  }
  if (from.has_lease_owner()) {
    _internal_mutable_lease_owner()->::bosdyn::api::LeaseOwner::MergeFrom(from._internal_lease_owner());
  }
}

void LeaseResource::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.LeaseResource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaseResource::CopyFrom(const LeaseResource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.LeaseResource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseResource::IsInitialized() const {
  return true;
}

void LeaseResource::InternalSwap(LeaseResource* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  resource_.Swap(&other->resource_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeaseResource, lease_owner_)
      + sizeof(LeaseResource::lease_owner_)
      - PROTOBUF_FIELD_OFFSET(LeaseResource, lease_)>(
          reinterpret_cast<char*>(&lease_),
          reinterpret_cast<char*>(&other->lease_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeaseResource::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ListLeasesResponse::InitAsDefaultInstance() {
  ::bosdyn::api::_ListLeasesResponse_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::ResponseHeader*>(
      ::bosdyn::api::ResponseHeader::internal_default_instance());
}
class ListLeasesResponse::_Internal {
 public:
  static const ::bosdyn::api::ResponseHeader& header(const ListLeasesResponse* msg);
};

const ::bosdyn::api::ResponseHeader&
ListLeasesResponse::_Internal::header(const ListLeasesResponse* msg) {
  return *msg->header_;
}
void ListLeasesResponse::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
ListLeasesResponse::ListLeasesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  resources_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.ListLeasesResponse)
}
ListLeasesResponse::ListLeasesResponse(const ListLeasesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      resources_(from.resources_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::ResponseHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.ListLeasesResponse)
}

void ListLeasesResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ListLeasesResponse_bosdyn_2fapi_2flease_2eproto.base);
  header_ = nullptr;
}

ListLeasesResponse::~ListLeasesResponse() {
  // @@protoc_insertion_point(destructor:bosdyn.api.ListLeasesResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ListLeasesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
}

void ListLeasesResponse::ArenaDtor(void* object) {
  ListLeasesResponse* _this = reinterpret_cast< ListLeasesResponse* >(object);
  (void)_this;
}
void ListLeasesResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ListLeasesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ListLeasesResponse& ListLeasesResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ListLeasesResponse_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void ListLeasesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.ListLeasesResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  resources_.Clear();
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListLeasesResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .bosdyn.api.LeaseResource resources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ListLeasesResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.ListLeasesResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // repeated .bosdyn.api.LeaseResource resources = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_resources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_resources(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.ListLeasesResponse)
  return target;
}

size_t ListLeasesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.ListLeasesResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .bosdyn.api.LeaseResource resources = 2;
  total_size += 1UL * this->_internal_resources_size();
  for (const auto& msg : this->resources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListLeasesResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.ListLeasesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const ListLeasesResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ListLeasesResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.ListLeasesResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.ListLeasesResponse)
    MergeFrom(*source);
  }
}

void ListLeasesResponse::MergeFrom(const ListLeasesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.ListLeasesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  resources_.MergeFrom(from.resources_);
  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::ResponseHeader::MergeFrom(from._internal_header());
  }
}

void ListLeasesResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.ListLeasesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ListLeasesResponse::CopyFrom(const ListLeasesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.ListLeasesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListLeasesResponse::IsInitialized() const {
  return true;
}

void ListLeasesResponse::InternalSwap(ListLeasesResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  resources_.InternalSwap(&other->resources_);
  swap(header_, other->header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ListLeasesResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RetainLeaseRequest::InitAsDefaultInstance() {
  ::bosdyn::api::_RetainLeaseRequest_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::RequestHeader*>(
      ::bosdyn::api::RequestHeader::internal_default_instance());
  ::bosdyn::api::_RetainLeaseRequest_default_instance_._instance.get_mutable()->lease_ = const_cast< ::bosdyn::api::Lease*>(
      ::bosdyn::api::Lease::internal_default_instance());
}
class RetainLeaseRequest::_Internal {
 public:
  static const ::bosdyn::api::RequestHeader& header(const RetainLeaseRequest* msg);
  static const ::bosdyn::api::Lease& lease(const RetainLeaseRequest* msg);
};

const ::bosdyn::api::RequestHeader&
RetainLeaseRequest::_Internal::header(const RetainLeaseRequest* msg) {
  return *msg->header_;
}
const ::bosdyn::api::Lease&
RetainLeaseRequest::_Internal::lease(const RetainLeaseRequest* msg) {
  return *msg->lease_;
}
void RetainLeaseRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
RetainLeaseRequest::RetainLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.RetainLeaseRequest)
}
RetainLeaseRequest::RetainLeaseRequest(const RetainLeaseRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::RequestHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_lease()) {
    lease_ = new ::bosdyn::api::Lease(*from.lease_);
  } else {
    lease_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.RetainLeaseRequest)
}

void RetainLeaseRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RetainLeaseRequest_bosdyn_2fapi_2flease_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lease_) -
      reinterpret_cast<char*>(&header_)) + sizeof(lease_));
}

RetainLeaseRequest::~RetainLeaseRequest() {
  // @@protoc_insertion_point(destructor:bosdyn.api.RetainLeaseRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RetainLeaseRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete lease_;
}

void RetainLeaseRequest::ArenaDtor(void* object) {
  RetainLeaseRequest* _this = reinterpret_cast< RetainLeaseRequest* >(object);
  (void)_this;
}
void RetainLeaseRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RetainLeaseRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RetainLeaseRequest& RetainLeaseRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RetainLeaseRequest_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void RetainLeaseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.RetainLeaseRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RetainLeaseRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.RequestHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.Lease lease = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RetainLeaseRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.RetainLeaseRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // .bosdyn.api.Lease lease = 2;
  if (this->has_lease()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::lease(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.RetainLeaseRequest)
  return target;
}

size_t RetainLeaseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.RetainLeaseRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bosdyn.api.RequestHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  // .bosdyn.api.Lease lease = 2;
  if (this->has_lease()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RetainLeaseRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.RetainLeaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const RetainLeaseRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RetainLeaseRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.RetainLeaseRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.RetainLeaseRequest)
    MergeFrom(*source);
  }
}

void RetainLeaseRequest::MergeFrom(const RetainLeaseRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.RetainLeaseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::RequestHeader::MergeFrom(from._internal_header());
  }
  if (from.has_lease()) {
    _internal_mutable_lease()->::bosdyn::api::Lease::MergeFrom(from._internal_lease());
  }
}

void RetainLeaseRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.RetainLeaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RetainLeaseRequest::CopyFrom(const RetainLeaseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.RetainLeaseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RetainLeaseRequest::IsInitialized() const {
  return true;
}

void RetainLeaseRequest::InternalSwap(RetainLeaseRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RetainLeaseRequest, lease_)
      + sizeof(RetainLeaseRequest::lease_)
      - PROTOBUF_FIELD_OFFSET(RetainLeaseRequest, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RetainLeaseRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RetainLeaseResponse::InitAsDefaultInstance() {
  ::bosdyn::api::_RetainLeaseResponse_default_instance_._instance.get_mutable()->header_ = const_cast< ::bosdyn::api::ResponseHeader*>(
      ::bosdyn::api::ResponseHeader::internal_default_instance());
  ::bosdyn::api::_RetainLeaseResponse_default_instance_._instance.get_mutable()->lease_use_result_ = const_cast< ::bosdyn::api::LeaseUseResult*>(
      ::bosdyn::api::LeaseUseResult::internal_default_instance());
}
class RetainLeaseResponse::_Internal {
 public:
  static const ::bosdyn::api::ResponseHeader& header(const RetainLeaseResponse* msg);
  static const ::bosdyn::api::LeaseUseResult& lease_use_result(const RetainLeaseResponse* msg);
};

const ::bosdyn::api::ResponseHeader&
RetainLeaseResponse::_Internal::header(const RetainLeaseResponse* msg) {
  return *msg->header_;
}
const ::bosdyn::api::LeaseUseResult&
RetainLeaseResponse::_Internal::lease_use_result(const RetainLeaseResponse* msg) {
  return *msg->lease_use_result_;
}
void RetainLeaseResponse::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
RetainLeaseResponse::RetainLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:bosdyn.api.RetainLeaseResponse)
}
RetainLeaseResponse::RetainLeaseResponse(const RetainLeaseResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_header()) {
    header_ = new ::bosdyn::api::ResponseHeader(*from.header_);
  } else {
    header_ = nullptr;
  }
  if (from._internal_has_lease_use_result()) {
    lease_use_result_ = new ::bosdyn::api::LeaseUseResult(*from.lease_use_result_);
  } else {
    lease_use_result_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:bosdyn.api.RetainLeaseResponse)
}

void RetainLeaseResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RetainLeaseResponse_bosdyn_2fapi_2flease_2eproto.base);
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lease_use_result_) -
      reinterpret_cast<char*>(&header_)) + sizeof(lease_use_result_));
}

RetainLeaseResponse::~RetainLeaseResponse() {
  // @@protoc_insertion_point(destructor:bosdyn.api.RetainLeaseResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RetainLeaseResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete lease_use_result_;
}

void RetainLeaseResponse::ArenaDtor(void* object) {
  RetainLeaseResponse* _this = reinterpret_cast< RetainLeaseResponse* >(object);
  (void)_this;
}
void RetainLeaseResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RetainLeaseResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RetainLeaseResponse& RetainLeaseResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RetainLeaseResponse_bosdyn_2fapi_2flease_2eproto.base);
  return *internal_default_instance();
}


void RetainLeaseResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:bosdyn.api.RetainLeaseResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
  if (GetArena() == nullptr && lease_use_result_ != nullptr) {
    delete lease_use_result_;
  }
  lease_use_result_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RetainLeaseResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .bosdyn.api.ResponseHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .bosdyn.api.LeaseUseResult lease_use_result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_lease_use_result(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RetainLeaseResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:bosdyn.api.RetainLeaseResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::header(this), target, stream);
  }

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  if (this->has_lease_use_result()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::lease_use_result(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:bosdyn.api.RetainLeaseResponse)
  return target;
}

size_t RetainLeaseResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:bosdyn.api.RetainLeaseResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .bosdyn.api.ResponseHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  if (this->has_lease_use_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lease_use_result_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RetainLeaseResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:bosdyn.api.RetainLeaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const RetainLeaseResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RetainLeaseResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:bosdyn.api.RetainLeaseResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:bosdyn.api.RetainLeaseResponse)
    MergeFrom(*source);
  }
}

void RetainLeaseResponse::MergeFrom(const RetainLeaseResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:bosdyn.api.RetainLeaseResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    _internal_mutable_header()->::bosdyn::api::ResponseHeader::MergeFrom(from._internal_header());
  }
  if (from.has_lease_use_result()) {
    _internal_mutable_lease_use_result()->::bosdyn::api::LeaseUseResult::MergeFrom(from._internal_lease_use_result());
  }
}

void RetainLeaseResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:bosdyn.api.RetainLeaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RetainLeaseResponse::CopyFrom(const RetainLeaseResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:bosdyn.api.RetainLeaseResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RetainLeaseResponse::IsInitialized() const {
  return true;
}

void RetainLeaseResponse::InternalSwap(RetainLeaseResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RetainLeaseResponse, lease_use_result_)
      + sizeof(RetainLeaseResponse::lease_use_result_)
      - PROTOBUF_FIELD_OFFSET(RetainLeaseResponse, header_)>(
          reinterpret_cast<char*>(&header_),
          reinterpret_cast<char*>(&other->header_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RetainLeaseResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::bosdyn::api::Lease* Arena::CreateMaybeMessage< ::bosdyn::api::Lease >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::Lease >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::LeaseOwner* Arena::CreateMaybeMessage< ::bosdyn::api::LeaseOwner >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::LeaseOwner >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::LeaseUseResult* Arena::CreateMaybeMessage< ::bosdyn::api::LeaseUseResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::LeaseUseResult >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::AcquireLeaseRequest* Arena::CreateMaybeMessage< ::bosdyn::api::AcquireLeaseRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::AcquireLeaseRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::AcquireLeaseResponse* Arena::CreateMaybeMessage< ::bosdyn::api::AcquireLeaseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::AcquireLeaseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::TakeLeaseRequest* Arena::CreateMaybeMessage< ::bosdyn::api::TakeLeaseRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::TakeLeaseRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::TakeLeaseResponse* Arena::CreateMaybeMessage< ::bosdyn::api::TakeLeaseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::TakeLeaseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::ReturnLeaseRequest* Arena::CreateMaybeMessage< ::bosdyn::api::ReturnLeaseRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::ReturnLeaseRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::ReturnLeaseResponse* Arena::CreateMaybeMessage< ::bosdyn::api::ReturnLeaseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::ReturnLeaseResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::ListLeasesRequest* Arena::CreateMaybeMessage< ::bosdyn::api::ListLeasesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::ListLeasesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::LeaseResource* Arena::CreateMaybeMessage< ::bosdyn::api::LeaseResource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::LeaseResource >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::ListLeasesResponse* Arena::CreateMaybeMessage< ::bosdyn::api::ListLeasesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::ListLeasesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::RetainLeaseRequest* Arena::CreateMaybeMessage< ::bosdyn::api::RetainLeaseRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::RetainLeaseRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::bosdyn::api::RetainLeaseResponse* Arena::CreateMaybeMessage< ::bosdyn::api::RetainLeaseResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::bosdyn::api::RetainLeaseResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
