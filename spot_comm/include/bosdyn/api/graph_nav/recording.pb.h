// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/graph_nav/recording.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/license.pb.h"
#include "bosdyn/api/graph_nav/map.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
namespace bosdyn {
namespace api {
namespace graph_nav {
class CreateEdgeRequest;
class CreateEdgeRequestDefaultTypeInternal;
extern CreateEdgeRequestDefaultTypeInternal _CreateEdgeRequest_default_instance_;
class CreateEdgeResponse;
class CreateEdgeResponseDefaultTypeInternal;
extern CreateEdgeResponseDefaultTypeInternal _CreateEdgeResponse_default_instance_;
class CreateWaypointRequest;
class CreateWaypointRequestDefaultTypeInternal;
extern CreateWaypointRequestDefaultTypeInternal _CreateWaypointRequest_default_instance_;
class CreateWaypointResponse;
class CreateWaypointResponseDefaultTypeInternal;
extern CreateWaypointResponseDefaultTypeInternal _CreateWaypointResponse_default_instance_;
class GetRecordStatusRequest;
class GetRecordStatusRequestDefaultTypeInternal;
extern GetRecordStatusRequestDefaultTypeInternal _GetRecordStatusRequest_default_instance_;
class GetRecordStatusResponse;
class GetRecordStatusResponseDefaultTypeInternal;
extern GetRecordStatusResponseDefaultTypeInternal _GetRecordStatusResponse_default_instance_;
class RecordingEnvironment;
class RecordingEnvironmentDefaultTypeInternal;
extern RecordingEnvironmentDefaultTypeInternal _RecordingEnvironment_default_instance_;
class SetRecordingEnvironmentRequest;
class SetRecordingEnvironmentRequestDefaultTypeInternal;
extern SetRecordingEnvironmentRequestDefaultTypeInternal _SetRecordingEnvironmentRequest_default_instance_;
class SetRecordingEnvironmentResponse;
class SetRecordingEnvironmentResponseDefaultTypeInternal;
extern SetRecordingEnvironmentResponseDefaultTypeInternal _SetRecordingEnvironmentResponse_default_instance_;
class StartRecordingRequest;
class StartRecordingRequestDefaultTypeInternal;
extern StartRecordingRequestDefaultTypeInternal _StartRecordingRequest_default_instance_;
class StartRecordingResponse;
class StartRecordingResponseDefaultTypeInternal;
extern StartRecordingResponseDefaultTypeInternal _StartRecordingResponse_default_instance_;
class StopRecordingRequest;
class StopRecordingRequestDefaultTypeInternal;
extern StopRecordingRequestDefaultTypeInternal _StopRecordingRequest_default_instance_;
class StopRecordingResponse;
class StopRecordingResponseDefaultTypeInternal;
extern StopRecordingResponseDefaultTypeInternal _StopRecordingResponse_default_instance_;
}  // namespace graph_nav
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::graph_nav::CreateEdgeRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::CreateEdgeRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::CreateEdgeResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::CreateEdgeResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::CreateWaypointRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::CreateWaypointRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::CreateWaypointResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::CreateWaypointResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::GetRecordStatusRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::GetRecordStatusRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::GetRecordStatusResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::GetRecordStatusResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::RecordingEnvironment* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::RecordingEnvironment>(Arena*);
template<> ::bosdyn::api::graph_nav::SetRecordingEnvironmentRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::SetRecordingEnvironmentRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::SetRecordingEnvironmentResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::SetRecordingEnvironmentResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::StartRecordingRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::StartRecordingRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::StartRecordingResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::StartRecordingResponse>(Arena*);
template<> ::bosdyn::api::graph_nav::StopRecordingRequest* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::StopRecordingRequest>(Arena*);
template<> ::bosdyn::api::graph_nav::StopRecordingResponse* Arena::CreateMaybeMessage<::bosdyn::api::graph_nav::StopRecordingResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace graph_nav {

enum StartRecordingResponse_Status : int {
  StartRecordingResponse_Status_STATUS_UNKNOWN = 0,
  StartRecordingResponse_Status_STATUS_OK = 1,
  StartRecordingResponse_Status_STATUS_COULD_NOT_CREATE_WAYPOINT = 2,
  StartRecordingResponse_Status_STATUS_FOLLOWING_ROUTE = 3,
  StartRecordingResponse_Status_STATUS_NOT_LOCALIZED_TO_EXISTING_MAP = 4,
  StartRecordingResponse_Status_STATUS_MISSING_FIDUCIALS = 5,
  StartRecordingResponse_Status_STATUS_MAP_TOO_LARGE_LICENSE = 6,
  StartRecordingResponse_Status_StartRecordingResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StartRecordingResponse_Status_StartRecordingResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StartRecordingResponse_Status_IsValid(int value);
constexpr StartRecordingResponse_Status StartRecordingResponse_Status_Status_MIN = StartRecordingResponse_Status_STATUS_UNKNOWN;
constexpr StartRecordingResponse_Status StartRecordingResponse_Status_Status_MAX = StartRecordingResponse_Status_STATUS_MAP_TOO_LARGE_LICENSE;
constexpr int StartRecordingResponse_Status_Status_ARRAYSIZE = StartRecordingResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StartRecordingResponse_Status_descriptor();
template<typename T>
inline const std::string& StartRecordingResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartRecordingResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartRecordingResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StartRecordingResponse_Status_descriptor(), enum_t_value);
}
inline bool StartRecordingResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StartRecordingResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StartRecordingResponse_Status>(
    StartRecordingResponse_Status_descriptor(), name, value);
}
enum StopRecordingResponse_Status : int {
  StopRecordingResponse_Status_STATUS_UNKNOWN = 0,
  StopRecordingResponse_Status_STATUS_OK = 1,
  StopRecordingResponse_Status_STATUS_NOT_LOCALIZED_TO_END = 2,
  StopRecordingResponse_Status_STATUS_NOT_READY_YET = 3,
  StopRecordingResponse_Status_StopRecordingResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StopRecordingResponse_Status_StopRecordingResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StopRecordingResponse_Status_IsValid(int value);
constexpr StopRecordingResponse_Status StopRecordingResponse_Status_Status_MIN = StopRecordingResponse_Status_STATUS_UNKNOWN;
constexpr StopRecordingResponse_Status StopRecordingResponse_Status_Status_MAX = StopRecordingResponse_Status_STATUS_NOT_READY_YET;
constexpr int StopRecordingResponse_Status_Status_ARRAYSIZE = StopRecordingResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StopRecordingResponse_Status_descriptor();
template<typename T>
inline const std::string& StopRecordingResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopRecordingResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopRecordingResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StopRecordingResponse_Status_descriptor(), enum_t_value);
}
inline bool StopRecordingResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StopRecordingResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StopRecordingResponse_Status>(
    StopRecordingResponse_Status_descriptor(), name, value);
}
enum CreateWaypointResponse_Status : int {
  CreateWaypointResponse_Status_STATUS_UNKNOWN = 0,
  CreateWaypointResponse_Status_STATUS_OK = 1,
  CreateWaypointResponse_Status_STATUS_NOT_RECORDING = 2,
  CreateWaypointResponse_Status_STATUS_COULD_NOT_CREATE_WAYPOINT = 3,
  CreateWaypointResponse_Status_STATUS_MISSING_FIDUCIALS = 4,
  CreateWaypointResponse_Status_STATUS_MAP_TOO_LARGE_LICENSE = 5,
  CreateWaypointResponse_Status_CreateWaypointResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CreateWaypointResponse_Status_CreateWaypointResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CreateWaypointResponse_Status_IsValid(int value);
constexpr CreateWaypointResponse_Status CreateWaypointResponse_Status_Status_MIN = CreateWaypointResponse_Status_STATUS_UNKNOWN;
constexpr CreateWaypointResponse_Status CreateWaypointResponse_Status_Status_MAX = CreateWaypointResponse_Status_STATUS_MAP_TOO_LARGE_LICENSE;
constexpr int CreateWaypointResponse_Status_Status_ARRAYSIZE = CreateWaypointResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CreateWaypointResponse_Status_descriptor();
template<typename T>
inline const std::string& CreateWaypointResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreateWaypointResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreateWaypointResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CreateWaypointResponse_Status_descriptor(), enum_t_value);
}
inline bool CreateWaypointResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CreateWaypointResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CreateWaypointResponse_Status>(
    CreateWaypointResponse_Status_descriptor(), name, value);
}
enum CreateEdgeResponse_Status : int {
  CreateEdgeResponse_Status_STATUS_UNKNOWN = 0,
  CreateEdgeResponse_Status_STATUS_OK = 1,
  CreateEdgeResponse_Status_STATUS_EXISTS = 2,
  CreateEdgeResponse_Status_STATUS_NOT_RECORDING = 3,
  CreateEdgeResponse_Status_STATUS_UNKNOWN_WAYPOINT = 4,
  CreateEdgeResponse_Status_STATUS_MISSING_TRANSFORM = 5,
  CreateEdgeResponse_Status_CreateEdgeResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CreateEdgeResponse_Status_CreateEdgeResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CreateEdgeResponse_Status_IsValid(int value);
constexpr CreateEdgeResponse_Status CreateEdgeResponse_Status_Status_MIN = CreateEdgeResponse_Status_STATUS_UNKNOWN;
constexpr CreateEdgeResponse_Status CreateEdgeResponse_Status_Status_MAX = CreateEdgeResponse_Status_STATUS_MISSING_TRANSFORM;
constexpr int CreateEdgeResponse_Status_Status_ARRAYSIZE = CreateEdgeResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CreateEdgeResponse_Status_descriptor();
template<typename T>
inline const std::string& CreateEdgeResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreateEdgeResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreateEdgeResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CreateEdgeResponse_Status_descriptor(), enum_t_value);
}
inline bool CreateEdgeResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CreateEdgeResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CreateEdgeResponse_Status>(
    CreateEdgeResponse_Status_descriptor(), name, value);
}
enum GetRecordStatusResponse_MapState : int {
  GetRecordStatusResponse_MapState_MAP_STATE_UNKNOWN = 0,
  GetRecordStatusResponse_MapState_MAP_STATE_OK = 1,
  GetRecordStatusResponse_MapState_MAP_STATE_TOO_LARGE_FOR_LICENSE = 2,
  GetRecordStatusResponse_MapState_GetRecordStatusResponse_MapState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GetRecordStatusResponse_MapState_GetRecordStatusResponse_MapState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GetRecordStatusResponse_MapState_IsValid(int value);
constexpr GetRecordStatusResponse_MapState GetRecordStatusResponse_MapState_MapState_MIN = GetRecordStatusResponse_MapState_MAP_STATE_UNKNOWN;
constexpr GetRecordStatusResponse_MapState GetRecordStatusResponse_MapState_MapState_MAX = GetRecordStatusResponse_MapState_MAP_STATE_TOO_LARGE_FOR_LICENSE;
constexpr int GetRecordStatusResponse_MapState_MapState_ARRAYSIZE = GetRecordStatusResponse_MapState_MapState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetRecordStatusResponse_MapState_descriptor();
template<typename T>
inline const std::string& GetRecordStatusResponse_MapState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetRecordStatusResponse_MapState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetRecordStatusResponse_MapState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetRecordStatusResponse_MapState_descriptor(), enum_t_value);
}
inline bool GetRecordStatusResponse_MapState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetRecordStatusResponse_MapState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetRecordStatusResponse_MapState>(
    GetRecordStatusResponse_MapState_descriptor(), name, value);
}
// ===================================================================

class RecordingEnvironment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.RecordingEnvironment) */ {
 public:
  inline RecordingEnvironment() : RecordingEnvironment(nullptr) {}
  virtual ~RecordingEnvironment();

  RecordingEnvironment(const RecordingEnvironment& from);
  RecordingEnvironment(RecordingEnvironment&& from) noexcept
    : RecordingEnvironment() {
    *this = ::std::move(from);
  }

  inline RecordingEnvironment& operator=(const RecordingEnvironment& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordingEnvironment& operator=(RecordingEnvironment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecordingEnvironment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordingEnvironment* internal_default_instance() {
    return reinterpret_cast<const RecordingEnvironment*>(
               &_RecordingEnvironment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RecordingEnvironment& a, RecordingEnvironment& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordingEnvironment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordingEnvironment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordingEnvironment* New() const final {
    return CreateMaybeMessage<RecordingEnvironment>(nullptr);
  }

  RecordingEnvironment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordingEnvironment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecordingEnvironment& from);
  void MergeFrom(const RecordingEnvironment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordingEnvironment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.RecordingEnvironment";
  }
  protected:
  explicit RecordingEnvironment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamePrefixFieldNumber = 1,
    kWaypointEnvironmentFieldNumber = 2,
    kEdgeEnvironmentFieldNumber = 3,
  };
  // string name_prefix = 1;
  void clear_name_prefix();
  const std::string& name_prefix() const;
  void set_name_prefix(const std::string& value);
  void set_name_prefix(std::string&& value);
  void set_name_prefix(const char* value);
  void set_name_prefix(const char* value, size_t size);
  std::string* mutable_name_prefix();
  std::string* release_name_prefix();
  void set_allocated_name_prefix(std::string* name_prefix);
  private:
  const std::string& _internal_name_prefix() const;
  void _internal_set_name_prefix(const std::string& value);
  std::string* _internal_mutable_name_prefix();
  public:

  // .bosdyn.api.graph_nav.Waypoint.Annotations waypoint_environment = 2;
  bool has_waypoint_environment() const;
  private:
  bool _internal_has_waypoint_environment() const;
  public:
  void clear_waypoint_environment();
  const ::bosdyn::api::graph_nav::Waypoint_Annotations& waypoint_environment() const;
  ::bosdyn::api::graph_nav::Waypoint_Annotations* release_waypoint_environment();
  ::bosdyn::api::graph_nav::Waypoint_Annotations* mutable_waypoint_environment();
  void set_allocated_waypoint_environment(::bosdyn::api::graph_nav::Waypoint_Annotations* waypoint_environment);
  private:
  const ::bosdyn::api::graph_nav::Waypoint_Annotations& _internal_waypoint_environment() const;
  ::bosdyn::api::graph_nav::Waypoint_Annotations* _internal_mutable_waypoint_environment();
  public:
  void unsafe_arena_set_allocated_waypoint_environment(
      ::bosdyn::api::graph_nav::Waypoint_Annotations* waypoint_environment);
  ::bosdyn::api::graph_nav::Waypoint_Annotations* unsafe_arena_release_waypoint_environment();

  // .bosdyn.api.graph_nav.Edge.Annotations edge_environment = 3;
  bool has_edge_environment() const;
  private:
  bool _internal_has_edge_environment() const;
  public:
  void clear_edge_environment();
  const ::bosdyn::api::graph_nav::Edge_Annotations& edge_environment() const;
  ::bosdyn::api::graph_nav::Edge_Annotations* release_edge_environment();
  ::bosdyn::api::graph_nav::Edge_Annotations* mutable_edge_environment();
  void set_allocated_edge_environment(::bosdyn::api::graph_nav::Edge_Annotations* edge_environment);
  private:
  const ::bosdyn::api::graph_nav::Edge_Annotations& _internal_edge_environment() const;
  ::bosdyn::api::graph_nav::Edge_Annotations* _internal_mutable_edge_environment();
  public:
  void unsafe_arena_set_allocated_edge_environment(
      ::bosdyn::api::graph_nav::Edge_Annotations* edge_environment);
  ::bosdyn::api::graph_nav::Edge_Annotations* unsafe_arena_release_edge_environment();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.RecordingEnvironment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_prefix_;
  ::bosdyn::api::graph_nav::Waypoint_Annotations* waypoint_environment_;
  ::bosdyn::api::graph_nav::Edge_Annotations* edge_environment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class SetRecordingEnvironmentRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest) */ {
 public:
  inline SetRecordingEnvironmentRequest() : SetRecordingEnvironmentRequest(nullptr) {}
  virtual ~SetRecordingEnvironmentRequest();

  SetRecordingEnvironmentRequest(const SetRecordingEnvironmentRequest& from);
  SetRecordingEnvironmentRequest(SetRecordingEnvironmentRequest&& from) noexcept
    : SetRecordingEnvironmentRequest() {
    *this = ::std::move(from);
  }

  inline SetRecordingEnvironmentRequest& operator=(const SetRecordingEnvironmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRecordingEnvironmentRequest& operator=(SetRecordingEnvironmentRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetRecordingEnvironmentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetRecordingEnvironmentRequest* internal_default_instance() {
    return reinterpret_cast<const SetRecordingEnvironmentRequest*>(
               &_SetRecordingEnvironmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetRecordingEnvironmentRequest& a, SetRecordingEnvironmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRecordingEnvironmentRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRecordingEnvironmentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetRecordingEnvironmentRequest* New() const final {
    return CreateMaybeMessage<SetRecordingEnvironmentRequest>(nullptr);
  }

  SetRecordingEnvironmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetRecordingEnvironmentRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetRecordingEnvironmentRequest& from);
  void MergeFrom(const SetRecordingEnvironmentRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRecordingEnvironmentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.SetRecordingEnvironmentRequest";
  }
  protected:
  explicit SetRecordingEnvironmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEnvironmentFieldNumber = 2,
    kLeaseFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.RecordingEnvironment environment = 2;
  bool has_environment() const;
  private:
  bool _internal_has_environment() const;
  public:
  void clear_environment();
  const ::bosdyn::api::graph_nav::RecordingEnvironment& environment() const;
  ::bosdyn::api::graph_nav::RecordingEnvironment* release_environment();
  ::bosdyn::api::graph_nav::RecordingEnvironment* mutable_environment();
  void set_allocated_environment(::bosdyn::api::graph_nav::RecordingEnvironment* environment);
  private:
  const ::bosdyn::api::graph_nav::RecordingEnvironment& _internal_environment() const;
  ::bosdyn::api::graph_nav::RecordingEnvironment* _internal_mutable_environment();
  public:
  void unsafe_arena_set_allocated_environment(
      ::bosdyn::api::graph_nav::RecordingEnvironment* environment);
  ::bosdyn::api::graph_nav::RecordingEnvironment* unsafe_arena_release_environment();

  // .bosdyn.api.Lease lease = 3;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::graph_nav::RecordingEnvironment* environment_;
  ::bosdyn::api::Lease* lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class SetRecordingEnvironmentResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse) */ {
 public:
  inline SetRecordingEnvironmentResponse() : SetRecordingEnvironmentResponse(nullptr) {}
  virtual ~SetRecordingEnvironmentResponse();

  SetRecordingEnvironmentResponse(const SetRecordingEnvironmentResponse& from);
  SetRecordingEnvironmentResponse(SetRecordingEnvironmentResponse&& from) noexcept
    : SetRecordingEnvironmentResponse() {
    *this = ::std::move(from);
  }

  inline SetRecordingEnvironmentResponse& operator=(const SetRecordingEnvironmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRecordingEnvironmentResponse& operator=(SetRecordingEnvironmentResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetRecordingEnvironmentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetRecordingEnvironmentResponse* internal_default_instance() {
    return reinterpret_cast<const SetRecordingEnvironmentResponse*>(
               &_SetRecordingEnvironmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SetRecordingEnvironmentResponse& a, SetRecordingEnvironmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRecordingEnvironmentResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRecordingEnvironmentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetRecordingEnvironmentResponse* New() const final {
    return CreateMaybeMessage<SetRecordingEnvironmentResponse>(nullptr);
  }

  SetRecordingEnvironmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetRecordingEnvironmentResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetRecordingEnvironmentResponse& from);
  void MergeFrom(const SetRecordingEnvironmentResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRecordingEnvironmentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.SetRecordingEnvironmentResponse";
  }
  protected:
  explicit SetRecordingEnvironmentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class StartRecordingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.StartRecordingRequest) */ {
 public:
  inline StartRecordingRequest() : StartRecordingRequest(nullptr) {}
  virtual ~StartRecordingRequest();

  StartRecordingRequest(const StartRecordingRequest& from);
  StartRecordingRequest(StartRecordingRequest&& from) noexcept
    : StartRecordingRequest() {
    *this = ::std::move(from);
  }

  inline StartRecordingRequest& operator=(const StartRecordingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartRecordingRequest& operator=(StartRecordingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartRecordingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartRecordingRequest* internal_default_instance() {
    return reinterpret_cast<const StartRecordingRequest*>(
               &_StartRecordingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StartRecordingRequest& a, StartRecordingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartRecordingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartRecordingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartRecordingRequest* New() const final {
    return CreateMaybeMessage<StartRecordingRequest>(nullptr);
  }

  StartRecordingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartRecordingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartRecordingRequest& from);
  void MergeFrom(const StartRecordingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartRecordingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.StartRecordingRequest";
  }
  protected:
  explicit StartRecordingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequireFiducialsFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kRecordingEnvironmentFieldNumber = 3,
  };
  // repeated int32 require_fiducials = 4;
  int require_fiducials_size() const;
  private:
  int _internal_require_fiducials_size() const;
  public:
  void clear_require_fiducials();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_require_fiducials(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_require_fiducials() const;
  void _internal_add_require_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_require_fiducials();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 require_fiducials(int index) const;
  void set_require_fiducials(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_require_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      require_fiducials() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_require_fiducials();

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.graph_nav.RecordingEnvironment recording_environment = 3;
  bool has_recording_environment() const;
  private:
  bool _internal_has_recording_environment() const;
  public:
  void clear_recording_environment();
  const ::bosdyn::api::graph_nav::RecordingEnvironment& recording_environment() const;
  ::bosdyn::api::graph_nav::RecordingEnvironment* release_recording_environment();
  ::bosdyn::api::graph_nav::RecordingEnvironment* mutable_recording_environment();
  void set_allocated_recording_environment(::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment);
  private:
  const ::bosdyn::api::graph_nav::RecordingEnvironment& _internal_recording_environment() const;
  ::bosdyn::api::graph_nav::RecordingEnvironment* _internal_mutable_recording_environment();
  public:
  void unsafe_arena_set_allocated_recording_environment(
      ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment);
  ::bosdyn::api::graph_nav::RecordingEnvironment* unsafe_arena_release_recording_environment();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.StartRecordingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > require_fiducials_;
  mutable std::atomic<int> _require_fiducials_cached_byte_size_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class StartRecordingResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.StartRecordingResponse) */ {
 public:
  inline StartRecordingResponse() : StartRecordingResponse(nullptr) {}
  virtual ~StartRecordingResponse();

  StartRecordingResponse(const StartRecordingResponse& from);
  StartRecordingResponse(StartRecordingResponse&& from) noexcept
    : StartRecordingResponse() {
    *this = ::std::move(from);
  }

  inline StartRecordingResponse& operator=(const StartRecordingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartRecordingResponse& operator=(StartRecordingResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartRecordingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartRecordingResponse* internal_default_instance() {
    return reinterpret_cast<const StartRecordingResponse*>(
               &_StartRecordingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StartRecordingResponse& a, StartRecordingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartRecordingResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartRecordingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartRecordingResponse* New() const final {
    return CreateMaybeMessage<StartRecordingResponse>(nullptr);
  }

  StartRecordingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartRecordingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartRecordingResponse& from);
  void MergeFrom(const StartRecordingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartRecordingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.StartRecordingResponse";
  }
  protected:
  explicit StartRecordingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef StartRecordingResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    StartRecordingResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    StartRecordingResponse_Status_STATUS_OK;
  static constexpr Status STATUS_COULD_NOT_CREATE_WAYPOINT =
    StartRecordingResponse_Status_STATUS_COULD_NOT_CREATE_WAYPOINT;
  static constexpr Status STATUS_FOLLOWING_ROUTE =
    StartRecordingResponse_Status_STATUS_FOLLOWING_ROUTE;
  static constexpr Status STATUS_NOT_LOCALIZED_TO_EXISTING_MAP =
    StartRecordingResponse_Status_STATUS_NOT_LOCALIZED_TO_EXISTING_MAP;
  static constexpr Status STATUS_MISSING_FIDUCIALS =
    StartRecordingResponse_Status_STATUS_MISSING_FIDUCIALS;
  static constexpr Status STATUS_MAP_TOO_LARGE_LICENSE =
    StartRecordingResponse_Status_STATUS_MAP_TOO_LARGE_LICENSE;
  static inline bool Status_IsValid(int value) {
    return StartRecordingResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StartRecordingResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StartRecordingResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StartRecordingResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StartRecordingResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StartRecordingResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StartRecordingResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMissingFiducialsFieldNumber = 5,
    kHeaderFieldNumber = 1,
    kCreatedWaypointFieldNumber = 2,
    kLeaseUseResultFieldNumber = 3,
    kStatusFieldNumber = 4,
    kLicenseStatusFieldNumber = 6,
  };
  // repeated int32 missing_fiducials = 5;
  int missing_fiducials_size() const;
  private:
  int _internal_missing_fiducials_size() const;
  public:
  void clear_missing_fiducials();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_missing_fiducials(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_missing_fiducials() const;
  void _internal_add_missing_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_missing_fiducials();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 missing_fiducials(int index) const;
  void set_missing_fiducials(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_missing_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      missing_fiducials() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_missing_fiducials();

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Waypoint created_waypoint = 2;
  bool has_created_waypoint() const;
  private:
  bool _internal_has_created_waypoint() const;
  public:
  void clear_created_waypoint();
  const ::bosdyn::api::graph_nav::Waypoint& created_waypoint() const;
  ::bosdyn::api::graph_nav::Waypoint* release_created_waypoint();
  ::bosdyn::api::graph_nav::Waypoint* mutable_created_waypoint();
  void set_allocated_created_waypoint(::bosdyn::api::graph_nav::Waypoint* created_waypoint);
  private:
  const ::bosdyn::api::graph_nav::Waypoint& _internal_created_waypoint() const;
  ::bosdyn::api::graph_nav::Waypoint* _internal_mutable_created_waypoint();
  public:
  void unsafe_arena_set_allocated_created_waypoint(
      ::bosdyn::api::graph_nav::Waypoint* created_waypoint);
  ::bosdyn::api::graph_nav::Waypoint* unsafe_arena_release_created_waypoint();

  // .bosdyn.api.LeaseUseResult lease_use_result = 3;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.graph_nav.StartRecordingResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::graph_nav::StartRecordingResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::StartRecordingResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::StartRecordingResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::StartRecordingResponse_Status value);
  public:

  // .bosdyn.api.LicenseInfo.Status license_status = 6;
  void clear_license_status();
  ::bosdyn::api::LicenseInfo_Status license_status() const;
  void set_license_status(::bosdyn::api::LicenseInfo_Status value);
  private:
  ::bosdyn::api::LicenseInfo_Status _internal_license_status() const;
  void _internal_set_license_status(::bosdyn::api::LicenseInfo_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.StartRecordingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > missing_fiducials_;
  mutable std::atomic<int> _missing_fiducials_cached_byte_size_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::graph_nav::Waypoint* created_waypoint_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  int status_;
  int license_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class StopRecordingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.StopRecordingRequest) */ {
 public:
  inline StopRecordingRequest() : StopRecordingRequest(nullptr) {}
  virtual ~StopRecordingRequest();

  StopRecordingRequest(const StopRecordingRequest& from);
  StopRecordingRequest(StopRecordingRequest&& from) noexcept
    : StopRecordingRequest() {
    *this = ::std::move(from);
  }

  inline StopRecordingRequest& operator=(const StopRecordingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopRecordingRequest& operator=(StopRecordingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopRecordingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopRecordingRequest* internal_default_instance() {
    return reinterpret_cast<const StopRecordingRequest*>(
               &_StopRecordingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StopRecordingRequest& a, StopRecordingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopRecordingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopRecordingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopRecordingRequest* New() const final {
    return CreateMaybeMessage<StopRecordingRequest>(nullptr);
  }

  StopRecordingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopRecordingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopRecordingRequest& from);
  void MergeFrom(const StopRecordingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopRecordingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.StopRecordingRequest";
  }
  protected:
  explicit StopRecordingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.StopRecordingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class StopRecordingResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.StopRecordingResponse) */ {
 public:
  inline StopRecordingResponse() : StopRecordingResponse(nullptr) {}
  virtual ~StopRecordingResponse();

  StopRecordingResponse(const StopRecordingResponse& from);
  StopRecordingResponse(StopRecordingResponse&& from) noexcept
    : StopRecordingResponse() {
    *this = ::std::move(from);
  }

  inline StopRecordingResponse& operator=(const StopRecordingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopRecordingResponse& operator=(StopRecordingResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopRecordingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopRecordingResponse* internal_default_instance() {
    return reinterpret_cast<const StopRecordingResponse*>(
               &_StopRecordingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StopRecordingResponse& a, StopRecordingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopRecordingResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopRecordingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopRecordingResponse* New() const final {
    return CreateMaybeMessage<StopRecordingResponse>(nullptr);
  }

  StopRecordingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopRecordingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopRecordingResponse& from);
  void MergeFrom(const StopRecordingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopRecordingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.StopRecordingResponse";
  }
  protected:
  explicit StopRecordingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef StopRecordingResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    StopRecordingResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    StopRecordingResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NOT_LOCALIZED_TO_END =
    StopRecordingResponse_Status_STATUS_NOT_LOCALIZED_TO_END;
  static constexpr Status STATUS_NOT_READY_YET =
    StopRecordingResponse_Status_STATUS_NOT_READY_YET;
  static inline bool Status_IsValid(int value) {
    return StopRecordingResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    StopRecordingResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    StopRecordingResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    StopRecordingResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return StopRecordingResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return StopRecordingResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return StopRecordingResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorWaypointLocalizedIdFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // string error_waypoint_localized_id = 3;
  void clear_error_waypoint_localized_id();
  const std::string& error_waypoint_localized_id() const;
  void set_error_waypoint_localized_id(const std::string& value);
  void set_error_waypoint_localized_id(std::string&& value);
  void set_error_waypoint_localized_id(const char* value);
  void set_error_waypoint_localized_id(const char* value, size_t size);
  std::string* mutable_error_waypoint_localized_id();
  std::string* release_error_waypoint_localized_id();
  void set_allocated_error_waypoint_localized_id(std::string* error_waypoint_localized_id);
  private:
  const std::string& _internal_error_waypoint_localized_id() const;
  void _internal_set_error_waypoint_localized_id(const std::string& value);
  std::string* _internal_mutable_error_waypoint_localized_id();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 4;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.graph_nav.StopRecordingResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::StopRecordingResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::StopRecordingResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::StopRecordingResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::StopRecordingResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.StopRecordingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_waypoint_localized_id_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class CreateWaypointRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.CreateWaypointRequest) */ {
 public:
  inline CreateWaypointRequest() : CreateWaypointRequest(nullptr) {}
  virtual ~CreateWaypointRequest();

  CreateWaypointRequest(const CreateWaypointRequest& from);
  CreateWaypointRequest(CreateWaypointRequest&& from) noexcept
    : CreateWaypointRequest() {
    *this = ::std::move(from);
  }

  inline CreateWaypointRequest& operator=(const CreateWaypointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateWaypointRequest& operator=(CreateWaypointRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateWaypointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateWaypointRequest* internal_default_instance() {
    return reinterpret_cast<const CreateWaypointRequest*>(
               &_CreateWaypointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateWaypointRequest& a, CreateWaypointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateWaypointRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateWaypointRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateWaypointRequest* New() const final {
    return CreateMaybeMessage<CreateWaypointRequest>(nullptr);
  }

  CreateWaypointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateWaypointRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateWaypointRequest& from);
  void MergeFrom(const CreateWaypointRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateWaypointRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.CreateWaypointRequest";
  }
  protected:
  explicit CreateWaypointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequireFiducialsFieldNumber = 5,
    kWaypointNameFieldNumber = 2,
    kHeaderFieldNumber = 1,
    kRecordingEnvironmentFieldNumber = 3,
    kLeaseFieldNumber = 4,
  };
  // repeated int32 require_fiducials = 5;
  int require_fiducials_size() const;
  private:
  int _internal_require_fiducials_size() const;
  public:
  void clear_require_fiducials();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_require_fiducials(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_require_fiducials() const;
  void _internal_add_require_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_require_fiducials();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 require_fiducials(int index) const;
  void set_require_fiducials(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_require_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      require_fiducials() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_require_fiducials();

  // string waypoint_name = 2;
  void clear_waypoint_name();
  const std::string& waypoint_name() const;
  void set_waypoint_name(const std::string& value);
  void set_waypoint_name(std::string&& value);
  void set_waypoint_name(const char* value);
  void set_waypoint_name(const char* value, size_t size);
  std::string* mutable_waypoint_name();
  std::string* release_waypoint_name();
  void set_allocated_waypoint_name(std::string* waypoint_name);
  private:
  const std::string& _internal_waypoint_name() const;
  void _internal_set_waypoint_name(const std::string& value);
  std::string* _internal_mutable_waypoint_name();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.RecordingEnvironment recording_environment = 3;
  bool has_recording_environment() const;
  private:
  bool _internal_has_recording_environment() const;
  public:
  void clear_recording_environment();
  const ::bosdyn::api::graph_nav::RecordingEnvironment& recording_environment() const;
  ::bosdyn::api::graph_nav::RecordingEnvironment* release_recording_environment();
  ::bosdyn::api::graph_nav::RecordingEnvironment* mutable_recording_environment();
  void set_allocated_recording_environment(::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment);
  private:
  const ::bosdyn::api::graph_nav::RecordingEnvironment& _internal_recording_environment() const;
  ::bosdyn::api::graph_nav::RecordingEnvironment* _internal_mutable_recording_environment();
  public:
  void unsafe_arena_set_allocated_recording_environment(
      ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment);
  ::bosdyn::api::graph_nav::RecordingEnvironment* unsafe_arena_release_recording_environment();

  // .bosdyn.api.Lease lease = 4;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.CreateWaypointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > require_fiducials_;
  mutable std::atomic<int> _require_fiducials_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr waypoint_name_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment_;
  ::bosdyn::api::Lease* lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class CreateWaypointResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.CreateWaypointResponse) */ {
 public:
  inline CreateWaypointResponse() : CreateWaypointResponse(nullptr) {}
  virtual ~CreateWaypointResponse();

  CreateWaypointResponse(const CreateWaypointResponse& from);
  CreateWaypointResponse(CreateWaypointResponse&& from) noexcept
    : CreateWaypointResponse() {
    *this = ::std::move(from);
  }

  inline CreateWaypointResponse& operator=(const CreateWaypointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateWaypointResponse& operator=(CreateWaypointResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateWaypointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateWaypointResponse* internal_default_instance() {
    return reinterpret_cast<const CreateWaypointResponse*>(
               &_CreateWaypointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateWaypointResponse& a, CreateWaypointResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateWaypointResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateWaypointResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateWaypointResponse* New() const final {
    return CreateMaybeMessage<CreateWaypointResponse>(nullptr);
  }

  CreateWaypointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateWaypointResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateWaypointResponse& from);
  void MergeFrom(const CreateWaypointResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateWaypointResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.CreateWaypointResponse";
  }
  protected:
  explicit CreateWaypointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CreateWaypointResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    CreateWaypointResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    CreateWaypointResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NOT_RECORDING =
    CreateWaypointResponse_Status_STATUS_NOT_RECORDING;
  static constexpr Status STATUS_COULD_NOT_CREATE_WAYPOINT =
    CreateWaypointResponse_Status_STATUS_COULD_NOT_CREATE_WAYPOINT;
  static constexpr Status STATUS_MISSING_FIDUCIALS =
    CreateWaypointResponse_Status_STATUS_MISSING_FIDUCIALS;
  static constexpr Status STATUS_MAP_TOO_LARGE_LICENSE =
    CreateWaypointResponse_Status_STATUS_MAP_TOO_LARGE_LICENSE;
  static inline bool Status_IsValid(int value) {
    return CreateWaypointResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    CreateWaypointResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    CreateWaypointResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    CreateWaypointResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return CreateWaypointResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return CreateWaypointResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return CreateWaypointResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMissingFiducialsFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kCreatedWaypointFieldNumber = 2,
    kCreatedEdgeFieldNumber = 3,
    kLeaseUseResultFieldNumber = 4,
    kStatusFieldNumber = 5,
    kLicenseStatusFieldNumber = 7,
  };
  // repeated int32 missing_fiducials = 6;
  int missing_fiducials_size() const;
  private:
  int _internal_missing_fiducials_size() const;
  public:
  void clear_missing_fiducials();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_missing_fiducials(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_missing_fiducials() const;
  void _internal_add_missing_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_missing_fiducials();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 missing_fiducials(int index) const;
  void set_missing_fiducials(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_missing_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      missing_fiducials() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_missing_fiducials();

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Waypoint created_waypoint = 2;
  bool has_created_waypoint() const;
  private:
  bool _internal_has_created_waypoint() const;
  public:
  void clear_created_waypoint();
  const ::bosdyn::api::graph_nav::Waypoint& created_waypoint() const;
  ::bosdyn::api::graph_nav::Waypoint* release_created_waypoint();
  ::bosdyn::api::graph_nav::Waypoint* mutable_created_waypoint();
  void set_allocated_created_waypoint(::bosdyn::api::graph_nav::Waypoint* created_waypoint);
  private:
  const ::bosdyn::api::graph_nav::Waypoint& _internal_created_waypoint() const;
  ::bosdyn::api::graph_nav::Waypoint* _internal_mutable_created_waypoint();
  public:
  void unsafe_arena_set_allocated_created_waypoint(
      ::bosdyn::api::graph_nav::Waypoint* created_waypoint);
  ::bosdyn::api::graph_nav::Waypoint* unsafe_arena_release_created_waypoint();

  // .bosdyn.api.graph_nav.Edge created_edge = 3;
  bool has_created_edge() const;
  private:
  bool _internal_has_created_edge() const;
  public:
  void clear_created_edge();
  const ::bosdyn::api::graph_nav::Edge& created_edge() const;
  ::bosdyn::api::graph_nav::Edge* release_created_edge();
  ::bosdyn::api::graph_nav::Edge* mutable_created_edge();
  void set_allocated_created_edge(::bosdyn::api::graph_nav::Edge* created_edge);
  private:
  const ::bosdyn::api::graph_nav::Edge& _internal_created_edge() const;
  ::bosdyn::api::graph_nav::Edge* _internal_mutable_created_edge();
  public:
  void unsafe_arena_set_allocated_created_edge(
      ::bosdyn::api::graph_nav::Edge* created_edge);
  ::bosdyn::api::graph_nav::Edge* unsafe_arena_release_created_edge();

  // .bosdyn.api.LeaseUseResult lease_use_result = 4;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.graph_nav.CreateWaypointResponse.Status status = 5;
  void clear_status();
  ::bosdyn::api::graph_nav::CreateWaypointResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::CreateWaypointResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::CreateWaypointResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::CreateWaypointResponse_Status value);
  public:

  // .bosdyn.api.LicenseInfo.Status license_status = 7;
  void clear_license_status();
  ::bosdyn::api::LicenseInfo_Status license_status() const;
  void set_license_status(::bosdyn::api::LicenseInfo_Status value);
  private:
  ::bosdyn::api::LicenseInfo_Status _internal_license_status() const;
  void _internal_set_license_status(::bosdyn::api::LicenseInfo_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.CreateWaypointResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > missing_fiducials_;
  mutable std::atomic<int> _missing_fiducials_cached_byte_size_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::graph_nav::Waypoint* created_waypoint_;
  ::bosdyn::api::graph_nav::Edge* created_edge_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  int status_;
  int license_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class CreateEdgeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.CreateEdgeRequest) */ {
 public:
  inline CreateEdgeRequest() : CreateEdgeRequest(nullptr) {}
  virtual ~CreateEdgeRequest();

  CreateEdgeRequest(const CreateEdgeRequest& from);
  CreateEdgeRequest(CreateEdgeRequest&& from) noexcept
    : CreateEdgeRequest() {
    *this = ::std::move(from);
  }

  inline CreateEdgeRequest& operator=(const CreateEdgeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEdgeRequest& operator=(CreateEdgeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateEdgeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateEdgeRequest* internal_default_instance() {
    return reinterpret_cast<const CreateEdgeRequest*>(
               &_CreateEdgeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateEdgeRequest& a, CreateEdgeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEdgeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEdgeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEdgeRequest* New() const final {
    return CreateMaybeMessage<CreateEdgeRequest>(nullptr);
  }

  CreateEdgeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEdgeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateEdgeRequest& from);
  void MergeFrom(const CreateEdgeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEdgeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.CreateEdgeRequest";
  }
  protected:
  explicit CreateEdgeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEdgeFieldNumber = 2,
    kLeaseFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Edge edge = 2;
  bool has_edge() const;
  private:
  bool _internal_has_edge() const;
  public:
  void clear_edge();
  const ::bosdyn::api::graph_nav::Edge& edge() const;
  ::bosdyn::api::graph_nav::Edge* release_edge();
  ::bosdyn::api::graph_nav::Edge* mutable_edge();
  void set_allocated_edge(::bosdyn::api::graph_nav::Edge* edge);
  private:
  const ::bosdyn::api::graph_nav::Edge& _internal_edge() const;
  ::bosdyn::api::graph_nav::Edge* _internal_mutable_edge();
  public:
  void unsafe_arena_set_allocated_edge(
      ::bosdyn::api::graph_nav::Edge* edge);
  ::bosdyn::api::graph_nav::Edge* unsafe_arena_release_edge();

  // .bosdyn.api.Lease lease = 3;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.CreateEdgeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::graph_nav::Edge* edge_;
  ::bosdyn::api::Lease* lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class CreateEdgeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.CreateEdgeResponse) */ {
 public:
  inline CreateEdgeResponse() : CreateEdgeResponse(nullptr) {}
  virtual ~CreateEdgeResponse();

  CreateEdgeResponse(const CreateEdgeResponse& from);
  CreateEdgeResponse(CreateEdgeResponse&& from) noexcept
    : CreateEdgeResponse() {
    *this = ::std::move(from);
  }

  inline CreateEdgeResponse& operator=(const CreateEdgeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateEdgeResponse& operator=(CreateEdgeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateEdgeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateEdgeResponse* internal_default_instance() {
    return reinterpret_cast<const CreateEdgeResponse*>(
               &_CreateEdgeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateEdgeResponse& a, CreateEdgeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateEdgeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateEdgeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateEdgeResponse* New() const final {
    return CreateMaybeMessage<CreateEdgeResponse>(nullptr);
  }

  CreateEdgeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateEdgeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateEdgeResponse& from);
  void MergeFrom(const CreateEdgeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateEdgeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.CreateEdgeResponse";
  }
  protected:
  explicit CreateEdgeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CreateEdgeResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    CreateEdgeResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    CreateEdgeResponse_Status_STATUS_OK;
  static constexpr Status STATUS_EXISTS =
    CreateEdgeResponse_Status_STATUS_EXISTS;
  static constexpr Status STATUS_NOT_RECORDING =
    CreateEdgeResponse_Status_STATUS_NOT_RECORDING;
  static constexpr Status STATUS_UNKNOWN_WAYPOINT =
    CreateEdgeResponse_Status_STATUS_UNKNOWN_WAYPOINT;
  static constexpr Status STATUS_MISSING_TRANSFORM =
    CreateEdgeResponse_Status_STATUS_MISSING_TRANSFORM;
  static inline bool Status_IsValid(int value) {
    return CreateEdgeResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    CreateEdgeResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    CreateEdgeResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    CreateEdgeResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return CreateEdgeResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return CreateEdgeResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return CreateEdgeResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kErrorExistingEdgeFieldNumber = 3,
    kLeaseUseResultFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.Edge error_existing_edge = 3;
  bool has_error_existing_edge() const;
  private:
  bool _internal_has_error_existing_edge() const;
  public:
  void clear_error_existing_edge();
  const ::bosdyn::api::graph_nav::Edge& error_existing_edge() const;
  ::bosdyn::api::graph_nav::Edge* release_error_existing_edge();
  ::bosdyn::api::graph_nav::Edge* mutable_error_existing_edge();
  void set_allocated_error_existing_edge(::bosdyn::api::graph_nav::Edge* error_existing_edge);
  private:
  const ::bosdyn::api::graph_nav::Edge& _internal_error_existing_edge() const;
  ::bosdyn::api::graph_nav::Edge* _internal_mutable_error_existing_edge();
  public:
  void unsafe_arena_set_allocated_error_existing_edge(
      ::bosdyn::api::graph_nav::Edge* error_existing_edge);
  ::bosdyn::api::graph_nav::Edge* unsafe_arena_release_error_existing_edge();

  // .bosdyn.api.LeaseUseResult lease_use_result = 4;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.graph_nav.CreateEdgeResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::graph_nav::CreateEdgeResponse_Status status() const;
  void set_status(::bosdyn::api::graph_nav::CreateEdgeResponse_Status value);
  private:
  ::bosdyn::api::graph_nav::CreateEdgeResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::graph_nav::CreateEdgeResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.CreateEdgeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::graph_nav::Edge* error_existing_edge_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class GetRecordStatusRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.GetRecordStatusRequest) */ {
 public:
  inline GetRecordStatusRequest() : GetRecordStatusRequest(nullptr) {}
  virtual ~GetRecordStatusRequest();

  GetRecordStatusRequest(const GetRecordStatusRequest& from);
  GetRecordStatusRequest(GetRecordStatusRequest&& from) noexcept
    : GetRecordStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetRecordStatusRequest& operator=(const GetRecordStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRecordStatusRequest& operator=(GetRecordStatusRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRecordStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRecordStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetRecordStatusRequest*>(
               &_GetRecordStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetRecordStatusRequest& a, GetRecordStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRecordStatusRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRecordStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRecordStatusRequest* New() const final {
    return CreateMaybeMessage<GetRecordStatusRequest>(nullptr);
  }

  GetRecordStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRecordStatusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRecordStatusRequest& from);
  void MergeFrom(const GetRecordStatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRecordStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.GetRecordStatusRequest";
  }
  protected:
  explicit GetRecordStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.GetRecordStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// -------------------------------------------------------------------

class GetRecordStatusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.graph_nav.GetRecordStatusResponse) */ {
 public:
  inline GetRecordStatusResponse() : GetRecordStatusResponse(nullptr) {}
  virtual ~GetRecordStatusResponse();

  GetRecordStatusResponse(const GetRecordStatusResponse& from);
  GetRecordStatusResponse(GetRecordStatusResponse&& from) noexcept
    : GetRecordStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetRecordStatusResponse& operator=(const GetRecordStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRecordStatusResponse& operator=(GetRecordStatusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRecordStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRecordStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetRecordStatusResponse*>(
               &_GetRecordStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetRecordStatusResponse& a, GetRecordStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRecordStatusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRecordStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRecordStatusResponse* New() const final {
    return CreateMaybeMessage<GetRecordStatusResponse>(nullptr);
  }

  GetRecordStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRecordStatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRecordStatusResponse& from);
  void MergeFrom(const GetRecordStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRecordStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.graph_nav.GetRecordStatusResponse";
  }
  protected:
  explicit GetRecordStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GetRecordStatusResponse_MapState MapState;
  static constexpr MapState MAP_STATE_UNKNOWN =
    GetRecordStatusResponse_MapState_MAP_STATE_UNKNOWN;
  static constexpr MapState MAP_STATE_OK =
    GetRecordStatusResponse_MapState_MAP_STATE_OK;
  static constexpr MapState MAP_STATE_TOO_LARGE_FOR_LICENSE =
    GetRecordStatusResponse_MapState_MAP_STATE_TOO_LARGE_FOR_LICENSE;
  static inline bool MapState_IsValid(int value) {
    return GetRecordStatusResponse_MapState_IsValid(value);
  }
  static constexpr MapState MapState_MIN =
    GetRecordStatusResponse_MapState_MapState_MIN;
  static constexpr MapState MapState_MAX =
    GetRecordStatusResponse_MapState_MapState_MAX;
  static constexpr int MapState_ARRAYSIZE =
    GetRecordStatusResponse_MapState_MapState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MapState_descriptor() {
    return GetRecordStatusResponse_MapState_descriptor();
  }
  template<typename T>
  static inline const std::string& MapState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MapState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MapState_Name.");
    return GetRecordStatusResponse_MapState_Name(enum_t_value);
  }
  static inline bool MapState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MapState* value) {
    return GetRecordStatusResponse_MapState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRecordingEnvironmentFieldNumber = 3,
    kIsRecordingFieldNumber = 2,
    kMapStateFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.graph_nav.RecordingEnvironment recording_environment = 3;
  bool has_recording_environment() const;
  private:
  bool _internal_has_recording_environment() const;
  public:
  void clear_recording_environment();
  const ::bosdyn::api::graph_nav::RecordingEnvironment& recording_environment() const;
  ::bosdyn::api::graph_nav::RecordingEnvironment* release_recording_environment();
  ::bosdyn::api::graph_nav::RecordingEnvironment* mutable_recording_environment();
  void set_allocated_recording_environment(::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment);
  private:
  const ::bosdyn::api::graph_nav::RecordingEnvironment& _internal_recording_environment() const;
  ::bosdyn::api::graph_nav::RecordingEnvironment* _internal_mutable_recording_environment();
  public:
  void unsafe_arena_set_allocated_recording_environment(
      ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment);
  ::bosdyn::api::graph_nav::RecordingEnvironment* unsafe_arena_release_recording_environment();

  // bool is_recording = 2;
  void clear_is_recording();
  bool is_recording() const;
  void set_is_recording(bool value);
  private:
  bool _internal_is_recording() const;
  void _internal_set_is_recording(bool value);
  public:

  // .bosdyn.api.graph_nav.GetRecordStatusResponse.MapState map_state = 4;
  void clear_map_state();
  ::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState map_state() const;
  void set_map_state(::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState value);
  private:
  ::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState _internal_map_state() const;
  void _internal_set_map_state(::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.graph_nav.GetRecordStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment_;
  bool is_recording_;
  int map_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecordingEnvironment

// string name_prefix = 1;
inline void RecordingEnvironment::clear_name_prefix() {
  name_prefix_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RecordingEnvironment::name_prefix() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RecordingEnvironment.name_prefix)
  return _internal_name_prefix();
}
inline void RecordingEnvironment::set_name_prefix(const std::string& value) {
  _internal_set_name_prefix(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.RecordingEnvironment.name_prefix)
}
inline std::string* RecordingEnvironment::mutable_name_prefix() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.RecordingEnvironment.name_prefix)
  return _internal_mutable_name_prefix();
}
inline const std::string& RecordingEnvironment::_internal_name_prefix() const {
  return name_prefix_.Get();
}
inline void RecordingEnvironment::_internal_set_name_prefix(const std::string& value) {
  
  name_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RecordingEnvironment::set_name_prefix(std::string&& value) {
  
  name_prefix_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.graph_nav.RecordingEnvironment.name_prefix)
}
inline void RecordingEnvironment::set_name_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.RecordingEnvironment.name_prefix)
}
inline void RecordingEnvironment::set_name_prefix(const char* value,
    size_t size) {
  
  name_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.RecordingEnvironment.name_prefix)
}
inline std::string* RecordingEnvironment::_internal_mutable_name_prefix() {
  
  return name_prefix_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RecordingEnvironment::release_name_prefix() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.RecordingEnvironment.name_prefix)
  return name_prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RecordingEnvironment::set_allocated_name_prefix(std::string* name_prefix) {
  if (name_prefix != nullptr) {
    
  } else {
    
  }
  name_prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name_prefix,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.RecordingEnvironment.name_prefix)
}

// .bosdyn.api.graph_nav.Waypoint.Annotations waypoint_environment = 2;
inline bool RecordingEnvironment::_internal_has_waypoint_environment() const {
  return this != internal_default_instance() && waypoint_environment_ != nullptr;
}
inline bool RecordingEnvironment::has_waypoint_environment() const {
  return _internal_has_waypoint_environment();
}
inline const ::bosdyn::api::graph_nav::Waypoint_Annotations& RecordingEnvironment::_internal_waypoint_environment() const {
  const ::bosdyn::api::graph_nav::Waypoint_Annotations* p = waypoint_environment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::Waypoint_Annotations*>(
      &::bosdyn::api::graph_nav::_Waypoint_Annotations_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Waypoint_Annotations& RecordingEnvironment::waypoint_environment() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RecordingEnvironment.waypoint_environment)
  return _internal_waypoint_environment();
}
inline void RecordingEnvironment::unsafe_arena_set_allocated_waypoint_environment(
    ::bosdyn::api::graph_nav::Waypoint_Annotations* waypoint_environment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(waypoint_environment_);
  }
  waypoint_environment_ = waypoint_environment;
  if (waypoint_environment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.RecordingEnvironment.waypoint_environment)
}
inline ::bosdyn::api::graph_nav::Waypoint_Annotations* RecordingEnvironment::release_waypoint_environment() {
  
  ::bosdyn::api::graph_nav::Waypoint_Annotations* temp = waypoint_environment_;
  waypoint_environment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::Waypoint_Annotations* RecordingEnvironment::unsafe_arena_release_waypoint_environment() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.RecordingEnvironment.waypoint_environment)
  
  ::bosdyn::api::graph_nav::Waypoint_Annotations* temp = waypoint_environment_;
  waypoint_environment_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Waypoint_Annotations* RecordingEnvironment::_internal_mutable_waypoint_environment() {
  
  if (waypoint_environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Waypoint_Annotations>(GetArena());
    waypoint_environment_ = p;
  }
  return waypoint_environment_;
}
inline ::bosdyn::api::graph_nav::Waypoint_Annotations* RecordingEnvironment::mutable_waypoint_environment() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.RecordingEnvironment.waypoint_environment)
  return _internal_mutable_waypoint_environment();
}
inline void RecordingEnvironment::set_allocated_waypoint_environment(::bosdyn::api::graph_nav::Waypoint_Annotations* waypoint_environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(waypoint_environment_);
  }
  if (waypoint_environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(waypoint_environment)->GetArena();
    if (message_arena != submessage_arena) {
      waypoint_environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, waypoint_environment, submessage_arena);
    }
    
  } else {
    
  }
  waypoint_environment_ = waypoint_environment;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.RecordingEnvironment.waypoint_environment)
}

// .bosdyn.api.graph_nav.Edge.Annotations edge_environment = 3;
inline bool RecordingEnvironment::_internal_has_edge_environment() const {
  return this != internal_default_instance() && edge_environment_ != nullptr;
}
inline bool RecordingEnvironment::has_edge_environment() const {
  return _internal_has_edge_environment();
}
inline const ::bosdyn::api::graph_nav::Edge_Annotations& RecordingEnvironment::_internal_edge_environment() const {
  const ::bosdyn::api::graph_nav::Edge_Annotations* p = edge_environment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::Edge_Annotations*>(
      &::bosdyn::api::graph_nav::_Edge_Annotations_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Edge_Annotations& RecordingEnvironment::edge_environment() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.RecordingEnvironment.edge_environment)
  return _internal_edge_environment();
}
inline void RecordingEnvironment::unsafe_arena_set_allocated_edge_environment(
    ::bosdyn::api::graph_nav::Edge_Annotations* edge_environment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge_environment_);
  }
  edge_environment_ = edge_environment;
  if (edge_environment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.RecordingEnvironment.edge_environment)
}
inline ::bosdyn::api::graph_nav::Edge_Annotations* RecordingEnvironment::release_edge_environment() {
  
  ::bosdyn::api::graph_nav::Edge_Annotations* temp = edge_environment_;
  edge_environment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::Edge_Annotations* RecordingEnvironment::unsafe_arena_release_edge_environment() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.RecordingEnvironment.edge_environment)
  
  ::bosdyn::api::graph_nav::Edge_Annotations* temp = edge_environment_;
  edge_environment_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Edge_Annotations* RecordingEnvironment::_internal_mutable_edge_environment() {
  
  if (edge_environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Edge_Annotations>(GetArena());
    edge_environment_ = p;
  }
  return edge_environment_;
}
inline ::bosdyn::api::graph_nav::Edge_Annotations* RecordingEnvironment::mutable_edge_environment() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.RecordingEnvironment.edge_environment)
  return _internal_mutable_edge_environment();
}
inline void RecordingEnvironment::set_allocated_edge_environment(::bosdyn::api::graph_nav::Edge_Annotations* edge_environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge_environment_);
  }
  if (edge_environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge_environment)->GetArena();
    if (message_arena != submessage_arena) {
      edge_environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge_environment, submessage_arena);
    }
    
  } else {
    
  }
  edge_environment_ = edge_environment;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.RecordingEnvironment.edge_environment)
}

// -------------------------------------------------------------------

// SetRecordingEnvironmentRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SetRecordingEnvironmentRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SetRecordingEnvironmentRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SetRecordingEnvironmentRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SetRecordingEnvironmentRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.header)
  return _internal_header();
}
inline void SetRecordingEnvironmentRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.header)
}
inline ::bosdyn::api::RequestHeader* SetRecordingEnvironmentRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetRecordingEnvironmentRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetRecordingEnvironmentRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* SetRecordingEnvironmentRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.header)
  return _internal_mutable_header();
}
inline void SetRecordingEnvironmentRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.header)
}

// .bosdyn.api.graph_nav.RecordingEnvironment environment = 2;
inline bool SetRecordingEnvironmentRequest::_internal_has_environment() const {
  return this != internal_default_instance() && environment_ != nullptr;
}
inline bool SetRecordingEnvironmentRequest::has_environment() const {
  return _internal_has_environment();
}
inline void SetRecordingEnvironmentRequest::clear_environment() {
  if (GetArena() == nullptr && environment_ != nullptr) {
    delete environment_;
  }
  environment_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::RecordingEnvironment& SetRecordingEnvironmentRequest::_internal_environment() const {
  const ::bosdyn::api::graph_nav::RecordingEnvironment* p = environment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::RecordingEnvironment*>(
      &::bosdyn::api::graph_nav::_RecordingEnvironment_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RecordingEnvironment& SetRecordingEnvironmentRequest::environment() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.environment)
  return _internal_environment();
}
inline void SetRecordingEnvironmentRequest::unsafe_arena_set_allocated_environment(
    ::bosdyn::api::graph_nav::RecordingEnvironment* environment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(environment_);
  }
  environment_ = environment;
  if (environment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.environment)
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* SetRecordingEnvironmentRequest::release_environment() {
  
  ::bosdyn::api::graph_nav::RecordingEnvironment* temp = environment_;
  environment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* SetRecordingEnvironmentRequest::unsafe_arena_release_environment() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.environment)
  
  ::bosdyn::api::graph_nav::RecordingEnvironment* temp = environment_;
  environment_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* SetRecordingEnvironmentRequest::_internal_mutable_environment() {
  
  if (environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RecordingEnvironment>(GetArena());
    environment_ = p;
  }
  return environment_;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* SetRecordingEnvironmentRequest::mutable_environment() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.environment)
  return _internal_mutable_environment();
}
inline void SetRecordingEnvironmentRequest::set_allocated_environment(::bosdyn::api::graph_nav::RecordingEnvironment* environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete environment_;
  }
  if (environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(environment);
    if (message_arena != submessage_arena) {
      environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    
  } else {
    
  }
  environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.environment)
}

// .bosdyn.api.Lease lease = 3;
inline bool SetRecordingEnvironmentRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool SetRecordingEnvironmentRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& SetRecordingEnvironmentRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& SetRecordingEnvironmentRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.lease)
  return _internal_lease();
}
inline void SetRecordingEnvironmentRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.lease)
}
inline ::bosdyn::api::Lease* SetRecordingEnvironmentRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* SetRecordingEnvironmentRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* SetRecordingEnvironmentRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* SetRecordingEnvironmentRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.lease)
  return _internal_mutable_lease();
}
inline void SetRecordingEnvironmentRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentRequest.lease)
}

// -------------------------------------------------------------------

// SetRecordingEnvironmentResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SetRecordingEnvironmentResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SetRecordingEnvironmentResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SetRecordingEnvironmentResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SetRecordingEnvironmentResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.header)
  return _internal_header();
}
inline void SetRecordingEnvironmentResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SetRecordingEnvironmentResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetRecordingEnvironmentResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetRecordingEnvironmentResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* SetRecordingEnvironmentResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.header)
  return _internal_mutable_header();
}
inline void SetRecordingEnvironmentResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool SetRecordingEnvironmentResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool SetRecordingEnvironmentResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& SetRecordingEnvironmentResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& SetRecordingEnvironmentResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void SetRecordingEnvironmentResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* SetRecordingEnvironmentResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* SetRecordingEnvironmentResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* SetRecordingEnvironmentResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* SetRecordingEnvironmentResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void SetRecordingEnvironmentResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.SetRecordingEnvironmentResponse.lease_use_result)
}

// -------------------------------------------------------------------

// StartRecordingRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StartRecordingRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool StartRecordingRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StartRecordingRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StartRecordingRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingRequest.header)
  return _internal_header();
}
inline void StartRecordingRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StartRecordingRequest.header)
}
inline ::bosdyn::api::RequestHeader* StartRecordingRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* StartRecordingRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StartRecordingRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StartRecordingRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* StartRecordingRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StartRecordingRequest.header)
  return _internal_mutable_header();
}
inline void StartRecordingRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StartRecordingRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool StartRecordingRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool StartRecordingRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& StartRecordingRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& StartRecordingRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingRequest.lease)
  return _internal_lease();
}
inline void StartRecordingRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StartRecordingRequest.lease)
}
inline ::bosdyn::api::Lease* StartRecordingRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* StartRecordingRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StartRecordingRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* StartRecordingRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* StartRecordingRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StartRecordingRequest.lease)
  return _internal_mutable_lease();
}
inline void StartRecordingRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StartRecordingRequest.lease)
}

// .bosdyn.api.graph_nav.RecordingEnvironment recording_environment = 3;
inline bool StartRecordingRequest::_internal_has_recording_environment() const {
  return this != internal_default_instance() && recording_environment_ != nullptr;
}
inline bool StartRecordingRequest::has_recording_environment() const {
  return _internal_has_recording_environment();
}
inline void StartRecordingRequest::clear_recording_environment() {
  if (GetArena() == nullptr && recording_environment_ != nullptr) {
    delete recording_environment_;
  }
  recording_environment_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::RecordingEnvironment& StartRecordingRequest::_internal_recording_environment() const {
  const ::bosdyn::api::graph_nav::RecordingEnvironment* p = recording_environment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::RecordingEnvironment*>(
      &::bosdyn::api::graph_nav::_RecordingEnvironment_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RecordingEnvironment& StartRecordingRequest::recording_environment() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingRequest.recording_environment)
  return _internal_recording_environment();
}
inline void StartRecordingRequest::unsafe_arena_set_allocated_recording_environment(
    ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recording_environment_);
  }
  recording_environment_ = recording_environment;
  if (recording_environment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StartRecordingRequest.recording_environment)
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* StartRecordingRequest::release_recording_environment() {
  
  ::bosdyn::api::graph_nav::RecordingEnvironment* temp = recording_environment_;
  recording_environment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* StartRecordingRequest::unsafe_arena_release_recording_environment() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StartRecordingRequest.recording_environment)
  
  ::bosdyn::api::graph_nav::RecordingEnvironment* temp = recording_environment_;
  recording_environment_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* StartRecordingRequest::_internal_mutable_recording_environment() {
  
  if (recording_environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RecordingEnvironment>(GetArena());
    recording_environment_ = p;
  }
  return recording_environment_;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* StartRecordingRequest::mutable_recording_environment() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StartRecordingRequest.recording_environment)
  return _internal_mutable_recording_environment();
}
inline void StartRecordingRequest::set_allocated_recording_environment(::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete recording_environment_;
  }
  if (recording_environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(recording_environment);
    if (message_arena != submessage_arena) {
      recording_environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recording_environment, submessage_arena);
    }
    
  } else {
    
  }
  recording_environment_ = recording_environment;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StartRecordingRequest.recording_environment)
}

// repeated int32 require_fiducials = 4;
inline int StartRecordingRequest::_internal_require_fiducials_size() const {
  return require_fiducials_.size();
}
inline int StartRecordingRequest::require_fiducials_size() const {
  return _internal_require_fiducials_size();
}
inline void StartRecordingRequest::clear_require_fiducials() {
  require_fiducials_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartRecordingRequest::_internal_require_fiducials(int index) const {
  return require_fiducials_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartRecordingRequest::require_fiducials(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingRequest.require_fiducials)
  return _internal_require_fiducials(index);
}
inline void StartRecordingRequest::set_require_fiducials(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  require_fiducials_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.StartRecordingRequest.require_fiducials)
}
inline void StartRecordingRequest::_internal_add_require_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value) {
  require_fiducials_.Add(value);
}
inline void StartRecordingRequest::add_require_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_require_fiducials(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.StartRecordingRequest.require_fiducials)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
StartRecordingRequest::_internal_require_fiducials() const {
  return require_fiducials_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
StartRecordingRequest::require_fiducials() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.StartRecordingRequest.require_fiducials)
  return _internal_require_fiducials();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
StartRecordingRequest::_internal_mutable_require_fiducials() {
  return &require_fiducials_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
StartRecordingRequest::mutable_require_fiducials() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.StartRecordingRequest.require_fiducials)
  return _internal_mutable_require_fiducials();
}

// -------------------------------------------------------------------

// StartRecordingResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StartRecordingResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool StartRecordingResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StartRecordingResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StartRecordingResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingResponse.header)
  return _internal_header();
}
inline void StartRecordingResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StartRecordingResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StartRecordingResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StartRecordingResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StartRecordingResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StartRecordingResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* StartRecordingResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StartRecordingResponse.header)
  return _internal_mutable_header();
}
inline void StartRecordingResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StartRecordingResponse.header)
}

// .bosdyn.api.graph_nav.Waypoint created_waypoint = 2;
inline bool StartRecordingResponse::_internal_has_created_waypoint() const {
  return this != internal_default_instance() && created_waypoint_ != nullptr;
}
inline bool StartRecordingResponse::has_created_waypoint() const {
  return _internal_has_created_waypoint();
}
inline const ::bosdyn::api::graph_nav::Waypoint& StartRecordingResponse::_internal_created_waypoint() const {
  const ::bosdyn::api::graph_nav::Waypoint* p = created_waypoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::Waypoint*>(
      &::bosdyn::api::graph_nav::_Waypoint_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Waypoint& StartRecordingResponse::created_waypoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingResponse.created_waypoint)
  return _internal_created_waypoint();
}
inline void StartRecordingResponse::unsafe_arena_set_allocated_created_waypoint(
    ::bosdyn::api::graph_nav::Waypoint* created_waypoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_waypoint_);
  }
  created_waypoint_ = created_waypoint;
  if (created_waypoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StartRecordingResponse.created_waypoint)
}
inline ::bosdyn::api::graph_nav::Waypoint* StartRecordingResponse::release_created_waypoint() {
  
  ::bosdyn::api::graph_nav::Waypoint* temp = created_waypoint_;
  created_waypoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::Waypoint* StartRecordingResponse::unsafe_arena_release_created_waypoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StartRecordingResponse.created_waypoint)
  
  ::bosdyn::api::graph_nav::Waypoint* temp = created_waypoint_;
  created_waypoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Waypoint* StartRecordingResponse::_internal_mutable_created_waypoint() {
  
  if (created_waypoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Waypoint>(GetArena());
    created_waypoint_ = p;
  }
  return created_waypoint_;
}
inline ::bosdyn::api::graph_nav::Waypoint* StartRecordingResponse::mutable_created_waypoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StartRecordingResponse.created_waypoint)
  return _internal_mutable_created_waypoint();
}
inline void StartRecordingResponse::set_allocated_created_waypoint(::bosdyn::api::graph_nav::Waypoint* created_waypoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_waypoint_);
  }
  if (created_waypoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_waypoint)->GetArena();
    if (message_arena != submessage_arena) {
      created_waypoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_waypoint, submessage_arena);
    }
    
  } else {
    
  }
  created_waypoint_ = created_waypoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StartRecordingResponse.created_waypoint)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 3;
inline bool StartRecordingResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool StartRecordingResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& StartRecordingResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& StartRecordingResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void StartRecordingResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StartRecordingResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* StartRecordingResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* StartRecordingResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StartRecordingResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* StartRecordingResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* StartRecordingResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StartRecordingResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void StartRecordingResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StartRecordingResponse.lease_use_result)
}

// .bosdyn.api.graph_nav.StartRecordingResponse.Status status = 4;
inline void StartRecordingResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::graph_nav::StartRecordingResponse_Status StartRecordingResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::StartRecordingResponse_Status >(status_);
}
inline ::bosdyn::api::graph_nav::StartRecordingResponse_Status StartRecordingResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingResponse.status)
  return _internal_status();
}
inline void StartRecordingResponse::_internal_set_status(::bosdyn::api::graph_nav::StartRecordingResponse_Status value) {
  
  status_ = value;
}
inline void StartRecordingResponse::set_status(::bosdyn::api::graph_nav::StartRecordingResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.StartRecordingResponse.status)
}

// repeated int32 missing_fiducials = 5;
inline int StartRecordingResponse::_internal_missing_fiducials_size() const {
  return missing_fiducials_.size();
}
inline int StartRecordingResponse::missing_fiducials_size() const {
  return _internal_missing_fiducials_size();
}
inline void StartRecordingResponse::clear_missing_fiducials() {
  missing_fiducials_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartRecordingResponse::_internal_missing_fiducials(int index) const {
  return missing_fiducials_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartRecordingResponse::missing_fiducials(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingResponse.missing_fiducials)
  return _internal_missing_fiducials(index);
}
inline void StartRecordingResponse::set_missing_fiducials(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  missing_fiducials_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.StartRecordingResponse.missing_fiducials)
}
inline void StartRecordingResponse::_internal_add_missing_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value) {
  missing_fiducials_.Add(value);
}
inline void StartRecordingResponse::add_missing_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_missing_fiducials(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.StartRecordingResponse.missing_fiducials)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
StartRecordingResponse::_internal_missing_fiducials() const {
  return missing_fiducials_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
StartRecordingResponse::missing_fiducials() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.StartRecordingResponse.missing_fiducials)
  return _internal_missing_fiducials();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
StartRecordingResponse::_internal_mutable_missing_fiducials() {
  return &missing_fiducials_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
StartRecordingResponse::mutable_missing_fiducials() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.StartRecordingResponse.missing_fiducials)
  return _internal_mutable_missing_fiducials();
}

// .bosdyn.api.LicenseInfo.Status license_status = 6;
inline void StartRecordingResponse::clear_license_status() {
  license_status_ = 0;
}
inline ::bosdyn::api::LicenseInfo_Status StartRecordingResponse::_internal_license_status() const {
  return static_cast< ::bosdyn::api::LicenseInfo_Status >(license_status_);
}
inline ::bosdyn::api::LicenseInfo_Status StartRecordingResponse::license_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StartRecordingResponse.license_status)
  return _internal_license_status();
}
inline void StartRecordingResponse::_internal_set_license_status(::bosdyn::api::LicenseInfo_Status value) {
  
  license_status_ = value;
}
inline void StartRecordingResponse::set_license_status(::bosdyn::api::LicenseInfo_Status value) {
  _internal_set_license_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.StartRecordingResponse.license_status)
}

// -------------------------------------------------------------------

// StopRecordingRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StopRecordingRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool StopRecordingRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StopRecordingRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StopRecordingRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StopRecordingRequest.header)
  return _internal_header();
}
inline void StopRecordingRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StopRecordingRequest.header)
}
inline ::bosdyn::api::RequestHeader* StopRecordingRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* StopRecordingRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StopRecordingRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StopRecordingRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* StopRecordingRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StopRecordingRequest.header)
  return _internal_mutable_header();
}
inline void StopRecordingRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StopRecordingRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool StopRecordingRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool StopRecordingRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& StopRecordingRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& StopRecordingRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StopRecordingRequest.lease)
  return _internal_lease();
}
inline void StopRecordingRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StopRecordingRequest.lease)
}
inline ::bosdyn::api::Lease* StopRecordingRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* StopRecordingRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StopRecordingRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* StopRecordingRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* StopRecordingRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StopRecordingRequest.lease)
  return _internal_mutable_lease();
}
inline void StopRecordingRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StopRecordingRequest.lease)
}

// -------------------------------------------------------------------

// StopRecordingResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StopRecordingResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool StopRecordingResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StopRecordingResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StopRecordingResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StopRecordingResponse.header)
  return _internal_header();
}
inline void StopRecordingResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StopRecordingResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StopRecordingResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StopRecordingResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StopRecordingResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StopRecordingResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* StopRecordingResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StopRecordingResponse.header)
  return _internal_mutable_header();
}
inline void StopRecordingResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StopRecordingResponse.header)
}

// .bosdyn.api.graph_nav.StopRecordingResponse.Status status = 2;
inline void StopRecordingResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::graph_nav::StopRecordingResponse_Status StopRecordingResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::StopRecordingResponse_Status >(status_);
}
inline ::bosdyn::api::graph_nav::StopRecordingResponse_Status StopRecordingResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StopRecordingResponse.status)
  return _internal_status();
}
inline void StopRecordingResponse::_internal_set_status(::bosdyn::api::graph_nav::StopRecordingResponse_Status value) {
  
  status_ = value;
}
inline void StopRecordingResponse::set_status(::bosdyn::api::graph_nav::StopRecordingResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.StopRecordingResponse.status)
}

// string error_waypoint_localized_id = 3;
inline void StopRecordingResponse::clear_error_waypoint_localized_id() {
  error_waypoint_localized_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& StopRecordingResponse::error_waypoint_localized_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StopRecordingResponse.error_waypoint_localized_id)
  return _internal_error_waypoint_localized_id();
}
inline void StopRecordingResponse::set_error_waypoint_localized_id(const std::string& value) {
  _internal_set_error_waypoint_localized_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.StopRecordingResponse.error_waypoint_localized_id)
}
inline std::string* StopRecordingResponse::mutable_error_waypoint_localized_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StopRecordingResponse.error_waypoint_localized_id)
  return _internal_mutable_error_waypoint_localized_id();
}
inline const std::string& StopRecordingResponse::_internal_error_waypoint_localized_id() const {
  return error_waypoint_localized_id_.Get();
}
inline void StopRecordingResponse::_internal_set_error_waypoint_localized_id(const std::string& value) {
  
  error_waypoint_localized_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StopRecordingResponse::set_error_waypoint_localized_id(std::string&& value) {
  
  error_waypoint_localized_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.graph_nav.StopRecordingResponse.error_waypoint_localized_id)
}
inline void StopRecordingResponse::set_error_waypoint_localized_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_waypoint_localized_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.StopRecordingResponse.error_waypoint_localized_id)
}
inline void StopRecordingResponse::set_error_waypoint_localized_id(const char* value,
    size_t size) {
  
  error_waypoint_localized_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.StopRecordingResponse.error_waypoint_localized_id)
}
inline std::string* StopRecordingResponse::_internal_mutable_error_waypoint_localized_id() {
  
  return error_waypoint_localized_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StopRecordingResponse::release_error_waypoint_localized_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StopRecordingResponse.error_waypoint_localized_id)
  return error_waypoint_localized_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StopRecordingResponse::set_allocated_error_waypoint_localized_id(std::string* error_waypoint_localized_id) {
  if (error_waypoint_localized_id != nullptr) {
    
  } else {
    
  }
  error_waypoint_localized_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_waypoint_localized_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StopRecordingResponse.error_waypoint_localized_id)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 4;
inline bool StopRecordingResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool StopRecordingResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& StopRecordingResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& StopRecordingResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.StopRecordingResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void StopRecordingResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.StopRecordingResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* StopRecordingResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* StopRecordingResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.StopRecordingResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* StopRecordingResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* StopRecordingResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.StopRecordingResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void StopRecordingResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.StopRecordingResponse.lease_use_result)
}

// -------------------------------------------------------------------

// CreateWaypointRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool CreateWaypointRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CreateWaypointRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& CreateWaypointRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& CreateWaypointRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointRequest.header)
  return _internal_header();
}
inline void CreateWaypointRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateWaypointRequest.header)
}
inline ::bosdyn::api::RequestHeader* CreateWaypointRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* CreateWaypointRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateWaypointRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* CreateWaypointRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* CreateWaypointRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateWaypointRequest.header)
  return _internal_mutable_header();
}
inline void CreateWaypointRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateWaypointRequest.header)
}

// string waypoint_name = 2;
inline void CreateWaypointRequest::clear_waypoint_name() {
  waypoint_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateWaypointRequest::waypoint_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointRequest.waypoint_name)
  return _internal_waypoint_name();
}
inline void CreateWaypointRequest::set_waypoint_name(const std::string& value) {
  _internal_set_waypoint_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.CreateWaypointRequest.waypoint_name)
}
inline std::string* CreateWaypointRequest::mutable_waypoint_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateWaypointRequest.waypoint_name)
  return _internal_mutable_waypoint_name();
}
inline const std::string& CreateWaypointRequest::_internal_waypoint_name() const {
  return waypoint_name_.Get();
}
inline void CreateWaypointRequest::_internal_set_waypoint_name(const std::string& value) {
  
  waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateWaypointRequest::set_waypoint_name(std::string&& value) {
  
  waypoint_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.graph_nav.CreateWaypointRequest.waypoint_name)
}
inline void CreateWaypointRequest::set_waypoint_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.graph_nav.CreateWaypointRequest.waypoint_name)
}
inline void CreateWaypointRequest::set_waypoint_name(const char* value,
    size_t size) {
  
  waypoint_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.graph_nav.CreateWaypointRequest.waypoint_name)
}
inline std::string* CreateWaypointRequest::_internal_mutable_waypoint_name() {
  
  return waypoint_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateWaypointRequest::release_waypoint_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateWaypointRequest.waypoint_name)
  return waypoint_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateWaypointRequest::set_allocated_waypoint_name(std::string* waypoint_name) {
  if (waypoint_name != nullptr) {
    
  } else {
    
  }
  waypoint_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), waypoint_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateWaypointRequest.waypoint_name)
}

// .bosdyn.api.graph_nav.RecordingEnvironment recording_environment = 3;
inline bool CreateWaypointRequest::_internal_has_recording_environment() const {
  return this != internal_default_instance() && recording_environment_ != nullptr;
}
inline bool CreateWaypointRequest::has_recording_environment() const {
  return _internal_has_recording_environment();
}
inline void CreateWaypointRequest::clear_recording_environment() {
  if (GetArena() == nullptr && recording_environment_ != nullptr) {
    delete recording_environment_;
  }
  recording_environment_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::RecordingEnvironment& CreateWaypointRequest::_internal_recording_environment() const {
  const ::bosdyn::api::graph_nav::RecordingEnvironment* p = recording_environment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::RecordingEnvironment*>(
      &::bosdyn::api::graph_nav::_RecordingEnvironment_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RecordingEnvironment& CreateWaypointRequest::recording_environment() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointRequest.recording_environment)
  return _internal_recording_environment();
}
inline void CreateWaypointRequest::unsafe_arena_set_allocated_recording_environment(
    ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recording_environment_);
  }
  recording_environment_ = recording_environment;
  if (recording_environment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateWaypointRequest.recording_environment)
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* CreateWaypointRequest::release_recording_environment() {
  
  ::bosdyn::api::graph_nav::RecordingEnvironment* temp = recording_environment_;
  recording_environment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* CreateWaypointRequest::unsafe_arena_release_recording_environment() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateWaypointRequest.recording_environment)
  
  ::bosdyn::api::graph_nav::RecordingEnvironment* temp = recording_environment_;
  recording_environment_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* CreateWaypointRequest::_internal_mutable_recording_environment() {
  
  if (recording_environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RecordingEnvironment>(GetArena());
    recording_environment_ = p;
  }
  return recording_environment_;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* CreateWaypointRequest::mutable_recording_environment() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateWaypointRequest.recording_environment)
  return _internal_mutable_recording_environment();
}
inline void CreateWaypointRequest::set_allocated_recording_environment(::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete recording_environment_;
  }
  if (recording_environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(recording_environment);
    if (message_arena != submessage_arena) {
      recording_environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recording_environment, submessage_arena);
    }
    
  } else {
    
  }
  recording_environment_ = recording_environment;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateWaypointRequest.recording_environment)
}

// .bosdyn.api.Lease lease = 4;
inline bool CreateWaypointRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool CreateWaypointRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& CreateWaypointRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& CreateWaypointRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointRequest.lease)
  return _internal_lease();
}
inline void CreateWaypointRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateWaypointRequest.lease)
}
inline ::bosdyn::api::Lease* CreateWaypointRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* CreateWaypointRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateWaypointRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* CreateWaypointRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* CreateWaypointRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateWaypointRequest.lease)
  return _internal_mutable_lease();
}
inline void CreateWaypointRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateWaypointRequest.lease)
}

// repeated int32 require_fiducials = 5;
inline int CreateWaypointRequest::_internal_require_fiducials_size() const {
  return require_fiducials_.size();
}
inline int CreateWaypointRequest::require_fiducials_size() const {
  return _internal_require_fiducials_size();
}
inline void CreateWaypointRequest::clear_require_fiducials() {
  require_fiducials_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateWaypointRequest::_internal_require_fiducials(int index) const {
  return require_fiducials_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateWaypointRequest::require_fiducials(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointRequest.require_fiducials)
  return _internal_require_fiducials(index);
}
inline void CreateWaypointRequest::set_require_fiducials(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  require_fiducials_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.CreateWaypointRequest.require_fiducials)
}
inline void CreateWaypointRequest::_internal_add_require_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value) {
  require_fiducials_.Add(value);
}
inline void CreateWaypointRequest::add_require_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_require_fiducials(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.CreateWaypointRequest.require_fiducials)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
CreateWaypointRequest::_internal_require_fiducials() const {
  return require_fiducials_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
CreateWaypointRequest::require_fiducials() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.CreateWaypointRequest.require_fiducials)
  return _internal_require_fiducials();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
CreateWaypointRequest::_internal_mutable_require_fiducials() {
  return &require_fiducials_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
CreateWaypointRequest::mutable_require_fiducials() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.CreateWaypointRequest.require_fiducials)
  return _internal_mutable_require_fiducials();
}

// -------------------------------------------------------------------

// CreateWaypointResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool CreateWaypointResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CreateWaypointResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& CreateWaypointResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& CreateWaypointResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointResponse.header)
  return _internal_header();
}
inline void CreateWaypointResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateWaypointResponse.header)
}
inline ::bosdyn::api::ResponseHeader* CreateWaypointResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CreateWaypointResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateWaypointResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CreateWaypointResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* CreateWaypointResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateWaypointResponse.header)
  return _internal_mutable_header();
}
inline void CreateWaypointResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateWaypointResponse.header)
}

// .bosdyn.api.graph_nav.Waypoint created_waypoint = 2;
inline bool CreateWaypointResponse::_internal_has_created_waypoint() const {
  return this != internal_default_instance() && created_waypoint_ != nullptr;
}
inline bool CreateWaypointResponse::has_created_waypoint() const {
  return _internal_has_created_waypoint();
}
inline const ::bosdyn::api::graph_nav::Waypoint& CreateWaypointResponse::_internal_created_waypoint() const {
  const ::bosdyn::api::graph_nav::Waypoint* p = created_waypoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::Waypoint*>(
      &::bosdyn::api::graph_nav::_Waypoint_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Waypoint& CreateWaypointResponse::created_waypoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointResponse.created_waypoint)
  return _internal_created_waypoint();
}
inline void CreateWaypointResponse::unsafe_arena_set_allocated_created_waypoint(
    ::bosdyn::api::graph_nav::Waypoint* created_waypoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_waypoint_);
  }
  created_waypoint_ = created_waypoint;
  if (created_waypoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateWaypointResponse.created_waypoint)
}
inline ::bosdyn::api::graph_nav::Waypoint* CreateWaypointResponse::release_created_waypoint() {
  
  ::bosdyn::api::graph_nav::Waypoint* temp = created_waypoint_;
  created_waypoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::Waypoint* CreateWaypointResponse::unsafe_arena_release_created_waypoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateWaypointResponse.created_waypoint)
  
  ::bosdyn::api::graph_nav::Waypoint* temp = created_waypoint_;
  created_waypoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Waypoint* CreateWaypointResponse::_internal_mutable_created_waypoint() {
  
  if (created_waypoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Waypoint>(GetArena());
    created_waypoint_ = p;
  }
  return created_waypoint_;
}
inline ::bosdyn::api::graph_nav::Waypoint* CreateWaypointResponse::mutable_created_waypoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateWaypointResponse.created_waypoint)
  return _internal_mutable_created_waypoint();
}
inline void CreateWaypointResponse::set_allocated_created_waypoint(::bosdyn::api::graph_nav::Waypoint* created_waypoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_waypoint_);
  }
  if (created_waypoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_waypoint)->GetArena();
    if (message_arena != submessage_arena) {
      created_waypoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_waypoint, submessage_arena);
    }
    
  } else {
    
  }
  created_waypoint_ = created_waypoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateWaypointResponse.created_waypoint)
}

// .bosdyn.api.graph_nav.Edge created_edge = 3;
inline bool CreateWaypointResponse::_internal_has_created_edge() const {
  return this != internal_default_instance() && created_edge_ != nullptr;
}
inline bool CreateWaypointResponse::has_created_edge() const {
  return _internal_has_created_edge();
}
inline const ::bosdyn::api::graph_nav::Edge& CreateWaypointResponse::_internal_created_edge() const {
  const ::bosdyn::api::graph_nav::Edge* p = created_edge_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::Edge*>(
      &::bosdyn::api::graph_nav::_Edge_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Edge& CreateWaypointResponse::created_edge() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointResponse.created_edge)
  return _internal_created_edge();
}
inline void CreateWaypointResponse::unsafe_arena_set_allocated_created_edge(
    ::bosdyn::api::graph_nav::Edge* created_edge) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_edge_);
  }
  created_edge_ = created_edge;
  if (created_edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateWaypointResponse.created_edge)
}
inline ::bosdyn::api::graph_nav::Edge* CreateWaypointResponse::release_created_edge() {
  
  ::bosdyn::api::graph_nav::Edge* temp = created_edge_;
  created_edge_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::Edge* CreateWaypointResponse::unsafe_arena_release_created_edge() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateWaypointResponse.created_edge)
  
  ::bosdyn::api::graph_nav::Edge* temp = created_edge_;
  created_edge_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Edge* CreateWaypointResponse::_internal_mutable_created_edge() {
  
  if (created_edge_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Edge>(GetArena());
    created_edge_ = p;
  }
  return created_edge_;
}
inline ::bosdyn::api::graph_nav::Edge* CreateWaypointResponse::mutable_created_edge() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateWaypointResponse.created_edge)
  return _internal_mutable_created_edge();
}
inline void CreateWaypointResponse::set_allocated_created_edge(::bosdyn::api::graph_nav::Edge* created_edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_edge_);
  }
  if (created_edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_edge)->GetArena();
    if (message_arena != submessage_arena) {
      created_edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_edge, submessage_arena);
    }
    
  } else {
    
  }
  created_edge_ = created_edge;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateWaypointResponse.created_edge)
}

// .bosdyn.api.graph_nav.CreateWaypointResponse.Status status = 5;
inline void CreateWaypointResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::graph_nav::CreateWaypointResponse_Status CreateWaypointResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::CreateWaypointResponse_Status >(status_);
}
inline ::bosdyn::api::graph_nav::CreateWaypointResponse_Status CreateWaypointResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointResponse.status)
  return _internal_status();
}
inline void CreateWaypointResponse::_internal_set_status(::bosdyn::api::graph_nav::CreateWaypointResponse_Status value) {
  
  status_ = value;
}
inline void CreateWaypointResponse::set_status(::bosdyn::api::graph_nav::CreateWaypointResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.CreateWaypointResponse.status)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 4;
inline bool CreateWaypointResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool CreateWaypointResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& CreateWaypointResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& CreateWaypointResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void CreateWaypointResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateWaypointResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* CreateWaypointResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* CreateWaypointResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateWaypointResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* CreateWaypointResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* CreateWaypointResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateWaypointResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void CreateWaypointResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateWaypointResponse.lease_use_result)
}

// repeated int32 missing_fiducials = 6;
inline int CreateWaypointResponse::_internal_missing_fiducials_size() const {
  return missing_fiducials_.size();
}
inline int CreateWaypointResponse::missing_fiducials_size() const {
  return _internal_missing_fiducials_size();
}
inline void CreateWaypointResponse::clear_missing_fiducials() {
  missing_fiducials_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateWaypointResponse::_internal_missing_fiducials(int index) const {
  return missing_fiducials_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateWaypointResponse::missing_fiducials(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointResponse.missing_fiducials)
  return _internal_missing_fiducials(index);
}
inline void CreateWaypointResponse::set_missing_fiducials(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  missing_fiducials_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.CreateWaypointResponse.missing_fiducials)
}
inline void CreateWaypointResponse::_internal_add_missing_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value) {
  missing_fiducials_.Add(value);
}
inline void CreateWaypointResponse::add_missing_fiducials(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_missing_fiducials(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.graph_nav.CreateWaypointResponse.missing_fiducials)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
CreateWaypointResponse::_internal_missing_fiducials() const {
  return missing_fiducials_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
CreateWaypointResponse::missing_fiducials() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.graph_nav.CreateWaypointResponse.missing_fiducials)
  return _internal_missing_fiducials();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
CreateWaypointResponse::_internal_mutable_missing_fiducials() {
  return &missing_fiducials_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
CreateWaypointResponse::mutable_missing_fiducials() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.graph_nav.CreateWaypointResponse.missing_fiducials)
  return _internal_mutable_missing_fiducials();
}

// .bosdyn.api.LicenseInfo.Status license_status = 7;
inline void CreateWaypointResponse::clear_license_status() {
  license_status_ = 0;
}
inline ::bosdyn::api::LicenseInfo_Status CreateWaypointResponse::_internal_license_status() const {
  return static_cast< ::bosdyn::api::LicenseInfo_Status >(license_status_);
}
inline ::bosdyn::api::LicenseInfo_Status CreateWaypointResponse::license_status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateWaypointResponse.license_status)
  return _internal_license_status();
}
inline void CreateWaypointResponse::_internal_set_license_status(::bosdyn::api::LicenseInfo_Status value) {
  
  license_status_ = value;
}
inline void CreateWaypointResponse::set_license_status(::bosdyn::api::LicenseInfo_Status value) {
  _internal_set_license_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.CreateWaypointResponse.license_status)
}

// -------------------------------------------------------------------

// CreateEdgeRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool CreateEdgeRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CreateEdgeRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& CreateEdgeRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& CreateEdgeRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateEdgeRequest.header)
  return _internal_header();
}
inline void CreateEdgeRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateEdgeRequest.header)
}
inline ::bosdyn::api::RequestHeader* CreateEdgeRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* CreateEdgeRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateEdgeRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* CreateEdgeRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* CreateEdgeRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateEdgeRequest.header)
  return _internal_mutable_header();
}
inline void CreateEdgeRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateEdgeRequest.header)
}

// .bosdyn.api.graph_nav.Edge edge = 2;
inline bool CreateEdgeRequest::_internal_has_edge() const {
  return this != internal_default_instance() && edge_ != nullptr;
}
inline bool CreateEdgeRequest::has_edge() const {
  return _internal_has_edge();
}
inline const ::bosdyn::api::graph_nav::Edge& CreateEdgeRequest::_internal_edge() const {
  const ::bosdyn::api::graph_nav::Edge* p = edge_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::Edge*>(
      &::bosdyn::api::graph_nav::_Edge_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Edge& CreateEdgeRequest::edge() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateEdgeRequest.edge)
  return _internal_edge();
}
inline void CreateEdgeRequest::unsafe_arena_set_allocated_edge(
    ::bosdyn::api::graph_nav::Edge* edge) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge_);
  }
  edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateEdgeRequest.edge)
}
inline ::bosdyn::api::graph_nav::Edge* CreateEdgeRequest::release_edge() {
  
  ::bosdyn::api::graph_nav::Edge* temp = edge_;
  edge_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::Edge* CreateEdgeRequest::unsafe_arena_release_edge() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateEdgeRequest.edge)
  
  ::bosdyn::api::graph_nav::Edge* temp = edge_;
  edge_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Edge* CreateEdgeRequest::_internal_mutable_edge() {
  
  if (edge_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Edge>(GetArena());
    edge_ = p;
  }
  return edge_;
}
inline ::bosdyn::api::graph_nav::Edge* CreateEdgeRequest::mutable_edge() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateEdgeRequest.edge)
  return _internal_mutable_edge();
}
inline void CreateEdgeRequest::set_allocated_edge(::bosdyn::api::graph_nav::Edge* edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge_);
  }
  if (edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge)->GetArena();
    if (message_arena != submessage_arena) {
      edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    
  } else {
    
  }
  edge_ = edge;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateEdgeRequest.edge)
}

// .bosdyn.api.Lease lease = 3;
inline bool CreateEdgeRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool CreateEdgeRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& CreateEdgeRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& CreateEdgeRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateEdgeRequest.lease)
  return _internal_lease();
}
inline void CreateEdgeRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateEdgeRequest.lease)
}
inline ::bosdyn::api::Lease* CreateEdgeRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* CreateEdgeRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateEdgeRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* CreateEdgeRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* CreateEdgeRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateEdgeRequest.lease)
  return _internal_mutable_lease();
}
inline void CreateEdgeRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateEdgeRequest.lease)
}

// -------------------------------------------------------------------

// CreateEdgeResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool CreateEdgeResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CreateEdgeResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& CreateEdgeResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& CreateEdgeResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateEdgeResponse.header)
  return _internal_header();
}
inline void CreateEdgeResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateEdgeResponse.header)
}
inline ::bosdyn::api::ResponseHeader* CreateEdgeResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CreateEdgeResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateEdgeResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CreateEdgeResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* CreateEdgeResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateEdgeResponse.header)
  return _internal_mutable_header();
}
inline void CreateEdgeResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateEdgeResponse.header)
}

// .bosdyn.api.graph_nav.CreateEdgeResponse.Status status = 2;
inline void CreateEdgeResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::graph_nav::CreateEdgeResponse_Status CreateEdgeResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::graph_nav::CreateEdgeResponse_Status >(status_);
}
inline ::bosdyn::api::graph_nav::CreateEdgeResponse_Status CreateEdgeResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateEdgeResponse.status)
  return _internal_status();
}
inline void CreateEdgeResponse::_internal_set_status(::bosdyn::api::graph_nav::CreateEdgeResponse_Status value) {
  
  status_ = value;
}
inline void CreateEdgeResponse::set_status(::bosdyn::api::graph_nav::CreateEdgeResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.CreateEdgeResponse.status)
}

// .bosdyn.api.graph_nav.Edge error_existing_edge = 3;
inline bool CreateEdgeResponse::_internal_has_error_existing_edge() const {
  return this != internal_default_instance() && error_existing_edge_ != nullptr;
}
inline bool CreateEdgeResponse::has_error_existing_edge() const {
  return _internal_has_error_existing_edge();
}
inline const ::bosdyn::api::graph_nav::Edge& CreateEdgeResponse::_internal_error_existing_edge() const {
  const ::bosdyn::api::graph_nav::Edge* p = error_existing_edge_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::Edge*>(
      &::bosdyn::api::graph_nav::_Edge_default_instance_);
}
inline const ::bosdyn::api::graph_nav::Edge& CreateEdgeResponse::error_existing_edge() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateEdgeResponse.error_existing_edge)
  return _internal_error_existing_edge();
}
inline void CreateEdgeResponse::unsafe_arena_set_allocated_error_existing_edge(
    ::bosdyn::api::graph_nav::Edge* error_existing_edge) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_existing_edge_);
  }
  error_existing_edge_ = error_existing_edge;
  if (error_existing_edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateEdgeResponse.error_existing_edge)
}
inline ::bosdyn::api::graph_nav::Edge* CreateEdgeResponse::release_error_existing_edge() {
  
  ::bosdyn::api::graph_nav::Edge* temp = error_existing_edge_;
  error_existing_edge_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::Edge* CreateEdgeResponse::unsafe_arena_release_error_existing_edge() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateEdgeResponse.error_existing_edge)
  
  ::bosdyn::api::graph_nav::Edge* temp = error_existing_edge_;
  error_existing_edge_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::Edge* CreateEdgeResponse::_internal_mutable_error_existing_edge() {
  
  if (error_existing_edge_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::Edge>(GetArena());
    error_existing_edge_ = p;
  }
  return error_existing_edge_;
}
inline ::bosdyn::api::graph_nav::Edge* CreateEdgeResponse::mutable_error_existing_edge() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateEdgeResponse.error_existing_edge)
  return _internal_mutable_error_existing_edge();
}
inline void CreateEdgeResponse::set_allocated_error_existing_edge(::bosdyn::api::graph_nav::Edge* error_existing_edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_existing_edge_);
  }
  if (error_existing_edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_existing_edge)->GetArena();
    if (message_arena != submessage_arena) {
      error_existing_edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_existing_edge, submessage_arena);
    }
    
  } else {
    
  }
  error_existing_edge_ = error_existing_edge;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateEdgeResponse.error_existing_edge)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 4;
inline bool CreateEdgeResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool CreateEdgeResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& CreateEdgeResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& CreateEdgeResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.CreateEdgeResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void CreateEdgeResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.CreateEdgeResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* CreateEdgeResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* CreateEdgeResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.CreateEdgeResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* CreateEdgeResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* CreateEdgeResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.CreateEdgeResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void CreateEdgeResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.CreateEdgeResponse.lease_use_result)
}

// -------------------------------------------------------------------

// GetRecordStatusRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetRecordStatusRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetRecordStatusRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetRecordStatusRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetRecordStatusRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetRecordStatusRequest.header)
  return _internal_header();
}
inline void GetRecordStatusRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetRecordStatusRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetRecordStatusRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetRecordStatusRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetRecordStatusRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetRecordStatusRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* GetRecordStatusRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetRecordStatusRequest.header)
  return _internal_mutable_header();
}
inline void GetRecordStatusRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetRecordStatusRequest.header)
}

// -------------------------------------------------------------------

// GetRecordStatusResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetRecordStatusResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetRecordStatusResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetRecordStatusResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetRecordStatusResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetRecordStatusResponse.header)
  return _internal_header();
}
inline void GetRecordStatusResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetRecordStatusResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetRecordStatusResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetRecordStatusResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetRecordStatusResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetRecordStatusResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* GetRecordStatusResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetRecordStatusResponse.header)
  return _internal_mutable_header();
}
inline void GetRecordStatusResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetRecordStatusResponse.header)
}

// bool is_recording = 2;
inline void GetRecordStatusResponse::clear_is_recording() {
  is_recording_ = false;
}
inline bool GetRecordStatusResponse::_internal_is_recording() const {
  return is_recording_;
}
inline bool GetRecordStatusResponse::is_recording() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetRecordStatusResponse.is_recording)
  return _internal_is_recording();
}
inline void GetRecordStatusResponse::_internal_set_is_recording(bool value) {
  
  is_recording_ = value;
}
inline void GetRecordStatusResponse::set_is_recording(bool value) {
  _internal_set_is_recording(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetRecordStatusResponse.is_recording)
}

// .bosdyn.api.graph_nav.RecordingEnvironment recording_environment = 3;
inline bool GetRecordStatusResponse::_internal_has_recording_environment() const {
  return this != internal_default_instance() && recording_environment_ != nullptr;
}
inline bool GetRecordStatusResponse::has_recording_environment() const {
  return _internal_has_recording_environment();
}
inline void GetRecordStatusResponse::clear_recording_environment() {
  if (GetArena() == nullptr && recording_environment_ != nullptr) {
    delete recording_environment_;
  }
  recording_environment_ = nullptr;
}
inline const ::bosdyn::api::graph_nav::RecordingEnvironment& GetRecordStatusResponse::_internal_recording_environment() const {
  const ::bosdyn::api::graph_nav::RecordingEnvironment* p = recording_environment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::RecordingEnvironment*>(
      &::bosdyn::api::graph_nav::_RecordingEnvironment_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RecordingEnvironment& GetRecordStatusResponse::recording_environment() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetRecordStatusResponse.recording_environment)
  return _internal_recording_environment();
}
inline void GetRecordStatusResponse::unsafe_arena_set_allocated_recording_environment(
    ::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recording_environment_);
  }
  recording_environment_ = recording_environment;
  if (recording_environment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.graph_nav.GetRecordStatusResponse.recording_environment)
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* GetRecordStatusResponse::release_recording_environment() {
  
  ::bosdyn::api::graph_nav::RecordingEnvironment* temp = recording_environment_;
  recording_environment_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* GetRecordStatusResponse::unsafe_arena_release_recording_environment() {
  // @@protoc_insertion_point(field_release:bosdyn.api.graph_nav.GetRecordStatusResponse.recording_environment)
  
  ::bosdyn::api::graph_nav::RecordingEnvironment* temp = recording_environment_;
  recording_environment_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* GetRecordStatusResponse::_internal_mutable_recording_environment() {
  
  if (recording_environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RecordingEnvironment>(GetArena());
    recording_environment_ = p;
  }
  return recording_environment_;
}
inline ::bosdyn::api::graph_nav::RecordingEnvironment* GetRecordStatusResponse::mutable_recording_environment() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.graph_nav.GetRecordStatusResponse.recording_environment)
  return _internal_mutable_recording_environment();
}
inline void GetRecordStatusResponse::set_allocated_recording_environment(::bosdyn::api::graph_nav::RecordingEnvironment* recording_environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete recording_environment_;
  }
  if (recording_environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(recording_environment);
    if (message_arena != submessage_arena) {
      recording_environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recording_environment, submessage_arena);
    }
    
  } else {
    
  }
  recording_environment_ = recording_environment;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.graph_nav.GetRecordStatusResponse.recording_environment)
}

// .bosdyn.api.graph_nav.GetRecordStatusResponse.MapState map_state = 4;
inline void GetRecordStatusResponse::clear_map_state() {
  map_state_ = 0;
}
inline ::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState GetRecordStatusResponse::_internal_map_state() const {
  return static_cast< ::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState >(map_state_);
}
inline ::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState GetRecordStatusResponse::map_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.graph_nav.GetRecordStatusResponse.map_state)
  return _internal_map_state();
}
inline void GetRecordStatusResponse::_internal_set_map_state(::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState value) {
  
  map_state_ = value;
}
inline void GetRecordStatusResponse::set_map_state(::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState value) {
  _internal_set_map_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.graph_nav.GetRecordStatusResponse.map_state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace graph_nav
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::graph_nav::StartRecordingResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::StartRecordingResponse_Status>() {
  return ::bosdyn::api::graph_nav::StartRecordingResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::StopRecordingResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::StopRecordingResponse_Status>() {
  return ::bosdyn::api::graph_nav::StopRecordingResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::CreateWaypointResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::CreateWaypointResponse_Status>() {
  return ::bosdyn::api::graph_nav::CreateWaypointResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::CreateEdgeResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::CreateEdgeResponse_Status>() {
  return ::bosdyn::api::graph_nav::CreateEdgeResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState>() {
  return ::bosdyn::api::graph_nav::GetRecordStatusResponse_MapState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgraph_5fnav_2frecording_2eproto
