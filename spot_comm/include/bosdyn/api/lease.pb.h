// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/lease.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2flease_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2flease_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2flease_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2flease_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2flease_2eproto;
namespace bosdyn {
namespace api {
class AcquireLeaseRequest;
class AcquireLeaseRequestDefaultTypeInternal;
extern AcquireLeaseRequestDefaultTypeInternal _AcquireLeaseRequest_default_instance_;
class AcquireLeaseResponse;
class AcquireLeaseResponseDefaultTypeInternal;
extern AcquireLeaseResponseDefaultTypeInternal _AcquireLeaseResponse_default_instance_;
class Lease;
class LeaseDefaultTypeInternal;
extern LeaseDefaultTypeInternal _Lease_default_instance_;
class LeaseOwner;
class LeaseOwnerDefaultTypeInternal;
extern LeaseOwnerDefaultTypeInternal _LeaseOwner_default_instance_;
class LeaseResource;
class LeaseResourceDefaultTypeInternal;
extern LeaseResourceDefaultTypeInternal _LeaseResource_default_instance_;
class LeaseUseResult;
class LeaseUseResultDefaultTypeInternal;
extern LeaseUseResultDefaultTypeInternal _LeaseUseResult_default_instance_;
class ListLeasesRequest;
class ListLeasesRequestDefaultTypeInternal;
extern ListLeasesRequestDefaultTypeInternal _ListLeasesRequest_default_instance_;
class ListLeasesResponse;
class ListLeasesResponseDefaultTypeInternal;
extern ListLeasesResponseDefaultTypeInternal _ListLeasesResponse_default_instance_;
class RetainLeaseRequest;
class RetainLeaseRequestDefaultTypeInternal;
extern RetainLeaseRequestDefaultTypeInternal _RetainLeaseRequest_default_instance_;
class RetainLeaseResponse;
class RetainLeaseResponseDefaultTypeInternal;
extern RetainLeaseResponseDefaultTypeInternal _RetainLeaseResponse_default_instance_;
class ReturnLeaseRequest;
class ReturnLeaseRequestDefaultTypeInternal;
extern ReturnLeaseRequestDefaultTypeInternal _ReturnLeaseRequest_default_instance_;
class ReturnLeaseResponse;
class ReturnLeaseResponseDefaultTypeInternal;
extern ReturnLeaseResponseDefaultTypeInternal _ReturnLeaseResponse_default_instance_;
class TakeLeaseRequest;
class TakeLeaseRequestDefaultTypeInternal;
extern TakeLeaseRequestDefaultTypeInternal _TakeLeaseRequest_default_instance_;
class TakeLeaseResponse;
class TakeLeaseResponseDefaultTypeInternal;
extern TakeLeaseResponseDefaultTypeInternal _TakeLeaseResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::AcquireLeaseRequest* Arena::CreateMaybeMessage<::bosdyn::api::AcquireLeaseRequest>(Arena*);
template<> ::bosdyn::api::AcquireLeaseResponse* Arena::CreateMaybeMessage<::bosdyn::api::AcquireLeaseResponse>(Arena*);
template<> ::bosdyn::api::Lease* Arena::CreateMaybeMessage<::bosdyn::api::Lease>(Arena*);
template<> ::bosdyn::api::LeaseOwner* Arena::CreateMaybeMessage<::bosdyn::api::LeaseOwner>(Arena*);
template<> ::bosdyn::api::LeaseResource* Arena::CreateMaybeMessage<::bosdyn::api::LeaseResource>(Arena*);
template<> ::bosdyn::api::LeaseUseResult* Arena::CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(Arena*);
template<> ::bosdyn::api::ListLeasesRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListLeasesRequest>(Arena*);
template<> ::bosdyn::api::ListLeasesResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListLeasesResponse>(Arena*);
template<> ::bosdyn::api::RetainLeaseRequest* Arena::CreateMaybeMessage<::bosdyn::api::RetainLeaseRequest>(Arena*);
template<> ::bosdyn::api::RetainLeaseResponse* Arena::CreateMaybeMessage<::bosdyn::api::RetainLeaseResponse>(Arena*);
template<> ::bosdyn::api::ReturnLeaseRequest* Arena::CreateMaybeMessage<::bosdyn::api::ReturnLeaseRequest>(Arena*);
template<> ::bosdyn::api::ReturnLeaseResponse* Arena::CreateMaybeMessage<::bosdyn::api::ReturnLeaseResponse>(Arena*);
template<> ::bosdyn::api::TakeLeaseRequest* Arena::CreateMaybeMessage<::bosdyn::api::TakeLeaseRequest>(Arena*);
template<> ::bosdyn::api::TakeLeaseResponse* Arena::CreateMaybeMessage<::bosdyn::api::TakeLeaseResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum LeaseUseResult_Status : int {
  LeaseUseResult_Status_STATUS_UNKNOWN = 0,
  LeaseUseResult_Status_STATUS_OK = 1,
  LeaseUseResult_Status_STATUS_INVALID_LEASE = 2,
  LeaseUseResult_Status_STATUS_OLDER = 3,
  LeaseUseResult_Status_STATUS_REVOKED = 4,
  LeaseUseResult_Status_STATUS_UNMANAGED = 5,
  LeaseUseResult_Status_STATUS_WRONG_EPOCH = 6,
  LeaseUseResult_Status_LeaseUseResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LeaseUseResult_Status_LeaseUseResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LeaseUseResult_Status_IsValid(int value);
constexpr LeaseUseResult_Status LeaseUseResult_Status_Status_MIN = LeaseUseResult_Status_STATUS_UNKNOWN;
constexpr LeaseUseResult_Status LeaseUseResult_Status_Status_MAX = LeaseUseResult_Status_STATUS_WRONG_EPOCH;
constexpr int LeaseUseResult_Status_Status_ARRAYSIZE = LeaseUseResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LeaseUseResult_Status_descriptor();
template<typename T>
inline const std::string& LeaseUseResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LeaseUseResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LeaseUseResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LeaseUseResult_Status_descriptor(), enum_t_value);
}
inline bool LeaseUseResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LeaseUseResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LeaseUseResult_Status>(
    LeaseUseResult_Status_descriptor(), name, value);
}
enum AcquireLeaseResponse_Status : int {
  AcquireLeaseResponse_Status_STATUS_UNKNOWN = 0,
  AcquireLeaseResponse_Status_STATUS_OK = 1,
  AcquireLeaseResponse_Status_STATUS_RESOURCE_ALREADY_CLAIMED = 2,
  AcquireLeaseResponse_Status_STATUS_INVALID_RESOURCE = 3,
  AcquireLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE = 4,
  AcquireLeaseResponse_Status_AcquireLeaseResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AcquireLeaseResponse_Status_AcquireLeaseResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AcquireLeaseResponse_Status_IsValid(int value);
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse_Status_Status_MIN = AcquireLeaseResponse_Status_STATUS_UNKNOWN;
constexpr AcquireLeaseResponse_Status AcquireLeaseResponse_Status_Status_MAX = AcquireLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE;
constexpr int AcquireLeaseResponse_Status_Status_ARRAYSIZE = AcquireLeaseResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AcquireLeaseResponse_Status_descriptor();
template<typename T>
inline const std::string& AcquireLeaseResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AcquireLeaseResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AcquireLeaseResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AcquireLeaseResponse_Status_descriptor(), enum_t_value);
}
inline bool AcquireLeaseResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AcquireLeaseResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AcquireLeaseResponse_Status>(
    AcquireLeaseResponse_Status_descriptor(), name, value);
}
enum TakeLeaseResponse_Status : int {
  TakeLeaseResponse_Status_STATUS_UNKNOWN = 0,
  TakeLeaseResponse_Status_STATUS_OK = 1,
  TakeLeaseResponse_Status_STATUS_INVALID_RESOURCE = 2,
  TakeLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE = 3,
  TakeLeaseResponse_Status_TakeLeaseResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TakeLeaseResponse_Status_TakeLeaseResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TakeLeaseResponse_Status_IsValid(int value);
constexpr TakeLeaseResponse_Status TakeLeaseResponse_Status_Status_MIN = TakeLeaseResponse_Status_STATUS_UNKNOWN;
constexpr TakeLeaseResponse_Status TakeLeaseResponse_Status_Status_MAX = TakeLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE;
constexpr int TakeLeaseResponse_Status_Status_ARRAYSIZE = TakeLeaseResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TakeLeaseResponse_Status_descriptor();
template<typename T>
inline const std::string& TakeLeaseResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TakeLeaseResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TakeLeaseResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TakeLeaseResponse_Status_descriptor(), enum_t_value);
}
inline bool TakeLeaseResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TakeLeaseResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TakeLeaseResponse_Status>(
    TakeLeaseResponse_Status_descriptor(), name, value);
}
enum ReturnLeaseResponse_Status : int {
  ReturnLeaseResponse_Status_STATUS_UNKNOWN = 0,
  ReturnLeaseResponse_Status_STATUS_OK = 1,
  ReturnLeaseResponse_Status_STATUS_INVALID_RESOURCE = 2,
  ReturnLeaseResponse_Status_STATUS_NOT_ACTIVE_LEASE = 3,
  ReturnLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE = 4,
  ReturnLeaseResponse_Status_ReturnLeaseResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ReturnLeaseResponse_Status_ReturnLeaseResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ReturnLeaseResponse_Status_IsValid(int value);
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse_Status_Status_MIN = ReturnLeaseResponse_Status_STATUS_UNKNOWN;
constexpr ReturnLeaseResponse_Status ReturnLeaseResponse_Status_Status_MAX = ReturnLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE;
constexpr int ReturnLeaseResponse_Status_Status_ARRAYSIZE = ReturnLeaseResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReturnLeaseResponse_Status_descriptor();
template<typename T>
inline const std::string& ReturnLeaseResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReturnLeaseResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReturnLeaseResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReturnLeaseResponse_Status_descriptor(), enum_t_value);
}
inline bool ReturnLeaseResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReturnLeaseResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReturnLeaseResponse_Status>(
    ReturnLeaseResponse_Status_descriptor(), name, value);
}
// ===================================================================

class Lease PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Lease) */ {
 public:
  inline Lease() : Lease(nullptr) {}
  virtual ~Lease();

  Lease(const Lease& from);
  Lease(Lease&& from) noexcept
    : Lease() {
    *this = ::std::move(from);
  }

  inline Lease& operator=(const Lease& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lease& operator=(Lease&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Lease& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lease* internal_default_instance() {
    return reinterpret_cast<const Lease*>(
               &_Lease_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Lease& a, Lease& b) {
    a.Swap(&b);
  }
  inline void Swap(Lease* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lease* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lease* New() const final {
    return CreateMaybeMessage<Lease>(nullptr);
  }

  Lease* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lease>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lease& from);
  void MergeFrom(const Lease& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lease* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Lease";
  }
  protected:
  explicit Lease(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 3,
    kResourceFieldNumber = 1,
    kEpochFieldNumber = 2,
  };
  // repeated uint32 sequence = 3;
  int sequence_size() const;
  private:
  int _internal_sequence_size() const;
  public:
  void clear_sequence();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sequence(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_sequence() const;
  void _internal_add_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_sequence();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence(int index) const;
  void set_sequence(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      sequence() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_sequence();

  // string resource = 1;
  void clear_resource();
  const std::string& resource() const;
  void set_resource(const std::string& value);
  void set_resource(std::string&& value);
  void set_resource(const char* value);
  void set_resource(const char* value, size_t size);
  std::string* mutable_resource();
  std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // string epoch = 2;
  void clear_epoch();
  const std::string& epoch() const;
  void set_epoch(const std::string& value);
  void set_epoch(std::string&& value);
  void set_epoch(const char* value);
  void set_epoch(const char* value, size_t size);
  std::string* mutable_epoch();
  std::string* release_epoch();
  void set_allocated_epoch(std::string* epoch);
  private:
  const std::string& _internal_epoch() const;
  void _internal_set_epoch(const std::string& value);
  std::string* _internal_mutable_epoch();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Lease)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > sequence_;
  mutable std::atomic<int> _sequence_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr epoch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class LeaseOwner PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.LeaseOwner) */ {
 public:
  inline LeaseOwner() : LeaseOwner(nullptr) {}
  virtual ~LeaseOwner();

  LeaseOwner(const LeaseOwner& from);
  LeaseOwner(LeaseOwner&& from) noexcept
    : LeaseOwner() {
    *this = ::std::move(from);
  }

  inline LeaseOwner& operator=(const LeaseOwner& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseOwner& operator=(LeaseOwner&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeaseOwner& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaseOwner* internal_default_instance() {
    return reinterpret_cast<const LeaseOwner*>(
               &_LeaseOwner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LeaseOwner& a, LeaseOwner& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseOwner* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseOwner* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaseOwner* New() const final {
    return CreateMaybeMessage<LeaseOwner>(nullptr);
  }

  LeaseOwner* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaseOwner>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeaseOwner& from);
  void MergeFrom(const LeaseOwner& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseOwner* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.LeaseOwner";
  }
  protected:
  explicit LeaseOwner(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 1,
    kUserNameFieldNumber = 2,
  };
  // string client_name = 1;
  void clear_client_name();
  const std::string& client_name() const;
  void set_client_name(const std::string& value);
  void set_client_name(std::string&& value);
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  std::string* mutable_client_name();
  std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  void set_user_name(const std::string& value);
  void set_user_name(std::string&& value);
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  std::string* mutable_user_name();
  std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.LeaseOwner)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class LeaseUseResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.LeaseUseResult) */ {
 public:
  inline LeaseUseResult() : LeaseUseResult(nullptr) {}
  virtual ~LeaseUseResult();

  LeaseUseResult(const LeaseUseResult& from);
  LeaseUseResult(LeaseUseResult&& from) noexcept
    : LeaseUseResult() {
    *this = ::std::move(from);
  }

  inline LeaseUseResult& operator=(const LeaseUseResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseUseResult& operator=(LeaseUseResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeaseUseResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaseUseResult* internal_default_instance() {
    return reinterpret_cast<const LeaseUseResult*>(
               &_LeaseUseResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LeaseUseResult& a, LeaseUseResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseUseResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseUseResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaseUseResult* New() const final {
    return CreateMaybeMessage<LeaseUseResult>(nullptr);
  }

  LeaseUseResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaseUseResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeaseUseResult& from);
  void MergeFrom(const LeaseUseResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseUseResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.LeaseUseResult";
  }
  protected:
  explicit LeaseUseResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LeaseUseResult_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    LeaseUseResult_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    LeaseUseResult_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_LEASE =
    LeaseUseResult_Status_STATUS_INVALID_LEASE;
  static constexpr Status STATUS_OLDER =
    LeaseUseResult_Status_STATUS_OLDER;
  static constexpr Status STATUS_REVOKED =
    LeaseUseResult_Status_STATUS_REVOKED;
  static constexpr Status STATUS_UNMANAGED =
    LeaseUseResult_Status_STATUS_UNMANAGED;
  static constexpr Status STATUS_WRONG_EPOCH =
    LeaseUseResult_Status_STATUS_WRONG_EPOCH;
  static inline bool Status_IsValid(int value) {
    return LeaseUseResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    LeaseUseResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    LeaseUseResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    LeaseUseResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return LeaseUseResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return LeaseUseResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return LeaseUseResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 2,
    kAttemptedLeaseFieldNumber = 3,
    kPreviousLeaseFieldNumber = 4,
    kStatusFieldNumber = 1,
  };
  // .bosdyn.api.LeaseOwner owner = 2;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const ::bosdyn::api::LeaseOwner& owner() const;
  ::bosdyn::api::LeaseOwner* release_owner();
  ::bosdyn::api::LeaseOwner* mutable_owner();
  void set_allocated_owner(::bosdyn::api::LeaseOwner* owner);
  private:
  const ::bosdyn::api::LeaseOwner& _internal_owner() const;
  ::bosdyn::api::LeaseOwner* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::bosdyn::api::LeaseOwner* owner);
  ::bosdyn::api::LeaseOwner* unsafe_arena_release_owner();

  // .bosdyn.api.Lease attempted_lease = 3;
  bool has_attempted_lease() const;
  private:
  bool _internal_has_attempted_lease() const;
  public:
  void clear_attempted_lease();
  const ::bosdyn::api::Lease& attempted_lease() const;
  ::bosdyn::api::Lease* release_attempted_lease();
  ::bosdyn::api::Lease* mutable_attempted_lease();
  void set_allocated_attempted_lease(::bosdyn::api::Lease* attempted_lease);
  private:
  const ::bosdyn::api::Lease& _internal_attempted_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_attempted_lease();
  public:
  void unsafe_arena_set_allocated_attempted_lease(
      ::bosdyn::api::Lease* attempted_lease);
  ::bosdyn::api::Lease* unsafe_arena_release_attempted_lease();

  // .bosdyn.api.Lease previous_lease = 4;
  bool has_previous_lease() const;
  private:
  bool _internal_has_previous_lease() const;
  public:
  void clear_previous_lease();
  const ::bosdyn::api::Lease& previous_lease() const;
  ::bosdyn::api::Lease* release_previous_lease();
  ::bosdyn::api::Lease* mutable_previous_lease();
  void set_allocated_previous_lease(::bosdyn::api::Lease* previous_lease);
  private:
  const ::bosdyn::api::Lease& _internal_previous_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_previous_lease();
  public:
  void unsafe_arena_set_allocated_previous_lease(
      ::bosdyn::api::Lease* previous_lease);
  ::bosdyn::api::Lease* unsafe_arena_release_previous_lease();

  // .bosdyn.api.LeaseUseResult.Status status = 1;
  void clear_status();
  ::bosdyn::api::LeaseUseResult_Status status() const;
  void set_status(::bosdyn::api::LeaseUseResult_Status value);
  private:
  ::bosdyn::api::LeaseUseResult_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::LeaseUseResult_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.LeaseUseResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::LeaseOwner* owner_;
  ::bosdyn::api::Lease* attempted_lease_;
  ::bosdyn::api::Lease* previous_lease_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class AcquireLeaseRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AcquireLeaseRequest) */ {
 public:
  inline AcquireLeaseRequest() : AcquireLeaseRequest(nullptr) {}
  virtual ~AcquireLeaseRequest();

  AcquireLeaseRequest(const AcquireLeaseRequest& from);
  AcquireLeaseRequest(AcquireLeaseRequest&& from) noexcept
    : AcquireLeaseRequest() {
    *this = ::std::move(from);
  }

  inline AcquireLeaseRequest& operator=(const AcquireLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquireLeaseRequest& operator=(AcquireLeaseRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AcquireLeaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcquireLeaseRequest* internal_default_instance() {
    return reinterpret_cast<const AcquireLeaseRequest*>(
               &_AcquireLeaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AcquireLeaseRequest& a, AcquireLeaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquireLeaseRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquireLeaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcquireLeaseRequest* New() const final {
    return CreateMaybeMessage<AcquireLeaseRequest>(nullptr);
  }

  AcquireLeaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcquireLeaseRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AcquireLeaseRequest& from);
  void MergeFrom(const AcquireLeaseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquireLeaseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AcquireLeaseRequest";
  }
  protected:
  explicit AcquireLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string resource = 2;
  void clear_resource();
  const std::string& resource() const;
  void set_resource(const std::string& value);
  void set_resource(std::string&& value);
  void set_resource(const char* value);
  void set_resource(const char* value, size_t size);
  std::string* mutable_resource();
  std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.AcquireLeaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class AcquireLeaseResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.AcquireLeaseResponse) */ {
 public:
  inline AcquireLeaseResponse() : AcquireLeaseResponse(nullptr) {}
  virtual ~AcquireLeaseResponse();

  AcquireLeaseResponse(const AcquireLeaseResponse& from);
  AcquireLeaseResponse(AcquireLeaseResponse&& from) noexcept
    : AcquireLeaseResponse() {
    *this = ::std::move(from);
  }

  inline AcquireLeaseResponse& operator=(const AcquireLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquireLeaseResponse& operator=(AcquireLeaseResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AcquireLeaseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcquireLeaseResponse* internal_default_instance() {
    return reinterpret_cast<const AcquireLeaseResponse*>(
               &_AcquireLeaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AcquireLeaseResponse& a, AcquireLeaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AcquireLeaseResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquireLeaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcquireLeaseResponse* New() const final {
    return CreateMaybeMessage<AcquireLeaseResponse>(nullptr);
  }

  AcquireLeaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcquireLeaseResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AcquireLeaseResponse& from);
  void MergeFrom(const AcquireLeaseResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquireLeaseResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.AcquireLeaseResponse";
  }
  protected:
  explicit AcquireLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AcquireLeaseResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    AcquireLeaseResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    AcquireLeaseResponse_Status_STATUS_OK;
  static constexpr Status STATUS_RESOURCE_ALREADY_CLAIMED =
    AcquireLeaseResponse_Status_STATUS_RESOURCE_ALREADY_CLAIMED;
  static constexpr Status STATUS_INVALID_RESOURCE =
    AcquireLeaseResponse_Status_STATUS_INVALID_RESOURCE;
  static constexpr Status STATUS_NOT_AUTHORITATIVE_SERVICE =
    AcquireLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE;
  static inline bool Status_IsValid(int value) {
    return AcquireLeaseResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    AcquireLeaseResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    AcquireLeaseResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    AcquireLeaseResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return AcquireLeaseResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return AcquireLeaseResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return AcquireLeaseResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 3,
    kLeaseOwnerFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 3;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.LeaseOwner lease_owner = 4;
  bool has_lease_owner() const;
  private:
  bool _internal_has_lease_owner() const;
  public:
  void clear_lease_owner();
  const ::bosdyn::api::LeaseOwner& lease_owner() const;
  ::bosdyn::api::LeaseOwner* release_lease_owner();
  ::bosdyn::api::LeaseOwner* mutable_lease_owner();
  void set_allocated_lease_owner(::bosdyn::api::LeaseOwner* lease_owner);
  private:
  const ::bosdyn::api::LeaseOwner& _internal_lease_owner() const;
  ::bosdyn::api::LeaseOwner* _internal_mutable_lease_owner();
  public:
  void unsafe_arena_set_allocated_lease_owner(
      ::bosdyn::api::LeaseOwner* lease_owner);
  ::bosdyn::api::LeaseOwner* unsafe_arena_release_lease_owner();

  // .bosdyn.api.AcquireLeaseResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::AcquireLeaseResponse_Status status() const;
  void set_status(::bosdyn::api::AcquireLeaseResponse_Status value);
  private:
  ::bosdyn::api::AcquireLeaseResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::AcquireLeaseResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.AcquireLeaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::Lease* lease_;
  ::bosdyn::api::LeaseOwner* lease_owner_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class TakeLeaseRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.TakeLeaseRequest) */ {
 public:
  inline TakeLeaseRequest() : TakeLeaseRequest(nullptr) {}
  virtual ~TakeLeaseRequest();

  TakeLeaseRequest(const TakeLeaseRequest& from);
  TakeLeaseRequest(TakeLeaseRequest&& from) noexcept
    : TakeLeaseRequest() {
    *this = ::std::move(from);
  }

  inline TakeLeaseRequest& operator=(const TakeLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakeLeaseRequest& operator=(TakeLeaseRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakeLeaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakeLeaseRequest* internal_default_instance() {
    return reinterpret_cast<const TakeLeaseRequest*>(
               &_TakeLeaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TakeLeaseRequest& a, TakeLeaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TakeLeaseRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TakeLeaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TakeLeaseRequest* New() const final {
    return CreateMaybeMessage<TakeLeaseRequest>(nullptr);
  }

  TakeLeaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakeLeaseRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakeLeaseRequest& from);
  void MergeFrom(const TakeLeaseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakeLeaseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.TakeLeaseRequest";
  }
  protected:
  explicit TakeLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string resource = 2;
  void clear_resource();
  const std::string& resource() const;
  void set_resource(const std::string& value);
  void set_resource(std::string&& value);
  void set_resource(const char* value);
  void set_resource(const char* value, size_t size);
  std::string* mutable_resource();
  std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.TakeLeaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class TakeLeaseResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.TakeLeaseResponse) */ {
 public:
  inline TakeLeaseResponse() : TakeLeaseResponse(nullptr) {}
  virtual ~TakeLeaseResponse();

  TakeLeaseResponse(const TakeLeaseResponse& from);
  TakeLeaseResponse(TakeLeaseResponse&& from) noexcept
    : TakeLeaseResponse() {
    *this = ::std::move(from);
  }

  inline TakeLeaseResponse& operator=(const TakeLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakeLeaseResponse& operator=(TakeLeaseResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TakeLeaseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TakeLeaseResponse* internal_default_instance() {
    return reinterpret_cast<const TakeLeaseResponse*>(
               &_TakeLeaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TakeLeaseResponse& a, TakeLeaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TakeLeaseResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TakeLeaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TakeLeaseResponse* New() const final {
    return CreateMaybeMessage<TakeLeaseResponse>(nullptr);
  }

  TakeLeaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TakeLeaseResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TakeLeaseResponse& from);
  void MergeFrom(const TakeLeaseResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakeLeaseResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.TakeLeaseResponse";
  }
  protected:
  explicit TakeLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TakeLeaseResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    TakeLeaseResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    TakeLeaseResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_RESOURCE =
    TakeLeaseResponse_Status_STATUS_INVALID_RESOURCE;
  static constexpr Status STATUS_NOT_AUTHORITATIVE_SERVICE =
    TakeLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE;
  static inline bool Status_IsValid(int value) {
    return TakeLeaseResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    TakeLeaseResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    TakeLeaseResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    TakeLeaseResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return TakeLeaseResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return TakeLeaseResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return TakeLeaseResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 3,
    kLeaseOwnerFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 3;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.LeaseOwner lease_owner = 4;
  bool has_lease_owner() const;
  private:
  bool _internal_has_lease_owner() const;
  public:
  void clear_lease_owner();
  const ::bosdyn::api::LeaseOwner& lease_owner() const;
  ::bosdyn::api::LeaseOwner* release_lease_owner();
  ::bosdyn::api::LeaseOwner* mutable_lease_owner();
  void set_allocated_lease_owner(::bosdyn::api::LeaseOwner* lease_owner);
  private:
  const ::bosdyn::api::LeaseOwner& _internal_lease_owner() const;
  ::bosdyn::api::LeaseOwner* _internal_mutable_lease_owner();
  public:
  void unsafe_arena_set_allocated_lease_owner(
      ::bosdyn::api::LeaseOwner* lease_owner);
  ::bosdyn::api::LeaseOwner* unsafe_arena_release_lease_owner();

  // .bosdyn.api.TakeLeaseResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::TakeLeaseResponse_Status status() const;
  void set_status(::bosdyn::api::TakeLeaseResponse_Status value);
  private:
  ::bosdyn::api::TakeLeaseResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::TakeLeaseResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.TakeLeaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::Lease* lease_;
  ::bosdyn::api::LeaseOwner* lease_owner_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class ReturnLeaseRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ReturnLeaseRequest) */ {
 public:
  inline ReturnLeaseRequest() : ReturnLeaseRequest(nullptr) {}
  virtual ~ReturnLeaseRequest();

  ReturnLeaseRequest(const ReturnLeaseRequest& from);
  ReturnLeaseRequest(ReturnLeaseRequest&& from) noexcept
    : ReturnLeaseRequest() {
    *this = ::std::move(from);
  }

  inline ReturnLeaseRequest& operator=(const ReturnLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReturnLeaseRequest& operator=(ReturnLeaseRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReturnLeaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReturnLeaseRequest* internal_default_instance() {
    return reinterpret_cast<const ReturnLeaseRequest*>(
               &_ReturnLeaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReturnLeaseRequest& a, ReturnLeaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReturnLeaseRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReturnLeaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReturnLeaseRequest* New() const final {
    return CreateMaybeMessage<ReturnLeaseRequest>(nullptr);
  }

  ReturnLeaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReturnLeaseRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReturnLeaseRequest& from);
  void MergeFrom(const ReturnLeaseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnLeaseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ReturnLeaseRequest";
  }
  protected:
  explicit ReturnLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ReturnLeaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class ReturnLeaseResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ReturnLeaseResponse) */ {
 public:
  inline ReturnLeaseResponse() : ReturnLeaseResponse(nullptr) {}
  virtual ~ReturnLeaseResponse();

  ReturnLeaseResponse(const ReturnLeaseResponse& from);
  ReturnLeaseResponse(ReturnLeaseResponse&& from) noexcept
    : ReturnLeaseResponse() {
    *this = ::std::move(from);
  }

  inline ReturnLeaseResponse& operator=(const ReturnLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReturnLeaseResponse& operator=(ReturnLeaseResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReturnLeaseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReturnLeaseResponse* internal_default_instance() {
    return reinterpret_cast<const ReturnLeaseResponse*>(
               &_ReturnLeaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReturnLeaseResponse& a, ReturnLeaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReturnLeaseResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReturnLeaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReturnLeaseResponse* New() const final {
    return CreateMaybeMessage<ReturnLeaseResponse>(nullptr);
  }

  ReturnLeaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReturnLeaseResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReturnLeaseResponse& from);
  void MergeFrom(const ReturnLeaseResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnLeaseResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ReturnLeaseResponse";
  }
  protected:
  explicit ReturnLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ReturnLeaseResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ReturnLeaseResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ReturnLeaseResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_RESOURCE =
    ReturnLeaseResponse_Status_STATUS_INVALID_RESOURCE;
  static constexpr Status STATUS_NOT_ACTIVE_LEASE =
    ReturnLeaseResponse_Status_STATUS_NOT_ACTIVE_LEASE;
  static constexpr Status STATUS_NOT_AUTHORITATIVE_SERVICE =
    ReturnLeaseResponse_Status_STATUS_NOT_AUTHORITATIVE_SERVICE;
  static inline bool Status_IsValid(int value) {
    return ReturnLeaseResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ReturnLeaseResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ReturnLeaseResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ReturnLeaseResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ReturnLeaseResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ReturnLeaseResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ReturnLeaseResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.ReturnLeaseResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::ReturnLeaseResponse_Status status() const;
  void set_status(::bosdyn::api::ReturnLeaseResponse_Status value);
  private:
  ::bosdyn::api::ReturnLeaseResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::ReturnLeaseResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ReturnLeaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class ListLeasesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListLeasesRequest) */ {
 public:
  inline ListLeasesRequest() : ListLeasesRequest(nullptr) {}
  virtual ~ListLeasesRequest();

  ListLeasesRequest(const ListLeasesRequest& from);
  ListLeasesRequest(ListLeasesRequest&& from) noexcept
    : ListLeasesRequest() {
    *this = ::std::move(from);
  }

  inline ListLeasesRequest& operator=(const ListLeasesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLeasesRequest& operator=(ListLeasesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListLeasesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListLeasesRequest* internal_default_instance() {
    return reinterpret_cast<const ListLeasesRequest*>(
               &_ListLeasesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListLeasesRequest& a, ListLeasesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLeasesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLeasesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListLeasesRequest* New() const final {
    return CreateMaybeMessage<ListLeasesRequest>(nullptr);
  }

  ListLeasesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListLeasesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListLeasesRequest& from);
  void MergeFrom(const ListLeasesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLeasesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListLeasesRequest";
  }
  protected:
  explicit ListLeasesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListLeasesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class LeaseResource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.LeaseResource) */ {
 public:
  inline LeaseResource() : LeaseResource(nullptr) {}
  virtual ~LeaseResource();

  LeaseResource(const LeaseResource& from);
  LeaseResource(LeaseResource&& from) noexcept
    : LeaseResource() {
    *this = ::std::move(from);
  }

  inline LeaseResource& operator=(const LeaseResource& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaseResource& operator=(LeaseResource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeaseResource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeaseResource* internal_default_instance() {
    return reinterpret_cast<const LeaseResource*>(
               &_LeaseResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LeaseResource& a, LeaseResource& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaseResource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaseResource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaseResource* New() const final {
    return CreateMaybeMessage<LeaseResource>(nullptr);
  }

  LeaseResource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaseResource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeaseResource& from);
  void MergeFrom(const LeaseResource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaseResource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.LeaseResource";
  }
  protected:
  explicit LeaseResource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kLeaseOwnerFieldNumber = 3,
  };
  // string resource = 1;
  void clear_resource();
  const std::string& resource() const;
  void set_resource(const std::string& value);
  void set_resource(std::string&& value);
  void set_resource(const char* value);
  void set_resource(const char* value, size_t size);
  std::string* mutable_resource();
  std::string* release_resource();
  void set_allocated_resource(std::string* resource);
  private:
  const std::string& _internal_resource() const;
  void _internal_set_resource(const std::string& value);
  std::string* _internal_mutable_resource();
  public:

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.LeaseOwner lease_owner = 3;
  bool has_lease_owner() const;
  private:
  bool _internal_has_lease_owner() const;
  public:
  void clear_lease_owner();
  const ::bosdyn::api::LeaseOwner& lease_owner() const;
  ::bosdyn::api::LeaseOwner* release_lease_owner();
  ::bosdyn::api::LeaseOwner* mutable_lease_owner();
  void set_allocated_lease_owner(::bosdyn::api::LeaseOwner* lease_owner);
  private:
  const ::bosdyn::api::LeaseOwner& _internal_lease_owner() const;
  ::bosdyn::api::LeaseOwner* _internal_mutable_lease_owner();
  public:
  void unsafe_arena_set_allocated_lease_owner(
      ::bosdyn::api::LeaseOwner* lease_owner);
  ::bosdyn::api::LeaseOwner* unsafe_arena_release_lease_owner();

  // @@protoc_insertion_point(class_scope:bosdyn.api.LeaseResource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
  ::bosdyn::api::Lease* lease_;
  ::bosdyn::api::LeaseOwner* lease_owner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class ListLeasesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListLeasesResponse) */ {
 public:
  inline ListLeasesResponse() : ListLeasesResponse(nullptr) {}
  virtual ~ListLeasesResponse();

  ListLeasesResponse(const ListLeasesResponse& from);
  ListLeasesResponse(ListLeasesResponse&& from) noexcept
    : ListLeasesResponse() {
    *this = ::std::move(from);
  }

  inline ListLeasesResponse& operator=(const ListLeasesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLeasesResponse& operator=(ListLeasesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListLeasesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListLeasesResponse* internal_default_instance() {
    return reinterpret_cast<const ListLeasesResponse*>(
               &_ListLeasesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListLeasesResponse& a, ListLeasesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLeasesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLeasesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListLeasesResponse* New() const final {
    return CreateMaybeMessage<ListLeasesResponse>(nullptr);
  }

  ListLeasesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListLeasesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListLeasesResponse& from);
  void MergeFrom(const ListLeasesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLeasesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListLeasesResponse";
  }
  protected:
  explicit ListLeasesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.LeaseResource resources = 2;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::bosdyn::api::LeaseResource* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseResource >*
      mutable_resources();
  private:
  const ::bosdyn::api::LeaseResource& _internal_resources(int index) const;
  ::bosdyn::api::LeaseResource* _internal_add_resources();
  public:
  const ::bosdyn::api::LeaseResource& resources(int index) const;
  ::bosdyn::api::LeaseResource* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseResource >&
      resources() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListLeasesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseResource > resources_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class RetainLeaseRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RetainLeaseRequest) */ {
 public:
  inline RetainLeaseRequest() : RetainLeaseRequest(nullptr) {}
  virtual ~RetainLeaseRequest();

  RetainLeaseRequest(const RetainLeaseRequest& from);
  RetainLeaseRequest(RetainLeaseRequest&& from) noexcept
    : RetainLeaseRequest() {
    *this = ::std::move(from);
  }

  inline RetainLeaseRequest& operator=(const RetainLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetainLeaseRequest& operator=(RetainLeaseRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RetainLeaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetainLeaseRequest* internal_default_instance() {
    return reinterpret_cast<const RetainLeaseRequest*>(
               &_RetainLeaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RetainLeaseRequest& a, RetainLeaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RetainLeaseRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetainLeaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RetainLeaseRequest* New() const final {
    return CreateMaybeMessage<RetainLeaseRequest>(nullptr);
  }

  RetainLeaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RetainLeaseRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RetainLeaseRequest& from);
  void MergeFrom(const RetainLeaseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetainLeaseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RetainLeaseRequest";
  }
  protected:
  explicit RetainLeaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RetainLeaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// -------------------------------------------------------------------

class RetainLeaseResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RetainLeaseResponse) */ {
 public:
  inline RetainLeaseResponse() : RetainLeaseResponse(nullptr) {}
  virtual ~RetainLeaseResponse();

  RetainLeaseResponse(const RetainLeaseResponse& from);
  RetainLeaseResponse(RetainLeaseResponse&& from) noexcept
    : RetainLeaseResponse() {
    *this = ::std::move(from);
  }

  inline RetainLeaseResponse& operator=(const RetainLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetainLeaseResponse& operator=(RetainLeaseResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RetainLeaseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetainLeaseResponse* internal_default_instance() {
    return reinterpret_cast<const RetainLeaseResponse*>(
               &_RetainLeaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RetainLeaseResponse& a, RetainLeaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RetainLeaseResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetainLeaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RetainLeaseResponse* New() const final {
    return CreateMaybeMessage<RetainLeaseResponse>(nullptr);
  }

  RetainLeaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RetainLeaseResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RetainLeaseResponse& from);
  void MergeFrom(const RetainLeaseResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetainLeaseResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RetainLeaseResponse";
  }
  protected:
  explicit RetainLeaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2flease_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2flease_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RetainLeaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2flease_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Lease

// string resource = 1;
inline void Lease::clear_resource() {
  resource_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Lease::resource() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Lease.resource)
  return _internal_resource();
}
inline void Lease::set_resource(const std::string& value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Lease.resource)
}
inline std::string* Lease::mutable_resource() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Lease.resource)
  return _internal_mutable_resource();
}
inline const std::string& Lease::_internal_resource() const {
  return resource_.Get();
}
inline void Lease::_internal_set_resource(const std::string& value) {
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Lease::set_resource(std::string&& value) {
  
  resource_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Lease.resource)
}
inline void Lease::set_resource(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Lease.resource)
}
inline void Lease::set_resource(const char* value,
    size_t size) {
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Lease.resource)
}
inline std::string* Lease::_internal_mutable_resource() {
  
  return resource_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Lease::release_resource() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Lease.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Lease::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Lease.resource)
}

// string epoch = 2;
inline void Lease::clear_epoch() {
  epoch_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Lease::epoch() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Lease.epoch)
  return _internal_epoch();
}
inline void Lease::set_epoch(const std::string& value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Lease.epoch)
}
inline std::string* Lease::mutable_epoch() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Lease.epoch)
  return _internal_mutable_epoch();
}
inline const std::string& Lease::_internal_epoch() const {
  return epoch_.Get();
}
inline void Lease::_internal_set_epoch(const std::string& value) {
  
  epoch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Lease::set_epoch(std::string&& value) {
  
  epoch_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Lease.epoch)
}
inline void Lease::set_epoch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  epoch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Lease.epoch)
}
inline void Lease::set_epoch(const char* value,
    size_t size) {
  
  epoch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Lease.epoch)
}
inline std::string* Lease::_internal_mutable_epoch() {
  
  return epoch_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Lease::release_epoch() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Lease.epoch)
  return epoch_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Lease::set_allocated_epoch(std::string* epoch) {
  if (epoch != nullptr) {
    
  } else {
    
  }
  epoch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), epoch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Lease.epoch)
}

// repeated uint32 sequence = 3;
inline int Lease::_internal_sequence_size() const {
  return sequence_.size();
}
inline int Lease::sequence_size() const {
  return _internal_sequence_size();
}
inline void Lease::clear_sequence() {
  sequence_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lease::_internal_sequence(int index) const {
  return sequence_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lease::sequence(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Lease.sequence)
  return _internal_sequence(index);
}
inline void Lease::set_sequence(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  sequence_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Lease.sequence)
}
inline void Lease::_internal_add_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  sequence_.Add(value);
}
inline void Lease::add_sequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_sequence(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.Lease.sequence)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Lease::_internal_sequence() const {
  return sequence_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
Lease::sequence() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Lease.sequence)
  return _internal_sequence();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Lease::_internal_mutable_sequence() {
  return &sequence_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
Lease::mutable_sequence() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Lease.sequence)
  return _internal_mutable_sequence();
}

// -------------------------------------------------------------------

// LeaseOwner

// string client_name = 1;
inline void LeaseOwner::clear_client_name() {
  client_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LeaseOwner::client_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseOwner.client_name)
  return _internal_client_name();
}
inline void LeaseOwner::set_client_name(const std::string& value) {
  _internal_set_client_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.LeaseOwner.client_name)
}
inline std::string* LeaseOwner::mutable_client_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.LeaseOwner.client_name)
  return _internal_mutable_client_name();
}
inline const std::string& LeaseOwner::_internal_client_name() const {
  return client_name_.Get();
}
inline void LeaseOwner::_internal_set_client_name(const std::string& value) {
  
  client_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LeaseOwner::set_client_name(std::string&& value) {
  
  client_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.LeaseOwner.client_name)
}
inline void LeaseOwner::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.LeaseOwner.client_name)
}
inline void LeaseOwner::set_client_name(const char* value,
    size_t size) {
  
  client_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.LeaseOwner.client_name)
}
inline std::string* LeaseOwner::_internal_mutable_client_name() {
  
  return client_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LeaseOwner::release_client_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.LeaseOwner.client_name)
  return client_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LeaseOwner::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    
  } else {
    
  }
  client_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.LeaseOwner.client_name)
}

// string user_name = 2;
inline void LeaseOwner::clear_user_name() {
  user_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LeaseOwner::user_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseOwner.user_name)
  return _internal_user_name();
}
inline void LeaseOwner::set_user_name(const std::string& value) {
  _internal_set_user_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.LeaseOwner.user_name)
}
inline std::string* LeaseOwner::mutable_user_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.LeaseOwner.user_name)
  return _internal_mutable_user_name();
}
inline const std::string& LeaseOwner::_internal_user_name() const {
  return user_name_.Get();
}
inline void LeaseOwner::_internal_set_user_name(const std::string& value) {
  
  user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LeaseOwner::set_user_name(std::string&& value) {
  
  user_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.LeaseOwner.user_name)
}
inline void LeaseOwner::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.LeaseOwner.user_name)
}
inline void LeaseOwner::set_user_name(const char* value,
    size_t size) {
  
  user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.LeaseOwner.user_name)
}
inline std::string* LeaseOwner::_internal_mutable_user_name() {
  
  return user_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LeaseOwner::release_user_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.LeaseOwner.user_name)
  return user_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LeaseOwner::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.LeaseOwner.user_name)
}

// -------------------------------------------------------------------

// LeaseUseResult

// .bosdyn.api.LeaseUseResult.Status status = 1;
inline void LeaseUseResult::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::LeaseUseResult_Status LeaseUseResult::_internal_status() const {
  return static_cast< ::bosdyn::api::LeaseUseResult_Status >(status_);
}
inline ::bosdyn::api::LeaseUseResult_Status LeaseUseResult::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseUseResult.status)
  return _internal_status();
}
inline void LeaseUseResult::_internal_set_status(::bosdyn::api::LeaseUseResult_Status value) {
  
  status_ = value;
}
inline void LeaseUseResult::set_status(::bosdyn::api::LeaseUseResult_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.LeaseUseResult.status)
}

// .bosdyn.api.LeaseOwner owner = 2;
inline bool LeaseUseResult::_internal_has_owner() const {
  return this != internal_default_instance() && owner_ != nullptr;
}
inline bool LeaseUseResult::has_owner() const {
  return _internal_has_owner();
}
inline void LeaseUseResult::clear_owner() {
  if (GetArena() == nullptr && owner_ != nullptr) {
    delete owner_;
  }
  owner_ = nullptr;
}
inline const ::bosdyn::api::LeaseOwner& LeaseUseResult::_internal_owner() const {
  const ::bosdyn::api::LeaseOwner* p = owner_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseOwner*>(
      &::bosdyn::api::_LeaseOwner_default_instance_);
}
inline const ::bosdyn::api::LeaseOwner& LeaseUseResult::owner() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseUseResult.owner)
  return _internal_owner();
}
inline void LeaseUseResult::unsafe_arena_set_allocated_owner(
    ::bosdyn::api::LeaseOwner* owner) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner_);
  }
  owner_ = owner;
  if (owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.LeaseUseResult.owner)
}
inline ::bosdyn::api::LeaseOwner* LeaseUseResult::release_owner() {
  
  ::bosdyn::api::LeaseOwner* temp = owner_;
  owner_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseOwner* LeaseUseResult::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:bosdyn.api.LeaseUseResult.owner)
  
  ::bosdyn::api::LeaseOwner* temp = owner_;
  owner_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseOwner* LeaseUseResult::_internal_mutable_owner() {
  
  if (owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseOwner>(GetArena());
    owner_ = p;
  }
  return owner_;
}
inline ::bosdyn::api::LeaseOwner* LeaseUseResult::mutable_owner() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.LeaseUseResult.owner)
  return _internal_mutable_owner();
}
inline void LeaseUseResult::set_allocated_owner(::bosdyn::api::LeaseOwner* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete owner_;
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(owner);
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    
  } else {
    
  }
  owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.LeaseUseResult.owner)
}

// .bosdyn.api.Lease attempted_lease = 3;
inline bool LeaseUseResult::_internal_has_attempted_lease() const {
  return this != internal_default_instance() && attempted_lease_ != nullptr;
}
inline bool LeaseUseResult::has_attempted_lease() const {
  return _internal_has_attempted_lease();
}
inline void LeaseUseResult::clear_attempted_lease() {
  if (GetArena() == nullptr && attempted_lease_ != nullptr) {
    delete attempted_lease_;
  }
  attempted_lease_ = nullptr;
}
inline const ::bosdyn::api::Lease& LeaseUseResult::_internal_attempted_lease() const {
  const ::bosdyn::api::Lease* p = attempted_lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& LeaseUseResult::attempted_lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseUseResult.attempted_lease)
  return _internal_attempted_lease();
}
inline void LeaseUseResult::unsafe_arena_set_allocated_attempted_lease(
    ::bosdyn::api::Lease* attempted_lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attempted_lease_);
  }
  attempted_lease_ = attempted_lease;
  if (attempted_lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.LeaseUseResult.attempted_lease)
}
inline ::bosdyn::api::Lease* LeaseUseResult::release_attempted_lease() {
  
  ::bosdyn::api::Lease* temp = attempted_lease_;
  attempted_lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* LeaseUseResult::unsafe_arena_release_attempted_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.LeaseUseResult.attempted_lease)
  
  ::bosdyn::api::Lease* temp = attempted_lease_;
  attempted_lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* LeaseUseResult::_internal_mutable_attempted_lease() {
  
  if (attempted_lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    attempted_lease_ = p;
  }
  return attempted_lease_;
}
inline ::bosdyn::api::Lease* LeaseUseResult::mutable_attempted_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.LeaseUseResult.attempted_lease)
  return _internal_mutable_attempted_lease();
}
inline void LeaseUseResult::set_allocated_attempted_lease(::bosdyn::api::Lease* attempted_lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete attempted_lease_;
  }
  if (attempted_lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(attempted_lease);
    if (message_arena != submessage_arena) {
      attempted_lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attempted_lease, submessage_arena);
    }
    
  } else {
    
  }
  attempted_lease_ = attempted_lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.LeaseUseResult.attempted_lease)
}

// .bosdyn.api.Lease previous_lease = 4;
inline bool LeaseUseResult::_internal_has_previous_lease() const {
  return this != internal_default_instance() && previous_lease_ != nullptr;
}
inline bool LeaseUseResult::has_previous_lease() const {
  return _internal_has_previous_lease();
}
inline void LeaseUseResult::clear_previous_lease() {
  if (GetArena() == nullptr && previous_lease_ != nullptr) {
    delete previous_lease_;
  }
  previous_lease_ = nullptr;
}
inline const ::bosdyn::api::Lease& LeaseUseResult::_internal_previous_lease() const {
  const ::bosdyn::api::Lease* p = previous_lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& LeaseUseResult::previous_lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseUseResult.previous_lease)
  return _internal_previous_lease();
}
inline void LeaseUseResult::unsafe_arena_set_allocated_previous_lease(
    ::bosdyn::api::Lease* previous_lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(previous_lease_);
  }
  previous_lease_ = previous_lease;
  if (previous_lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.LeaseUseResult.previous_lease)
}
inline ::bosdyn::api::Lease* LeaseUseResult::release_previous_lease() {
  
  ::bosdyn::api::Lease* temp = previous_lease_;
  previous_lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* LeaseUseResult::unsafe_arena_release_previous_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.LeaseUseResult.previous_lease)
  
  ::bosdyn::api::Lease* temp = previous_lease_;
  previous_lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* LeaseUseResult::_internal_mutable_previous_lease() {
  
  if (previous_lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    previous_lease_ = p;
  }
  return previous_lease_;
}
inline ::bosdyn::api::Lease* LeaseUseResult::mutable_previous_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.LeaseUseResult.previous_lease)
  return _internal_mutable_previous_lease();
}
inline void LeaseUseResult::set_allocated_previous_lease(::bosdyn::api::Lease* previous_lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete previous_lease_;
  }
  if (previous_lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(previous_lease);
    if (message_arena != submessage_arena) {
      previous_lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, previous_lease, submessage_arena);
    }
    
  } else {
    
  }
  previous_lease_ = previous_lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.LeaseUseResult.previous_lease)
}

// -------------------------------------------------------------------

// AcquireLeaseRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool AcquireLeaseRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool AcquireLeaseRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& AcquireLeaseRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& AcquireLeaseRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireLeaseRequest.header)
  return _internal_header();
}
inline void AcquireLeaseRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireLeaseRequest.header)
}
inline ::bosdyn::api::RequestHeader* AcquireLeaseRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* AcquireLeaseRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireLeaseRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* AcquireLeaseRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* AcquireLeaseRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireLeaseRequest.header)
  return _internal_mutable_header();
}
inline void AcquireLeaseRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireLeaseRequest.header)
}

// string resource = 2;
inline void AcquireLeaseRequest::clear_resource() {
  resource_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AcquireLeaseRequest::resource() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireLeaseRequest.resource)
  return _internal_resource();
}
inline void AcquireLeaseRequest::set_resource(const std::string& value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AcquireLeaseRequest.resource)
}
inline std::string* AcquireLeaseRequest::mutable_resource() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireLeaseRequest.resource)
  return _internal_mutable_resource();
}
inline const std::string& AcquireLeaseRequest::_internal_resource() const {
  return resource_.Get();
}
inline void AcquireLeaseRequest::_internal_set_resource(const std::string& value) {
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AcquireLeaseRequest::set_resource(std::string&& value) {
  
  resource_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.AcquireLeaseRequest.resource)
}
inline void AcquireLeaseRequest::set_resource(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.AcquireLeaseRequest.resource)
}
inline void AcquireLeaseRequest::set_resource(const char* value,
    size_t size) {
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.AcquireLeaseRequest.resource)
}
inline std::string* AcquireLeaseRequest::_internal_mutable_resource() {
  
  return resource_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AcquireLeaseRequest::release_resource() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireLeaseRequest.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AcquireLeaseRequest::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireLeaseRequest.resource)
}

// -------------------------------------------------------------------

// AcquireLeaseResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool AcquireLeaseResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool AcquireLeaseResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& AcquireLeaseResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& AcquireLeaseResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireLeaseResponse.header)
  return _internal_header();
}
inline void AcquireLeaseResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireLeaseResponse.header)
}
inline ::bosdyn::api::ResponseHeader* AcquireLeaseResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AcquireLeaseResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireLeaseResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AcquireLeaseResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* AcquireLeaseResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireLeaseResponse.header)
  return _internal_mutable_header();
}
inline void AcquireLeaseResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireLeaseResponse.header)
}

// .bosdyn.api.AcquireLeaseResponse.Status status = 2;
inline void AcquireLeaseResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::AcquireLeaseResponse_Status AcquireLeaseResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::AcquireLeaseResponse_Status >(status_);
}
inline ::bosdyn::api::AcquireLeaseResponse_Status AcquireLeaseResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireLeaseResponse.status)
  return _internal_status();
}
inline void AcquireLeaseResponse::_internal_set_status(::bosdyn::api::AcquireLeaseResponse_Status value) {
  
  status_ = value;
}
inline void AcquireLeaseResponse::set_status(::bosdyn::api::AcquireLeaseResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.AcquireLeaseResponse.status)
}

// .bosdyn.api.Lease lease = 3;
inline bool AcquireLeaseResponse::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool AcquireLeaseResponse::has_lease() const {
  return _internal_has_lease();
}
inline void AcquireLeaseResponse::clear_lease() {
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
}
inline const ::bosdyn::api::Lease& AcquireLeaseResponse::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& AcquireLeaseResponse::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireLeaseResponse.lease)
  return _internal_lease();
}
inline void AcquireLeaseResponse::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireLeaseResponse.lease)
}
inline ::bosdyn::api::Lease* AcquireLeaseResponse::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* AcquireLeaseResponse::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireLeaseResponse.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* AcquireLeaseResponse::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* AcquireLeaseResponse::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireLeaseResponse.lease)
  return _internal_mutable_lease();
}
inline void AcquireLeaseResponse::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_;
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease);
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireLeaseResponse.lease)
}

// .bosdyn.api.LeaseOwner lease_owner = 4;
inline bool AcquireLeaseResponse::_internal_has_lease_owner() const {
  return this != internal_default_instance() && lease_owner_ != nullptr;
}
inline bool AcquireLeaseResponse::has_lease_owner() const {
  return _internal_has_lease_owner();
}
inline void AcquireLeaseResponse::clear_lease_owner() {
  if (GetArena() == nullptr && lease_owner_ != nullptr) {
    delete lease_owner_;
  }
  lease_owner_ = nullptr;
}
inline const ::bosdyn::api::LeaseOwner& AcquireLeaseResponse::_internal_lease_owner() const {
  const ::bosdyn::api::LeaseOwner* p = lease_owner_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseOwner*>(
      &::bosdyn::api::_LeaseOwner_default_instance_);
}
inline const ::bosdyn::api::LeaseOwner& AcquireLeaseResponse::lease_owner() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.AcquireLeaseResponse.lease_owner)
  return _internal_lease_owner();
}
inline void AcquireLeaseResponse::unsafe_arena_set_allocated_lease_owner(
    ::bosdyn::api::LeaseOwner* lease_owner) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_owner_);
  }
  lease_owner_ = lease_owner;
  if (lease_owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.AcquireLeaseResponse.lease_owner)
}
inline ::bosdyn::api::LeaseOwner* AcquireLeaseResponse::release_lease_owner() {
  
  ::bosdyn::api::LeaseOwner* temp = lease_owner_;
  lease_owner_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseOwner* AcquireLeaseResponse::unsafe_arena_release_lease_owner() {
  // @@protoc_insertion_point(field_release:bosdyn.api.AcquireLeaseResponse.lease_owner)
  
  ::bosdyn::api::LeaseOwner* temp = lease_owner_;
  lease_owner_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseOwner* AcquireLeaseResponse::_internal_mutable_lease_owner() {
  
  if (lease_owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseOwner>(GetArena());
    lease_owner_ = p;
  }
  return lease_owner_;
}
inline ::bosdyn::api::LeaseOwner* AcquireLeaseResponse::mutable_lease_owner() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.AcquireLeaseResponse.lease_owner)
  return _internal_mutable_lease_owner();
}
inline void AcquireLeaseResponse::set_allocated_lease_owner(::bosdyn::api::LeaseOwner* lease_owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_owner_;
  }
  if (lease_owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease_owner);
    if (message_arena != submessage_arena) {
      lease_owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_owner, submessage_arena);
    }
    
  } else {
    
  }
  lease_owner_ = lease_owner;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.AcquireLeaseResponse.lease_owner)
}

// -------------------------------------------------------------------

// TakeLeaseRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool TakeLeaseRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool TakeLeaseRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& TakeLeaseRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& TakeLeaseRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TakeLeaseRequest.header)
  return _internal_header();
}
inline void TakeLeaseRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TakeLeaseRequest.header)
}
inline ::bosdyn::api::RequestHeader* TakeLeaseRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* TakeLeaseRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TakeLeaseRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* TakeLeaseRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* TakeLeaseRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TakeLeaseRequest.header)
  return _internal_mutable_header();
}
inline void TakeLeaseRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TakeLeaseRequest.header)
}

// string resource = 2;
inline void TakeLeaseRequest::clear_resource() {
  resource_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TakeLeaseRequest::resource() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TakeLeaseRequest.resource)
  return _internal_resource();
}
inline void TakeLeaseRequest::set_resource(const std::string& value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.TakeLeaseRequest.resource)
}
inline std::string* TakeLeaseRequest::mutable_resource() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TakeLeaseRequest.resource)
  return _internal_mutable_resource();
}
inline const std::string& TakeLeaseRequest::_internal_resource() const {
  return resource_.Get();
}
inline void TakeLeaseRequest::_internal_set_resource(const std::string& value) {
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TakeLeaseRequest::set_resource(std::string&& value) {
  
  resource_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.TakeLeaseRequest.resource)
}
inline void TakeLeaseRequest::set_resource(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.TakeLeaseRequest.resource)
}
inline void TakeLeaseRequest::set_resource(const char* value,
    size_t size) {
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.TakeLeaseRequest.resource)
}
inline std::string* TakeLeaseRequest::_internal_mutable_resource() {
  
  return resource_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TakeLeaseRequest::release_resource() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TakeLeaseRequest.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TakeLeaseRequest::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TakeLeaseRequest.resource)
}

// -------------------------------------------------------------------

// TakeLeaseResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool TakeLeaseResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool TakeLeaseResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& TakeLeaseResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& TakeLeaseResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TakeLeaseResponse.header)
  return _internal_header();
}
inline void TakeLeaseResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TakeLeaseResponse.header)
}
inline ::bosdyn::api::ResponseHeader* TakeLeaseResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TakeLeaseResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TakeLeaseResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TakeLeaseResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* TakeLeaseResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TakeLeaseResponse.header)
  return _internal_mutable_header();
}
inline void TakeLeaseResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TakeLeaseResponse.header)
}

// .bosdyn.api.TakeLeaseResponse.Status status = 2;
inline void TakeLeaseResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::TakeLeaseResponse_Status TakeLeaseResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::TakeLeaseResponse_Status >(status_);
}
inline ::bosdyn::api::TakeLeaseResponse_Status TakeLeaseResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TakeLeaseResponse.status)
  return _internal_status();
}
inline void TakeLeaseResponse::_internal_set_status(::bosdyn::api::TakeLeaseResponse_Status value) {
  
  status_ = value;
}
inline void TakeLeaseResponse::set_status(::bosdyn::api::TakeLeaseResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.TakeLeaseResponse.status)
}

// .bosdyn.api.Lease lease = 3;
inline bool TakeLeaseResponse::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool TakeLeaseResponse::has_lease() const {
  return _internal_has_lease();
}
inline void TakeLeaseResponse::clear_lease() {
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
}
inline const ::bosdyn::api::Lease& TakeLeaseResponse::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& TakeLeaseResponse::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TakeLeaseResponse.lease)
  return _internal_lease();
}
inline void TakeLeaseResponse::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TakeLeaseResponse.lease)
}
inline ::bosdyn::api::Lease* TakeLeaseResponse::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* TakeLeaseResponse::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TakeLeaseResponse.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* TakeLeaseResponse::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* TakeLeaseResponse::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TakeLeaseResponse.lease)
  return _internal_mutable_lease();
}
inline void TakeLeaseResponse::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_;
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease);
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TakeLeaseResponse.lease)
}

// .bosdyn.api.LeaseOwner lease_owner = 4;
inline bool TakeLeaseResponse::_internal_has_lease_owner() const {
  return this != internal_default_instance() && lease_owner_ != nullptr;
}
inline bool TakeLeaseResponse::has_lease_owner() const {
  return _internal_has_lease_owner();
}
inline void TakeLeaseResponse::clear_lease_owner() {
  if (GetArena() == nullptr && lease_owner_ != nullptr) {
    delete lease_owner_;
  }
  lease_owner_ = nullptr;
}
inline const ::bosdyn::api::LeaseOwner& TakeLeaseResponse::_internal_lease_owner() const {
  const ::bosdyn::api::LeaseOwner* p = lease_owner_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseOwner*>(
      &::bosdyn::api::_LeaseOwner_default_instance_);
}
inline const ::bosdyn::api::LeaseOwner& TakeLeaseResponse::lease_owner() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.TakeLeaseResponse.lease_owner)
  return _internal_lease_owner();
}
inline void TakeLeaseResponse::unsafe_arena_set_allocated_lease_owner(
    ::bosdyn::api::LeaseOwner* lease_owner) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_owner_);
  }
  lease_owner_ = lease_owner;
  if (lease_owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.TakeLeaseResponse.lease_owner)
}
inline ::bosdyn::api::LeaseOwner* TakeLeaseResponse::release_lease_owner() {
  
  ::bosdyn::api::LeaseOwner* temp = lease_owner_;
  lease_owner_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseOwner* TakeLeaseResponse::unsafe_arena_release_lease_owner() {
  // @@protoc_insertion_point(field_release:bosdyn.api.TakeLeaseResponse.lease_owner)
  
  ::bosdyn::api::LeaseOwner* temp = lease_owner_;
  lease_owner_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseOwner* TakeLeaseResponse::_internal_mutable_lease_owner() {
  
  if (lease_owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseOwner>(GetArena());
    lease_owner_ = p;
  }
  return lease_owner_;
}
inline ::bosdyn::api::LeaseOwner* TakeLeaseResponse::mutable_lease_owner() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.TakeLeaseResponse.lease_owner)
  return _internal_mutable_lease_owner();
}
inline void TakeLeaseResponse::set_allocated_lease_owner(::bosdyn::api::LeaseOwner* lease_owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_owner_;
  }
  if (lease_owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease_owner);
    if (message_arena != submessage_arena) {
      lease_owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_owner, submessage_arena);
    }
    
  } else {
    
  }
  lease_owner_ = lease_owner;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.TakeLeaseResponse.lease_owner)
}

// -------------------------------------------------------------------

// ReturnLeaseRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ReturnLeaseRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ReturnLeaseRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ReturnLeaseRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ReturnLeaseRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ReturnLeaseRequest.header)
  return _internal_header();
}
inline void ReturnLeaseRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ReturnLeaseRequest.header)
}
inline ::bosdyn::api::RequestHeader* ReturnLeaseRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* ReturnLeaseRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ReturnLeaseRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ReturnLeaseRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* ReturnLeaseRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ReturnLeaseRequest.header)
  return _internal_mutable_header();
}
inline void ReturnLeaseRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ReturnLeaseRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool ReturnLeaseRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool ReturnLeaseRequest::has_lease() const {
  return _internal_has_lease();
}
inline void ReturnLeaseRequest::clear_lease() {
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
}
inline const ::bosdyn::api::Lease& ReturnLeaseRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& ReturnLeaseRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ReturnLeaseRequest.lease)
  return _internal_lease();
}
inline void ReturnLeaseRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ReturnLeaseRequest.lease)
}
inline ::bosdyn::api::Lease* ReturnLeaseRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* ReturnLeaseRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ReturnLeaseRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* ReturnLeaseRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* ReturnLeaseRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ReturnLeaseRequest.lease)
  return _internal_mutable_lease();
}
inline void ReturnLeaseRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_;
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease);
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ReturnLeaseRequest.lease)
}

// -------------------------------------------------------------------

// ReturnLeaseResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ReturnLeaseResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ReturnLeaseResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ReturnLeaseResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ReturnLeaseResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ReturnLeaseResponse.header)
  return _internal_header();
}
inline void ReturnLeaseResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ReturnLeaseResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ReturnLeaseResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ReturnLeaseResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ReturnLeaseResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ReturnLeaseResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* ReturnLeaseResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ReturnLeaseResponse.header)
  return _internal_mutable_header();
}
inline void ReturnLeaseResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ReturnLeaseResponse.header)
}

// .bosdyn.api.ReturnLeaseResponse.Status status = 2;
inline void ReturnLeaseResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::ReturnLeaseResponse_Status ReturnLeaseResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::ReturnLeaseResponse_Status >(status_);
}
inline ::bosdyn::api::ReturnLeaseResponse_Status ReturnLeaseResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ReturnLeaseResponse.status)
  return _internal_status();
}
inline void ReturnLeaseResponse::_internal_set_status(::bosdyn::api::ReturnLeaseResponse_Status value) {
  
  status_ = value;
}
inline void ReturnLeaseResponse::set_status(::bosdyn::api::ReturnLeaseResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ReturnLeaseResponse.status)
}

// -------------------------------------------------------------------

// ListLeasesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListLeasesRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListLeasesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListLeasesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListLeasesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListLeasesRequest.header)
  return _internal_header();
}
inline void ListLeasesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListLeasesRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListLeasesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListLeasesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListLeasesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListLeasesRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* ListLeasesRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListLeasesRequest.header)
  return _internal_mutable_header();
}
inline void ListLeasesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListLeasesRequest.header)
}

// -------------------------------------------------------------------

// LeaseResource

// string resource = 1;
inline void LeaseResource::clear_resource() {
  resource_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LeaseResource::resource() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseResource.resource)
  return _internal_resource();
}
inline void LeaseResource::set_resource(const std::string& value) {
  _internal_set_resource(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.LeaseResource.resource)
}
inline std::string* LeaseResource::mutable_resource() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.LeaseResource.resource)
  return _internal_mutable_resource();
}
inline const std::string& LeaseResource::_internal_resource() const {
  return resource_.Get();
}
inline void LeaseResource::_internal_set_resource(const std::string& value) {
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LeaseResource::set_resource(std::string&& value) {
  
  resource_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.LeaseResource.resource)
}
inline void LeaseResource::set_resource(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.LeaseResource.resource)
}
inline void LeaseResource::set_resource(const char* value,
    size_t size) {
  
  resource_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.LeaseResource.resource)
}
inline std::string* LeaseResource::_internal_mutable_resource() {
  
  return resource_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LeaseResource::release_resource() {
  // @@protoc_insertion_point(field_release:bosdyn.api.LeaseResource.resource)
  return resource_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LeaseResource::set_allocated_resource(std::string* resource) {
  if (resource != nullptr) {
    
  } else {
    
  }
  resource_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.LeaseResource.resource)
}

// .bosdyn.api.Lease lease = 2;
inline bool LeaseResource::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool LeaseResource::has_lease() const {
  return _internal_has_lease();
}
inline void LeaseResource::clear_lease() {
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
}
inline const ::bosdyn::api::Lease& LeaseResource::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& LeaseResource::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseResource.lease)
  return _internal_lease();
}
inline void LeaseResource::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.LeaseResource.lease)
}
inline ::bosdyn::api::Lease* LeaseResource::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* LeaseResource::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.LeaseResource.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* LeaseResource::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* LeaseResource::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.LeaseResource.lease)
  return _internal_mutable_lease();
}
inline void LeaseResource::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_;
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease);
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.LeaseResource.lease)
}

// .bosdyn.api.LeaseOwner lease_owner = 3;
inline bool LeaseResource::_internal_has_lease_owner() const {
  return this != internal_default_instance() && lease_owner_ != nullptr;
}
inline bool LeaseResource::has_lease_owner() const {
  return _internal_has_lease_owner();
}
inline void LeaseResource::clear_lease_owner() {
  if (GetArena() == nullptr && lease_owner_ != nullptr) {
    delete lease_owner_;
  }
  lease_owner_ = nullptr;
}
inline const ::bosdyn::api::LeaseOwner& LeaseResource::_internal_lease_owner() const {
  const ::bosdyn::api::LeaseOwner* p = lease_owner_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseOwner*>(
      &::bosdyn::api::_LeaseOwner_default_instance_);
}
inline const ::bosdyn::api::LeaseOwner& LeaseResource::lease_owner() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.LeaseResource.lease_owner)
  return _internal_lease_owner();
}
inline void LeaseResource::unsafe_arena_set_allocated_lease_owner(
    ::bosdyn::api::LeaseOwner* lease_owner) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_owner_);
  }
  lease_owner_ = lease_owner;
  if (lease_owner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.LeaseResource.lease_owner)
}
inline ::bosdyn::api::LeaseOwner* LeaseResource::release_lease_owner() {
  
  ::bosdyn::api::LeaseOwner* temp = lease_owner_;
  lease_owner_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseOwner* LeaseResource::unsafe_arena_release_lease_owner() {
  // @@protoc_insertion_point(field_release:bosdyn.api.LeaseResource.lease_owner)
  
  ::bosdyn::api::LeaseOwner* temp = lease_owner_;
  lease_owner_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseOwner* LeaseResource::_internal_mutable_lease_owner() {
  
  if (lease_owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseOwner>(GetArena());
    lease_owner_ = p;
  }
  return lease_owner_;
}
inline ::bosdyn::api::LeaseOwner* LeaseResource::mutable_lease_owner() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.LeaseResource.lease_owner)
  return _internal_mutable_lease_owner();
}
inline void LeaseResource::set_allocated_lease_owner(::bosdyn::api::LeaseOwner* lease_owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_owner_;
  }
  if (lease_owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease_owner);
    if (message_arena != submessage_arena) {
      lease_owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_owner, submessage_arena);
    }
    
  } else {
    
  }
  lease_owner_ = lease_owner;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.LeaseResource.lease_owner)
}

// -------------------------------------------------------------------

// ListLeasesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListLeasesResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListLeasesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListLeasesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListLeasesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListLeasesResponse.header)
  return _internal_header();
}
inline void ListLeasesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListLeasesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListLeasesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListLeasesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListLeasesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListLeasesResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* ListLeasesResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListLeasesResponse.header)
  return _internal_mutable_header();
}
inline void ListLeasesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListLeasesResponse.header)
}

// repeated .bosdyn.api.LeaseResource resources = 2;
inline int ListLeasesResponse::_internal_resources_size() const {
  return resources_.size();
}
inline int ListLeasesResponse::resources_size() const {
  return _internal_resources_size();
}
inline void ListLeasesResponse::clear_resources() {
  resources_.Clear();
}
inline ::bosdyn::api::LeaseResource* ListLeasesResponse::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListLeasesResponse.resources)
  return resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseResource >*
ListLeasesResponse::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListLeasesResponse.resources)
  return &resources_;
}
inline const ::bosdyn::api::LeaseResource& ListLeasesResponse::_internal_resources(int index) const {
  return resources_.Get(index);
}
inline const ::bosdyn::api::LeaseResource& ListLeasesResponse::resources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListLeasesResponse.resources)
  return _internal_resources(index);
}
inline ::bosdyn::api::LeaseResource* ListLeasesResponse::_internal_add_resources() {
  return resources_.Add();
}
inline ::bosdyn::api::LeaseResource* ListLeasesResponse::add_resources() {
  // @@protoc_insertion_point(field_add:bosdyn.api.ListLeasesResponse.resources)
  return _internal_add_resources();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseResource >&
ListLeasesResponse::resources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListLeasesResponse.resources)
  return resources_;
}

// -------------------------------------------------------------------

// RetainLeaseRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RetainLeaseRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RetainLeaseRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RetainLeaseRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RetainLeaseRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RetainLeaseRequest.header)
  return _internal_header();
}
inline void RetainLeaseRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RetainLeaseRequest.header)
}
inline ::bosdyn::api::RequestHeader* RetainLeaseRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RetainLeaseRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RetainLeaseRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RetainLeaseRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RetainLeaseRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RetainLeaseRequest.header)
  return _internal_mutable_header();
}
inline void RetainLeaseRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RetainLeaseRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool RetainLeaseRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool RetainLeaseRequest::has_lease() const {
  return _internal_has_lease();
}
inline void RetainLeaseRequest::clear_lease() {
  if (GetArena() == nullptr && lease_ != nullptr) {
    delete lease_;
  }
  lease_ = nullptr;
}
inline const ::bosdyn::api::Lease& RetainLeaseRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& RetainLeaseRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RetainLeaseRequest.lease)
  return _internal_lease();
}
inline void RetainLeaseRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RetainLeaseRequest.lease)
}
inline ::bosdyn::api::Lease* RetainLeaseRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* RetainLeaseRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RetainLeaseRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* RetainLeaseRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* RetainLeaseRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RetainLeaseRequest.lease)
  return _internal_mutable_lease();
}
inline void RetainLeaseRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_;
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease);
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RetainLeaseRequest.lease)
}

// -------------------------------------------------------------------

// RetainLeaseResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RetainLeaseResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RetainLeaseResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RetainLeaseResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RetainLeaseResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RetainLeaseResponse.header)
  return _internal_header();
}
inline void RetainLeaseResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RetainLeaseResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RetainLeaseResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RetainLeaseResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RetainLeaseResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RetainLeaseResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RetainLeaseResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RetainLeaseResponse.header)
  return _internal_mutable_header();
}
inline void RetainLeaseResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RetainLeaseResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool RetainLeaseResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool RetainLeaseResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline void RetainLeaseResponse::clear_lease_use_result() {
  if (GetArena() == nullptr && lease_use_result_ != nullptr) {
    delete lease_use_result_;
  }
  lease_use_result_ = nullptr;
}
inline const ::bosdyn::api::LeaseUseResult& RetainLeaseResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& RetainLeaseResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RetainLeaseResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void RetainLeaseResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RetainLeaseResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* RetainLeaseResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* RetainLeaseResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RetainLeaseResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* RetainLeaseResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* RetainLeaseResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RetainLeaseResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void RetainLeaseResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lease_use_result_;
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lease_use_result);
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RetainLeaseResponse.lease_use_result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::LeaseUseResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::LeaseUseResult_Status>() {
  return ::bosdyn::api::LeaseUseResult_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::AcquireLeaseResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::AcquireLeaseResponse_Status>() {
  return ::bosdyn::api::AcquireLeaseResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::TakeLeaseResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::TakeLeaseResponse_Status>() {
  return ::bosdyn::api::TakeLeaseResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ReturnLeaseResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ReturnLeaseResponse_Status>() {
  return ::bosdyn::api::ReturnLeaseResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2flease_2eproto
