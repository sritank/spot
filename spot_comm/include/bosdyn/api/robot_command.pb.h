// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/robot_command.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fcommand_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fcommand_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/full_body_command.pb.h"
#include "bosdyn/api/mobility_command.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2frobot_5fcommand_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto;
namespace bosdyn {
namespace api {
class ClearBehaviorFaultRequest;
class ClearBehaviorFaultRequestDefaultTypeInternal;
extern ClearBehaviorFaultRequestDefaultTypeInternal _ClearBehaviorFaultRequest_default_instance_;
class ClearBehaviorFaultResponse;
class ClearBehaviorFaultResponseDefaultTypeInternal;
extern ClearBehaviorFaultResponseDefaultTypeInternal _ClearBehaviorFaultResponse_default_instance_;
class RobotCommand;
class RobotCommandDefaultTypeInternal;
extern RobotCommandDefaultTypeInternal _RobotCommand_default_instance_;
class RobotCommandFeedback;
class RobotCommandFeedbackDefaultTypeInternal;
extern RobotCommandFeedbackDefaultTypeInternal _RobotCommandFeedback_default_instance_;
class RobotCommandFeedbackRequest;
class RobotCommandFeedbackRequestDefaultTypeInternal;
extern RobotCommandFeedbackRequestDefaultTypeInternal _RobotCommandFeedbackRequest_default_instance_;
class RobotCommandFeedbackResponse;
class RobotCommandFeedbackResponseDefaultTypeInternal;
extern RobotCommandFeedbackResponseDefaultTypeInternal _RobotCommandFeedbackResponse_default_instance_;
class RobotCommandRequest;
class RobotCommandRequestDefaultTypeInternal;
extern RobotCommandRequestDefaultTypeInternal _RobotCommandRequest_default_instance_;
class RobotCommandResponse;
class RobotCommandResponseDefaultTypeInternal;
extern RobotCommandResponseDefaultTypeInternal _RobotCommandResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::ClearBehaviorFaultRequest* Arena::CreateMaybeMessage<::bosdyn::api::ClearBehaviorFaultRequest>(Arena*);
template<> ::bosdyn::api::ClearBehaviorFaultResponse* Arena::CreateMaybeMessage<::bosdyn::api::ClearBehaviorFaultResponse>(Arena*);
template<> ::bosdyn::api::RobotCommand* Arena::CreateMaybeMessage<::bosdyn::api::RobotCommand>(Arena*);
template<> ::bosdyn::api::RobotCommandFeedback* Arena::CreateMaybeMessage<::bosdyn::api::RobotCommandFeedback>(Arena*);
template<> ::bosdyn::api::RobotCommandFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotCommandFeedbackRequest>(Arena*);
template<> ::bosdyn::api::RobotCommandFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotCommandFeedbackResponse>(Arena*);
template<> ::bosdyn::api::RobotCommandRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotCommandRequest>(Arena*);
template<> ::bosdyn::api::RobotCommandResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotCommandResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum RobotCommandResponse_Status : int {
  RobotCommandResponse_Status_STATUS_UNKNOWN = 0,
  RobotCommandResponse_Status_STATUS_OK = 1,
  RobotCommandResponse_Status_STATUS_INVALID_REQUEST = 2,
  RobotCommandResponse_Status_STATUS_UNSUPPORTED = 3,
  RobotCommandResponse_Status_STATUS_NO_TIMESYNC = 4,
  RobotCommandResponse_Status_STATUS_EXPIRED = 5,
  RobotCommandResponse_Status_STATUS_TOO_DISTANT = 6,
  RobotCommandResponse_Status_STATUS_NOT_POWERED_ON = 7,
  RobotCommandResponse_Status_STATUS_BEHAVIOR_FAULT = 9,
  RobotCommandResponse_Status_STATUS_UNKNOWN_FRAME = 8,
  RobotCommandResponse_Status_RobotCommandResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RobotCommandResponse_Status_RobotCommandResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RobotCommandResponse_Status_IsValid(int value);
constexpr RobotCommandResponse_Status RobotCommandResponse_Status_Status_MIN = RobotCommandResponse_Status_STATUS_UNKNOWN;
constexpr RobotCommandResponse_Status RobotCommandResponse_Status_Status_MAX = RobotCommandResponse_Status_STATUS_BEHAVIOR_FAULT;
constexpr int RobotCommandResponse_Status_Status_ARRAYSIZE = RobotCommandResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotCommandResponse_Status_descriptor();
template<typename T>
inline const std::string& RobotCommandResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotCommandResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotCommandResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotCommandResponse_Status_descriptor(), enum_t_value);
}
inline bool RobotCommandResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotCommandResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotCommandResponse_Status>(
    RobotCommandResponse_Status_descriptor(), name, value);
}
enum RobotCommandFeedbackResponse_Status : int {
  RobotCommandFeedbackResponse_Status_STATUS_UNKNOWN = 0,
  RobotCommandFeedbackResponse_Status_STATUS_PROCESSING = 1,
  RobotCommandFeedbackResponse_Status_STATUS_COMMAND_OVERRIDDEN = 2,
  RobotCommandFeedbackResponse_Status_STATUS_COMMAND_TIMED_OUT = 3,
  RobotCommandFeedbackResponse_Status_STATUS_ROBOT_FROZEN = 4,
  RobotCommandFeedbackResponse_Status_RobotCommandFeedbackResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RobotCommandFeedbackResponse_Status_RobotCommandFeedbackResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RobotCommandFeedbackResponse_Status_IsValid(int value);
constexpr RobotCommandFeedbackResponse_Status RobotCommandFeedbackResponse_Status_Status_MIN = RobotCommandFeedbackResponse_Status_STATUS_UNKNOWN;
constexpr RobotCommandFeedbackResponse_Status RobotCommandFeedbackResponse_Status_Status_MAX = RobotCommandFeedbackResponse_Status_STATUS_ROBOT_FROZEN;
constexpr int RobotCommandFeedbackResponse_Status_Status_ARRAYSIZE = RobotCommandFeedbackResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotCommandFeedbackResponse_Status_descriptor();
template<typename T>
inline const std::string& RobotCommandFeedbackResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotCommandFeedbackResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotCommandFeedbackResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotCommandFeedbackResponse_Status_descriptor(), enum_t_value);
}
inline bool RobotCommandFeedbackResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotCommandFeedbackResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotCommandFeedbackResponse_Status>(
    RobotCommandFeedbackResponse_Status_descriptor(), name, value);
}
enum ClearBehaviorFaultResponse_Status : int {
  ClearBehaviorFaultResponse_Status_STATUS_UNKNOWN = 0,
  ClearBehaviorFaultResponse_Status_STATUS_CLEARED = 1,
  ClearBehaviorFaultResponse_Status_STATUS_NOT_CLEARED = 2,
  ClearBehaviorFaultResponse_Status_ClearBehaviorFaultResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClearBehaviorFaultResponse_Status_ClearBehaviorFaultResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClearBehaviorFaultResponse_Status_IsValid(int value);
constexpr ClearBehaviorFaultResponse_Status ClearBehaviorFaultResponse_Status_Status_MIN = ClearBehaviorFaultResponse_Status_STATUS_UNKNOWN;
constexpr ClearBehaviorFaultResponse_Status ClearBehaviorFaultResponse_Status_Status_MAX = ClearBehaviorFaultResponse_Status_STATUS_NOT_CLEARED;
constexpr int ClearBehaviorFaultResponse_Status_Status_ARRAYSIZE = ClearBehaviorFaultResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClearBehaviorFaultResponse_Status_descriptor();
template<typename T>
inline const std::string& ClearBehaviorFaultResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClearBehaviorFaultResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClearBehaviorFaultResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClearBehaviorFaultResponse_Status_descriptor(), enum_t_value);
}
inline bool ClearBehaviorFaultResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClearBehaviorFaultResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClearBehaviorFaultResponse_Status>(
    ClearBehaviorFaultResponse_Status_descriptor(), name, value);
}
// ===================================================================

class RobotCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotCommand) */ {
 public:
  inline RobotCommand() : RobotCommand(nullptr) {}
  virtual ~RobotCommand();

  RobotCommand(const RobotCommand& from);
  RobotCommand(RobotCommand&& from) noexcept
    : RobotCommand() {
    *this = ::std::move(from);
  }

  inline RobotCommand& operator=(const RobotCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommand& operator=(RobotCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotCommand* internal_default_instance() {
    return reinterpret_cast<const RobotCommand*>(
               &_RobotCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RobotCommand& a, RobotCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommand* New() const final {
    return CreateMaybeMessage<RobotCommand>(nullptr);
  }

  RobotCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotCommand& from);
  void MergeFrom(const RobotCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotCommand";
  }
  protected:
  explicit RobotCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullBodyCommandFieldNumber = 1,
    kMobilityCommandFieldNumber = 2,
  };
  // .bosdyn.api.FullBodyCommand.Request full_body_command = 1;
  bool has_full_body_command() const;
  private:
  bool _internal_has_full_body_command() const;
  public:
  void clear_full_body_command();
  const ::bosdyn::api::FullBodyCommand_Request& full_body_command() const;
  ::bosdyn::api::FullBodyCommand_Request* release_full_body_command();
  ::bosdyn::api::FullBodyCommand_Request* mutable_full_body_command();
  void set_allocated_full_body_command(::bosdyn::api::FullBodyCommand_Request* full_body_command);
  private:
  const ::bosdyn::api::FullBodyCommand_Request& _internal_full_body_command() const;
  ::bosdyn::api::FullBodyCommand_Request* _internal_mutable_full_body_command();
  public:
  void unsafe_arena_set_allocated_full_body_command(
      ::bosdyn::api::FullBodyCommand_Request* full_body_command);
  ::bosdyn::api::FullBodyCommand_Request* unsafe_arena_release_full_body_command();

  // .bosdyn.api.MobilityCommand.Request mobility_command = 2;
  bool has_mobility_command() const;
  private:
  bool _internal_has_mobility_command() const;
  public:
  void clear_mobility_command();
  const ::bosdyn::api::MobilityCommand_Request& mobility_command() const;
  ::bosdyn::api::MobilityCommand_Request* release_mobility_command();
  ::bosdyn::api::MobilityCommand_Request* mutable_mobility_command();
  void set_allocated_mobility_command(::bosdyn::api::MobilityCommand_Request* mobility_command);
  private:
  const ::bosdyn::api::MobilityCommand_Request& _internal_mobility_command() const;
  ::bosdyn::api::MobilityCommand_Request* _internal_mutable_mobility_command();
  public:
  void unsafe_arena_set_allocated_mobility_command(
      ::bosdyn::api::MobilityCommand_Request* mobility_command);
  ::bosdyn::api::MobilityCommand_Request* unsafe_arena_release_mobility_command();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::FullBodyCommand_Request* full_body_command_;
  ::bosdyn::api::MobilityCommand_Request* mobility_command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class RobotCommandFeedback PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotCommandFeedback) */ {
 public:
  inline RobotCommandFeedback() : RobotCommandFeedback(nullptr) {}
  virtual ~RobotCommandFeedback();

  RobotCommandFeedback(const RobotCommandFeedback& from);
  RobotCommandFeedback(RobotCommandFeedback&& from) noexcept
    : RobotCommandFeedback() {
    *this = ::std::move(from);
  }

  inline RobotCommandFeedback& operator=(const RobotCommandFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommandFeedback& operator=(RobotCommandFeedback&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotCommandFeedback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotCommandFeedback* internal_default_instance() {
    return reinterpret_cast<const RobotCommandFeedback*>(
               &_RobotCommandFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RobotCommandFeedback& a, RobotCommandFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommandFeedback* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommandFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommandFeedback* New() const final {
    return CreateMaybeMessage<RobotCommandFeedback>(nullptr);
  }

  RobotCommandFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommandFeedback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotCommandFeedback& from);
  void MergeFrom(const RobotCommandFeedback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommandFeedback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotCommandFeedback";
  }
  protected:
  explicit RobotCommandFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMobilityFeedbackFieldNumber = 1,
    kFullBodyFeedbackFieldNumber = 2,
  };
  // .bosdyn.api.MobilityCommand.Feedback mobility_feedback = 1;
  bool has_mobility_feedback() const;
  private:
  bool _internal_has_mobility_feedback() const;
  public:
  void clear_mobility_feedback();
  const ::bosdyn::api::MobilityCommand_Feedback& mobility_feedback() const;
  ::bosdyn::api::MobilityCommand_Feedback* release_mobility_feedback();
  ::bosdyn::api::MobilityCommand_Feedback* mutable_mobility_feedback();
  void set_allocated_mobility_feedback(::bosdyn::api::MobilityCommand_Feedback* mobility_feedback);
  private:
  const ::bosdyn::api::MobilityCommand_Feedback& _internal_mobility_feedback() const;
  ::bosdyn::api::MobilityCommand_Feedback* _internal_mutable_mobility_feedback();
  public:
  void unsafe_arena_set_allocated_mobility_feedback(
      ::bosdyn::api::MobilityCommand_Feedback* mobility_feedback);
  ::bosdyn::api::MobilityCommand_Feedback* unsafe_arena_release_mobility_feedback();

  // .bosdyn.api.FullBodyCommand.Feedback full_body_feedback = 2;
  bool has_full_body_feedback() const;
  private:
  bool _internal_has_full_body_feedback() const;
  public:
  void clear_full_body_feedback();
  const ::bosdyn::api::FullBodyCommand_Feedback& full_body_feedback() const;
  ::bosdyn::api::FullBodyCommand_Feedback* release_full_body_feedback();
  ::bosdyn::api::FullBodyCommand_Feedback* mutable_full_body_feedback();
  void set_allocated_full_body_feedback(::bosdyn::api::FullBodyCommand_Feedback* full_body_feedback);
  private:
  const ::bosdyn::api::FullBodyCommand_Feedback& _internal_full_body_feedback() const;
  ::bosdyn::api::FullBodyCommand_Feedback* _internal_mutable_full_body_feedback();
  public:
  void unsafe_arena_set_allocated_full_body_feedback(
      ::bosdyn::api::FullBodyCommand_Feedback* full_body_feedback);
  ::bosdyn::api::FullBodyCommand_Feedback* unsafe_arena_release_full_body_feedback();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotCommandFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::MobilityCommand_Feedback* mobility_feedback_;
  ::bosdyn::api::FullBodyCommand_Feedback* full_body_feedback_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class RobotCommandRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotCommandRequest) */ {
 public:
  inline RobotCommandRequest() : RobotCommandRequest(nullptr) {}
  virtual ~RobotCommandRequest();

  RobotCommandRequest(const RobotCommandRequest& from);
  RobotCommandRequest(RobotCommandRequest&& from) noexcept
    : RobotCommandRequest() {
    *this = ::std::move(from);
  }

  inline RobotCommandRequest& operator=(const RobotCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommandRequest& operator=(RobotCommandRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotCommandRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotCommandRequest* internal_default_instance() {
    return reinterpret_cast<const RobotCommandRequest*>(
               &_RobotCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RobotCommandRequest& a, RobotCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommandRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommandRequest* New() const final {
    return CreateMaybeMessage<RobotCommandRequest>(nullptr);
  }

  RobotCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommandRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotCommandRequest& from);
  void MergeFrom(const RobotCommandRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommandRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotCommandRequest";
  }
  protected:
  explicit RobotCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClockIdentifierFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // string clock_identifier = 4;
  void clear_clock_identifier();
  const std::string& clock_identifier() const;
  void set_clock_identifier(const std::string& value);
  void set_clock_identifier(std::string&& value);
  void set_clock_identifier(const char* value);
  void set_clock_identifier(const char* value, size_t size);
  std::string* mutable_clock_identifier();
  std::string* release_clock_identifier();
  void set_allocated_clock_identifier(std::string* clock_identifier);
  private:
  const std::string& _internal_clock_identifier() const;
  void _internal_set_clock_identifier(const std::string& value);
  std::string* _internal_mutable_clock_identifier();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.RobotCommand command = 3;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::bosdyn::api::RobotCommand& command() const;
  ::bosdyn::api::RobotCommand* release_command();
  ::bosdyn::api::RobotCommand* mutable_command();
  void set_allocated_command(::bosdyn::api::RobotCommand* command);
  private:
  const ::bosdyn::api::RobotCommand& _internal_command() const;
  ::bosdyn::api::RobotCommand* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::bosdyn::api::RobotCommand* command);
  ::bosdyn::api::RobotCommand* unsafe_arena_release_command();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clock_identifier_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  ::bosdyn::api::RobotCommand* command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class RobotCommandResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotCommandResponse) */ {
 public:
  inline RobotCommandResponse() : RobotCommandResponse(nullptr) {}
  virtual ~RobotCommandResponse();

  RobotCommandResponse(const RobotCommandResponse& from);
  RobotCommandResponse(RobotCommandResponse&& from) noexcept
    : RobotCommandResponse() {
    *this = ::std::move(from);
  }

  inline RobotCommandResponse& operator=(const RobotCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommandResponse& operator=(RobotCommandResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotCommandResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotCommandResponse* internal_default_instance() {
    return reinterpret_cast<const RobotCommandResponse*>(
               &_RobotCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RobotCommandResponse& a, RobotCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommandResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommandResponse* New() const final {
    return CreateMaybeMessage<RobotCommandResponse>(nullptr);
  }

  RobotCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommandResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotCommandResponse& from);
  void MergeFrom(const RobotCommandResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommandResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotCommandResponse";
  }
  protected:
  explicit RobotCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RobotCommandResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    RobotCommandResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    RobotCommandResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_REQUEST =
    RobotCommandResponse_Status_STATUS_INVALID_REQUEST;
  static constexpr Status STATUS_UNSUPPORTED =
    RobotCommandResponse_Status_STATUS_UNSUPPORTED;
  static constexpr Status STATUS_NO_TIMESYNC =
    RobotCommandResponse_Status_STATUS_NO_TIMESYNC;
  static constexpr Status STATUS_EXPIRED =
    RobotCommandResponse_Status_STATUS_EXPIRED;
  static constexpr Status STATUS_TOO_DISTANT =
    RobotCommandResponse_Status_STATUS_TOO_DISTANT;
  static constexpr Status STATUS_NOT_POWERED_ON =
    RobotCommandResponse_Status_STATUS_NOT_POWERED_ON;
  static constexpr Status STATUS_BEHAVIOR_FAULT =
    RobotCommandResponse_Status_STATUS_BEHAVIOR_FAULT;
  static constexpr Status STATUS_UNKNOWN_FRAME =
    RobotCommandResponse_Status_STATUS_UNKNOWN_FRAME;
  static inline bool Status_IsValid(int value) {
    return RobotCommandResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    RobotCommandResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    RobotCommandResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    RobotCommandResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return RobotCommandResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return RobotCommandResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return RobotCommandResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kStatusFieldNumber = 3,
    kRobotCommandIdFieldNumber = 5,
  };
  // string message = 4;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.RobotCommandResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::RobotCommandResponse_Status status() const;
  void set_status(::bosdyn::api::RobotCommandResponse_Status value);
  private:
  ::bosdyn::api::RobotCommandResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::RobotCommandResponse_Status value);
  public:

  // uint32 robot_command_id = 5;
  void clear_robot_command_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 robot_command_id() const;
  void set_robot_command_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_robot_command_id() const;
  void _internal_set_robot_command_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 robot_command_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class RobotCommandFeedbackRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotCommandFeedbackRequest) */ {
 public:
  inline RobotCommandFeedbackRequest() : RobotCommandFeedbackRequest(nullptr) {}
  virtual ~RobotCommandFeedbackRequest();

  RobotCommandFeedbackRequest(const RobotCommandFeedbackRequest& from);
  RobotCommandFeedbackRequest(RobotCommandFeedbackRequest&& from) noexcept
    : RobotCommandFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline RobotCommandFeedbackRequest& operator=(const RobotCommandFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommandFeedbackRequest& operator=(RobotCommandFeedbackRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotCommandFeedbackRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotCommandFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const RobotCommandFeedbackRequest*>(
               &_RobotCommandFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RobotCommandFeedbackRequest& a, RobotCommandFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommandFeedbackRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommandFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommandFeedbackRequest* New() const final {
    return CreateMaybeMessage<RobotCommandFeedbackRequest>(nullptr);
  }

  RobotCommandFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommandFeedbackRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotCommandFeedbackRequest& from);
  void MergeFrom(const RobotCommandFeedbackRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommandFeedbackRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotCommandFeedbackRequest";
  }
  protected:
  explicit RobotCommandFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRobotCommandIdFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // uint32 robot_command_id = 2;
  void clear_robot_command_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 robot_command_id() const;
  void set_robot_command_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_robot_command_id() const;
  void _internal_set_robot_command_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotCommandFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::uint32 robot_command_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class RobotCommandFeedbackResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotCommandFeedbackResponse) */ {
 public:
  inline RobotCommandFeedbackResponse() : RobotCommandFeedbackResponse(nullptr) {}
  virtual ~RobotCommandFeedbackResponse();

  RobotCommandFeedbackResponse(const RobotCommandFeedbackResponse& from);
  RobotCommandFeedbackResponse(RobotCommandFeedbackResponse&& from) noexcept
    : RobotCommandFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline RobotCommandFeedbackResponse& operator=(const RobotCommandFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommandFeedbackResponse& operator=(RobotCommandFeedbackResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotCommandFeedbackResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotCommandFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const RobotCommandFeedbackResponse*>(
               &_RobotCommandFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RobotCommandFeedbackResponse& a, RobotCommandFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommandFeedbackResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommandFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotCommandFeedbackResponse* New() const final {
    return CreateMaybeMessage<RobotCommandFeedbackResponse>(nullptr);
  }

  RobotCommandFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotCommandFeedbackResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotCommandFeedbackResponse& from);
  void MergeFrom(const RobotCommandFeedbackResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommandFeedbackResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotCommandFeedbackResponse";
  }
  protected:
  explicit RobotCommandFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RobotCommandFeedbackResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    RobotCommandFeedbackResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_PROCESSING =
    RobotCommandFeedbackResponse_Status_STATUS_PROCESSING;
  static constexpr Status STATUS_COMMAND_OVERRIDDEN =
    RobotCommandFeedbackResponse_Status_STATUS_COMMAND_OVERRIDDEN;
  static constexpr Status STATUS_COMMAND_TIMED_OUT =
    RobotCommandFeedbackResponse_Status_STATUS_COMMAND_TIMED_OUT;
  static constexpr Status STATUS_ROBOT_FROZEN =
    RobotCommandFeedbackResponse_Status_STATUS_ROBOT_FROZEN;
  static inline bool Status_IsValid(int value) {
    return RobotCommandFeedbackResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    RobotCommandFeedbackResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    RobotCommandFeedbackResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    RobotCommandFeedbackResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return RobotCommandFeedbackResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return RobotCommandFeedbackResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return RobotCommandFeedbackResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kFeedbackFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RobotCommandFeedback feedback = 4;
  bool has_feedback() const;
  private:
  bool _internal_has_feedback() const;
  public:
  void clear_feedback();
  const ::bosdyn::api::RobotCommandFeedback& feedback() const;
  ::bosdyn::api::RobotCommandFeedback* release_feedback();
  ::bosdyn::api::RobotCommandFeedback* mutable_feedback();
  void set_allocated_feedback(::bosdyn::api::RobotCommandFeedback* feedback);
  private:
  const ::bosdyn::api::RobotCommandFeedback& _internal_feedback() const;
  ::bosdyn::api::RobotCommandFeedback* _internal_mutable_feedback();
  public:
  void unsafe_arena_set_allocated_feedback(
      ::bosdyn::api::RobotCommandFeedback* feedback);
  ::bosdyn::api::RobotCommandFeedback* unsafe_arena_release_feedback();

  // .bosdyn.api.RobotCommandFeedbackResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::RobotCommandFeedbackResponse_Status status() const;
  void set_status(::bosdyn::api::RobotCommandFeedbackResponse_Status value);
  private:
  ::bosdyn::api::RobotCommandFeedbackResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::RobotCommandFeedbackResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotCommandFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::RobotCommandFeedback* feedback_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ClearBehaviorFaultRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ClearBehaviorFaultRequest) */ {
 public:
  inline ClearBehaviorFaultRequest() : ClearBehaviorFaultRequest(nullptr) {}
  virtual ~ClearBehaviorFaultRequest();

  ClearBehaviorFaultRequest(const ClearBehaviorFaultRequest& from);
  ClearBehaviorFaultRequest(ClearBehaviorFaultRequest&& from) noexcept
    : ClearBehaviorFaultRequest() {
    *this = ::std::move(from);
  }

  inline ClearBehaviorFaultRequest& operator=(const ClearBehaviorFaultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearBehaviorFaultRequest& operator=(ClearBehaviorFaultRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClearBehaviorFaultRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearBehaviorFaultRequest* internal_default_instance() {
    return reinterpret_cast<const ClearBehaviorFaultRequest*>(
               &_ClearBehaviorFaultRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClearBehaviorFaultRequest& a, ClearBehaviorFaultRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearBehaviorFaultRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearBehaviorFaultRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClearBehaviorFaultRequest* New() const final {
    return CreateMaybeMessage<ClearBehaviorFaultRequest>(nullptr);
  }

  ClearBehaviorFaultRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClearBehaviorFaultRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClearBehaviorFaultRequest& from);
  void MergeFrom(const ClearBehaviorFaultRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearBehaviorFaultRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ClearBehaviorFaultRequest";
  }
  protected:
  explicit ClearBehaviorFaultRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kBehaviorFaultIdFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // uint32 behavior_fault_id = 3;
  void clear_behavior_fault_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 behavior_fault_id() const;
  void set_behavior_fault_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_behavior_fault_id() const;
  void _internal_set_behavior_fault_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ClearBehaviorFaultRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  ::PROTOBUF_NAMESPACE_ID::uint32 behavior_fault_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto;
};
// -------------------------------------------------------------------

class ClearBehaviorFaultResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ClearBehaviorFaultResponse) */ {
 public:
  inline ClearBehaviorFaultResponse() : ClearBehaviorFaultResponse(nullptr) {}
  virtual ~ClearBehaviorFaultResponse();

  ClearBehaviorFaultResponse(const ClearBehaviorFaultResponse& from);
  ClearBehaviorFaultResponse(ClearBehaviorFaultResponse&& from) noexcept
    : ClearBehaviorFaultResponse() {
    *this = ::std::move(from);
  }

  inline ClearBehaviorFaultResponse& operator=(const ClearBehaviorFaultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearBehaviorFaultResponse& operator=(ClearBehaviorFaultResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClearBehaviorFaultResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClearBehaviorFaultResponse* internal_default_instance() {
    return reinterpret_cast<const ClearBehaviorFaultResponse*>(
               &_ClearBehaviorFaultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClearBehaviorFaultResponse& a, ClearBehaviorFaultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearBehaviorFaultResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearBehaviorFaultResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClearBehaviorFaultResponse* New() const final {
    return CreateMaybeMessage<ClearBehaviorFaultResponse>(nullptr);
  }

  ClearBehaviorFaultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClearBehaviorFaultResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClearBehaviorFaultResponse& from);
  void MergeFrom(const ClearBehaviorFaultResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearBehaviorFaultResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ClearBehaviorFaultResponse";
  }
  protected:
  explicit ClearBehaviorFaultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fcommand_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ClearBehaviorFaultResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ClearBehaviorFaultResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_CLEARED =
    ClearBehaviorFaultResponse_Status_STATUS_CLEARED;
  static constexpr Status STATUS_NOT_CLEARED =
    ClearBehaviorFaultResponse_Status_STATUS_NOT_CLEARED;
  static inline bool Status_IsValid(int value) {
    return ClearBehaviorFaultResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ClearBehaviorFaultResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ClearBehaviorFaultResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ClearBehaviorFaultResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ClearBehaviorFaultResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ClearBehaviorFaultResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ClearBehaviorFaultResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.ClearBehaviorFaultResponse.Status status = 3;
  void clear_status();
  ::bosdyn::api::ClearBehaviorFaultResponse_Status status() const;
  void set_status(::bosdyn::api::ClearBehaviorFaultResponse_Status value);
  private:
  ::bosdyn::api::ClearBehaviorFaultResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::ClearBehaviorFaultResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ClearBehaviorFaultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fcommand_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotCommand

// .bosdyn.api.FullBodyCommand.Request full_body_command = 1;
inline bool RobotCommand::_internal_has_full_body_command() const {
  return this != internal_default_instance() && full_body_command_ != nullptr;
}
inline bool RobotCommand::has_full_body_command() const {
  return _internal_has_full_body_command();
}
inline const ::bosdyn::api::FullBodyCommand_Request& RobotCommand::_internal_full_body_command() const {
  const ::bosdyn::api::FullBodyCommand_Request* p = full_body_command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::FullBodyCommand_Request*>(
      &::bosdyn::api::_FullBodyCommand_Request_default_instance_);
}
inline const ::bosdyn::api::FullBodyCommand_Request& RobotCommand::full_body_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommand.full_body_command)
  return _internal_full_body_command();
}
inline void RobotCommand::unsafe_arena_set_allocated_full_body_command(
    ::bosdyn::api::FullBodyCommand_Request* full_body_command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_body_command_);
  }
  full_body_command_ = full_body_command;
  if (full_body_command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommand.full_body_command)
}
inline ::bosdyn::api::FullBodyCommand_Request* RobotCommand::release_full_body_command() {
  
  ::bosdyn::api::FullBodyCommand_Request* temp = full_body_command_;
  full_body_command_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::FullBodyCommand_Request* RobotCommand::unsafe_arena_release_full_body_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommand.full_body_command)
  
  ::bosdyn::api::FullBodyCommand_Request* temp = full_body_command_;
  full_body_command_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FullBodyCommand_Request* RobotCommand::_internal_mutable_full_body_command() {
  
  if (full_body_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FullBodyCommand_Request>(GetArena());
    full_body_command_ = p;
  }
  return full_body_command_;
}
inline ::bosdyn::api::FullBodyCommand_Request* RobotCommand::mutable_full_body_command() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommand.full_body_command)
  return _internal_mutable_full_body_command();
}
inline void RobotCommand::set_allocated_full_body_command(::bosdyn::api::FullBodyCommand_Request* full_body_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_body_command_);
  }
  if (full_body_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_body_command)->GetArena();
    if (message_arena != submessage_arena) {
      full_body_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_body_command, submessage_arena);
    }
    
  } else {
    
  }
  full_body_command_ = full_body_command;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommand.full_body_command)
}

// .bosdyn.api.MobilityCommand.Request mobility_command = 2;
inline bool RobotCommand::_internal_has_mobility_command() const {
  return this != internal_default_instance() && mobility_command_ != nullptr;
}
inline bool RobotCommand::has_mobility_command() const {
  return _internal_has_mobility_command();
}
inline const ::bosdyn::api::MobilityCommand_Request& RobotCommand::_internal_mobility_command() const {
  const ::bosdyn::api::MobilityCommand_Request* p = mobility_command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::MobilityCommand_Request*>(
      &::bosdyn::api::_MobilityCommand_Request_default_instance_);
}
inline const ::bosdyn::api::MobilityCommand_Request& RobotCommand::mobility_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommand.mobility_command)
  return _internal_mobility_command();
}
inline void RobotCommand::unsafe_arena_set_allocated_mobility_command(
    ::bosdyn::api::MobilityCommand_Request* mobility_command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mobility_command_);
  }
  mobility_command_ = mobility_command;
  if (mobility_command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommand.mobility_command)
}
inline ::bosdyn::api::MobilityCommand_Request* RobotCommand::release_mobility_command() {
  
  ::bosdyn::api::MobilityCommand_Request* temp = mobility_command_;
  mobility_command_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::MobilityCommand_Request* RobotCommand::unsafe_arena_release_mobility_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommand.mobility_command)
  
  ::bosdyn::api::MobilityCommand_Request* temp = mobility_command_;
  mobility_command_ = nullptr;
  return temp;
}
inline ::bosdyn::api::MobilityCommand_Request* RobotCommand::_internal_mutable_mobility_command() {
  
  if (mobility_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::MobilityCommand_Request>(GetArena());
    mobility_command_ = p;
  }
  return mobility_command_;
}
inline ::bosdyn::api::MobilityCommand_Request* RobotCommand::mutable_mobility_command() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommand.mobility_command)
  return _internal_mutable_mobility_command();
}
inline void RobotCommand::set_allocated_mobility_command(::bosdyn::api::MobilityCommand_Request* mobility_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mobility_command_);
  }
  if (mobility_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mobility_command)->GetArena();
    if (message_arena != submessage_arena) {
      mobility_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mobility_command, submessage_arena);
    }
    
  } else {
    
  }
  mobility_command_ = mobility_command;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommand.mobility_command)
}

// -------------------------------------------------------------------

// RobotCommandFeedback

// .bosdyn.api.FullBodyCommand.Feedback full_body_feedback = 2;
inline bool RobotCommandFeedback::_internal_has_full_body_feedback() const {
  return this != internal_default_instance() && full_body_feedback_ != nullptr;
}
inline bool RobotCommandFeedback::has_full_body_feedback() const {
  return _internal_has_full_body_feedback();
}
inline const ::bosdyn::api::FullBodyCommand_Feedback& RobotCommandFeedback::_internal_full_body_feedback() const {
  const ::bosdyn::api::FullBodyCommand_Feedback* p = full_body_feedback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::FullBodyCommand_Feedback*>(
      &::bosdyn::api::_FullBodyCommand_Feedback_default_instance_);
}
inline const ::bosdyn::api::FullBodyCommand_Feedback& RobotCommandFeedback::full_body_feedback() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandFeedback.full_body_feedback)
  return _internal_full_body_feedback();
}
inline void RobotCommandFeedback::unsafe_arena_set_allocated_full_body_feedback(
    ::bosdyn::api::FullBodyCommand_Feedback* full_body_feedback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_body_feedback_);
  }
  full_body_feedback_ = full_body_feedback;
  if (full_body_feedback) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandFeedback.full_body_feedback)
}
inline ::bosdyn::api::FullBodyCommand_Feedback* RobotCommandFeedback::release_full_body_feedback() {
  
  ::bosdyn::api::FullBodyCommand_Feedback* temp = full_body_feedback_;
  full_body_feedback_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::FullBodyCommand_Feedback* RobotCommandFeedback::unsafe_arena_release_full_body_feedback() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandFeedback.full_body_feedback)
  
  ::bosdyn::api::FullBodyCommand_Feedback* temp = full_body_feedback_;
  full_body_feedback_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FullBodyCommand_Feedback* RobotCommandFeedback::_internal_mutable_full_body_feedback() {
  
  if (full_body_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FullBodyCommand_Feedback>(GetArena());
    full_body_feedback_ = p;
  }
  return full_body_feedback_;
}
inline ::bosdyn::api::FullBodyCommand_Feedback* RobotCommandFeedback::mutable_full_body_feedback() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandFeedback.full_body_feedback)
  return _internal_mutable_full_body_feedback();
}
inline void RobotCommandFeedback::set_allocated_full_body_feedback(::bosdyn::api::FullBodyCommand_Feedback* full_body_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_body_feedback_);
  }
  if (full_body_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_body_feedback)->GetArena();
    if (message_arena != submessage_arena) {
      full_body_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_body_feedback, submessage_arena);
    }
    
  } else {
    
  }
  full_body_feedback_ = full_body_feedback;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandFeedback.full_body_feedback)
}

// .bosdyn.api.MobilityCommand.Feedback mobility_feedback = 1;
inline bool RobotCommandFeedback::_internal_has_mobility_feedback() const {
  return this != internal_default_instance() && mobility_feedback_ != nullptr;
}
inline bool RobotCommandFeedback::has_mobility_feedback() const {
  return _internal_has_mobility_feedback();
}
inline const ::bosdyn::api::MobilityCommand_Feedback& RobotCommandFeedback::_internal_mobility_feedback() const {
  const ::bosdyn::api::MobilityCommand_Feedback* p = mobility_feedback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::MobilityCommand_Feedback*>(
      &::bosdyn::api::_MobilityCommand_Feedback_default_instance_);
}
inline const ::bosdyn::api::MobilityCommand_Feedback& RobotCommandFeedback::mobility_feedback() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandFeedback.mobility_feedback)
  return _internal_mobility_feedback();
}
inline void RobotCommandFeedback::unsafe_arena_set_allocated_mobility_feedback(
    ::bosdyn::api::MobilityCommand_Feedback* mobility_feedback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mobility_feedback_);
  }
  mobility_feedback_ = mobility_feedback;
  if (mobility_feedback) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandFeedback.mobility_feedback)
}
inline ::bosdyn::api::MobilityCommand_Feedback* RobotCommandFeedback::release_mobility_feedback() {
  
  ::bosdyn::api::MobilityCommand_Feedback* temp = mobility_feedback_;
  mobility_feedback_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::MobilityCommand_Feedback* RobotCommandFeedback::unsafe_arena_release_mobility_feedback() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandFeedback.mobility_feedback)
  
  ::bosdyn::api::MobilityCommand_Feedback* temp = mobility_feedback_;
  mobility_feedback_ = nullptr;
  return temp;
}
inline ::bosdyn::api::MobilityCommand_Feedback* RobotCommandFeedback::_internal_mutable_mobility_feedback() {
  
  if (mobility_feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::MobilityCommand_Feedback>(GetArena());
    mobility_feedback_ = p;
  }
  return mobility_feedback_;
}
inline ::bosdyn::api::MobilityCommand_Feedback* RobotCommandFeedback::mutable_mobility_feedback() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandFeedback.mobility_feedback)
  return _internal_mutable_mobility_feedback();
}
inline void RobotCommandFeedback::set_allocated_mobility_feedback(::bosdyn::api::MobilityCommand_Feedback* mobility_feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mobility_feedback_);
  }
  if (mobility_feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mobility_feedback)->GetArena();
    if (message_arena != submessage_arena) {
      mobility_feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mobility_feedback, submessage_arena);
    }
    
  } else {
    
  }
  mobility_feedback_ = mobility_feedback;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandFeedback.mobility_feedback)
}

// -------------------------------------------------------------------

// RobotCommandRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotCommandRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandRequest.header)
  return _internal_header();
}
inline void RobotCommandRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotCommandRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotCommandRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RobotCommandRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandRequest.header)
  return _internal_mutable_header();
}
inline void RobotCommandRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool RobotCommandRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool RobotCommandRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& RobotCommandRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& RobotCommandRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandRequest.lease)
  return _internal_lease();
}
inline void RobotCommandRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandRequest.lease)
}
inline ::bosdyn::api::Lease* RobotCommandRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* RobotCommandRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* RobotCommandRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* RobotCommandRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandRequest.lease)
  return _internal_mutable_lease();
}
inline void RobotCommandRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandRequest.lease)
}

// .bosdyn.api.RobotCommand command = 3;
inline bool RobotCommandRequest::_internal_has_command() const {
  return this != internal_default_instance() && command_ != nullptr;
}
inline bool RobotCommandRequest::has_command() const {
  return _internal_has_command();
}
inline void RobotCommandRequest::clear_command() {
  if (GetArena() == nullptr && command_ != nullptr) {
    delete command_;
  }
  command_ = nullptr;
}
inline const ::bosdyn::api::RobotCommand& RobotCommandRequest::_internal_command() const {
  const ::bosdyn::api::RobotCommand* p = command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RobotCommand*>(
      &::bosdyn::api::_RobotCommand_default_instance_);
}
inline const ::bosdyn::api::RobotCommand& RobotCommandRequest::command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandRequest.command)
  return _internal_command();
}
inline void RobotCommandRequest::unsafe_arena_set_allocated_command(
    ::bosdyn::api::RobotCommand* command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandRequest.command)
}
inline ::bosdyn::api::RobotCommand* RobotCommandRequest::release_command() {
  
  ::bosdyn::api::RobotCommand* temp = command_;
  command_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RobotCommand* RobotCommandRequest::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandRequest.command)
  
  ::bosdyn::api::RobotCommand* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotCommand* RobotCommandRequest::_internal_mutable_command() {
  
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotCommand>(GetArena());
    command_ = p;
  }
  return command_;
}
inline ::bosdyn::api::RobotCommand* RobotCommandRequest::mutable_command() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandRequest.command)
  return _internal_mutable_command();
}
inline void RobotCommandRequest::set_allocated_command(::bosdyn::api::RobotCommand* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandRequest.command)
}

// string clock_identifier = 4;
inline void RobotCommandRequest::clear_clock_identifier() {
  clock_identifier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RobotCommandRequest::clock_identifier() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandRequest.clock_identifier)
  return _internal_clock_identifier();
}
inline void RobotCommandRequest::set_clock_identifier(const std::string& value) {
  _internal_set_clock_identifier(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotCommandRequest.clock_identifier)
}
inline std::string* RobotCommandRequest::mutable_clock_identifier() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandRequest.clock_identifier)
  return _internal_mutable_clock_identifier();
}
inline const std::string& RobotCommandRequest::_internal_clock_identifier() const {
  return clock_identifier_.Get();
}
inline void RobotCommandRequest::_internal_set_clock_identifier(const std::string& value) {
  
  clock_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RobotCommandRequest::set_clock_identifier(std::string&& value) {
  
  clock_identifier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.RobotCommandRequest.clock_identifier)
}
inline void RobotCommandRequest::set_clock_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  clock_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.RobotCommandRequest.clock_identifier)
}
inline void RobotCommandRequest::set_clock_identifier(const char* value,
    size_t size) {
  
  clock_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.RobotCommandRequest.clock_identifier)
}
inline std::string* RobotCommandRequest::_internal_mutable_clock_identifier() {
  
  return clock_identifier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RobotCommandRequest::release_clock_identifier() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandRequest.clock_identifier)
  return clock_identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RobotCommandRequest::set_allocated_clock_identifier(std::string* clock_identifier) {
  if (clock_identifier != nullptr) {
    
  } else {
    
  }
  clock_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clock_identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandRequest.clock_identifier)
}

// -------------------------------------------------------------------

// RobotCommandResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotCommandResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandResponse.header)
  return _internal_header();
}
inline void RobotCommandResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotCommandResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotCommandResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RobotCommandResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandResponse.header)
  return _internal_mutable_header();
}
inline void RobotCommandResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool RobotCommandResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool RobotCommandResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& RobotCommandResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& RobotCommandResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void RobotCommandResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* RobotCommandResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* RobotCommandResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* RobotCommandResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* RobotCommandResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void RobotCommandResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandResponse.lease_use_result)
}

// .bosdyn.api.RobotCommandResponse.Status status = 3;
inline void RobotCommandResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::RobotCommandResponse_Status RobotCommandResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::RobotCommandResponse_Status >(status_);
}
inline ::bosdyn::api::RobotCommandResponse_Status RobotCommandResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandResponse.status)
  return _internal_status();
}
inline void RobotCommandResponse::_internal_set_status(::bosdyn::api::RobotCommandResponse_Status value) {
  
  status_ = value;
}
inline void RobotCommandResponse::set_status(::bosdyn::api::RobotCommandResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotCommandResponse.status)
}

// string message = 4;
inline void RobotCommandResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RobotCommandResponse::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandResponse.message)
  return _internal_message();
}
inline void RobotCommandResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotCommandResponse.message)
}
inline std::string* RobotCommandResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandResponse.message)
  return _internal_mutable_message();
}
inline const std::string& RobotCommandResponse::_internal_message() const {
  return message_.Get();
}
inline void RobotCommandResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RobotCommandResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.RobotCommandResponse.message)
}
inline void RobotCommandResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.RobotCommandResponse.message)
}
inline void RobotCommandResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.RobotCommandResponse.message)
}
inline std::string* RobotCommandResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RobotCommandResponse::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RobotCommandResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandResponse.message)
}

// uint32 robot_command_id = 5;
inline void RobotCommandResponse::clear_robot_command_id() {
  robot_command_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RobotCommandResponse::_internal_robot_command_id() const {
  return robot_command_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RobotCommandResponse::robot_command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandResponse.robot_command_id)
  return _internal_robot_command_id();
}
inline void RobotCommandResponse::_internal_set_robot_command_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  robot_command_id_ = value;
}
inline void RobotCommandResponse::set_robot_command_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_robot_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotCommandResponse.robot_command_id)
}

// -------------------------------------------------------------------

// RobotCommandFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotCommandFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotCommandFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotCommandFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotCommandFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandFeedbackRequest.header)
  return _internal_header();
}
inline void RobotCommandFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotCommandFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotCommandFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotCommandFeedbackRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RobotCommandFeedbackRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandFeedbackRequest.header)
  return _internal_mutable_header();
}
inline void RobotCommandFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandFeedbackRequest.header)
}

// uint32 robot_command_id = 2;
inline void RobotCommandFeedbackRequest::clear_robot_command_id() {
  robot_command_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RobotCommandFeedbackRequest::_internal_robot_command_id() const {
  return robot_command_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RobotCommandFeedbackRequest::robot_command_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandFeedbackRequest.robot_command_id)
  return _internal_robot_command_id();
}
inline void RobotCommandFeedbackRequest::_internal_set_robot_command_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  robot_command_id_ = value;
}
inline void RobotCommandFeedbackRequest::set_robot_command_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_robot_command_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotCommandFeedbackRequest.robot_command_id)
}

// -------------------------------------------------------------------

// RobotCommandFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotCommandFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotCommandFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotCommandFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotCommandFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandFeedbackResponse.header)
  return _internal_header();
}
inline void RobotCommandFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotCommandFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotCommandFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotCommandFeedbackResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RobotCommandFeedbackResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandFeedbackResponse.header)
  return _internal_mutable_header();
}
inline void RobotCommandFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandFeedbackResponse.header)
}

// .bosdyn.api.RobotCommandFeedbackResponse.Status status = 2;
inline void RobotCommandFeedbackResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::RobotCommandFeedbackResponse_Status RobotCommandFeedbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::RobotCommandFeedbackResponse_Status >(status_);
}
inline ::bosdyn::api::RobotCommandFeedbackResponse_Status RobotCommandFeedbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandFeedbackResponse.status)
  return _internal_status();
}
inline void RobotCommandFeedbackResponse::_internal_set_status(::bosdyn::api::RobotCommandFeedbackResponse_Status value) {
  
  status_ = value;
}
inline void RobotCommandFeedbackResponse::set_status(::bosdyn::api::RobotCommandFeedbackResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotCommandFeedbackResponse.status)
}

// string message = 3;
inline void RobotCommandFeedbackResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RobotCommandFeedbackResponse::message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandFeedbackResponse.message)
  return _internal_message();
}
inline void RobotCommandFeedbackResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotCommandFeedbackResponse.message)
}
inline std::string* RobotCommandFeedbackResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandFeedbackResponse.message)
  return _internal_mutable_message();
}
inline const std::string& RobotCommandFeedbackResponse::_internal_message() const {
  return message_.Get();
}
inline void RobotCommandFeedbackResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RobotCommandFeedbackResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.RobotCommandFeedbackResponse.message)
}
inline void RobotCommandFeedbackResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.RobotCommandFeedbackResponse.message)
}
inline void RobotCommandFeedbackResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.RobotCommandFeedbackResponse.message)
}
inline std::string* RobotCommandFeedbackResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RobotCommandFeedbackResponse::release_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandFeedbackResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RobotCommandFeedbackResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandFeedbackResponse.message)
}

// .bosdyn.api.RobotCommandFeedback feedback = 4;
inline bool RobotCommandFeedbackResponse::_internal_has_feedback() const {
  return this != internal_default_instance() && feedback_ != nullptr;
}
inline bool RobotCommandFeedbackResponse::has_feedback() const {
  return _internal_has_feedback();
}
inline void RobotCommandFeedbackResponse::clear_feedback() {
  if (GetArena() == nullptr && feedback_ != nullptr) {
    delete feedback_;
  }
  feedback_ = nullptr;
}
inline const ::bosdyn::api::RobotCommandFeedback& RobotCommandFeedbackResponse::_internal_feedback() const {
  const ::bosdyn::api::RobotCommandFeedback* p = feedback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RobotCommandFeedback*>(
      &::bosdyn::api::_RobotCommandFeedback_default_instance_);
}
inline const ::bosdyn::api::RobotCommandFeedback& RobotCommandFeedbackResponse::feedback() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotCommandFeedbackResponse.feedback)
  return _internal_feedback();
}
inline void RobotCommandFeedbackResponse::unsafe_arena_set_allocated_feedback(
    ::bosdyn::api::RobotCommandFeedback* feedback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feedback_);
  }
  feedback_ = feedback;
  if (feedback) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotCommandFeedbackResponse.feedback)
}
inline ::bosdyn::api::RobotCommandFeedback* RobotCommandFeedbackResponse::release_feedback() {
  
  ::bosdyn::api::RobotCommandFeedback* temp = feedback_;
  feedback_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RobotCommandFeedback* RobotCommandFeedbackResponse::unsafe_arena_release_feedback() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotCommandFeedbackResponse.feedback)
  
  ::bosdyn::api::RobotCommandFeedback* temp = feedback_;
  feedback_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotCommandFeedback* RobotCommandFeedbackResponse::_internal_mutable_feedback() {
  
  if (feedback_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotCommandFeedback>(GetArena());
    feedback_ = p;
  }
  return feedback_;
}
inline ::bosdyn::api::RobotCommandFeedback* RobotCommandFeedbackResponse::mutable_feedback() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotCommandFeedbackResponse.feedback)
  return _internal_mutable_feedback();
}
inline void RobotCommandFeedbackResponse::set_allocated_feedback(::bosdyn::api::RobotCommandFeedback* feedback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete feedback_;
  }
  if (feedback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(feedback);
    if (message_arena != submessage_arena) {
      feedback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feedback, submessage_arena);
    }
    
  } else {
    
  }
  feedback_ = feedback;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotCommandFeedbackResponse.feedback)
}

// -------------------------------------------------------------------

// ClearBehaviorFaultRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ClearBehaviorFaultRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ClearBehaviorFaultRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ClearBehaviorFaultRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ClearBehaviorFaultRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearBehaviorFaultRequest.header)
  return _internal_header();
}
inline void ClearBehaviorFaultRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ClearBehaviorFaultRequest.header)
}
inline ::bosdyn::api::RequestHeader* ClearBehaviorFaultRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* ClearBehaviorFaultRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ClearBehaviorFaultRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ClearBehaviorFaultRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* ClearBehaviorFaultRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ClearBehaviorFaultRequest.header)
  return _internal_mutable_header();
}
inline void ClearBehaviorFaultRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ClearBehaviorFaultRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool ClearBehaviorFaultRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool ClearBehaviorFaultRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& ClearBehaviorFaultRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& ClearBehaviorFaultRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearBehaviorFaultRequest.lease)
  return _internal_lease();
}
inline void ClearBehaviorFaultRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ClearBehaviorFaultRequest.lease)
}
inline ::bosdyn::api::Lease* ClearBehaviorFaultRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* ClearBehaviorFaultRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ClearBehaviorFaultRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* ClearBehaviorFaultRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* ClearBehaviorFaultRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ClearBehaviorFaultRequest.lease)
  return _internal_mutable_lease();
}
inline void ClearBehaviorFaultRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ClearBehaviorFaultRequest.lease)
}

// uint32 behavior_fault_id = 3;
inline void ClearBehaviorFaultRequest::clear_behavior_fault_id() {
  behavior_fault_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClearBehaviorFaultRequest::_internal_behavior_fault_id() const {
  return behavior_fault_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClearBehaviorFaultRequest::behavior_fault_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearBehaviorFaultRequest.behavior_fault_id)
  return _internal_behavior_fault_id();
}
inline void ClearBehaviorFaultRequest::_internal_set_behavior_fault_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  behavior_fault_id_ = value;
}
inline void ClearBehaviorFaultRequest::set_behavior_fault_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_behavior_fault_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ClearBehaviorFaultRequest.behavior_fault_id)
}

// -------------------------------------------------------------------

// ClearBehaviorFaultResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ClearBehaviorFaultResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ClearBehaviorFaultResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ClearBehaviorFaultResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ClearBehaviorFaultResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearBehaviorFaultResponse.header)
  return _internal_header();
}
inline void ClearBehaviorFaultResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ClearBehaviorFaultResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ClearBehaviorFaultResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ClearBehaviorFaultResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ClearBehaviorFaultResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ClearBehaviorFaultResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* ClearBehaviorFaultResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ClearBehaviorFaultResponse.header)
  return _internal_mutable_header();
}
inline void ClearBehaviorFaultResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ClearBehaviorFaultResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool ClearBehaviorFaultResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool ClearBehaviorFaultResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& ClearBehaviorFaultResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& ClearBehaviorFaultResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearBehaviorFaultResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void ClearBehaviorFaultResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ClearBehaviorFaultResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* ClearBehaviorFaultResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* ClearBehaviorFaultResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ClearBehaviorFaultResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* ClearBehaviorFaultResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* ClearBehaviorFaultResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ClearBehaviorFaultResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void ClearBehaviorFaultResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ClearBehaviorFaultResponse.lease_use_result)
}

// .bosdyn.api.ClearBehaviorFaultResponse.Status status = 3;
inline void ClearBehaviorFaultResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::ClearBehaviorFaultResponse_Status ClearBehaviorFaultResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::ClearBehaviorFaultResponse_Status >(status_);
}
inline ::bosdyn::api::ClearBehaviorFaultResponse_Status ClearBehaviorFaultResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ClearBehaviorFaultResponse.status)
  return _internal_status();
}
inline void ClearBehaviorFaultResponse::_internal_set_status(::bosdyn::api::ClearBehaviorFaultResponse_Status value) {
  
  status_ = value;
}
inline void ClearBehaviorFaultResponse::set_status(::bosdyn::api::ClearBehaviorFaultResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ClearBehaviorFaultResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::RobotCommandResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RobotCommandResponse_Status>() {
  return ::bosdyn::api::RobotCommandResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RobotCommandFeedbackResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RobotCommandFeedbackResponse_Status>() {
  return ::bosdyn::api::RobotCommandFeedbackResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ClearBehaviorFaultResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ClearBehaviorFaultResponse_Status>() {
  return ::bosdyn::api::ClearBehaviorFaultResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fcommand_2eproto
