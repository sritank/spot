// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/geometry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgeometry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgeometry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fgeometry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fgeometry_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fgeometry_2eproto;
namespace bosdyn {
namespace api {
class Area;
class AreaDefaultTypeInternal;
extern AreaDefaultTypeInternal _Area_default_instance_;
class Box2;
class Box2DefaultTypeInternal;
extern Box2DefaultTypeInternal _Box2_default_instance_;
class Box2WithFrame;
class Box2WithFrameDefaultTypeInternal;
extern Box2WithFrameDefaultTypeInternal _Box2WithFrame_default_instance_;
class Box3;
class Box3DefaultTypeInternal;
extern Box3DefaultTypeInternal _Box3_default_instance_;
class Box3WithFrame;
class Box3WithFrameDefaultTypeInternal;
extern Box3WithFrameDefaultTypeInternal _Box3WithFrame_default_instance_;
class Circle;
class CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class CylindricalCoordinate;
class CylindricalCoordinateDefaultTypeInternal;
extern CylindricalCoordinateDefaultTypeInternal _CylindricalCoordinate_default_instance_;
class EulerZXYRate;
class EulerZXYRateDefaultTypeInternal;
extern EulerZXYRateDefaultTypeInternal _EulerZXYRate_default_instance_;
class FrameTreeSnapshot;
class FrameTreeSnapshotDefaultTypeInternal;
extern FrameTreeSnapshotDefaultTypeInternal _FrameTreeSnapshot_default_instance_;
class FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse;
class FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUseDefaultTypeInternal;
extern FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUseDefaultTypeInternal _FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse_default_instance_;
class FrameTreeSnapshot_ParentEdge;
class FrameTreeSnapshot_ParentEdgeDefaultTypeInternal;
extern FrameTreeSnapshot_ParentEdgeDefaultTypeInternal _FrameTreeSnapshot_ParentEdge_default_instance_;
class Plane;
class PlaneDefaultTypeInternal;
extern PlaneDefaultTypeInternal _Plane_default_instance_;
class PolyLine;
class PolyLineDefaultTypeInternal;
extern PolyLineDefaultTypeInternal _PolyLine_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class SE2Pose;
class SE2PoseDefaultTypeInternal;
extern SE2PoseDefaultTypeInternal _SE2Pose_default_instance_;
class SE2Velocity;
class SE2VelocityDefaultTypeInternal;
extern SE2VelocityDefaultTypeInternal _SE2Velocity_default_instance_;
class SE2VelocityLimit;
class SE2VelocityLimitDefaultTypeInternal;
extern SE2VelocityLimitDefaultTypeInternal _SE2VelocityLimit_default_instance_;
class SE3Covariance;
class SE3CovarianceDefaultTypeInternal;
extern SE3CovarianceDefaultTypeInternal _SE3Covariance_default_instance_;
class SE3Pose;
class SE3PoseDefaultTypeInternal;
extern SE3PoseDefaultTypeInternal _SE3Pose_default_instance_;
class SE3Velocity;
class SE3VelocityDefaultTypeInternal;
extern SE3VelocityDefaultTypeInternal _SE3Velocity_default_instance_;
class Vec2;
class Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
class Vec2Value;
class Vec2ValueDefaultTypeInternal;
extern Vec2ValueDefaultTypeInternal _Vec2Value_default_instance_;
class Vec3;
class Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Vec3Value;
class Vec3ValueDefaultTypeInternal;
extern Vec3ValueDefaultTypeInternal _Vec3Value_default_instance_;
class Volume;
class VolumeDefaultTypeInternal;
extern VolumeDefaultTypeInternal _Volume_default_instance_;
class Wrench;
class WrenchDefaultTypeInternal;
extern WrenchDefaultTypeInternal _Wrench_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::Area* Arena::CreateMaybeMessage<::bosdyn::api::Area>(Arena*);
template<> ::bosdyn::api::Box2* Arena::CreateMaybeMessage<::bosdyn::api::Box2>(Arena*);
template<> ::bosdyn::api::Box2WithFrame* Arena::CreateMaybeMessage<::bosdyn::api::Box2WithFrame>(Arena*);
template<> ::bosdyn::api::Box3* Arena::CreateMaybeMessage<::bosdyn::api::Box3>(Arena*);
template<> ::bosdyn::api::Box3WithFrame* Arena::CreateMaybeMessage<::bosdyn::api::Box3WithFrame>(Arena*);
template<> ::bosdyn::api::Circle* Arena::CreateMaybeMessage<::bosdyn::api::Circle>(Arena*);
template<> ::bosdyn::api::CylindricalCoordinate* Arena::CreateMaybeMessage<::bosdyn::api::CylindricalCoordinate>(Arena*);
template<> ::bosdyn::api::EulerZXYRate* Arena::CreateMaybeMessage<::bosdyn::api::EulerZXYRate>(Arena*);
template<> ::bosdyn::api::FrameTreeSnapshot* Arena::CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(Arena*);
template<> ::bosdyn::api::FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::FrameTreeSnapshot_ParentEdge* Arena::CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot_ParentEdge>(Arena*);
template<> ::bosdyn::api::Plane* Arena::CreateMaybeMessage<::bosdyn::api::Plane>(Arena*);
template<> ::bosdyn::api::PolyLine* Arena::CreateMaybeMessage<::bosdyn::api::PolyLine>(Arena*);
template<> ::bosdyn::api::Polygon* Arena::CreateMaybeMessage<::bosdyn::api::Polygon>(Arena*);
template<> ::bosdyn::api::Quaternion* Arena::CreateMaybeMessage<::bosdyn::api::Quaternion>(Arena*);
template<> ::bosdyn::api::SE2Pose* Arena::CreateMaybeMessage<::bosdyn::api::SE2Pose>(Arena*);
template<> ::bosdyn::api::SE2Velocity* Arena::CreateMaybeMessage<::bosdyn::api::SE2Velocity>(Arena*);
template<> ::bosdyn::api::SE2VelocityLimit* Arena::CreateMaybeMessage<::bosdyn::api::SE2VelocityLimit>(Arena*);
template<> ::bosdyn::api::SE3Covariance* Arena::CreateMaybeMessage<::bosdyn::api::SE3Covariance>(Arena*);
template<> ::bosdyn::api::SE3Pose* Arena::CreateMaybeMessage<::bosdyn::api::SE3Pose>(Arena*);
template<> ::bosdyn::api::SE3Velocity* Arena::CreateMaybeMessage<::bosdyn::api::SE3Velocity>(Arena*);
template<> ::bosdyn::api::Vec2* Arena::CreateMaybeMessage<::bosdyn::api::Vec2>(Arena*);
template<> ::bosdyn::api::Vec2Value* Arena::CreateMaybeMessage<::bosdyn::api::Vec2Value>(Arena*);
template<> ::bosdyn::api::Vec3* Arena::CreateMaybeMessage<::bosdyn::api::Vec3>(Arena*);
template<> ::bosdyn::api::Vec3Value* Arena::CreateMaybeMessage<::bosdyn::api::Vec3Value>(Arena*);
template<> ::bosdyn::api::Volume* Arena::CreateMaybeMessage<::bosdyn::api::Volume>(Arena*);
template<> ::bosdyn::api::Wrench* Arena::CreateMaybeMessage<::bosdyn::api::Wrench>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

// ===================================================================

class Vec2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vec2) */ {
 public:
  inline Vec2() : Vec2(nullptr) {}
  virtual ~Vec2();

  Vec2(const Vec2& from);
  Vec2(Vec2&& from) noexcept
    : Vec2() {
    *this = ::std::move(from);
  }

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2& operator=(Vec2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec2* internal_default_instance() {
    return reinterpret_cast<const Vec2*>(
               &_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vec2& a, Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2* New() const final {
    return CreateMaybeMessage<Vec2>(nullptr);
  }

  Vec2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2& from);
  void MergeFrom(const Vec2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vec2";
  }
  protected:
  explicit Vec2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vec2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Vec3 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vec3) */ {
 public:
  inline Vec3() : Vec3(nullptr) {}
  virtual ~Vec3();

  Vec3(const Vec3& from);
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec3* New() const final {
    return CreateMaybeMessage<Vec3>(nullptr);
  }

  Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vec3";
  }
  protected:
  explicit Vec3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vec3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class CylindricalCoordinate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.CylindricalCoordinate) */ {
 public:
  inline CylindricalCoordinate() : CylindricalCoordinate(nullptr) {}
  virtual ~CylindricalCoordinate();

  CylindricalCoordinate(const CylindricalCoordinate& from);
  CylindricalCoordinate(CylindricalCoordinate&& from) noexcept
    : CylindricalCoordinate() {
    *this = ::std::move(from);
  }

  inline CylindricalCoordinate& operator=(const CylindricalCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CylindricalCoordinate& operator=(CylindricalCoordinate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CylindricalCoordinate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CylindricalCoordinate* internal_default_instance() {
    return reinterpret_cast<const CylindricalCoordinate*>(
               &_CylindricalCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CylindricalCoordinate& a, CylindricalCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(CylindricalCoordinate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CylindricalCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CylindricalCoordinate* New() const final {
    return CreateMaybeMessage<CylindricalCoordinate>(nullptr);
  }

  CylindricalCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CylindricalCoordinate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CylindricalCoordinate& from);
  void MergeFrom(const CylindricalCoordinate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CylindricalCoordinate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.CylindricalCoordinate";
  }
  protected:
  explicit CylindricalCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kThetaFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double r = 1;
  void clear_r();
  double r() const;
  void set_r(double value);
  private:
  double _internal_r() const;
  void _internal_set_r(double value);
  public:

  // double theta = 2;
  void clear_theta();
  double theta() const;
  void set_theta(double value);
  private:
  double _internal_theta() const;
  void _internal_set_theta(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.CylindricalCoordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double r_;
  double theta_;
  double z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Quaternion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(nullptr);
  }

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // double w = 4;
  void clear_w();
  double w() const;
  void set_w(double value);
  private:
  double _internal_w() const;
  void _internal_set_w(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double z_;
  double w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Plane PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Plane) */ {
 public:
  inline Plane() : Plane(nullptr) {}
  virtual ~Plane();

  Plane(const Plane& from);
  Plane(Plane&& from) noexcept
    : Plane() {
    *this = ::std::move(from);
  }

  inline Plane& operator=(const Plane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plane& operator=(Plane&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Plane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Plane* internal_default_instance() {
    return reinterpret_cast<const Plane*>(
               &_Plane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Plane& a, Plane& b) {
    a.Swap(&b);
  }
  inline void Swap(Plane* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Plane* New() const final {
    return CreateMaybeMessage<Plane>(nullptr);
  }

  Plane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Plane>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Plane& from);
  void MergeFrom(const Plane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Plane";
  }
  protected:
  explicit Plane(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
    kNormalFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::Vec3& point() const;
  ::bosdyn::api::Vec3* release_point();
  ::bosdyn::api::Vec3* mutable_point();
  void set_allocated_point(::bosdyn::api::Vec3* point);
  private:
  const ::bosdyn::api::Vec3& _internal_point() const;
  ::bosdyn::api::Vec3* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::Vec3* point);
  ::bosdyn::api::Vec3* unsafe_arena_release_point();

  // .bosdyn.api.Vec3 normal = 2;
  bool has_normal() const;
  private:
  bool _internal_has_normal() const;
  public:
  void clear_normal();
  const ::bosdyn::api::Vec3& normal() const;
  ::bosdyn::api::Vec3* release_normal();
  ::bosdyn::api::Vec3* mutable_normal();
  void set_allocated_normal(::bosdyn::api::Vec3* normal);
  private:
  const ::bosdyn::api::Vec3& _internal_normal() const;
  ::bosdyn::api::Vec3* _internal_mutable_normal();
  public:
  void unsafe_arena_set_allocated_normal(
      ::bosdyn::api::Vec3* normal);
  ::bosdyn::api::Vec3* unsafe_arena_release_normal();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Plane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec3* point_;
  ::bosdyn::api::Vec3* normal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE2Pose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2Pose) */ {
 public:
  inline SE2Pose() : SE2Pose(nullptr) {}
  virtual ~SE2Pose();

  SE2Pose(const SE2Pose& from);
  SE2Pose(SE2Pose&& from) noexcept
    : SE2Pose() {
    *this = ::std::move(from);
  }

  inline SE2Pose& operator=(const SE2Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2Pose& operator=(SE2Pose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SE2Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SE2Pose* internal_default_instance() {
    return reinterpret_cast<const SE2Pose*>(
               &_SE2Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SE2Pose& a, SE2Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2Pose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE2Pose* New() const final {
    return CreateMaybeMessage<SE2Pose>(nullptr);
  }

  SE2Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE2Pose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SE2Pose& from);
  void MergeFrom(const SE2Pose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2Pose";
  }
  protected:
  explicit SE2Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kAngleFieldNumber = 2,
  };
  // .bosdyn.api.Vec2 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::bosdyn::api::Vec2& position() const;
  ::bosdyn::api::Vec2* release_position();
  ::bosdyn::api::Vec2* mutable_position();
  void set_allocated_position(::bosdyn::api::Vec2* position);
  private:
  const ::bosdyn::api::Vec2& _internal_position() const;
  ::bosdyn::api::Vec2* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::bosdyn::api::Vec2* position);
  ::bosdyn::api::Vec2* unsafe_arena_release_position();

  // double angle = 2;
  void clear_angle();
  double angle() const;
  void set_angle(double value);
  private:
  double _internal_angle() const;
  void _internal_set_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec2* position_;
  double angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE2Velocity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2Velocity) */ {
 public:
  inline SE2Velocity() : SE2Velocity(nullptr) {}
  virtual ~SE2Velocity();

  SE2Velocity(const SE2Velocity& from);
  SE2Velocity(SE2Velocity&& from) noexcept
    : SE2Velocity() {
    *this = ::std::move(from);
  }

  inline SE2Velocity& operator=(const SE2Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2Velocity& operator=(SE2Velocity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SE2Velocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SE2Velocity* internal_default_instance() {
    return reinterpret_cast<const SE2Velocity*>(
               &_SE2Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SE2Velocity& a, SE2Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2Velocity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE2Velocity* New() const final {
    return CreateMaybeMessage<SE2Velocity>(nullptr);
  }

  SE2Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE2Velocity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SE2Velocity& from);
  void MergeFrom(const SE2Velocity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2Velocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2Velocity";
  }
  protected:
  explicit SE2Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .bosdyn.api.Vec2 linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::bosdyn::api::Vec2& linear() const;
  ::bosdyn::api::Vec2* release_linear();
  ::bosdyn::api::Vec2* mutable_linear();
  void set_allocated_linear(::bosdyn::api::Vec2* linear);
  private:
  const ::bosdyn::api::Vec2& _internal_linear() const;
  ::bosdyn::api::Vec2* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::bosdyn::api::Vec2* linear);
  ::bosdyn::api::Vec2* unsafe_arena_release_linear();

  // double angular = 2;
  void clear_angular();
  double angular() const;
  void set_angular(double value);
  private:
  double _internal_angular() const;
  void _internal_set_angular(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2Velocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec2* linear_;
  double angular_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE2VelocityLimit PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE2VelocityLimit) */ {
 public:
  inline SE2VelocityLimit() : SE2VelocityLimit(nullptr) {}
  virtual ~SE2VelocityLimit();

  SE2VelocityLimit(const SE2VelocityLimit& from);
  SE2VelocityLimit(SE2VelocityLimit&& from) noexcept
    : SE2VelocityLimit() {
    *this = ::std::move(from);
  }

  inline SE2VelocityLimit& operator=(const SE2VelocityLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2VelocityLimit& operator=(SE2VelocityLimit&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SE2VelocityLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SE2VelocityLimit* internal_default_instance() {
    return reinterpret_cast<const SE2VelocityLimit*>(
               &_SE2VelocityLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SE2VelocityLimit& a, SE2VelocityLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2VelocityLimit* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2VelocityLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE2VelocityLimit* New() const final {
    return CreateMaybeMessage<SE2VelocityLimit>(nullptr);
  }

  SE2VelocityLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE2VelocityLimit>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SE2VelocityLimit& from);
  void MergeFrom(const SE2VelocityLimit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2VelocityLimit* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE2VelocityLimit";
  }
  protected:
  explicit SE2VelocityLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxVelFieldNumber = 1,
    kMinVelFieldNumber = 2,
  };
  // .bosdyn.api.SE2Velocity max_vel = 1;
  bool has_max_vel() const;
  private:
  bool _internal_has_max_vel() const;
  public:
  void clear_max_vel();
  const ::bosdyn::api::SE2Velocity& max_vel() const;
  ::bosdyn::api::SE2Velocity* release_max_vel();
  ::bosdyn::api::SE2Velocity* mutable_max_vel();
  void set_allocated_max_vel(::bosdyn::api::SE2Velocity* max_vel);
  private:
  const ::bosdyn::api::SE2Velocity& _internal_max_vel() const;
  ::bosdyn::api::SE2Velocity* _internal_mutable_max_vel();
  public:
  void unsafe_arena_set_allocated_max_vel(
      ::bosdyn::api::SE2Velocity* max_vel);
  ::bosdyn::api::SE2Velocity* unsafe_arena_release_max_vel();

  // .bosdyn.api.SE2Velocity min_vel = 2;
  bool has_min_vel() const;
  private:
  bool _internal_has_min_vel() const;
  public:
  void clear_min_vel();
  const ::bosdyn::api::SE2Velocity& min_vel() const;
  ::bosdyn::api::SE2Velocity* release_min_vel();
  ::bosdyn::api::SE2Velocity* mutable_min_vel();
  void set_allocated_min_vel(::bosdyn::api::SE2Velocity* min_vel);
  private:
  const ::bosdyn::api::SE2Velocity& _internal_min_vel() const;
  ::bosdyn::api::SE2Velocity* _internal_mutable_min_vel();
  public:
  void unsafe_arena_set_allocated_min_vel(
      ::bosdyn::api::SE2Velocity* min_vel);
  ::bosdyn::api::SE2Velocity* unsafe_arena_release_min_vel();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE2VelocityLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::SE2Velocity* max_vel_;
  ::bosdyn::api::SE2Velocity* min_vel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Pose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE3Pose) */ {
 public:
  inline SE3Pose() : SE3Pose(nullptr) {}
  virtual ~SE3Pose();

  SE3Pose(const SE3Pose& from);
  SE3Pose(SE3Pose&& from) noexcept
    : SE3Pose() {
    *this = ::std::move(from);
  }

  inline SE3Pose& operator=(const SE3Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Pose& operator=(SE3Pose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SE3Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SE3Pose* internal_default_instance() {
    return reinterpret_cast<const SE3Pose*>(
               &_SE3Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SE3Pose& a, SE3Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Pose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE3Pose* New() const final {
    return CreateMaybeMessage<SE3Pose>(nullptr);
  }

  SE3Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE3Pose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SE3Pose& from);
  void MergeFrom(const SE3Pose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE3Pose";
  }
  protected:
  explicit SE3Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::bosdyn::api::Vec3& position() const;
  ::bosdyn::api::Vec3* release_position();
  ::bosdyn::api::Vec3* mutable_position();
  void set_allocated_position(::bosdyn::api::Vec3* position);
  private:
  const ::bosdyn::api::Vec3& _internal_position() const;
  ::bosdyn::api::Vec3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::bosdyn::api::Vec3* position);
  ::bosdyn::api::Vec3* unsafe_arena_release_position();

  // .bosdyn.api.Quaternion rotation = 2;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::bosdyn::api::Quaternion& rotation() const;
  ::bosdyn::api::Quaternion* release_rotation();
  ::bosdyn::api::Quaternion* mutable_rotation();
  void set_allocated_rotation(::bosdyn::api::Quaternion* rotation);
  private:
  const ::bosdyn::api::Quaternion& _internal_rotation() const;
  ::bosdyn::api::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::bosdyn::api::Quaternion* rotation);
  ::bosdyn::api::Quaternion* unsafe_arena_release_rotation();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE3Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec3* position_;
  ::bosdyn::api::Quaternion* rotation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Velocity PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE3Velocity) */ {
 public:
  inline SE3Velocity() : SE3Velocity(nullptr) {}
  virtual ~SE3Velocity();

  SE3Velocity(const SE3Velocity& from);
  SE3Velocity(SE3Velocity&& from) noexcept
    : SE3Velocity() {
    *this = ::std::move(from);
  }

  inline SE3Velocity& operator=(const SE3Velocity& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Velocity& operator=(SE3Velocity&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SE3Velocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SE3Velocity* internal_default_instance() {
    return reinterpret_cast<const SE3Velocity*>(
               &_SE3Velocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SE3Velocity& a, SE3Velocity& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Velocity* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Velocity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE3Velocity* New() const final {
    return CreateMaybeMessage<SE3Velocity>(nullptr);
  }

  SE3Velocity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE3Velocity>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SE3Velocity& from);
  void MergeFrom(const SE3Velocity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Velocity* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE3Velocity";
  }
  protected:
  explicit SE3Velocity(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinearFieldNumber = 1,
    kAngularFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 linear = 1;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::bosdyn::api::Vec3& linear() const;
  ::bosdyn::api::Vec3* release_linear();
  ::bosdyn::api::Vec3* mutable_linear();
  void set_allocated_linear(::bosdyn::api::Vec3* linear);
  private:
  const ::bosdyn::api::Vec3& _internal_linear() const;
  ::bosdyn::api::Vec3* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::bosdyn::api::Vec3* linear);
  ::bosdyn::api::Vec3* unsafe_arena_release_linear();

  // .bosdyn.api.Vec3 angular = 2;
  bool has_angular() const;
  private:
  bool _internal_has_angular() const;
  public:
  void clear_angular();
  const ::bosdyn::api::Vec3& angular() const;
  ::bosdyn::api::Vec3* release_angular();
  ::bosdyn::api::Vec3* mutable_angular();
  void set_allocated_angular(::bosdyn::api::Vec3* angular);
  private:
  const ::bosdyn::api::Vec3& _internal_angular() const;
  ::bosdyn::api::Vec3* _internal_mutable_angular();
  public:
  void unsafe_arena_set_allocated_angular(
      ::bosdyn::api::Vec3* angular);
  ::bosdyn::api::Vec3* unsafe_arena_release_angular();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE3Velocity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec3* linear_;
  ::bosdyn::api::Vec3* angular_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Wrench PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Wrench) */ {
 public:
  inline Wrench() : Wrench(nullptr) {}
  virtual ~Wrench();

  Wrench(const Wrench& from);
  Wrench(Wrench&& from) noexcept
    : Wrench() {
    *this = ::std::move(from);
  }

  inline Wrench& operator=(const Wrench& from) {
    CopyFrom(from);
    return *this;
  }
  inline Wrench& operator=(Wrench&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Wrench& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Wrench* internal_default_instance() {
    return reinterpret_cast<const Wrench*>(
               &_Wrench_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Wrench& a, Wrench& b) {
    a.Swap(&b);
  }
  inline void Swap(Wrench* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Wrench* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Wrench* New() const final {
    return CreateMaybeMessage<Wrench>(nullptr);
  }

  Wrench* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Wrench>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Wrench& from);
  void MergeFrom(const Wrench& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Wrench* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Wrench";
  }
  protected:
  explicit Wrench(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForceFieldNumber = 1,
    kTorqueFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 force = 1;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  const ::bosdyn::api::Vec3& force() const;
  ::bosdyn::api::Vec3* release_force();
  ::bosdyn::api::Vec3* mutable_force();
  void set_allocated_force(::bosdyn::api::Vec3* force);
  private:
  const ::bosdyn::api::Vec3& _internal_force() const;
  ::bosdyn::api::Vec3* _internal_mutable_force();
  public:
  void unsafe_arena_set_allocated_force(
      ::bosdyn::api::Vec3* force);
  ::bosdyn::api::Vec3* unsafe_arena_release_force();

  // .bosdyn.api.Vec3 torque = 2;
  bool has_torque() const;
  private:
  bool _internal_has_torque() const;
  public:
  void clear_torque();
  const ::bosdyn::api::Vec3& torque() const;
  ::bosdyn::api::Vec3* release_torque();
  ::bosdyn::api::Vec3* mutable_torque();
  void set_allocated_torque(::bosdyn::api::Vec3* torque);
  private:
  const ::bosdyn::api::Vec3& _internal_torque() const;
  ::bosdyn::api::Vec3* _internal_mutable_torque();
  public:
  void unsafe_arena_set_allocated_torque(
      ::bosdyn::api::Vec3* torque);
  ::bosdyn::api::Vec3* unsafe_arena_release_torque();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Wrench)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec3* force_;
  ::bosdyn::api::Vec3* torque_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class FrameTreeSnapshot_ParentEdge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FrameTreeSnapshot.ParentEdge) */ {
 public:
  inline FrameTreeSnapshot_ParentEdge() : FrameTreeSnapshot_ParentEdge(nullptr) {}
  virtual ~FrameTreeSnapshot_ParentEdge();

  FrameTreeSnapshot_ParentEdge(const FrameTreeSnapshot_ParentEdge& from);
  FrameTreeSnapshot_ParentEdge(FrameTreeSnapshot_ParentEdge&& from) noexcept
    : FrameTreeSnapshot_ParentEdge() {
    *this = ::std::move(from);
  }

  inline FrameTreeSnapshot_ParentEdge& operator=(const FrameTreeSnapshot_ParentEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameTreeSnapshot_ParentEdge& operator=(FrameTreeSnapshot_ParentEdge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FrameTreeSnapshot_ParentEdge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameTreeSnapshot_ParentEdge* internal_default_instance() {
    return reinterpret_cast<const FrameTreeSnapshot_ParentEdge*>(
               &_FrameTreeSnapshot_ParentEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FrameTreeSnapshot_ParentEdge& a, FrameTreeSnapshot_ParentEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameTreeSnapshot_ParentEdge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameTreeSnapshot_ParentEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameTreeSnapshot_ParentEdge* New() const final {
    return CreateMaybeMessage<FrameTreeSnapshot_ParentEdge>(nullptr);
  }

  FrameTreeSnapshot_ParentEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameTreeSnapshot_ParentEdge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FrameTreeSnapshot_ParentEdge& from);
  void MergeFrom(const FrameTreeSnapshot_ParentEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameTreeSnapshot_ParentEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FrameTreeSnapshot.ParentEdge";
  }
  protected:
  explicit FrameTreeSnapshot_ParentEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFrameNameFieldNumber = 1,
    kParentTformChildFieldNumber = 2,
  };
  // string parent_frame_name = 1;
  void clear_parent_frame_name();
  const std::string& parent_frame_name() const;
  void set_parent_frame_name(const std::string& value);
  void set_parent_frame_name(std::string&& value);
  void set_parent_frame_name(const char* value);
  void set_parent_frame_name(const char* value, size_t size);
  std::string* mutable_parent_frame_name();
  std::string* release_parent_frame_name();
  void set_allocated_parent_frame_name(std::string* parent_frame_name);
  private:
  const std::string& _internal_parent_frame_name() const;
  void _internal_set_parent_frame_name(const std::string& value);
  std::string* _internal_mutable_parent_frame_name();
  public:

  // .bosdyn.api.SE3Pose parent_tform_child = 2;
  bool has_parent_tform_child() const;
  private:
  bool _internal_has_parent_tform_child() const;
  public:
  void clear_parent_tform_child();
  const ::bosdyn::api::SE3Pose& parent_tform_child() const;
  ::bosdyn::api::SE3Pose* release_parent_tform_child();
  ::bosdyn::api::SE3Pose* mutable_parent_tform_child();
  void set_allocated_parent_tform_child(::bosdyn::api::SE3Pose* parent_tform_child);
  private:
  const ::bosdyn::api::SE3Pose& _internal_parent_tform_child() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_parent_tform_child();
  public:
  void unsafe_arena_set_allocated_parent_tform_child(
      ::bosdyn::api::SE3Pose* parent_tform_child);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_parent_tform_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.FrameTreeSnapshot.ParentEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_frame_name_;
  ::bosdyn::api::SE3Pose* parent_tform_child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse, 
    std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse, 
    std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse();
  explicit FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse& other);
  static const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse*>(&_FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.FrameTreeSnapshot.ChildToParentEdgeMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[12];
  }

  public:
};

// -------------------------------------------------------------------

class FrameTreeSnapshot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FrameTreeSnapshot) */ {
 public:
  inline FrameTreeSnapshot() : FrameTreeSnapshot(nullptr) {}
  virtual ~FrameTreeSnapshot();

  FrameTreeSnapshot(const FrameTreeSnapshot& from);
  FrameTreeSnapshot(FrameTreeSnapshot&& from) noexcept
    : FrameTreeSnapshot() {
    *this = ::std::move(from);
  }

  inline FrameTreeSnapshot& operator=(const FrameTreeSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameTreeSnapshot& operator=(FrameTreeSnapshot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FrameTreeSnapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameTreeSnapshot* internal_default_instance() {
    return reinterpret_cast<const FrameTreeSnapshot*>(
               &_FrameTreeSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FrameTreeSnapshot& a, FrameTreeSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameTreeSnapshot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameTreeSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameTreeSnapshot* New() const final {
    return CreateMaybeMessage<FrameTreeSnapshot>(nullptr);
  }

  FrameTreeSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameTreeSnapshot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FrameTreeSnapshot& from);
  void MergeFrom(const FrameTreeSnapshot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameTreeSnapshot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FrameTreeSnapshot";
  }
  protected:
  explicit FrameTreeSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FrameTreeSnapshot_ParentEdge ParentEdge;

  // accessors -------------------------------------------------------

  enum : int {
    kChildToParentEdgeMapFieldNumber = 1,
  };
  // map<string, .bosdyn.api.FrameTreeSnapshot.ParentEdge> child_to_parent_edge_map = 1;
  int child_to_parent_edge_map_size() const;
  private:
  int _internal_child_to_parent_edge_map_size() const;
  public:
  void clear_child_to_parent_edge_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >&
      _internal_child_to_parent_edge_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >*
      _internal_mutable_child_to_parent_edge_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >&
      child_to_parent_edge_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >*
      mutable_child_to_parent_edge_map();

  // @@protoc_insertion_point(class_scope:bosdyn.api.FrameTreeSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      FrameTreeSnapshot_ChildToParentEdgeMapEntry_DoNotUse,
      std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > child_to_parent_edge_map_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Box2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Box2) */ {
 public:
  inline Box2() : Box2(nullptr) {}
  virtual ~Box2();

  Box2(const Box2& from);
  Box2(Box2&& from) noexcept
    : Box2() {
    *this = ::std::move(from);
  }

  inline Box2& operator=(const Box2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box2& operator=(Box2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Box2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box2* internal_default_instance() {
    return reinterpret_cast<const Box2*>(
               &_Box2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Box2& a, Box2& b) {
    a.Swap(&b);
  }
  inline void Swap(Box2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Box2* New() const final {
    return CreateMaybeMessage<Box2>(nullptr);
  }

  Box2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Box2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Box2& from);
  void MergeFrom(const Box2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Box2";
  }
  protected:
  explicit Box2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // .bosdyn.api.Vec2 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::bosdyn::api::Vec2& size() const;
  ::bosdyn::api::Vec2* release_size();
  ::bosdyn::api::Vec2* mutable_size();
  void set_allocated_size(::bosdyn::api::Vec2* size);
  private:
  const ::bosdyn::api::Vec2& _internal_size() const;
  ::bosdyn::api::Vec2* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::bosdyn::api::Vec2* size);
  ::bosdyn::api::Vec2* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Box2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec2* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Box2WithFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Box2WithFrame) */ {
 public:
  inline Box2WithFrame() : Box2WithFrame(nullptr) {}
  virtual ~Box2WithFrame();

  Box2WithFrame(const Box2WithFrame& from);
  Box2WithFrame(Box2WithFrame&& from) noexcept
    : Box2WithFrame() {
    *this = ::std::move(from);
  }

  inline Box2WithFrame& operator=(const Box2WithFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box2WithFrame& operator=(Box2WithFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Box2WithFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box2WithFrame* internal_default_instance() {
    return reinterpret_cast<const Box2WithFrame*>(
               &_Box2WithFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Box2WithFrame& a, Box2WithFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(Box2WithFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box2WithFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Box2WithFrame* New() const final {
    return CreateMaybeMessage<Box2WithFrame>(nullptr);
  }

  Box2WithFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Box2WithFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Box2WithFrame& from);
  void MergeFrom(const Box2WithFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box2WithFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Box2WithFrame";
  }
  protected:
  explicit Box2WithFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kBoxFieldNumber = 1,
    kFrameNameTformBoxFieldNumber = 3,
  };
  // string frame_name = 2;
  void clear_frame_name();
  const std::string& frame_name() const;
  void set_frame_name(const std::string& value);
  void set_frame_name(std::string&& value);
  void set_frame_name(const char* value);
  void set_frame_name(const char* value, size_t size);
  std::string* mutable_frame_name();
  std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Box2 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::bosdyn::api::Box2& box() const;
  ::bosdyn::api::Box2* release_box();
  ::bosdyn::api::Box2* mutable_box();
  void set_allocated_box(::bosdyn::api::Box2* box);
  private:
  const ::bosdyn::api::Box2& _internal_box() const;
  ::bosdyn::api::Box2* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::bosdyn::api::Box2* box);
  ::bosdyn::api::Box2* unsafe_arena_release_box();

  // .bosdyn.api.SE3Pose frame_name_tform_box = 3;
  bool has_frame_name_tform_box() const;
  private:
  bool _internal_has_frame_name_tform_box() const;
  public:
  void clear_frame_name_tform_box();
  const ::bosdyn::api::SE3Pose& frame_name_tform_box() const;
  ::bosdyn::api::SE3Pose* release_frame_name_tform_box();
  ::bosdyn::api::SE3Pose* mutable_frame_name_tform_box();
  void set_allocated_frame_name_tform_box(::bosdyn::api::SE3Pose* frame_name_tform_box);
  private:
  const ::bosdyn::api::SE3Pose& _internal_frame_name_tform_box() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_frame_name_tform_box();
  public:
  void unsafe_arena_set_allocated_frame_name_tform_box(
      ::bosdyn::api::SE3Pose* frame_name_tform_box);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_frame_name_tform_box();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Box2WithFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
  ::bosdyn::api::Box2* box_;
  ::bosdyn::api::SE3Pose* frame_name_tform_box_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Box3 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Box3) */ {
 public:
  inline Box3() : Box3(nullptr) {}
  virtual ~Box3();

  Box3(const Box3& from);
  Box3(Box3&& from) noexcept
    : Box3() {
    *this = ::std::move(from);
  }

  inline Box3& operator=(const Box3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box3& operator=(Box3&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Box3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box3* internal_default_instance() {
    return reinterpret_cast<const Box3*>(
               &_Box3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Box3& a, Box3& b) {
    a.Swap(&b);
  }
  inline void Swap(Box3* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Box3* New() const final {
    return CreateMaybeMessage<Box3>(nullptr);
  }

  Box3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Box3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Box3& from);
  void MergeFrom(const Box3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Box3";
  }
  protected:
  explicit Box3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // .bosdyn.api.Vec3 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  const ::bosdyn::api::Vec3& size() const;
  ::bosdyn::api::Vec3* release_size();
  ::bosdyn::api::Vec3* mutable_size();
  void set_allocated_size(::bosdyn::api::Vec3* size);
  private:
  const ::bosdyn::api::Vec3& _internal_size() const;
  ::bosdyn::api::Vec3* _internal_mutable_size();
  public:
  void unsafe_arena_set_allocated_size(
      ::bosdyn::api::Vec3* size);
  ::bosdyn::api::Vec3* unsafe_arena_release_size();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Box3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec3* size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Box3WithFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Box3WithFrame) */ {
 public:
  inline Box3WithFrame() : Box3WithFrame(nullptr) {}
  virtual ~Box3WithFrame();

  Box3WithFrame(const Box3WithFrame& from);
  Box3WithFrame(Box3WithFrame&& from) noexcept
    : Box3WithFrame() {
    *this = ::std::move(from);
  }

  inline Box3WithFrame& operator=(const Box3WithFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box3WithFrame& operator=(Box3WithFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Box3WithFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box3WithFrame* internal_default_instance() {
    return reinterpret_cast<const Box3WithFrame*>(
               &_Box3WithFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Box3WithFrame& a, Box3WithFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(Box3WithFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box3WithFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Box3WithFrame* New() const final {
    return CreateMaybeMessage<Box3WithFrame>(nullptr);
  }

  Box3WithFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Box3WithFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Box3WithFrame& from);
  void MergeFrom(const Box3WithFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box3WithFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Box3WithFrame";
  }
  protected:
  explicit Box3WithFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameFieldNumber = 2,
    kBoxFieldNumber = 1,
    kFrameNameTformBoxFieldNumber = 3,
  };
  // string frame_name = 2;
  void clear_frame_name();
  const std::string& frame_name() const;
  void set_frame_name(const std::string& value);
  void set_frame_name(std::string&& value);
  void set_frame_name(const char* value);
  void set_frame_name(const char* value, size_t size);
  std::string* mutable_frame_name();
  std::string* release_frame_name();
  void set_allocated_frame_name(std::string* frame_name);
  private:
  const std::string& _internal_frame_name() const;
  void _internal_set_frame_name(const std::string& value);
  std::string* _internal_mutable_frame_name();
  public:

  // .bosdyn.api.Box3 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::bosdyn::api::Box3& box() const;
  ::bosdyn::api::Box3* release_box();
  ::bosdyn::api::Box3* mutable_box();
  void set_allocated_box(::bosdyn::api::Box3* box);
  private:
  const ::bosdyn::api::Box3& _internal_box() const;
  ::bosdyn::api::Box3* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::bosdyn::api::Box3* box);
  ::bosdyn::api::Box3* unsafe_arena_release_box();

  // .bosdyn.api.SE3Pose frame_name_tform_box = 3;
  bool has_frame_name_tform_box() const;
  private:
  bool _internal_has_frame_name_tform_box() const;
  public:
  void clear_frame_name_tform_box();
  const ::bosdyn::api::SE3Pose& frame_name_tform_box() const;
  ::bosdyn::api::SE3Pose* release_frame_name_tform_box();
  ::bosdyn::api::SE3Pose* mutable_frame_name_tform_box();
  void set_allocated_frame_name_tform_box(::bosdyn::api::SE3Pose* frame_name_tform_box);
  private:
  const ::bosdyn::api::SE3Pose& _internal_frame_name_tform_box() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_frame_name_tform_box();
  public:
  void unsafe_arena_set_allocated_frame_name_tform_box(
      ::bosdyn::api::SE3Pose* frame_name_tform_box);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_frame_name_tform_box();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Box3WithFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_;
  ::bosdyn::api::Box3* box_;
  ::bosdyn::api::SE3Pose* frame_name_tform_box_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class SE3Covariance PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SE3Covariance) */ {
 public:
  inline SE3Covariance() : SE3Covariance(nullptr) {}
  virtual ~SE3Covariance();

  SE3Covariance(const SE3Covariance& from);
  SE3Covariance(SE3Covariance&& from) noexcept
    : SE3Covariance() {
    *this = ::std::move(from);
  }

  inline SE3Covariance& operator=(const SE3Covariance& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE3Covariance& operator=(SE3Covariance&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SE3Covariance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SE3Covariance* internal_default_instance() {
    return reinterpret_cast<const SE3Covariance*>(
               &_SE3Covariance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SE3Covariance& a, SE3Covariance& b) {
    a.Swap(&b);
  }
  inline void Swap(SE3Covariance* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE3Covariance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE3Covariance* New() const final {
    return CreateMaybeMessage<SE3Covariance>(nullptr);
  }

  SE3Covariance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE3Covariance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SE3Covariance& from);
  void MergeFrom(const SE3Covariance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE3Covariance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SE3Covariance";
  }
  protected:
  explicit SE3Covariance(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawVarianceFieldNumber = 2,
    kCovXxFieldNumber = 3,
    kCovXyFieldNumber = 4,
    kCovXzFieldNumber = 5,
    kCovYxFieldNumber = 6,
    kCovYyFieldNumber = 7,
    kCovYzFieldNumber = 8,
    kCovZxFieldNumber = 9,
    kCovZyFieldNumber = 10,
    kCovZzFieldNumber = 11,
  };
  // double yaw_variance = 2;
  void clear_yaw_variance();
  double yaw_variance() const;
  void set_yaw_variance(double value);
  private:
  double _internal_yaw_variance() const;
  void _internal_set_yaw_variance(double value);
  public:

  // double cov_xx = 3;
  void clear_cov_xx();
  double cov_xx() const;
  void set_cov_xx(double value);
  private:
  double _internal_cov_xx() const;
  void _internal_set_cov_xx(double value);
  public:

  // double cov_xy = 4;
  void clear_cov_xy();
  double cov_xy() const;
  void set_cov_xy(double value);
  private:
  double _internal_cov_xy() const;
  void _internal_set_cov_xy(double value);
  public:

  // double cov_xz = 5;
  void clear_cov_xz();
  double cov_xz() const;
  void set_cov_xz(double value);
  private:
  double _internal_cov_xz() const;
  void _internal_set_cov_xz(double value);
  public:

  // double cov_yx = 6;
  void clear_cov_yx();
  double cov_yx() const;
  void set_cov_yx(double value);
  private:
  double _internal_cov_yx() const;
  void _internal_set_cov_yx(double value);
  public:

  // double cov_yy = 7;
  void clear_cov_yy();
  double cov_yy() const;
  void set_cov_yy(double value);
  private:
  double _internal_cov_yy() const;
  void _internal_set_cov_yy(double value);
  public:

  // double cov_yz = 8;
  void clear_cov_yz();
  double cov_yz() const;
  void set_cov_yz(double value);
  private:
  double _internal_cov_yz() const;
  void _internal_set_cov_yz(double value);
  public:

  // double cov_zx = 9;
  void clear_cov_zx();
  double cov_zx() const;
  void set_cov_zx(double value);
  private:
  double _internal_cov_zx() const;
  void _internal_set_cov_zx(double value);
  public:

  // double cov_zy = 10;
  void clear_cov_zy();
  double cov_zy() const;
  void set_cov_zy(double value);
  private:
  double _internal_cov_zy() const;
  void _internal_set_cov_zy(double value);
  public:

  // double cov_zz = 11;
  void clear_cov_zz();
  double cov_zz() const;
  void set_cov_zz(double value);
  private:
  double _internal_cov_zz() const;
  void _internal_set_cov_zz(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SE3Covariance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double yaw_variance_;
  double cov_xx_;
  double cov_xy_;
  double cov_xz_;
  double cov_yx_;
  double cov_yy_;
  double cov_yz_;
  double cov_zx_;
  double cov_zy_;
  double cov_zz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class EulerZXYRate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EulerZXYRate) */ {
 public:
  inline EulerZXYRate() : EulerZXYRate(nullptr) {}
  virtual ~EulerZXYRate();

  EulerZXYRate(const EulerZXYRate& from);
  EulerZXYRate(EulerZXYRate&& from) noexcept
    : EulerZXYRate() {
    *this = ::std::move(from);
  }

  inline EulerZXYRate& operator=(const EulerZXYRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EulerZXYRate& operator=(EulerZXYRate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EulerZXYRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EulerZXYRate* internal_default_instance() {
    return reinterpret_cast<const EulerZXYRate*>(
               &_EulerZXYRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EulerZXYRate& a, EulerZXYRate& b) {
    a.Swap(&b);
  }
  inline void Swap(EulerZXYRate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EulerZXYRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EulerZXYRate* New() const final {
    return CreateMaybeMessage<EulerZXYRate>(nullptr);
  }

  EulerZXYRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EulerZXYRate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EulerZXYRate& from);
  void MergeFrom(const EulerZXYRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EulerZXYRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EulerZXYRate";
  }
  protected:
  explicit EulerZXYRate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawFieldNumber = 1,
    kRollFieldNumber = 2,
    kPitchFieldNumber = 3,
  };
  // double yaw = 1;
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // double roll = 2;
  void clear_roll();
  double roll() const;
  void set_roll(double value);
  private:
  double _internal_roll() const;
  void _internal_set_roll(double value);
  public:

  // double pitch = 3;
  void clear_pitch();
  double pitch() const;
  void set_pitch(double value);
  private:
  double _internal_pitch() const;
  void _internal_set_pitch(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EulerZXYRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double yaw_;
  double roll_;
  double pitch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class PolyLine PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PolyLine) */ {
 public:
  inline PolyLine() : PolyLine(nullptr) {}
  virtual ~PolyLine();

  PolyLine(const PolyLine& from);
  PolyLine(PolyLine&& from) noexcept
    : PolyLine() {
    *this = ::std::move(from);
  }

  inline PolyLine& operator=(const PolyLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolyLine& operator=(PolyLine&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PolyLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PolyLine* internal_default_instance() {
    return reinterpret_cast<const PolyLine*>(
               &_PolyLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PolyLine& a, PolyLine& b) {
    a.Swap(&b);
  }
  inline void Swap(PolyLine* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolyLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PolyLine* New() const final {
    return CreateMaybeMessage<PolyLine>(nullptr);
  }

  PolyLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PolyLine>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PolyLine& from);
  void MergeFrom(const PolyLine& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolyLine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PolyLine";
  }
  protected:
  explicit PolyLine(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .bosdyn.api.Vec2 points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::bosdyn::api::Vec2* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >*
      mutable_points();
  private:
  const ::bosdyn::api::Vec2& _internal_points(int index) const;
  ::bosdyn::api::Vec2* _internal_add_points();
  public:
  const ::bosdyn::api::Vec2& points(int index) const;
  ::bosdyn::api::Vec2* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >&
      points() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.PolyLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 > points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Polygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  virtual ~Polygon();

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return CreateMaybeMessage<Polygon>(nullptr);
  }

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVertexesFieldNumber = 1,
  };
  // repeated .bosdyn.api.Vec2 vertexes = 1;
  int vertexes_size() const;
  private:
  int _internal_vertexes_size() const;
  public:
  void clear_vertexes();
  ::bosdyn::api::Vec2* mutable_vertexes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >*
      mutable_vertexes();
  private:
  const ::bosdyn::api::Vec2& _internal_vertexes(int index) const;
  ::bosdyn::api::Vec2* _internal_add_vertexes();
  public:
  const ::bosdyn::api::Vec2& vertexes(int index) const;
  ::bosdyn::api::Vec2* add_vertexes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >&
      vertexes() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 > vertexes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Circle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Circle) */ {
 public:
  inline Circle() : Circle(nullptr) {}
  virtual ~Circle();

  Circle(const Circle& from);
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circle& operator=(Circle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Circle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }
  inline void Swap(Circle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Circle* New() const final {
    return CreateMaybeMessage<Circle>(nullptr);
  }

  Circle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Circle& from);
  void MergeFrom(const Circle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Circle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Circle";
  }
  protected:
  explicit Circle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterPtFieldNumber = 1,
    kRadiusFieldNumber = 2,
  };
  // .bosdyn.api.Vec2 center_pt = 1;
  bool has_center_pt() const;
  private:
  bool _internal_has_center_pt() const;
  public:
  void clear_center_pt();
  const ::bosdyn::api::Vec2& center_pt() const;
  ::bosdyn::api::Vec2* release_center_pt();
  ::bosdyn::api::Vec2* mutable_center_pt();
  void set_allocated_center_pt(::bosdyn::api::Vec2* center_pt);
  private:
  const ::bosdyn::api::Vec2& _internal_center_pt() const;
  ::bosdyn::api::Vec2* _internal_mutable_center_pt();
  public:
  void unsafe_arena_set_allocated_center_pt(
      ::bosdyn::api::Vec2* center_pt);
  ::bosdyn::api::Vec2* unsafe_arena_release_center_pt();

  // double radius = 2;
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Circle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec2* center_pt_;
  double radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Area PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Area) */ {
 public:
  inline Area() : Area(nullptr) {}
  virtual ~Area();

  Area(const Area& from);
  Area(Area&& from) noexcept
    : Area() {
    *this = ::std::move(from);
  }

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }
  inline Area& operator=(Area&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Area& default_instance();

  enum GeometryCase {
    kPolygon = 1,
    kCircle = 2,
    GEOMETRY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Area* internal_default_instance() {
    return reinterpret_cast<const Area*>(
               &_Area_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Area& a, Area& b) {
    a.Swap(&b);
  }
  inline void Swap(Area* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Area* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Area* New() const final {
    return CreateMaybeMessage<Area>(nullptr);
  }

  Area* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Area>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Area& from);
  void MergeFrom(const Area& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Area* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Area";
  }
  protected:
  explicit Area(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonFieldNumber = 1,
    kCircleFieldNumber = 2,
  };
  // .bosdyn.api.Polygon polygon = 1;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::bosdyn::api::Polygon& polygon() const;
  ::bosdyn::api::Polygon* release_polygon();
  ::bosdyn::api::Polygon* mutable_polygon();
  void set_allocated_polygon(::bosdyn::api::Polygon* polygon);
  private:
  const ::bosdyn::api::Polygon& _internal_polygon() const;
  ::bosdyn::api::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::bosdyn::api::Polygon* polygon);
  ::bosdyn::api::Polygon* unsafe_arena_release_polygon();

  // .bosdyn.api.Circle circle = 2;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;
  public:
  void clear_circle();
  const ::bosdyn::api::Circle& circle() const;
  ::bosdyn::api::Circle* release_circle();
  ::bosdyn::api::Circle* mutable_circle();
  void set_allocated_circle(::bosdyn::api::Circle* circle);
  private:
  const ::bosdyn::api::Circle& _internal_circle() const;
  ::bosdyn::api::Circle* _internal_mutable_circle();
  public:
  void unsafe_arena_set_allocated_circle(
      ::bosdyn::api::Circle* circle);
  ::bosdyn::api::Circle* unsafe_arena_release_circle();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.Area)
 private:
  class _Internal;
  void set_has_polygon();
  void set_has_circle();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union GeometryUnion {
    GeometryUnion() {}
    ::bosdyn::api::Polygon* polygon_;
    ::bosdyn::api::Circle* circle_;
  } geometry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Volume PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Volume) */ {
 public:
  inline Volume() : Volume(nullptr) {}
  virtual ~Volume();

  Volume(const Volume& from);
  Volume(Volume&& from) noexcept
    : Volume() {
    *this = ::std::move(from);
  }

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }
  inline Volume& operator=(Volume&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Volume& default_instance();

  enum GeometryCase {
    kBox = 1,
    GEOMETRY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Volume* internal_default_instance() {
    return reinterpret_cast<const Volume*>(
               &_Volume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Volume& a, Volume& b) {
    a.Swap(&b);
  }
  inline void Swap(Volume* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Volume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Volume* New() const final {
    return CreateMaybeMessage<Volume>(nullptr);
  }

  Volume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Volume>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Volume& from);
  void MergeFrom(const Volume& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Volume* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Volume";
  }
  protected:
  explicit Volume(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoxFieldNumber = 1,
  };
  // .bosdyn.api.Vec3 box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::bosdyn::api::Vec3& box() const;
  ::bosdyn::api::Vec3* release_box();
  ::bosdyn::api::Vec3* mutable_box();
  void set_allocated_box(::bosdyn::api::Vec3* box);
  private:
  const ::bosdyn::api::Vec3& _internal_box() const;
  ::bosdyn::api::Vec3* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::bosdyn::api::Vec3* box);
  ::bosdyn::api::Vec3* unsafe_arena_release_box();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.Volume)
 private:
  class _Internal;
  void set_has_box();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union GeometryUnion {
    GeometryUnion() {}
    ::bosdyn::api::Vec3* box_;
  } geometry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Vec2Value PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vec2Value) */ {
 public:
  inline Vec2Value() : Vec2Value(nullptr) {}
  virtual ~Vec2Value();

  Vec2Value(const Vec2Value& from);
  Vec2Value(Vec2Value&& from) noexcept
    : Vec2Value() {
    *this = ::std::move(from);
  }

  inline Vec2Value& operator=(const Vec2Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2Value& operator=(Vec2Value&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec2Value* internal_default_instance() {
    return reinterpret_cast<const Vec2Value*>(
               &_Vec2Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Vec2Value& a, Vec2Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2Value* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2Value* New() const final {
    return CreateMaybeMessage<Vec2Value>(nullptr);
  }

  Vec2Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2Value>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2Value& from);
  void MergeFrom(const Vec2Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vec2Value";
  }
  protected:
  explicit Vec2Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // .google.protobuf.DoubleValue x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& x() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_x();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_x();
  void set_allocated_x(PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_x() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_x();

  // .google.protobuf.DoubleValue y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& y() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_y();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_y();
  void set_allocated_y(PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_y() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_y();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vec2Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* x_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// -------------------------------------------------------------------

class Vec3Value PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Vec3Value) */ {
 public:
  inline Vec3Value() : Vec3Value(nullptr) {}
  virtual ~Vec3Value();

  Vec3Value(const Vec3Value& from);
  Vec3Value(Vec3Value&& from) noexcept
    : Vec3Value() {
    *this = ::std::move(from);
  }

  inline Vec3Value& operator=(const Vec3Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3Value& operator=(Vec3Value&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec3Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3Value* internal_default_instance() {
    return reinterpret_cast<const Vec3Value*>(
               &_Vec3Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Vec3Value& a, Vec3Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3Value* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec3Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec3Value* New() const final {
    return CreateMaybeMessage<Vec3Value>(nullptr);
  }

  Vec3Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec3Value>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec3Value& from);
  void MergeFrom(const Vec3Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Vec3Value";
  }
  protected:
  explicit Vec3Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fgeometry_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .google.protobuf.DoubleValue x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& x() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_x();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_x();
  void set_allocated_x(PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_x() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      PROTOBUF_NAMESPACE_ID::DoubleValue* x);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_x();

  // .google.protobuf.DoubleValue y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& y() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_y();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_y();
  void set_allocated_y(PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_y() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      PROTOBUF_NAMESPACE_ID::DoubleValue* y);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_y();

  // .google.protobuf.DoubleValue z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& z() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_z();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_z();
  void set_allocated_z(PROTOBUF_NAMESPACE_ID::DoubleValue* z);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_z() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_z();
  public:
  void unsafe_arena_set_allocated_z(
      PROTOBUF_NAMESPACE_ID::DoubleValue* z);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Vec3Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* x_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* y_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fgeometry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vec2

// double x = 1;
inline void Vec2::clear_x() {
  x_ = 0;
}
inline double Vec2::_internal_x() const {
  return x_;
}
inline double Vec2::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec2.x)
  return _internal_x();
}
inline void Vec2::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vec2::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec2.x)
}

// double y = 2;
inline void Vec2::clear_y() {
  y_ = 0;
}
inline double Vec2::_internal_y() const {
  return y_;
}
inline double Vec2::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec2.y)
  return _internal_y();
}
inline void Vec2::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vec2::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec2.y)
}

// -------------------------------------------------------------------

// Vec3

// double x = 1;
inline void Vec3::clear_x() {
  x_ = 0;
}
inline double Vec3::_internal_x() const {
  return x_;
}
inline double Vec3::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3.x)
  return _internal_x();
}
inline void Vec3::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vec3::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec3.x)
}

// double y = 2;
inline void Vec3::clear_y() {
  y_ = 0;
}
inline double Vec3::_internal_y() const {
  return y_;
}
inline double Vec3::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3.y)
  return _internal_y();
}
inline void Vec3::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vec3::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec3.y)
}

// double z = 3;
inline void Vec3::clear_z() {
  z_ = 0;
}
inline double Vec3::_internal_z() const {
  return z_;
}
inline double Vec3::z() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3.z)
  return _internal_z();
}
inline void Vec3::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Vec3::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Vec3.z)
}

// -------------------------------------------------------------------

// CylindricalCoordinate

// double r = 1;
inline void CylindricalCoordinate::clear_r() {
  r_ = 0;
}
inline double CylindricalCoordinate::_internal_r() const {
  return r_;
}
inline double CylindricalCoordinate::r() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CylindricalCoordinate.r)
  return _internal_r();
}
inline void CylindricalCoordinate::_internal_set_r(double value) {
  
  r_ = value;
}
inline void CylindricalCoordinate::set_r(double value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CylindricalCoordinate.r)
}

// double theta = 2;
inline void CylindricalCoordinate::clear_theta() {
  theta_ = 0;
}
inline double CylindricalCoordinate::_internal_theta() const {
  return theta_;
}
inline double CylindricalCoordinate::theta() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CylindricalCoordinate.theta)
  return _internal_theta();
}
inline void CylindricalCoordinate::_internal_set_theta(double value) {
  
  theta_ = value;
}
inline void CylindricalCoordinate::set_theta(double value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CylindricalCoordinate.theta)
}

// double z = 3;
inline void CylindricalCoordinate::clear_z() {
  z_ = 0;
}
inline double CylindricalCoordinate::_internal_z() const {
  return z_;
}
inline double CylindricalCoordinate::z() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CylindricalCoordinate.z)
  return _internal_z();
}
inline void CylindricalCoordinate::_internal_set_z(double value) {
  
  z_ = value;
}
inline void CylindricalCoordinate::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.CylindricalCoordinate.z)
}

// -------------------------------------------------------------------

// Quaternion

// double x = 1;
inline void Quaternion::clear_x() {
  x_ = 0;
}
inline double Quaternion::_internal_x() const {
  return x_;
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Quaternion::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quaternion.x)
}

// double y = 2;
inline void Quaternion::clear_y() {
  y_ = 0;
}
inline double Quaternion::_internal_y() const {
  return y_;
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Quaternion::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quaternion.y)
}

// double z = 3;
inline void Quaternion::clear_z() {
  z_ = 0;
}
inline double Quaternion::_internal_z() const {
  return z_;
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::_internal_set_z(double value) {
  
  z_ = value;
}
inline void Quaternion::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quaternion.z)
}

// double w = 4;
inline void Quaternion::clear_w() {
  w_ = 0;
}
inline double Quaternion::_internal_w() const {
  return w_;
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::_internal_set_w(double value) {
  
  w_ = value;
}
inline void Quaternion::set_w(double value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Quaternion.w)
}

// -------------------------------------------------------------------

// Plane

// .bosdyn.api.Vec3 point = 1;
inline bool Plane::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool Plane::has_point() const {
  return _internal_has_point();
}
inline void Plane::clear_point() {
  if (GetArena() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Plane::_internal_point() const {
  const ::bosdyn::api::Vec3* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Plane::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Plane.point)
  return _internal_point();
}
inline void Plane::unsafe_arena_set_allocated_point(
    ::bosdyn::api::Vec3* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Plane.point)
}
inline ::bosdyn::api::Vec3* Plane::release_point() {
  
  ::bosdyn::api::Vec3* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* Plane::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Plane.point)
  
  ::bosdyn::api::Vec3* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Plane::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::bosdyn::api::Vec3* Plane::mutable_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Plane.point)
  return _internal_mutable_point();
}
inline void Plane::set_allocated_point(::bosdyn::api::Vec3* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Plane.point)
}

// .bosdyn.api.Vec3 normal = 2;
inline bool Plane::_internal_has_normal() const {
  return this != internal_default_instance() && normal_ != nullptr;
}
inline bool Plane::has_normal() const {
  return _internal_has_normal();
}
inline void Plane::clear_normal() {
  if (GetArena() == nullptr && normal_ != nullptr) {
    delete normal_;
  }
  normal_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Plane::_internal_normal() const {
  const ::bosdyn::api::Vec3* p = normal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Plane::normal() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Plane.normal)
  return _internal_normal();
}
inline void Plane::unsafe_arena_set_allocated_normal(
    ::bosdyn::api::Vec3* normal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(normal_);
  }
  normal_ = normal;
  if (normal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Plane.normal)
}
inline ::bosdyn::api::Vec3* Plane::release_normal() {
  
  ::bosdyn::api::Vec3* temp = normal_;
  normal_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* Plane::unsafe_arena_release_normal() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Plane.normal)
  
  ::bosdyn::api::Vec3* temp = normal_;
  normal_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Plane::_internal_mutable_normal() {
  
  if (normal_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    normal_ = p;
  }
  return normal_;
}
inline ::bosdyn::api::Vec3* Plane::mutable_normal() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Plane.normal)
  return _internal_mutable_normal();
}
inline void Plane::set_allocated_normal(::bosdyn::api::Vec3* normal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete normal_;
  }
  if (normal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(normal);
    if (message_arena != submessage_arena) {
      normal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    
  } else {
    
  }
  normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Plane.normal)
}

// -------------------------------------------------------------------

// SE2Pose

// .bosdyn.api.Vec2 position = 1;
inline bool SE2Pose::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SE2Pose::has_position() const {
  return _internal_has_position();
}
inline void SE2Pose::clear_position() {
  if (GetArena() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::bosdyn::api::Vec2& SE2Pose::_internal_position() const {
  const ::bosdyn::api::Vec2* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec2*>(
      &::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& SE2Pose::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2Pose.position)
  return _internal_position();
}
inline void SE2Pose::unsafe_arena_set_allocated_position(
    ::bosdyn::api::Vec2* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2Pose.position)
}
inline ::bosdyn::api::Vec2* SE2Pose::release_position() {
  
  ::bosdyn::api::Vec2* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec2* SE2Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2Pose.position)
  
  ::bosdyn::api::Vec2* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* SE2Pose::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::bosdyn::api::Vec2* SE2Pose::mutable_position() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2Pose.position)
  return _internal_mutable_position();
}
inline void SE2Pose::set_allocated_position(::bosdyn::api::Vec2* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2Pose.position)
}

// double angle = 2;
inline void SE2Pose::clear_angle() {
  angle_ = 0;
}
inline double SE2Pose::_internal_angle() const {
  return angle_;
}
inline double SE2Pose::angle() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2Pose.angle)
  return _internal_angle();
}
inline void SE2Pose::_internal_set_angle(double value) {
  
  angle_ = value;
}
inline void SE2Pose::set_angle(double value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE2Pose.angle)
}

// -------------------------------------------------------------------

// SE2Velocity

// .bosdyn.api.Vec2 linear = 1;
inline bool SE2Velocity::_internal_has_linear() const {
  return this != internal_default_instance() && linear_ != nullptr;
}
inline bool SE2Velocity::has_linear() const {
  return _internal_has_linear();
}
inline void SE2Velocity::clear_linear() {
  if (GetArena() == nullptr && linear_ != nullptr) {
    delete linear_;
  }
  linear_ = nullptr;
}
inline const ::bosdyn::api::Vec2& SE2Velocity::_internal_linear() const {
  const ::bosdyn::api::Vec2* p = linear_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec2*>(
      &::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& SE2Velocity::linear() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2Velocity.linear)
  return _internal_linear();
}
inline void SE2Velocity::unsafe_arena_set_allocated_linear(
    ::bosdyn::api::Vec2* linear) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_);
  }
  linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2Velocity.linear)
}
inline ::bosdyn::api::Vec2* SE2Velocity::release_linear() {
  
  ::bosdyn::api::Vec2* temp = linear_;
  linear_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec2* SE2Velocity::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2Velocity.linear)
  
  ::bosdyn::api::Vec2* temp = linear_;
  linear_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* SE2Velocity::_internal_mutable_linear() {
  
  if (linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArena());
    linear_ = p;
  }
  return linear_;
}
inline ::bosdyn::api::Vec2* SE2Velocity::mutable_linear() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2Velocity.linear)
  return _internal_mutable_linear();
}
inline void SE2Velocity::set_allocated_linear(::bosdyn::api::Vec2* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    
  } else {
    
  }
  linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2Velocity.linear)
}

// double angular = 2;
inline void SE2Velocity::clear_angular() {
  angular_ = 0;
}
inline double SE2Velocity::_internal_angular() const {
  return angular_;
}
inline double SE2Velocity::angular() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2Velocity.angular)
  return _internal_angular();
}
inline void SE2Velocity::_internal_set_angular(double value) {
  
  angular_ = value;
}
inline void SE2Velocity::set_angular(double value) {
  _internal_set_angular(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE2Velocity.angular)
}

// -------------------------------------------------------------------

// SE2VelocityLimit

// .bosdyn.api.SE2Velocity max_vel = 1;
inline bool SE2VelocityLimit::_internal_has_max_vel() const {
  return this != internal_default_instance() && max_vel_ != nullptr;
}
inline bool SE2VelocityLimit::has_max_vel() const {
  return _internal_has_max_vel();
}
inline void SE2VelocityLimit::clear_max_vel() {
  if (GetArena() == nullptr && max_vel_ != nullptr) {
    delete max_vel_;
  }
  max_vel_ = nullptr;
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityLimit::_internal_max_vel() const {
  const ::bosdyn::api::SE2Velocity* p = max_vel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE2Velocity*>(
      &::bosdyn::api::_SE2Velocity_default_instance_);
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityLimit::max_vel() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2VelocityLimit.max_vel)
  return _internal_max_vel();
}
inline void SE2VelocityLimit::unsafe_arena_set_allocated_max_vel(
    ::bosdyn::api::SE2Velocity* max_vel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_vel_);
  }
  max_vel_ = max_vel;
  if (max_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2VelocityLimit.max_vel)
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::release_max_vel() {
  
  ::bosdyn::api::SE2Velocity* temp = max_vel_;
  max_vel_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::unsafe_arena_release_max_vel() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2VelocityLimit.max_vel)
  
  ::bosdyn::api::SE2Velocity* temp = max_vel_;
  max_vel_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::_internal_mutable_max_vel() {
  
  if (max_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Velocity>(GetArena());
    max_vel_ = p;
  }
  return max_vel_;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::mutable_max_vel() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2VelocityLimit.max_vel)
  return _internal_mutable_max_vel();
}
inline void SE2VelocityLimit::set_allocated_max_vel(::bosdyn::api::SE2Velocity* max_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete max_vel_;
  }
  if (max_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(max_vel);
    if (message_arena != submessage_arena) {
      max_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_vel, submessage_arena);
    }
    
  } else {
    
  }
  max_vel_ = max_vel;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2VelocityLimit.max_vel)
}

// .bosdyn.api.SE2Velocity min_vel = 2;
inline bool SE2VelocityLimit::_internal_has_min_vel() const {
  return this != internal_default_instance() && min_vel_ != nullptr;
}
inline bool SE2VelocityLimit::has_min_vel() const {
  return _internal_has_min_vel();
}
inline void SE2VelocityLimit::clear_min_vel() {
  if (GetArena() == nullptr && min_vel_ != nullptr) {
    delete min_vel_;
  }
  min_vel_ = nullptr;
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityLimit::_internal_min_vel() const {
  const ::bosdyn::api::SE2Velocity* p = min_vel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE2Velocity*>(
      &::bosdyn::api::_SE2Velocity_default_instance_);
}
inline const ::bosdyn::api::SE2Velocity& SE2VelocityLimit::min_vel() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE2VelocityLimit.min_vel)
  return _internal_min_vel();
}
inline void SE2VelocityLimit::unsafe_arena_set_allocated_min_vel(
    ::bosdyn::api::SE2Velocity* min_vel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_vel_);
  }
  min_vel_ = min_vel;
  if (min_vel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE2VelocityLimit.min_vel)
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::release_min_vel() {
  
  ::bosdyn::api::SE2Velocity* temp = min_vel_;
  min_vel_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::unsafe_arena_release_min_vel() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE2VelocityLimit.min_vel)
  
  ::bosdyn::api::SE2Velocity* temp = min_vel_;
  min_vel_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::_internal_mutable_min_vel() {
  
  if (min_vel_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2Velocity>(GetArena());
    min_vel_ = p;
  }
  return min_vel_;
}
inline ::bosdyn::api::SE2Velocity* SE2VelocityLimit::mutable_min_vel() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE2VelocityLimit.min_vel)
  return _internal_mutable_min_vel();
}
inline void SE2VelocityLimit::set_allocated_min_vel(::bosdyn::api::SE2Velocity* min_vel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete min_vel_;
  }
  if (min_vel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(min_vel);
    if (message_arena != submessage_arena) {
      min_vel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_vel, submessage_arena);
    }
    
  } else {
    
  }
  min_vel_ = min_vel;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE2VelocityLimit.min_vel)
}

// -------------------------------------------------------------------

// SE3Pose

// .bosdyn.api.Vec3 position = 1;
inline bool SE3Pose::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SE3Pose::has_position() const {
  return _internal_has_position();
}
inline void SE3Pose::clear_position() {
  if (GetArena() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::bosdyn::api::Vec3& SE3Pose::_internal_position() const {
  const ::bosdyn::api::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& SE3Pose::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Pose.position)
  return _internal_position();
}
inline void SE3Pose::unsafe_arena_set_allocated_position(
    ::bosdyn::api::Vec3* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Pose.position)
}
inline ::bosdyn::api::Vec3* SE3Pose::release_position() {
  
  ::bosdyn::api::Vec3* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Pose::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Pose.position)
  
  ::bosdyn::api::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Pose::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::bosdyn::api::Vec3* SE3Pose::mutable_position() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Pose.position)
  return _internal_mutable_position();
}
inline void SE3Pose::set_allocated_position(::bosdyn::api::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Pose.position)
}

// .bosdyn.api.Quaternion rotation = 2;
inline bool SE3Pose::_internal_has_rotation() const {
  return this != internal_default_instance() && rotation_ != nullptr;
}
inline bool SE3Pose::has_rotation() const {
  return _internal_has_rotation();
}
inline void SE3Pose::clear_rotation() {
  if (GetArena() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
}
inline const ::bosdyn::api::Quaternion& SE3Pose::_internal_rotation() const {
  const ::bosdyn::api::Quaternion* p = rotation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Quaternion*>(
      &::bosdyn::api::_Quaternion_default_instance_);
}
inline const ::bosdyn::api::Quaternion& SE3Pose::rotation() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Pose.rotation)
  return _internal_rotation();
}
inline void SE3Pose::unsafe_arena_set_allocated_rotation(
    ::bosdyn::api::Quaternion* rotation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Pose.rotation)
}
inline ::bosdyn::api::Quaternion* SE3Pose::release_rotation() {
  
  ::bosdyn::api::Quaternion* temp = rotation_;
  rotation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Quaternion* SE3Pose::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Pose.rotation)
  
  ::bosdyn::api::Quaternion* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Quaternion* SE3Pose::_internal_mutable_rotation() {
  
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Quaternion>(GetArena());
    rotation_ = p;
  }
  return rotation_;
}
inline ::bosdyn::api::Quaternion* SE3Pose::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Pose.rotation)
  return _internal_mutable_rotation();
}
inline void SE3Pose::set_allocated_rotation(::bosdyn::api::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Pose.rotation)
}

// -------------------------------------------------------------------

// SE3Velocity

// .bosdyn.api.Vec3 linear = 1;
inline bool SE3Velocity::_internal_has_linear() const {
  return this != internal_default_instance() && linear_ != nullptr;
}
inline bool SE3Velocity::has_linear() const {
  return _internal_has_linear();
}
inline void SE3Velocity::clear_linear() {
  if (GetArena() == nullptr && linear_ != nullptr) {
    delete linear_;
  }
  linear_ = nullptr;
}
inline const ::bosdyn::api::Vec3& SE3Velocity::_internal_linear() const {
  const ::bosdyn::api::Vec3* p = linear_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& SE3Velocity::linear() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Velocity.linear)
  return _internal_linear();
}
inline void SE3Velocity::unsafe_arena_set_allocated_linear(
    ::bosdyn::api::Vec3* linear) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linear_);
  }
  linear_ = linear;
  if (linear) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Velocity.linear)
}
inline ::bosdyn::api::Vec3* SE3Velocity::release_linear() {
  
  ::bosdyn::api::Vec3* temp = linear_;
  linear_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Velocity::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Velocity.linear)
  
  ::bosdyn::api::Vec3* temp = linear_;
  linear_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Velocity::_internal_mutable_linear() {
  
  if (linear_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    linear_ = p;
  }
  return linear_;
}
inline ::bosdyn::api::Vec3* SE3Velocity::mutable_linear() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Velocity.linear)
  return _internal_mutable_linear();
}
inline void SE3Velocity::set_allocated_linear(::bosdyn::api::Vec3* linear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete linear_;
  }
  if (linear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(linear);
    if (message_arena != submessage_arena) {
      linear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear, submessage_arena);
    }
    
  } else {
    
  }
  linear_ = linear;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Velocity.linear)
}

// .bosdyn.api.Vec3 angular = 2;
inline bool SE3Velocity::_internal_has_angular() const {
  return this != internal_default_instance() && angular_ != nullptr;
}
inline bool SE3Velocity::has_angular() const {
  return _internal_has_angular();
}
inline void SE3Velocity::clear_angular() {
  if (GetArena() == nullptr && angular_ != nullptr) {
    delete angular_;
  }
  angular_ = nullptr;
}
inline const ::bosdyn::api::Vec3& SE3Velocity::_internal_angular() const {
  const ::bosdyn::api::Vec3* p = angular_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& SE3Velocity::angular() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Velocity.angular)
  return _internal_angular();
}
inline void SE3Velocity::unsafe_arena_set_allocated_angular(
    ::bosdyn::api::Vec3* angular) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(angular_);
  }
  angular_ = angular;
  if (angular) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SE3Velocity.angular)
}
inline ::bosdyn::api::Vec3* SE3Velocity::release_angular() {
  
  ::bosdyn::api::Vec3* temp = angular_;
  angular_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Velocity::unsafe_arena_release_angular() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SE3Velocity.angular)
  
  ::bosdyn::api::Vec3* temp = angular_;
  angular_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* SE3Velocity::_internal_mutable_angular() {
  
  if (angular_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    angular_ = p;
  }
  return angular_;
}
inline ::bosdyn::api::Vec3* SE3Velocity::mutable_angular() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SE3Velocity.angular)
  return _internal_mutable_angular();
}
inline void SE3Velocity::set_allocated_angular(::bosdyn::api::Vec3* angular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete angular_;
  }
  if (angular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(angular);
    if (message_arena != submessage_arena) {
      angular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, angular, submessage_arena);
    }
    
  } else {
    
  }
  angular_ = angular;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SE3Velocity.angular)
}

// -------------------------------------------------------------------

// Wrench

// .bosdyn.api.Vec3 force = 1;
inline bool Wrench::_internal_has_force() const {
  return this != internal_default_instance() && force_ != nullptr;
}
inline bool Wrench::has_force() const {
  return _internal_has_force();
}
inline void Wrench::clear_force() {
  if (GetArena() == nullptr && force_ != nullptr) {
    delete force_;
  }
  force_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Wrench::_internal_force() const {
  const ::bosdyn::api::Vec3* p = force_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Wrench::force() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Wrench.force)
  return _internal_force();
}
inline void Wrench::unsafe_arena_set_allocated_force(
    ::bosdyn::api::Vec3* force) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(force_);
  }
  force_ = force;
  if (force) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Wrench.force)
}
inline ::bosdyn::api::Vec3* Wrench::release_force() {
  
  ::bosdyn::api::Vec3* temp = force_;
  force_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* Wrench::unsafe_arena_release_force() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Wrench.force)
  
  ::bosdyn::api::Vec3* temp = force_;
  force_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Wrench::_internal_mutable_force() {
  
  if (force_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    force_ = p;
  }
  return force_;
}
inline ::bosdyn::api::Vec3* Wrench::mutable_force() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Wrench.force)
  return _internal_mutable_force();
}
inline void Wrench::set_allocated_force(::bosdyn::api::Vec3* force) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete force_;
  }
  if (force) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(force);
    if (message_arena != submessage_arena) {
      force = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, force, submessage_arena);
    }
    
  } else {
    
  }
  force_ = force;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Wrench.force)
}

// .bosdyn.api.Vec3 torque = 2;
inline bool Wrench::_internal_has_torque() const {
  return this != internal_default_instance() && torque_ != nullptr;
}
inline bool Wrench::has_torque() const {
  return _internal_has_torque();
}
inline void Wrench::clear_torque() {
  if (GetArena() == nullptr && torque_ != nullptr) {
    delete torque_;
  }
  torque_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Wrench::_internal_torque() const {
  const ::bosdyn::api::Vec3* p = torque_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Wrench::torque() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Wrench.torque)
  return _internal_torque();
}
inline void Wrench::unsafe_arena_set_allocated_torque(
    ::bosdyn::api::Vec3* torque) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(torque_);
  }
  torque_ = torque;
  if (torque) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Wrench.torque)
}
inline ::bosdyn::api::Vec3* Wrench::release_torque() {
  
  ::bosdyn::api::Vec3* temp = torque_;
  torque_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* Wrench::unsafe_arena_release_torque() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Wrench.torque)
  
  ::bosdyn::api::Vec3* temp = torque_;
  torque_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Wrench::_internal_mutable_torque() {
  
  if (torque_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    torque_ = p;
  }
  return torque_;
}
inline ::bosdyn::api::Vec3* Wrench::mutable_torque() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Wrench.torque)
  return _internal_mutable_torque();
}
inline void Wrench::set_allocated_torque(::bosdyn::api::Vec3* torque) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete torque_;
  }
  if (torque) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(torque);
    if (message_arena != submessage_arena) {
      torque = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torque, submessage_arena);
    }
    
  } else {
    
  }
  torque_ = torque;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Wrench.torque)
}

// -------------------------------------------------------------------

// FrameTreeSnapshot_ParentEdge

// string parent_frame_name = 1;
inline void FrameTreeSnapshot_ParentEdge::clear_parent_frame_name() {
  parent_frame_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FrameTreeSnapshot_ParentEdge::parent_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return _internal_parent_frame_name();
}
inline void FrameTreeSnapshot_ParentEdge::set_parent_frame_name(const std::string& value) {
  _internal_set_parent_frame_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}
inline std::string* FrameTreeSnapshot_ParentEdge::mutable_parent_frame_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return _internal_mutable_parent_frame_name();
}
inline const std::string& FrameTreeSnapshot_ParentEdge::_internal_parent_frame_name() const {
  return parent_frame_name_.Get();
}
inline void FrameTreeSnapshot_ParentEdge::_internal_set_parent_frame_name(const std::string& value) {
  
  parent_frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FrameTreeSnapshot_ParentEdge::set_parent_frame_name(std::string&& value) {
  
  parent_frame_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}
inline void FrameTreeSnapshot_ParentEdge::set_parent_frame_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  parent_frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}
inline void FrameTreeSnapshot_ParentEdge::set_parent_frame_name(const char* value,
    size_t size) {
  
  parent_frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}
inline std::string* FrameTreeSnapshot_ParentEdge::_internal_mutable_parent_frame_name() {
  
  return parent_frame_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FrameTreeSnapshot_ParentEdge::release_parent_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
  return parent_frame_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FrameTreeSnapshot_ParentEdge::set_allocated_parent_frame_name(std::string* parent_frame_name) {
  if (parent_frame_name != nullptr) {
    
  } else {
    
  }
  parent_frame_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_frame_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_frame_name)
}

// .bosdyn.api.SE3Pose parent_tform_child = 2;
inline bool FrameTreeSnapshot_ParentEdge::_internal_has_parent_tform_child() const {
  return this != internal_default_instance() && parent_tform_child_ != nullptr;
}
inline bool FrameTreeSnapshot_ParentEdge::has_parent_tform_child() const {
  return _internal_has_parent_tform_child();
}
inline void FrameTreeSnapshot_ParentEdge::clear_parent_tform_child() {
  if (GetArena() == nullptr && parent_tform_child_ != nullptr) {
    delete parent_tform_child_;
  }
  parent_tform_child_ = nullptr;
}
inline const ::bosdyn::api::SE3Pose& FrameTreeSnapshot_ParentEdge::_internal_parent_tform_child() const {
  const ::bosdyn::api::SE3Pose* p = parent_tform_child_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Pose*>(
      &::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& FrameTreeSnapshot_ParentEdge::parent_tform_child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  return _internal_parent_tform_child();
}
inline void FrameTreeSnapshot_ParentEdge::unsafe_arena_set_allocated_parent_tform_child(
    ::bosdyn::api::SE3Pose* parent_tform_child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_tform_child_);
  }
  parent_tform_child_ = parent_tform_child;
  if (parent_tform_child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
}
inline ::bosdyn::api::SE3Pose* FrameTreeSnapshot_ParentEdge::release_parent_tform_child() {
  
  ::bosdyn::api::SE3Pose* temp = parent_tform_child_;
  parent_tform_child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Pose* FrameTreeSnapshot_ParentEdge::unsafe_arena_release_parent_tform_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  
  ::bosdyn::api::SE3Pose* temp = parent_tform_child_;
  parent_tform_child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* FrameTreeSnapshot_ParentEdge::_internal_mutable_parent_tform_child() {
  
  if (parent_tform_child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArena());
    parent_tform_child_ = p;
  }
  return parent_tform_child_;
}
inline ::bosdyn::api::SE3Pose* FrameTreeSnapshot_ParentEdge::mutable_parent_tform_child() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
  return _internal_mutable_parent_tform_child();
}
inline void FrameTreeSnapshot_ParentEdge::set_allocated_parent_tform_child(::bosdyn::api::SE3Pose* parent_tform_child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete parent_tform_child_;
  }
  if (parent_tform_child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(parent_tform_child);
    if (message_arena != submessage_arena) {
      parent_tform_child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_tform_child, submessage_arena);
    }
    
  } else {
    
  }
  parent_tform_child_ = parent_tform_child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FrameTreeSnapshot.ParentEdge.parent_tform_child)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FrameTreeSnapshot

// map<string, .bosdyn.api.FrameTreeSnapshot.ParentEdge> child_to_parent_edge_map = 1;
inline int FrameTreeSnapshot::_internal_child_to_parent_edge_map_size() const {
  return child_to_parent_edge_map_.size();
}
inline int FrameTreeSnapshot::child_to_parent_edge_map_size() const {
  return _internal_child_to_parent_edge_map_size();
}
inline void FrameTreeSnapshot::clear_child_to_parent_edge_map() {
  child_to_parent_edge_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >&
FrameTreeSnapshot::_internal_child_to_parent_edge_map() const {
  return child_to_parent_edge_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >&
FrameTreeSnapshot::child_to_parent_edge_map() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.FrameTreeSnapshot.child_to_parent_edge_map)
  return _internal_child_to_parent_edge_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >*
FrameTreeSnapshot::_internal_mutable_child_to_parent_edge_map() {
  return child_to_parent_edge_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::FrameTreeSnapshot_ParentEdge >*
FrameTreeSnapshot::mutable_child_to_parent_edge_map() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.FrameTreeSnapshot.child_to_parent_edge_map)
  return _internal_mutable_child_to_parent_edge_map();
}

// -------------------------------------------------------------------

// Box2

// .bosdyn.api.Vec2 size = 1;
inline bool Box2::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Box2::has_size() const {
  return _internal_has_size();
}
inline void Box2::clear_size() {
  if (GetArena() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::bosdyn::api::Vec2& Box2::_internal_size() const {
  const ::bosdyn::api::Vec2* p = size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec2*>(
      &::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& Box2::size() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box2.size)
  return _internal_size();
}
inline void Box2::unsafe_arena_set_allocated_size(
    ::bosdyn::api::Vec2* size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box2.size)
}
inline ::bosdyn::api::Vec2* Box2::release_size() {
  
  ::bosdyn::api::Vec2* temp = size_;
  size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec2* Box2::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box2.size)
  
  ::bosdyn::api::Vec2* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* Box2::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArena());
    size_ = p;
  }
  return size_;
}
inline ::bosdyn::api::Vec2* Box2::mutable_size() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box2.size)
  return _internal_mutable_size();
}
inline void Box2::set_allocated_size(::bosdyn::api::Vec2* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box2.size)
}

// -------------------------------------------------------------------

// Box2WithFrame

// .bosdyn.api.Box2 box = 1;
inline bool Box2WithFrame::_internal_has_box() const {
  return this != internal_default_instance() && box_ != nullptr;
}
inline bool Box2WithFrame::has_box() const {
  return _internal_has_box();
}
inline void Box2WithFrame::clear_box() {
  if (GetArena() == nullptr && box_ != nullptr) {
    delete box_;
  }
  box_ = nullptr;
}
inline const ::bosdyn::api::Box2& Box2WithFrame::_internal_box() const {
  const ::bosdyn::api::Box2* p = box_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Box2*>(
      &::bosdyn::api::_Box2_default_instance_);
}
inline const ::bosdyn::api::Box2& Box2WithFrame::box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box2WithFrame.box)
  return _internal_box();
}
inline void Box2WithFrame::unsafe_arena_set_allocated_box(
    ::bosdyn::api::Box2* box) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box2WithFrame.box)
}
inline ::bosdyn::api::Box2* Box2WithFrame::release_box() {
  
  ::bosdyn::api::Box2* temp = box_;
  box_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Box2* Box2WithFrame::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box2WithFrame.box)
  
  ::bosdyn::api::Box2* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Box2* Box2WithFrame::_internal_mutable_box() {
  
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Box2>(GetArena());
    box_ = p;
  }
  return box_;
}
inline ::bosdyn::api::Box2* Box2WithFrame::mutable_box() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box2WithFrame.box)
  return _internal_mutable_box();
}
inline void Box2WithFrame::set_allocated_box(::bosdyn::api::Box2* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box2WithFrame.box)
}

// string frame_name = 2;
inline void Box2WithFrame::clear_frame_name() {
  frame_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Box2WithFrame::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box2WithFrame.frame_name)
  return _internal_frame_name();
}
inline void Box2WithFrame::set_frame_name(const std::string& value) {
  _internal_set_frame_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Box2WithFrame.frame_name)
}
inline std::string* Box2WithFrame::mutable_frame_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box2WithFrame.frame_name)
  return _internal_mutable_frame_name();
}
inline const std::string& Box2WithFrame::_internal_frame_name() const {
  return frame_name_.Get();
}
inline void Box2WithFrame::_internal_set_frame_name(const std::string& value) {
  
  frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Box2WithFrame::set_frame_name(std::string&& value) {
  
  frame_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Box2WithFrame.frame_name)
}
inline void Box2WithFrame::set_frame_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Box2WithFrame.frame_name)
}
inline void Box2WithFrame::set_frame_name(const char* value,
    size_t size) {
  
  frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Box2WithFrame.frame_name)
}
inline std::string* Box2WithFrame::_internal_mutable_frame_name() {
  
  return frame_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Box2WithFrame::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box2WithFrame.frame_name)
  return frame_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Box2WithFrame::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  frame_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frame_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box2WithFrame.frame_name)
}

// .bosdyn.api.SE3Pose frame_name_tform_box = 3;
inline bool Box2WithFrame::_internal_has_frame_name_tform_box() const {
  return this != internal_default_instance() && frame_name_tform_box_ != nullptr;
}
inline bool Box2WithFrame::has_frame_name_tform_box() const {
  return _internal_has_frame_name_tform_box();
}
inline void Box2WithFrame::clear_frame_name_tform_box() {
  if (GetArena() == nullptr && frame_name_tform_box_ != nullptr) {
    delete frame_name_tform_box_;
  }
  frame_name_tform_box_ = nullptr;
}
inline const ::bosdyn::api::SE3Pose& Box2WithFrame::_internal_frame_name_tform_box() const {
  const ::bosdyn::api::SE3Pose* p = frame_name_tform_box_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Pose*>(
      &::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Box2WithFrame::frame_name_tform_box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box2WithFrame.frame_name_tform_box)
  return _internal_frame_name_tform_box();
}
inline void Box2WithFrame::unsafe_arena_set_allocated_frame_name_tform_box(
    ::bosdyn::api::SE3Pose* frame_name_tform_box) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_name_tform_box_);
  }
  frame_name_tform_box_ = frame_name_tform_box;
  if (frame_name_tform_box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box2WithFrame.frame_name_tform_box)
}
inline ::bosdyn::api::SE3Pose* Box2WithFrame::release_frame_name_tform_box() {
  
  ::bosdyn::api::SE3Pose* temp = frame_name_tform_box_;
  frame_name_tform_box_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Pose* Box2WithFrame::unsafe_arena_release_frame_name_tform_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box2WithFrame.frame_name_tform_box)
  
  ::bosdyn::api::SE3Pose* temp = frame_name_tform_box_;
  frame_name_tform_box_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Box2WithFrame::_internal_mutable_frame_name_tform_box() {
  
  if (frame_name_tform_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArena());
    frame_name_tform_box_ = p;
  }
  return frame_name_tform_box_;
}
inline ::bosdyn::api::SE3Pose* Box2WithFrame::mutable_frame_name_tform_box() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box2WithFrame.frame_name_tform_box)
  return _internal_mutable_frame_name_tform_box();
}
inline void Box2WithFrame::set_allocated_frame_name_tform_box(::bosdyn::api::SE3Pose* frame_name_tform_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete frame_name_tform_box_;
  }
  if (frame_name_tform_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(frame_name_tform_box);
    if (message_arena != submessage_arena) {
      frame_name_tform_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_name_tform_box, submessage_arena);
    }
    
  } else {
    
  }
  frame_name_tform_box_ = frame_name_tform_box;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box2WithFrame.frame_name_tform_box)
}

// -------------------------------------------------------------------

// Box3

// .bosdyn.api.Vec3 size = 1;
inline bool Box3::_internal_has_size() const {
  return this != internal_default_instance() && size_ != nullptr;
}
inline bool Box3::has_size() const {
  return _internal_has_size();
}
inline void Box3::clear_size() {
  if (GetArena() == nullptr && size_ != nullptr) {
    delete size_;
  }
  size_ = nullptr;
}
inline const ::bosdyn::api::Vec3& Box3::_internal_size() const {
  const ::bosdyn::api::Vec3* p = size_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Box3::size() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box3.size)
  return _internal_size();
}
inline void Box3::unsafe_arena_set_allocated_size(
    ::bosdyn::api::Vec3* size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(size_);
  }
  size_ = size;
  if (size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box3.size)
}
inline ::bosdyn::api::Vec3* Box3::release_size() {
  
  ::bosdyn::api::Vec3* temp = size_;
  size_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* Box3::unsafe_arena_release_size() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box3.size)
  
  ::bosdyn::api::Vec3* temp = size_;
  size_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* Box3::_internal_mutable_size() {
  
  if (size_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    size_ = p;
  }
  return size_;
}
inline ::bosdyn::api::Vec3* Box3::mutable_size() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box3.size)
  return _internal_mutable_size();
}
inline void Box3::set_allocated_size(::bosdyn::api::Vec3* size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete size_;
  }
  if (size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(size);
    if (message_arena != submessage_arena) {
      size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, size, submessage_arena);
    }
    
  } else {
    
  }
  size_ = size;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box3.size)
}

// -------------------------------------------------------------------

// Box3WithFrame

// .bosdyn.api.Box3 box = 1;
inline bool Box3WithFrame::_internal_has_box() const {
  return this != internal_default_instance() && box_ != nullptr;
}
inline bool Box3WithFrame::has_box() const {
  return _internal_has_box();
}
inline void Box3WithFrame::clear_box() {
  if (GetArena() == nullptr && box_ != nullptr) {
    delete box_;
  }
  box_ = nullptr;
}
inline const ::bosdyn::api::Box3& Box3WithFrame::_internal_box() const {
  const ::bosdyn::api::Box3* p = box_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Box3*>(
      &::bosdyn::api::_Box3_default_instance_);
}
inline const ::bosdyn::api::Box3& Box3WithFrame::box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box3WithFrame.box)
  return _internal_box();
}
inline void Box3WithFrame::unsafe_arena_set_allocated_box(
    ::bosdyn::api::Box3* box) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box3WithFrame.box)
}
inline ::bosdyn::api::Box3* Box3WithFrame::release_box() {
  
  ::bosdyn::api::Box3* temp = box_;
  box_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Box3* Box3WithFrame::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box3WithFrame.box)
  
  ::bosdyn::api::Box3* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Box3* Box3WithFrame::_internal_mutable_box() {
  
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Box3>(GetArena());
    box_ = p;
  }
  return box_;
}
inline ::bosdyn::api::Box3* Box3WithFrame::mutable_box() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box3WithFrame.box)
  return _internal_mutable_box();
}
inline void Box3WithFrame::set_allocated_box(::bosdyn::api::Box3* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box3WithFrame.box)
}

// string frame_name = 2;
inline void Box3WithFrame::clear_frame_name() {
  frame_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Box3WithFrame::frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box3WithFrame.frame_name)
  return _internal_frame_name();
}
inline void Box3WithFrame::set_frame_name(const std::string& value) {
  _internal_set_frame_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Box3WithFrame.frame_name)
}
inline std::string* Box3WithFrame::mutable_frame_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box3WithFrame.frame_name)
  return _internal_mutable_frame_name();
}
inline const std::string& Box3WithFrame::_internal_frame_name() const {
  return frame_name_.Get();
}
inline void Box3WithFrame::_internal_set_frame_name(const std::string& value) {
  
  frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Box3WithFrame::set_frame_name(std::string&& value) {
  
  frame_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Box3WithFrame.frame_name)
}
inline void Box3WithFrame::set_frame_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Box3WithFrame.frame_name)
}
inline void Box3WithFrame::set_frame_name(const char* value,
    size_t size) {
  
  frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Box3WithFrame.frame_name)
}
inline std::string* Box3WithFrame::_internal_mutable_frame_name() {
  
  return frame_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Box3WithFrame::release_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box3WithFrame.frame_name)
  return frame_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Box3WithFrame::set_allocated_frame_name(std::string* frame_name) {
  if (frame_name != nullptr) {
    
  } else {
    
  }
  frame_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frame_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box3WithFrame.frame_name)
}

// .bosdyn.api.SE3Pose frame_name_tform_box = 3;
inline bool Box3WithFrame::_internal_has_frame_name_tform_box() const {
  return this != internal_default_instance() && frame_name_tform_box_ != nullptr;
}
inline bool Box3WithFrame::has_frame_name_tform_box() const {
  return _internal_has_frame_name_tform_box();
}
inline void Box3WithFrame::clear_frame_name_tform_box() {
  if (GetArena() == nullptr && frame_name_tform_box_ != nullptr) {
    delete frame_name_tform_box_;
  }
  frame_name_tform_box_ = nullptr;
}
inline const ::bosdyn::api::SE3Pose& Box3WithFrame::_internal_frame_name_tform_box() const {
  const ::bosdyn::api::SE3Pose* p = frame_name_tform_box_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Pose*>(
      &::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Box3WithFrame::frame_name_tform_box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Box3WithFrame.frame_name_tform_box)
  return _internal_frame_name_tform_box();
}
inline void Box3WithFrame::unsafe_arena_set_allocated_frame_name_tform_box(
    ::bosdyn::api::SE3Pose* frame_name_tform_box) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_name_tform_box_);
  }
  frame_name_tform_box_ = frame_name_tform_box;
  if (frame_name_tform_box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Box3WithFrame.frame_name_tform_box)
}
inline ::bosdyn::api::SE3Pose* Box3WithFrame::release_frame_name_tform_box() {
  
  ::bosdyn::api::SE3Pose* temp = frame_name_tform_box_;
  frame_name_tform_box_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Pose* Box3WithFrame::unsafe_arena_release_frame_name_tform_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Box3WithFrame.frame_name_tform_box)
  
  ::bosdyn::api::SE3Pose* temp = frame_name_tform_box_;
  frame_name_tform_box_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Box3WithFrame::_internal_mutable_frame_name_tform_box() {
  
  if (frame_name_tform_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArena());
    frame_name_tform_box_ = p;
  }
  return frame_name_tform_box_;
}
inline ::bosdyn::api::SE3Pose* Box3WithFrame::mutable_frame_name_tform_box() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Box3WithFrame.frame_name_tform_box)
  return _internal_mutable_frame_name_tform_box();
}
inline void Box3WithFrame::set_allocated_frame_name_tform_box(::bosdyn::api::SE3Pose* frame_name_tform_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete frame_name_tform_box_;
  }
  if (frame_name_tform_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(frame_name_tform_box);
    if (message_arena != submessage_arena) {
      frame_name_tform_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_name_tform_box, submessage_arena);
    }
    
  } else {
    
  }
  frame_name_tform_box_ = frame_name_tform_box;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Box3WithFrame.frame_name_tform_box)
}

// -------------------------------------------------------------------

// SE3Covariance

// double cov_xx = 3;
inline void SE3Covariance::clear_cov_xx() {
  cov_xx_ = 0;
}
inline double SE3Covariance::_internal_cov_xx() const {
  return cov_xx_;
}
inline double SE3Covariance::cov_xx() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_xx)
  return _internal_cov_xx();
}
inline void SE3Covariance::_internal_set_cov_xx(double value) {
  
  cov_xx_ = value;
}
inline void SE3Covariance::set_cov_xx(double value) {
  _internal_set_cov_xx(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_xx)
}

// double cov_xy = 4;
inline void SE3Covariance::clear_cov_xy() {
  cov_xy_ = 0;
}
inline double SE3Covariance::_internal_cov_xy() const {
  return cov_xy_;
}
inline double SE3Covariance::cov_xy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_xy)
  return _internal_cov_xy();
}
inline void SE3Covariance::_internal_set_cov_xy(double value) {
  
  cov_xy_ = value;
}
inline void SE3Covariance::set_cov_xy(double value) {
  _internal_set_cov_xy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_xy)
}

// double cov_xz = 5;
inline void SE3Covariance::clear_cov_xz() {
  cov_xz_ = 0;
}
inline double SE3Covariance::_internal_cov_xz() const {
  return cov_xz_;
}
inline double SE3Covariance::cov_xz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_xz)
  return _internal_cov_xz();
}
inline void SE3Covariance::_internal_set_cov_xz(double value) {
  
  cov_xz_ = value;
}
inline void SE3Covariance::set_cov_xz(double value) {
  _internal_set_cov_xz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_xz)
}

// double cov_yx = 6;
inline void SE3Covariance::clear_cov_yx() {
  cov_yx_ = 0;
}
inline double SE3Covariance::_internal_cov_yx() const {
  return cov_yx_;
}
inline double SE3Covariance::cov_yx() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_yx)
  return _internal_cov_yx();
}
inline void SE3Covariance::_internal_set_cov_yx(double value) {
  
  cov_yx_ = value;
}
inline void SE3Covariance::set_cov_yx(double value) {
  _internal_set_cov_yx(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_yx)
}

// double cov_yy = 7;
inline void SE3Covariance::clear_cov_yy() {
  cov_yy_ = 0;
}
inline double SE3Covariance::_internal_cov_yy() const {
  return cov_yy_;
}
inline double SE3Covariance::cov_yy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_yy)
  return _internal_cov_yy();
}
inline void SE3Covariance::_internal_set_cov_yy(double value) {
  
  cov_yy_ = value;
}
inline void SE3Covariance::set_cov_yy(double value) {
  _internal_set_cov_yy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_yy)
}

// double cov_yz = 8;
inline void SE3Covariance::clear_cov_yz() {
  cov_yz_ = 0;
}
inline double SE3Covariance::_internal_cov_yz() const {
  return cov_yz_;
}
inline double SE3Covariance::cov_yz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_yz)
  return _internal_cov_yz();
}
inline void SE3Covariance::_internal_set_cov_yz(double value) {
  
  cov_yz_ = value;
}
inline void SE3Covariance::set_cov_yz(double value) {
  _internal_set_cov_yz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_yz)
}

// double cov_zx = 9;
inline void SE3Covariance::clear_cov_zx() {
  cov_zx_ = 0;
}
inline double SE3Covariance::_internal_cov_zx() const {
  return cov_zx_;
}
inline double SE3Covariance::cov_zx() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_zx)
  return _internal_cov_zx();
}
inline void SE3Covariance::_internal_set_cov_zx(double value) {
  
  cov_zx_ = value;
}
inline void SE3Covariance::set_cov_zx(double value) {
  _internal_set_cov_zx(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_zx)
}

// double cov_zy = 10;
inline void SE3Covariance::clear_cov_zy() {
  cov_zy_ = 0;
}
inline double SE3Covariance::_internal_cov_zy() const {
  return cov_zy_;
}
inline double SE3Covariance::cov_zy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_zy)
  return _internal_cov_zy();
}
inline void SE3Covariance::_internal_set_cov_zy(double value) {
  
  cov_zy_ = value;
}
inline void SE3Covariance::set_cov_zy(double value) {
  _internal_set_cov_zy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_zy)
}

// double cov_zz = 11;
inline void SE3Covariance::clear_cov_zz() {
  cov_zz_ = 0;
}
inline double SE3Covariance::_internal_cov_zz() const {
  return cov_zz_;
}
inline double SE3Covariance::cov_zz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.cov_zz)
  return _internal_cov_zz();
}
inline void SE3Covariance::_internal_set_cov_zz(double value) {
  
  cov_zz_ = value;
}
inline void SE3Covariance::set_cov_zz(double value) {
  _internal_set_cov_zz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.cov_zz)
}

// double yaw_variance = 2;
inline void SE3Covariance::clear_yaw_variance() {
  yaw_variance_ = 0;
}
inline double SE3Covariance::_internal_yaw_variance() const {
  return yaw_variance_;
}
inline double SE3Covariance::yaw_variance() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SE3Covariance.yaw_variance)
  return _internal_yaw_variance();
}
inline void SE3Covariance::_internal_set_yaw_variance(double value) {
  
  yaw_variance_ = value;
}
inline void SE3Covariance::set_yaw_variance(double value) {
  _internal_set_yaw_variance(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SE3Covariance.yaw_variance)
}

// -------------------------------------------------------------------

// EulerZXYRate

// double yaw = 1;
inline void EulerZXYRate::clear_yaw() {
  yaw_ = 0;
}
inline double EulerZXYRate::_internal_yaw() const {
  return yaw_;
}
inline double EulerZXYRate::yaw() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EulerZXYRate.yaw)
  return _internal_yaw();
}
inline void EulerZXYRate::_internal_set_yaw(double value) {
  
  yaw_ = value;
}
inline void EulerZXYRate::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EulerZXYRate.yaw)
}

// double roll = 2;
inline void EulerZXYRate::clear_roll() {
  roll_ = 0;
}
inline double EulerZXYRate::_internal_roll() const {
  return roll_;
}
inline double EulerZXYRate::roll() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EulerZXYRate.roll)
  return _internal_roll();
}
inline void EulerZXYRate::_internal_set_roll(double value) {
  
  roll_ = value;
}
inline void EulerZXYRate::set_roll(double value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EulerZXYRate.roll)
}

// double pitch = 3;
inline void EulerZXYRate::clear_pitch() {
  pitch_ = 0;
}
inline double EulerZXYRate::_internal_pitch() const {
  return pitch_;
}
inline double EulerZXYRate::pitch() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EulerZXYRate.pitch)
  return _internal_pitch();
}
inline void EulerZXYRate::_internal_set_pitch(double value) {
  
  pitch_ = value;
}
inline void EulerZXYRate::set_pitch(double value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EulerZXYRate.pitch)
}

// -------------------------------------------------------------------

// PolyLine

// repeated .bosdyn.api.Vec2 points = 1;
inline int PolyLine::_internal_points_size() const {
  return points_.size();
}
inline int PolyLine::points_size() const {
  return _internal_points_size();
}
inline void PolyLine::clear_points() {
  points_.Clear();
}
inline ::bosdyn::api::Vec2* PolyLine::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PolyLine.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >*
PolyLine::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PolyLine.points)
  return &points_;
}
inline const ::bosdyn::api::Vec2& PolyLine::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::bosdyn::api::Vec2& PolyLine::points(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PolyLine.points)
  return _internal_points(index);
}
inline ::bosdyn::api::Vec2* PolyLine::_internal_add_points() {
  return points_.Add();
}
inline ::bosdyn::api::Vec2* PolyLine::add_points() {
  // @@protoc_insertion_point(field_add:bosdyn.api.PolyLine.points)
  return _internal_add_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >&
PolyLine::points() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PolyLine.points)
  return points_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .bosdyn.api.Vec2 vertexes = 1;
inline int Polygon::_internal_vertexes_size() const {
  return vertexes_.size();
}
inline int Polygon::vertexes_size() const {
  return _internal_vertexes_size();
}
inline void Polygon::clear_vertexes() {
  vertexes_.Clear();
}
inline ::bosdyn::api::Vec2* Polygon::mutable_vertexes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Polygon.vertexes)
  return vertexes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >*
Polygon::mutable_vertexes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Polygon.vertexes)
  return &vertexes_;
}
inline const ::bosdyn::api::Vec2& Polygon::_internal_vertexes(int index) const {
  return vertexes_.Get(index);
}
inline const ::bosdyn::api::Vec2& Polygon::vertexes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Polygon.vertexes)
  return _internal_vertexes(index);
}
inline ::bosdyn::api::Vec2* Polygon::_internal_add_vertexes() {
  return vertexes_.Add();
}
inline ::bosdyn::api::Vec2* Polygon::add_vertexes() {
  // @@protoc_insertion_point(field_add:bosdyn.api.Polygon.vertexes)
  return _internal_add_vertexes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Vec2 >&
Polygon::vertexes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Polygon.vertexes)
  return vertexes_;
}

// -------------------------------------------------------------------

// Circle

// .bosdyn.api.Vec2 center_pt = 1;
inline bool Circle::_internal_has_center_pt() const {
  return this != internal_default_instance() && center_pt_ != nullptr;
}
inline bool Circle::has_center_pt() const {
  return _internal_has_center_pt();
}
inline void Circle::clear_center_pt() {
  if (GetArena() == nullptr && center_pt_ != nullptr) {
    delete center_pt_;
  }
  center_pt_ = nullptr;
}
inline const ::bosdyn::api::Vec2& Circle::_internal_center_pt() const {
  const ::bosdyn::api::Vec2* p = center_pt_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec2*>(
      &::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& Circle::center_pt() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Circle.center_pt)
  return _internal_center_pt();
}
inline void Circle::unsafe_arena_set_allocated_center_pt(
    ::bosdyn::api::Vec2* center_pt) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_pt_);
  }
  center_pt_ = center_pt;
  if (center_pt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Circle.center_pt)
}
inline ::bosdyn::api::Vec2* Circle::release_center_pt() {
  
  ::bosdyn::api::Vec2* temp = center_pt_;
  center_pt_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec2* Circle::unsafe_arena_release_center_pt() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Circle.center_pt)
  
  ::bosdyn::api::Vec2* temp = center_pt_;
  center_pt_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* Circle::_internal_mutable_center_pt() {
  
  if (center_pt_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArena());
    center_pt_ = p;
  }
  return center_pt_;
}
inline ::bosdyn::api::Vec2* Circle::mutable_center_pt() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Circle.center_pt)
  return _internal_mutable_center_pt();
}
inline void Circle::set_allocated_center_pt(::bosdyn::api::Vec2* center_pt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete center_pt_;
  }
  if (center_pt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(center_pt);
    if (message_arena != submessage_arena) {
      center_pt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_pt, submessage_arena);
    }
    
  } else {
    
  }
  center_pt_ = center_pt;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Circle.center_pt)
}

// double radius = 2;
inline void Circle::clear_radius() {
  radius_ = 0;
}
inline double Circle::_internal_radius() const {
  return radius_;
}
inline double Circle::radius() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Circle.radius)
  return _internal_radius();
}
inline void Circle::_internal_set_radius(double value) {
  
  radius_ = value;
}
inline void Circle::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Circle.radius)
}

// -------------------------------------------------------------------

// Area

// .bosdyn.api.Polygon polygon = 1;
inline bool Area::_internal_has_polygon() const {
  return geometry_case() == kPolygon;
}
inline bool Area::has_polygon() const {
  return _internal_has_polygon();
}
inline void Area::set_has_polygon() {
  _oneof_case_[0] = kPolygon;
}
inline void Area::clear_polygon() {
  if (_internal_has_polygon()) {
    if (GetArena() == nullptr) {
      delete geometry_.polygon_;
    }
    clear_has_geometry();
  }
}
inline ::bosdyn::api::Polygon* Area::release_polygon() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Area.polygon)
  if (_internal_has_polygon()) {
    clear_has_geometry();
      ::bosdyn::api::Polygon* temp = geometry_.polygon_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Polygon& Area::_internal_polygon() const {
  return _internal_has_polygon()
      ? *geometry_.polygon_
      : *reinterpret_cast< ::bosdyn::api::Polygon*>(&::bosdyn::api::_Polygon_default_instance_);
}
inline const ::bosdyn::api::Polygon& Area::polygon() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Area.polygon)
  return _internal_polygon();
}
inline ::bosdyn::api::Polygon* Area::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.Area.polygon)
  if (_internal_has_polygon()) {
    clear_has_geometry();
    ::bosdyn::api::Polygon* temp = geometry_.polygon_;
    geometry_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Area::unsafe_arena_set_allocated_polygon(::bosdyn::api::Polygon* polygon) {
  clear_geometry();
  if (polygon) {
    set_has_polygon();
    geometry_.polygon_ = polygon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Area.polygon)
}
inline ::bosdyn::api::Polygon* Area::_internal_mutable_polygon() {
  if (!_internal_has_polygon()) {
    clear_geometry();
    set_has_polygon();
    geometry_.polygon_ = CreateMaybeMessage< ::bosdyn::api::Polygon >(GetArena());
  }
  return geometry_.polygon_;
}
inline ::bosdyn::api::Polygon* Area::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Area.polygon)
  return _internal_mutable_polygon();
}

// .bosdyn.api.Circle circle = 2;
inline bool Area::_internal_has_circle() const {
  return geometry_case() == kCircle;
}
inline bool Area::has_circle() const {
  return _internal_has_circle();
}
inline void Area::set_has_circle() {
  _oneof_case_[0] = kCircle;
}
inline void Area::clear_circle() {
  if (_internal_has_circle()) {
    if (GetArena() == nullptr) {
      delete geometry_.circle_;
    }
    clear_has_geometry();
  }
}
inline ::bosdyn::api::Circle* Area::release_circle() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Area.circle)
  if (_internal_has_circle()) {
    clear_has_geometry();
      ::bosdyn::api::Circle* temp = geometry_.circle_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Circle& Area::_internal_circle() const {
  return _internal_has_circle()
      ? *geometry_.circle_
      : *reinterpret_cast< ::bosdyn::api::Circle*>(&::bosdyn::api::_Circle_default_instance_);
}
inline const ::bosdyn::api::Circle& Area::circle() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Area.circle)
  return _internal_circle();
}
inline ::bosdyn::api::Circle* Area::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.Area.circle)
  if (_internal_has_circle()) {
    clear_has_geometry();
    ::bosdyn::api::Circle* temp = geometry_.circle_;
    geometry_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Area::unsafe_arena_set_allocated_circle(::bosdyn::api::Circle* circle) {
  clear_geometry();
  if (circle) {
    set_has_circle();
    geometry_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Area.circle)
}
inline ::bosdyn::api::Circle* Area::_internal_mutable_circle() {
  if (!_internal_has_circle()) {
    clear_geometry();
    set_has_circle();
    geometry_.circle_ = CreateMaybeMessage< ::bosdyn::api::Circle >(GetArena());
  }
  return geometry_.circle_;
}
inline ::bosdyn::api::Circle* Area::mutable_circle() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Area.circle)
  return _internal_mutable_circle();
}

inline bool Area::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void Area::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline Area::GeometryCase Area::geometry_case() const {
  return Area::GeometryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Volume

// .bosdyn.api.Vec3 box = 1;
inline bool Volume::_internal_has_box() const {
  return geometry_case() == kBox;
}
inline bool Volume::has_box() const {
  return _internal_has_box();
}
inline void Volume::set_has_box() {
  _oneof_case_[0] = kBox;
}
inline void Volume::clear_box() {
  if (_internal_has_box()) {
    if (GetArena() == nullptr) {
      delete geometry_.box_;
    }
    clear_has_geometry();
  }
}
inline ::bosdyn::api::Vec3* Volume::release_box() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Volume.box)
  if (_internal_has_box()) {
    clear_has_geometry();
      ::bosdyn::api::Vec3* temp = geometry_.box_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    geometry_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::Vec3& Volume::_internal_box() const {
  return _internal_has_box()
      ? *geometry_.box_
      : *reinterpret_cast< ::bosdyn::api::Vec3*>(&::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& Volume::box() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Volume.box)
  return _internal_box();
}
inline ::bosdyn::api::Vec3* Volume::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.Volume.box)
  if (_internal_has_box()) {
    clear_has_geometry();
    ::bosdyn::api::Vec3* temp = geometry_.box_;
    geometry_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Volume::unsafe_arena_set_allocated_box(::bosdyn::api::Vec3* box) {
  clear_geometry();
  if (box) {
    set_has_box();
    geometry_.box_ = box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Volume.box)
}
inline ::bosdyn::api::Vec3* Volume::_internal_mutable_box() {
  if (!_internal_has_box()) {
    clear_geometry();
    set_has_box();
    geometry_.box_ = CreateMaybeMessage< ::bosdyn::api::Vec3 >(GetArena());
  }
  return geometry_.box_;
}
inline ::bosdyn::api::Vec3* Volume::mutable_box() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Volume.box)
  return _internal_mutable_box();
}

inline bool Volume::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void Volume::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline Volume::GeometryCase Volume::geometry_case() const {
  return Volume::GeometryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Vec2Value

// .google.protobuf.DoubleValue x = 1;
inline bool Vec2Value::_internal_has_x() const {
  return this != internal_default_instance() && x_ != nullptr;
}
inline bool Vec2Value::has_x() const {
  return _internal_has_x();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::_internal_x() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = x_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec2Value.x)
  return _internal_x();
}
inline void Vec2Value::unsafe_arena_set_allocated_x(
    PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec2Value.x)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::release_x() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = x_;
  x_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec2Value.x)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = x_;
  x_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::_internal_mutable_x() {
  
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    x_ = p;
  }
  return x_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::mutable_x() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec2Value.x)
  return _internal_mutable_x();
}
inline void Vec2Value::set_allocated_x(PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x)->GetArena();
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec2Value.x)
}

// .google.protobuf.DoubleValue y = 2;
inline bool Vec2Value::_internal_has_y() const {
  return this != internal_default_instance() && y_ != nullptr;
}
inline bool Vec2Value::has_y() const {
  return _internal_has_y();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::_internal_y() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = y_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec2Value::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec2Value.y)
  return _internal_y();
}
inline void Vec2Value::unsafe_arena_set_allocated_y(
    PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec2Value.y)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::release_y() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = y_;
  y_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec2Value.y)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = y_;
  y_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::_internal_mutable_y() {
  
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    y_ = p;
  }
  return y_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec2Value::mutable_y() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec2Value.y)
  return _internal_mutable_y();
}
inline void Vec2Value::set_allocated_y(PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y)->GetArena();
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec2Value.y)
}

// -------------------------------------------------------------------

// Vec3Value

// .google.protobuf.DoubleValue x = 1;
inline bool Vec3Value::_internal_has_x() const {
  return this != internal_default_instance() && x_ != nullptr;
}
inline bool Vec3Value::has_x() const {
  return _internal_has_x();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_x() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = x_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::x() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3Value.x)
  return _internal_x();
}
inline void Vec3Value::unsafe_arena_set_allocated_x(
    PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec3Value.x)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_x() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = x_;
  x_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec3Value.x)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = x_;
  x_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_x() {
  
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    x_ = p;
  }
  return x_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_x() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec3Value.x)
  return _internal_mutable_x();
}
inline void Vec3Value::set_allocated_x(PROTOBUF_NAMESPACE_ID::DoubleValue* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x)->GetArena();
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec3Value.x)
}

// .google.protobuf.DoubleValue y = 2;
inline bool Vec3Value::_internal_has_y() const {
  return this != internal_default_instance() && y_ != nullptr;
}
inline bool Vec3Value::has_y() const {
  return _internal_has_y();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_y() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = y_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::y() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3Value.y)
  return _internal_y();
}
inline void Vec3Value::unsafe_arena_set_allocated_y(
    PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec3Value.y)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_y() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = y_;
  y_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec3Value.y)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = y_;
  y_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_y() {
  
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    y_ = p;
  }
  return y_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_y() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec3Value.y)
  return _internal_mutable_y();
}
inline void Vec3Value::set_allocated_y(PROTOBUF_NAMESPACE_ID::DoubleValue* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y)->GetArena();
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec3Value.y)
}

// .google.protobuf.DoubleValue z = 3;
inline bool Vec3Value::_internal_has_z() const {
  return this != internal_default_instance() && z_ != nullptr;
}
inline bool Vec3Value::has_z() const {
  return _internal_has_z();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::_internal_z() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = z_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& Vec3Value::z() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Vec3Value.z)
  return _internal_z();
}
inline void Vec3Value::unsafe_arena_set_allocated_z(
    PROTOBUF_NAMESPACE_ID::DoubleValue* z) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  z_ = z;
  if (z) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Vec3Value.z)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::release_z() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = z_;
  z_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Vec3Value.z)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = z_;
  z_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::_internal_mutable_z() {
  
  if (z_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    z_ = p;
  }
  return z_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* Vec3Value::mutable_z() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Vec3Value.z)
  return _internal_mutable_z();
}
inline void Vec3Value::set_allocated_z(PROTOBUF_NAMESPACE_ID::DoubleValue* z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  if (z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z)->GetArena();
    if (message_arena != submessage_arena) {
      z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Vec3Value.z)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fgeometry_2eproto
