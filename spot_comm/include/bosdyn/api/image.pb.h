// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/image.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fimage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fimage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/geometry.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fimage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fimage_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fimage_2eproto;
namespace bosdyn {
namespace api {
class GetImageRequest;
class GetImageRequestDefaultTypeInternal;
extern GetImageRequestDefaultTypeInternal _GetImageRequest_default_instance_;
class GetImageResponse;
class GetImageResponseDefaultTypeInternal;
extern GetImageResponseDefaultTypeInternal _GetImageResponse_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImageCapture;
class ImageCaptureDefaultTypeInternal;
extern ImageCaptureDefaultTypeInternal _ImageCapture_default_instance_;
class ImageRequest;
class ImageRequestDefaultTypeInternal;
extern ImageRequestDefaultTypeInternal _ImageRequest_default_instance_;
class ImageResponse;
class ImageResponseDefaultTypeInternal;
extern ImageResponseDefaultTypeInternal _ImageResponse_default_instance_;
class ImageSource;
class ImageSourceDefaultTypeInternal;
extern ImageSourceDefaultTypeInternal _ImageSource_default_instance_;
class ImageSource_PinholeModel;
class ImageSource_PinholeModelDefaultTypeInternal;
extern ImageSource_PinholeModelDefaultTypeInternal _ImageSource_PinholeModel_default_instance_;
class ImageSource_PinholeModel_CameraIntrinsics;
class ImageSource_PinholeModel_CameraIntrinsicsDefaultTypeInternal;
extern ImageSource_PinholeModel_CameraIntrinsicsDefaultTypeInternal _ImageSource_PinholeModel_CameraIntrinsics_default_instance_;
class ListImageSourcesRequest;
class ListImageSourcesRequestDefaultTypeInternal;
extern ListImageSourcesRequestDefaultTypeInternal _ListImageSourcesRequest_default_instance_;
class ListImageSourcesResponse;
class ListImageSourcesResponseDefaultTypeInternal;
extern ListImageSourcesResponseDefaultTypeInternal _ListImageSourcesResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::GetImageRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetImageRequest>(Arena*);
template<> ::bosdyn::api::GetImageResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetImageResponse>(Arena*);
template<> ::bosdyn::api::Image* Arena::CreateMaybeMessage<::bosdyn::api::Image>(Arena*);
template<> ::bosdyn::api::ImageCapture* Arena::CreateMaybeMessage<::bosdyn::api::ImageCapture>(Arena*);
template<> ::bosdyn::api::ImageRequest* Arena::CreateMaybeMessage<::bosdyn::api::ImageRequest>(Arena*);
template<> ::bosdyn::api::ImageResponse* Arena::CreateMaybeMessage<::bosdyn::api::ImageResponse>(Arena*);
template<> ::bosdyn::api::ImageSource* Arena::CreateMaybeMessage<::bosdyn::api::ImageSource>(Arena*);
template<> ::bosdyn::api::ImageSource_PinholeModel* Arena::CreateMaybeMessage<::bosdyn::api::ImageSource_PinholeModel>(Arena*);
template<> ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* Arena::CreateMaybeMessage<::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics>(Arena*);
template<> ::bosdyn::api::ListImageSourcesRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListImageSourcesRequest>(Arena*);
template<> ::bosdyn::api::ListImageSourcesResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListImageSourcesResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum Image_Format : int {
  Image_Format_FORMAT_UNKNOWN = 0,
  Image_Format_FORMAT_JPEG = 1,
  Image_Format_FORMAT_RAW = 2,
  Image_Format_FORMAT_RLE = 3,
  Image_Format_Image_Format_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Image_Format_Image_Format_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Image_Format_IsValid(int value);
constexpr Image_Format Image_Format_Format_MIN = Image_Format_FORMAT_UNKNOWN;
constexpr Image_Format Image_Format_Format_MAX = Image_Format_FORMAT_RLE;
constexpr int Image_Format_Format_ARRAYSIZE = Image_Format_Format_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Image_Format_descriptor();
template<typename T>
inline const std::string& Image_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Image_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Image_Format_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Image_Format_descriptor(), enum_t_value);
}
inline bool Image_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Image_Format* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Image_Format>(
    Image_Format_descriptor(), name, value);
}
enum Image_PixelFormat : int {
  Image_PixelFormat_PIXEL_FORMAT_UNKNOWN = 0,
  Image_PixelFormat_PIXEL_FORMAT_GREYSCALE_U8 = 1,
  Image_PixelFormat_PIXEL_FORMAT_RGB_U8 = 3,
  Image_PixelFormat_PIXEL_FORMAT_RGBA_U8 = 4,
  Image_PixelFormat_PIXEL_FORMAT_DEPTH_U16 = 5,
  Image_PixelFormat_Image_PixelFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Image_PixelFormat_Image_PixelFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Image_PixelFormat_IsValid(int value);
constexpr Image_PixelFormat Image_PixelFormat_PixelFormat_MIN = Image_PixelFormat_PIXEL_FORMAT_UNKNOWN;
constexpr Image_PixelFormat Image_PixelFormat_PixelFormat_MAX = Image_PixelFormat_PIXEL_FORMAT_DEPTH_U16;
constexpr int Image_PixelFormat_PixelFormat_ARRAYSIZE = Image_PixelFormat_PixelFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Image_PixelFormat_descriptor();
template<typename T>
inline const std::string& Image_PixelFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Image_PixelFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Image_PixelFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Image_PixelFormat_descriptor(), enum_t_value);
}
inline bool Image_PixelFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Image_PixelFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Image_PixelFormat>(
    Image_PixelFormat_descriptor(), name, value);
}
enum ImageSource_ImageType : int {
  ImageSource_ImageType_IMAGE_TYPE_UNKNOWN = 0,
  ImageSource_ImageType_IMAGE_TYPE_VISUAL = 1,
  ImageSource_ImageType_IMAGE_TYPE_DEPTH = 2,
  ImageSource_ImageType_ImageSource_ImageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImageSource_ImageType_ImageSource_ImageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImageSource_ImageType_IsValid(int value);
constexpr ImageSource_ImageType ImageSource_ImageType_ImageType_MIN = ImageSource_ImageType_IMAGE_TYPE_UNKNOWN;
constexpr ImageSource_ImageType ImageSource_ImageType_ImageType_MAX = ImageSource_ImageType_IMAGE_TYPE_DEPTH;
constexpr int ImageSource_ImageType_ImageType_ARRAYSIZE = ImageSource_ImageType_ImageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageSource_ImageType_descriptor();
template<typename T>
inline const std::string& ImageSource_ImageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageSource_ImageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageSource_ImageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageSource_ImageType_descriptor(), enum_t_value);
}
inline bool ImageSource_ImageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageSource_ImageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageSource_ImageType>(
    ImageSource_ImageType_descriptor(), name, value);
}
enum ImageResponse_Status : int {
  ImageResponse_Status_STATUS_UNKNOWN = 0,
  ImageResponse_Status_STATUS_OK = 1,
  ImageResponse_Status_STATUS_UNKNOWN_CAMERA = 2,
  ImageResponse_Status_STATUS_SOURCE_DATA_ERROR = 3,
  ImageResponse_Status_STATUS_IMAGE_DATA_ERROR = 4,
  ImageResponse_Status_ImageResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImageResponse_Status_ImageResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImageResponse_Status_IsValid(int value);
constexpr ImageResponse_Status ImageResponse_Status_Status_MIN = ImageResponse_Status_STATUS_UNKNOWN;
constexpr ImageResponse_Status ImageResponse_Status_Status_MAX = ImageResponse_Status_STATUS_IMAGE_DATA_ERROR;
constexpr int ImageResponse_Status_Status_ARRAYSIZE = ImageResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageResponse_Status_descriptor();
template<typename T>
inline const std::string& ImageResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageResponse_Status_descriptor(), enum_t_value);
}
inline bool ImageResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageResponse_Status>(
    ImageResponse_Status_descriptor(), name, value);
}
// ===================================================================

class Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  virtual ~Image();

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Image_Format Format;
  static constexpr Format FORMAT_UNKNOWN =
    Image_Format_FORMAT_UNKNOWN;
  static constexpr Format FORMAT_JPEG =
    Image_Format_FORMAT_JPEG;
  static constexpr Format FORMAT_RAW =
    Image_Format_FORMAT_RAW;
  static constexpr Format FORMAT_RLE =
    Image_Format_FORMAT_RLE;
  static inline bool Format_IsValid(int value) {
    return Image_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    Image_Format_Format_MIN;
  static constexpr Format Format_MAX =
    Image_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    Image_Format_Format_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Format_descriptor() {
    return Image_Format_descriptor();
  }
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return Image_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return Image_Format_Parse(name, value);
  }

  typedef Image_PixelFormat PixelFormat;
  static constexpr PixelFormat PIXEL_FORMAT_UNKNOWN =
    Image_PixelFormat_PIXEL_FORMAT_UNKNOWN;
  static constexpr PixelFormat PIXEL_FORMAT_GREYSCALE_U8 =
    Image_PixelFormat_PIXEL_FORMAT_GREYSCALE_U8;
  static constexpr PixelFormat PIXEL_FORMAT_RGB_U8 =
    Image_PixelFormat_PIXEL_FORMAT_RGB_U8;
  static constexpr PixelFormat PIXEL_FORMAT_RGBA_U8 =
    Image_PixelFormat_PIXEL_FORMAT_RGBA_U8;
  static constexpr PixelFormat PIXEL_FORMAT_DEPTH_U16 =
    Image_PixelFormat_PIXEL_FORMAT_DEPTH_U16;
  static inline bool PixelFormat_IsValid(int value) {
    return Image_PixelFormat_IsValid(value);
  }
  static constexpr PixelFormat PixelFormat_MIN =
    Image_PixelFormat_PixelFormat_MIN;
  static constexpr PixelFormat PixelFormat_MAX =
    Image_PixelFormat_PixelFormat_MAX;
  static constexpr int PixelFormat_ARRAYSIZE =
    Image_PixelFormat_PixelFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PixelFormat_descriptor() {
    return Image_PixelFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& PixelFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PixelFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PixelFormat_Name.");
    return Image_PixelFormat_Name(enum_t_value);
  }
  static inline bool PixelFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PixelFormat* value) {
    return Image_PixelFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kColsFieldNumber = 2,
    kRowsFieldNumber = 3,
    kFormatFieldNumber = 5,
    kPixelFormatFieldNumber = 6,
  };
  // bytes data = 4;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 cols = 2;
  void clear_cols();
  ::PROTOBUF_NAMESPACE_ID::int32 cols() const;
  void set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cols() const;
  void _internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rows = 3;
  void clear_rows();
  ::PROTOBUF_NAMESPACE_ID::int32 rows() const;
  void set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rows() const;
  void _internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .bosdyn.api.Image.Format format = 5;
  void clear_format();
  ::bosdyn::api::Image_Format format() const;
  void set_format(::bosdyn::api::Image_Format value);
  private:
  ::bosdyn::api::Image_Format _internal_format() const;
  void _internal_set_format(::bosdyn::api::Image_Format value);
  public:

  // .bosdyn.api.Image.PixelFormat pixel_format = 6;
  void clear_pixel_format();
  ::bosdyn::api::Image_PixelFormat pixel_format() const;
  void set_pixel_format(::bosdyn::api::Image_PixelFormat value);
  private:
  ::bosdyn::api::Image_PixelFormat _internal_pixel_format() const;
  void _internal_set_pixel_format(::bosdyn::api::Image_PixelFormat value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 cols_;
  ::PROTOBUF_NAMESPACE_ID::int32 rows_;
  int format_;
  int pixel_format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageCapture PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageCapture) */ {
 public:
  inline ImageCapture() : ImageCapture(nullptr) {}
  virtual ~ImageCapture();

  ImageCapture(const ImageCapture& from);
  ImageCapture(ImageCapture&& from) noexcept
    : ImageCapture() {
    *this = ::std::move(from);
  }

  inline ImageCapture& operator=(const ImageCapture& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageCapture& operator=(ImageCapture&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageCapture& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageCapture* internal_default_instance() {
    return reinterpret_cast<const ImageCapture*>(
               &_ImageCapture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ImageCapture& a, ImageCapture& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageCapture* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageCapture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageCapture* New() const final {
    return CreateMaybeMessage<ImageCapture>(nullptr);
  }

  ImageCapture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageCapture>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageCapture& from);
  void MergeFrom(const ImageCapture& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageCapture* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageCapture";
  }
  protected:
  explicit ImageCapture(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameNameImageSensorFieldNumber = 5,
    kImageFieldNumber = 3,
    kAcquisitionTimeFieldNumber = 30,
    kTransformsSnapshotFieldNumber = 31,
  };
  // string frame_name_image_sensor = 5;
  void clear_frame_name_image_sensor();
  const std::string& frame_name_image_sensor() const;
  void set_frame_name_image_sensor(const std::string& value);
  void set_frame_name_image_sensor(std::string&& value);
  void set_frame_name_image_sensor(const char* value);
  void set_frame_name_image_sensor(const char* value, size_t size);
  std::string* mutable_frame_name_image_sensor();
  std::string* release_frame_name_image_sensor();
  void set_allocated_frame_name_image_sensor(std::string* frame_name_image_sensor);
  private:
  const std::string& _internal_frame_name_image_sensor() const;
  void _internal_set_frame_name_image_sensor(const std::string& value);
  std::string* _internal_mutable_frame_name_image_sensor();
  public:

  // .bosdyn.api.Image image = 3;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::bosdyn::api::Image& image() const;
  ::bosdyn::api::Image* release_image();
  ::bosdyn::api::Image* mutable_image();
  void set_allocated_image(::bosdyn::api::Image* image);
  private:
  const ::bosdyn::api::Image& _internal_image() const;
  ::bosdyn::api::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::bosdyn::api::Image* image);
  ::bosdyn::api::Image* unsafe_arena_release_image();

  // .google.protobuf.Timestamp acquisition_time = 30;
  bool has_acquisition_time() const;
  private:
  bool _internal_has_acquisition_time() const;
  public:
  void clear_acquisition_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& acquisition_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_acquisition_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_acquisition_time();
  void set_allocated_acquisition_time(PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_acquisition_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_acquisition_time();
  public:
  void unsafe_arena_set_allocated_acquisition_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_acquisition_time();

  // .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
  bool has_transforms_snapshot() const;
  private:
  bool _internal_has_transforms_snapshot() const;
  public:
  void clear_transforms_snapshot();
  const ::bosdyn::api::FrameTreeSnapshot& transforms_snapshot() const;
  ::bosdyn::api::FrameTreeSnapshot* release_transforms_snapshot();
  ::bosdyn::api::FrameTreeSnapshot* mutable_transforms_snapshot();
  void set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  private:
  const ::bosdyn::api::FrameTreeSnapshot& _internal_transforms_snapshot() const;
  ::bosdyn::api::FrameTreeSnapshot* _internal_mutable_transforms_snapshot();
  public:
  void unsafe_arena_set_allocated_transforms_snapshot(
      ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  ::bosdyn::api::FrameTreeSnapshot* unsafe_arena_release_transforms_snapshot();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageCapture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_name_image_sensor_;
  ::bosdyn::api::Image* image_;
  PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time_;
  ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageSource_PinholeModel_CameraIntrinsics PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics) */ {
 public:
  inline ImageSource_PinholeModel_CameraIntrinsics() : ImageSource_PinholeModel_CameraIntrinsics(nullptr) {}
  virtual ~ImageSource_PinholeModel_CameraIntrinsics();

  ImageSource_PinholeModel_CameraIntrinsics(const ImageSource_PinholeModel_CameraIntrinsics& from);
  ImageSource_PinholeModel_CameraIntrinsics(ImageSource_PinholeModel_CameraIntrinsics&& from) noexcept
    : ImageSource_PinholeModel_CameraIntrinsics() {
    *this = ::std::move(from);
  }

  inline ImageSource_PinholeModel_CameraIntrinsics& operator=(const ImageSource_PinholeModel_CameraIntrinsics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSource_PinholeModel_CameraIntrinsics& operator=(ImageSource_PinholeModel_CameraIntrinsics&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageSource_PinholeModel_CameraIntrinsics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageSource_PinholeModel_CameraIntrinsics* internal_default_instance() {
    return reinterpret_cast<const ImageSource_PinholeModel_CameraIntrinsics*>(
               &_ImageSource_PinholeModel_CameraIntrinsics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ImageSource_PinholeModel_CameraIntrinsics& a, ImageSource_PinholeModel_CameraIntrinsics& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSource_PinholeModel_CameraIntrinsics* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSource_PinholeModel_CameraIntrinsics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageSource_PinholeModel_CameraIntrinsics* New() const final {
    return CreateMaybeMessage<ImageSource_PinholeModel_CameraIntrinsics>(nullptr);
  }

  ImageSource_PinholeModel_CameraIntrinsics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageSource_PinholeModel_CameraIntrinsics>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageSource_PinholeModel_CameraIntrinsics& from);
  void MergeFrom(const ImageSource_PinholeModel_CameraIntrinsics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSource_PinholeModel_CameraIntrinsics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics";
  }
  protected:
  explicit ImageSource_PinholeModel_CameraIntrinsics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFocalLengthFieldNumber = 1,
    kPrincipalPointFieldNumber = 2,
    kSkewFieldNumber = 3,
  };
  // .bosdyn.api.Vec2 focal_length = 1;
  bool has_focal_length() const;
  private:
  bool _internal_has_focal_length() const;
  public:
  void clear_focal_length();
  const ::bosdyn::api::Vec2& focal_length() const;
  ::bosdyn::api::Vec2* release_focal_length();
  ::bosdyn::api::Vec2* mutable_focal_length();
  void set_allocated_focal_length(::bosdyn::api::Vec2* focal_length);
  private:
  const ::bosdyn::api::Vec2& _internal_focal_length() const;
  ::bosdyn::api::Vec2* _internal_mutable_focal_length();
  public:
  void unsafe_arena_set_allocated_focal_length(
      ::bosdyn::api::Vec2* focal_length);
  ::bosdyn::api::Vec2* unsafe_arena_release_focal_length();

  // .bosdyn.api.Vec2 principal_point = 2;
  bool has_principal_point() const;
  private:
  bool _internal_has_principal_point() const;
  public:
  void clear_principal_point();
  const ::bosdyn::api::Vec2& principal_point() const;
  ::bosdyn::api::Vec2* release_principal_point();
  ::bosdyn::api::Vec2* mutable_principal_point();
  void set_allocated_principal_point(::bosdyn::api::Vec2* principal_point);
  private:
  const ::bosdyn::api::Vec2& _internal_principal_point() const;
  ::bosdyn::api::Vec2* _internal_mutable_principal_point();
  public:
  void unsafe_arena_set_allocated_principal_point(
      ::bosdyn::api::Vec2* principal_point);
  ::bosdyn::api::Vec2* unsafe_arena_release_principal_point();

  // .bosdyn.api.Vec2 skew = 3;
  bool has_skew() const;
  private:
  bool _internal_has_skew() const;
  public:
  void clear_skew();
  const ::bosdyn::api::Vec2& skew() const;
  ::bosdyn::api::Vec2* release_skew();
  ::bosdyn::api::Vec2* mutable_skew();
  void set_allocated_skew(::bosdyn::api::Vec2* skew);
  private:
  const ::bosdyn::api::Vec2& _internal_skew() const;
  ::bosdyn::api::Vec2* _internal_mutable_skew();
  public:
  void unsafe_arena_set_allocated_skew(
      ::bosdyn::api::Vec2* skew);
  ::bosdyn::api::Vec2* unsafe_arena_release_skew();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec2* focal_length_;
  ::bosdyn::api::Vec2* principal_point_;
  ::bosdyn::api::Vec2* skew_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageSource_PinholeModel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageSource.PinholeModel) */ {
 public:
  inline ImageSource_PinholeModel() : ImageSource_PinholeModel(nullptr) {}
  virtual ~ImageSource_PinholeModel();

  ImageSource_PinholeModel(const ImageSource_PinholeModel& from);
  ImageSource_PinholeModel(ImageSource_PinholeModel&& from) noexcept
    : ImageSource_PinholeModel() {
    *this = ::std::move(from);
  }

  inline ImageSource_PinholeModel& operator=(const ImageSource_PinholeModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSource_PinholeModel& operator=(ImageSource_PinholeModel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageSource_PinholeModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageSource_PinholeModel* internal_default_instance() {
    return reinterpret_cast<const ImageSource_PinholeModel*>(
               &_ImageSource_PinholeModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ImageSource_PinholeModel& a, ImageSource_PinholeModel& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSource_PinholeModel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSource_PinholeModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageSource_PinholeModel* New() const final {
    return CreateMaybeMessage<ImageSource_PinholeModel>(nullptr);
  }

  ImageSource_PinholeModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageSource_PinholeModel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageSource_PinholeModel& from);
  void MergeFrom(const ImageSource_PinholeModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSource_PinholeModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageSource.PinholeModel";
  }
  protected:
  explicit ImageSource_PinholeModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImageSource_PinholeModel_CameraIntrinsics CameraIntrinsics;

  // accessors -------------------------------------------------------

  enum : int {
    kIntrinsicsFieldNumber = 1,
  };
  // .bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics intrinsics = 1;
  bool has_intrinsics() const;
  private:
  bool _internal_has_intrinsics() const;
  public:
  void clear_intrinsics();
  const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics& intrinsics() const;
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* release_intrinsics();
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* mutable_intrinsics();
  void set_allocated_intrinsics(::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics);
  private:
  const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics& _internal_intrinsics() const;
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* _internal_mutable_intrinsics();
  public:
  void unsafe_arena_set_allocated_intrinsics(
      ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics);
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* unsafe_arena_release_intrinsics();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageSource.PinholeModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageSource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageSource) */ {
 public:
  inline ImageSource() : ImageSource(nullptr) {}
  virtual ~ImageSource();

  ImageSource(const ImageSource& from);
  ImageSource(ImageSource&& from) noexcept
    : ImageSource() {
    *this = ::std::move(from);
  }

  inline ImageSource& operator=(const ImageSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSource& operator=(ImageSource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageSource& default_instance();

  enum CameraModelsCase {
    kPinhole = 8,
    CAMERA_MODELS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageSource* internal_default_instance() {
    return reinterpret_cast<const ImageSource*>(
               &_ImageSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ImageSource& a, ImageSource& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageSource* New() const final {
    return CreateMaybeMessage<ImageSource>(nullptr);
  }

  ImageSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageSource& from);
  void MergeFrom(const ImageSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageSource";
  }
  protected:
  explicit ImageSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImageSource_PinholeModel PinholeModel;

  typedef ImageSource_ImageType ImageType;
  static constexpr ImageType IMAGE_TYPE_UNKNOWN =
    ImageSource_ImageType_IMAGE_TYPE_UNKNOWN;
  static constexpr ImageType IMAGE_TYPE_VISUAL =
    ImageSource_ImageType_IMAGE_TYPE_VISUAL;
  static constexpr ImageType IMAGE_TYPE_DEPTH =
    ImageSource_ImageType_IMAGE_TYPE_DEPTH;
  static inline bool ImageType_IsValid(int value) {
    return ImageSource_ImageType_IsValid(value);
  }
  static constexpr ImageType ImageType_MIN =
    ImageSource_ImageType_ImageType_MIN;
  static constexpr ImageType ImageType_MAX =
    ImageSource_ImageType_ImageType_MAX;
  static constexpr int ImageType_ARRAYSIZE =
    ImageSource_ImageType_ImageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImageType_descriptor() {
    return ImageSource_ImageType_descriptor();
  }
  template<typename T>
  static inline const std::string& ImageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImageType_Name.");
    return ImageSource_ImageType_Name(enum_t_value);
  }
  static inline bool ImageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImageType* value) {
    return ImageSource_ImageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kColsFieldNumber = 4,
    kRowsFieldNumber = 5,
    kDepthScaleFieldNumber = 6,
    kImageTypeFieldNumber = 9,
    kPinholeFieldNumber = 8,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 cols = 4;
  void clear_cols();
  ::PROTOBUF_NAMESPACE_ID::int32 cols() const;
  void set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cols() const;
  void _internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rows = 5;
  void clear_rows();
  ::PROTOBUF_NAMESPACE_ID::int32 rows() const;
  void set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rows() const;
  void _internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // double depth_scale = 6;
  void clear_depth_scale();
  double depth_scale() const;
  void set_depth_scale(double value);
  private:
  double _internal_depth_scale() const;
  void _internal_set_depth_scale(double value);
  public:

  // .bosdyn.api.ImageSource.ImageType image_type = 9;
  void clear_image_type();
  ::bosdyn::api::ImageSource_ImageType image_type() const;
  void set_image_type(::bosdyn::api::ImageSource_ImageType value);
  private:
  ::bosdyn::api::ImageSource_ImageType _internal_image_type() const;
  void _internal_set_image_type(::bosdyn::api::ImageSource_ImageType value);
  public:

  // .bosdyn.api.ImageSource.PinholeModel pinhole = 8;
  bool has_pinhole() const;
  private:
  bool _internal_has_pinhole() const;
  public:
  void clear_pinhole();
  const ::bosdyn::api::ImageSource_PinholeModel& pinhole() const;
  ::bosdyn::api::ImageSource_PinholeModel* release_pinhole();
  ::bosdyn::api::ImageSource_PinholeModel* mutable_pinhole();
  void set_allocated_pinhole(::bosdyn::api::ImageSource_PinholeModel* pinhole);
  private:
  const ::bosdyn::api::ImageSource_PinholeModel& _internal_pinhole() const;
  ::bosdyn::api::ImageSource_PinholeModel* _internal_mutable_pinhole();
  public:
  void unsafe_arena_set_allocated_pinhole(
      ::bosdyn::api::ImageSource_PinholeModel* pinhole);
  ::bosdyn::api::ImageSource_PinholeModel* unsafe_arena_release_pinhole();

  void clear_camera_models();
  CameraModelsCase camera_models_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageSource)
 private:
  class _Internal;
  void set_has_pinhole();

  inline bool has_camera_models() const;
  inline void clear_has_camera_models();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 cols_;
  ::PROTOBUF_NAMESPACE_ID::int32 rows_;
  double depth_scale_;
  int image_type_;
  union CameraModelsUnion {
    CameraModelsUnion() {}
    ::bosdyn::api::ImageSource_PinholeModel* pinhole_;
  } camera_models_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ListImageSourcesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListImageSourcesRequest) */ {
 public:
  inline ListImageSourcesRequest() : ListImageSourcesRequest(nullptr) {}
  virtual ~ListImageSourcesRequest();

  ListImageSourcesRequest(const ListImageSourcesRequest& from);
  ListImageSourcesRequest(ListImageSourcesRequest&& from) noexcept
    : ListImageSourcesRequest() {
    *this = ::std::move(from);
  }

  inline ListImageSourcesRequest& operator=(const ListImageSourcesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListImageSourcesRequest& operator=(ListImageSourcesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListImageSourcesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListImageSourcesRequest* internal_default_instance() {
    return reinterpret_cast<const ListImageSourcesRequest*>(
               &_ListImageSourcesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListImageSourcesRequest& a, ListImageSourcesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListImageSourcesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListImageSourcesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListImageSourcesRequest* New() const final {
    return CreateMaybeMessage<ListImageSourcesRequest>(nullptr);
  }

  ListImageSourcesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListImageSourcesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListImageSourcesRequest& from);
  void MergeFrom(const ListImageSourcesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListImageSourcesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListImageSourcesRequest";
  }
  protected:
  explicit ListImageSourcesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListImageSourcesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ListImageSourcesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListImageSourcesResponse) */ {
 public:
  inline ListImageSourcesResponse() : ListImageSourcesResponse(nullptr) {}
  virtual ~ListImageSourcesResponse();

  ListImageSourcesResponse(const ListImageSourcesResponse& from);
  ListImageSourcesResponse(ListImageSourcesResponse&& from) noexcept
    : ListImageSourcesResponse() {
    *this = ::std::move(from);
  }

  inline ListImageSourcesResponse& operator=(const ListImageSourcesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListImageSourcesResponse& operator=(ListImageSourcesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListImageSourcesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListImageSourcesResponse* internal_default_instance() {
    return reinterpret_cast<const ListImageSourcesResponse*>(
               &_ListImageSourcesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListImageSourcesResponse& a, ListImageSourcesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListImageSourcesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListImageSourcesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListImageSourcesResponse* New() const final {
    return CreateMaybeMessage<ListImageSourcesResponse>(nullptr);
  }

  ListImageSourcesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListImageSourcesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListImageSourcesResponse& from);
  void MergeFrom(const ListImageSourcesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListImageSourcesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListImageSourcesResponse";
  }
  protected:
  explicit ListImageSourcesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSourcesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.ImageSource image_sources = 2;
  int image_sources_size() const;
  private:
  int _internal_image_sources_size() const;
  public:
  void clear_image_sources();
  ::bosdyn::api::ImageSource* mutable_image_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >*
      mutable_image_sources();
  private:
  const ::bosdyn::api::ImageSource& _internal_image_sources(int index) const;
  ::bosdyn::api::ImageSource* _internal_add_image_sources();
  public:
  const ::bosdyn::api::ImageSource& image_sources(int index) const;
  ::bosdyn::api::ImageSource* add_image_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >&
      image_sources() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListImageSourcesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource > image_sources_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageRequest) */ {
 public:
  inline ImageRequest() : ImageRequest(nullptr) {}
  virtual ~ImageRequest();

  ImageRequest(const ImageRequest& from);
  ImageRequest(ImageRequest&& from) noexcept
    : ImageRequest() {
    *this = ::std::move(from);
  }

  inline ImageRequest& operator=(const ImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageRequest& operator=(ImageRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageRequest* internal_default_instance() {
    return reinterpret_cast<const ImageRequest*>(
               &_ImageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ImageRequest& a, ImageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageRequest* New() const final {
    return CreateMaybeMessage<ImageRequest>(nullptr);
  }

  ImageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageRequest& from);
  void MergeFrom(const ImageRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageRequest";
  }
  protected:
  explicit ImageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSourceNameFieldNumber = 1,
    kQualityPercentFieldNumber = 2,
    kImageFormatFieldNumber = 3,
  };
  // string image_source_name = 1;
  void clear_image_source_name();
  const std::string& image_source_name() const;
  void set_image_source_name(const std::string& value);
  void set_image_source_name(std::string&& value);
  void set_image_source_name(const char* value);
  void set_image_source_name(const char* value, size_t size);
  std::string* mutable_image_source_name();
  std::string* release_image_source_name();
  void set_allocated_image_source_name(std::string* image_source_name);
  private:
  const std::string& _internal_image_source_name() const;
  void _internal_set_image_source_name(const std::string& value);
  std::string* _internal_mutable_image_source_name();
  public:

  // double quality_percent = 2;
  void clear_quality_percent();
  double quality_percent() const;
  void set_quality_percent(double value);
  private:
  double _internal_quality_percent() const;
  void _internal_set_quality_percent(double value);
  public:

  // .bosdyn.api.Image.Format image_format = 3;
  void clear_image_format();
  ::bosdyn::api::Image_Format image_format() const;
  void set_image_format(::bosdyn::api::Image_Format value);
  private:
  ::bosdyn::api::Image_Format _internal_image_format() const;
  void _internal_set_image_format(::bosdyn::api::Image_Format value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_source_name_;
  double quality_percent_;
  int image_format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class GetImageRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetImageRequest) */ {
 public:
  inline GetImageRequest() : GetImageRequest(nullptr) {}
  virtual ~GetImageRequest();

  GetImageRequest(const GetImageRequest& from);
  GetImageRequest(GetImageRequest&& from) noexcept
    : GetImageRequest() {
    *this = ::std::move(from);
  }

  inline GetImageRequest& operator=(const GetImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImageRequest& operator=(GetImageRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetImageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetImageRequest* internal_default_instance() {
    return reinterpret_cast<const GetImageRequest*>(
               &_GetImageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetImageRequest& a, GetImageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetImageRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetImageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetImageRequest* New() const final {
    return CreateMaybeMessage<GetImageRequest>(nullptr);
  }

  GetImageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetImageRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetImageRequest& from);
  void MergeFrom(const GetImageRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetImageRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetImageRequest";
  }
  protected:
  explicit GetImageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageRequestsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.ImageRequest image_requests = 2;
  int image_requests_size() const;
  private:
  int _internal_image_requests_size() const;
  public:
  void clear_image_requests();
  ::bosdyn::api::ImageRequest* mutable_image_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest >*
      mutable_image_requests();
  private:
  const ::bosdyn::api::ImageRequest& _internal_image_requests(int index) const;
  ::bosdyn::api::ImageRequest* _internal_add_image_requests();
  public:
  const ::bosdyn::api::ImageRequest& image_requests(int index) const;
  ::bosdyn::api::ImageRequest* add_image_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest >&
      image_requests() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetImageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest > image_requests_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class ImageResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ImageResponse) */ {
 public:
  inline ImageResponse() : ImageResponse(nullptr) {}
  virtual ~ImageResponse();

  ImageResponse(const ImageResponse& from);
  ImageResponse(ImageResponse&& from) noexcept
    : ImageResponse() {
    *this = ::std::move(from);
  }

  inline ImageResponse& operator=(const ImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageResponse& operator=(ImageResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageResponse* internal_default_instance() {
    return reinterpret_cast<const ImageResponse*>(
               &_ImageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ImageResponse& a, ImageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImageResponse* New() const final {
    return CreateMaybeMessage<ImageResponse>(nullptr);
  }

  ImageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImageResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImageResponse& from);
  void MergeFrom(const ImageResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ImageResponse";
  }
  protected:
  explicit ImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImageResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    ImageResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    ImageResponse_Status_STATUS_OK;
  static constexpr Status STATUS_UNKNOWN_CAMERA =
    ImageResponse_Status_STATUS_UNKNOWN_CAMERA;
  static constexpr Status STATUS_SOURCE_DATA_ERROR =
    ImageResponse_Status_STATUS_SOURCE_DATA_ERROR;
  static constexpr Status STATUS_IMAGE_DATA_ERROR =
    ImageResponse_Status_STATUS_IMAGE_DATA_ERROR;
  static inline bool Status_IsValid(int value) {
    return ImageResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ImageResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ImageResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ImageResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ImageResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ImageResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return ImageResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kShotFieldNumber = 1,
    kSourceFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ImageCapture shot = 1;
  bool has_shot() const;
  private:
  bool _internal_has_shot() const;
  public:
  void clear_shot();
  const ::bosdyn::api::ImageCapture& shot() const;
  ::bosdyn::api::ImageCapture* release_shot();
  ::bosdyn::api::ImageCapture* mutable_shot();
  void set_allocated_shot(::bosdyn::api::ImageCapture* shot);
  private:
  const ::bosdyn::api::ImageCapture& _internal_shot() const;
  ::bosdyn::api::ImageCapture* _internal_mutable_shot();
  public:
  void unsafe_arena_set_allocated_shot(
      ::bosdyn::api::ImageCapture* shot);
  ::bosdyn::api::ImageCapture* unsafe_arena_release_shot();

  // .bosdyn.api.ImageSource source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::bosdyn::api::ImageSource& source() const;
  ::bosdyn::api::ImageSource* release_source();
  ::bosdyn::api::ImageSource* mutable_source();
  void set_allocated_source(::bosdyn::api::ImageSource* source);
  private:
  const ::bosdyn::api::ImageSource& _internal_source() const;
  ::bosdyn::api::ImageSource* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::bosdyn::api::ImageSource* source);
  ::bosdyn::api::ImageSource* unsafe_arena_release_source();

  // .bosdyn.api.ImageResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::ImageResponse_Status status() const;
  void set_status(::bosdyn::api::ImageResponse_Status value);
  private:
  ::bosdyn::api::ImageResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::ImageResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.ImageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ImageCapture* shot_;
  ::bosdyn::api::ImageSource* source_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// -------------------------------------------------------------------

class GetImageResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetImageResponse) */ {
 public:
  inline GetImageResponse() : GetImageResponse(nullptr) {}
  virtual ~GetImageResponse();

  GetImageResponse(const GetImageResponse& from);
  GetImageResponse(GetImageResponse&& from) noexcept
    : GetImageResponse() {
    *this = ::std::move(from);
  }

  inline GetImageResponse& operator=(const GetImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImageResponse& operator=(GetImageResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetImageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetImageResponse* internal_default_instance() {
    return reinterpret_cast<const GetImageResponse*>(
               &_GetImageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetImageResponse& a, GetImageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetImageResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetImageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetImageResponse* New() const final {
    return CreateMaybeMessage<GetImageResponse>(nullptr);
  }

  GetImageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetImageResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetImageResponse& from);
  void MergeFrom(const GetImageResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetImageResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetImageResponse";
  }
  protected:
  explicit GetImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fimage_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fimage_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageResponsesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.ImageResponse image_responses = 2;
  int image_responses_size() const;
  private:
  int _internal_image_responses_size() const;
  public:
  void clear_image_responses();
  ::bosdyn::api::ImageResponse* mutable_image_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse >*
      mutable_image_responses();
  private:
  const ::bosdyn::api::ImageResponse& _internal_image_responses(int index) const;
  ::bosdyn::api::ImageResponse* _internal_add_image_responses();
  public:
  const ::bosdyn::api::ImageResponse& image_responses(int index) const;
  ::bosdyn::api::ImageResponse* add_image_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse >&
      image_responses() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetImageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse > image_responses_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fimage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Image

// int32 cols = 2;
inline void Image::clear_cols() {
  cols_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Image::_internal_cols() const {
  return cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Image::cols() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.cols)
  return _internal_cols();
}
inline void Image::_internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cols_ = value;
}
inline void Image::set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.cols)
}

// int32 rows = 3;
inline void Image::clear_rows() {
  rows_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Image::_internal_rows() const {
  return rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Image::rows() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.rows)
  return _internal_rows();
}
inline void Image::_internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rows_ = value;
}
inline void Image::set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.rows)
}

// bytes data = 4;
inline void Image::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.data)
  return _internal_data();
}
inline void Image::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.data)
}
inline std::string* Image::mutable_data() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Image.data)
  return _internal_mutable_data();
}
inline const std::string& Image::_internal_data() const {
  return data_.Get();
}
inline void Image::_internal_set_data(const std::string& value) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Image::set_data(std::string&& value) {
  
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Image.data)
}
inline void Image::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Image.data)
}
inline void Image::set_data(const void* value,
    size_t size) {
  
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Image.data)
}
inline std::string* Image::_internal_mutable_data() {
  
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Image.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Image::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Image.data)
}

// .bosdyn.api.Image.Format format = 5;
inline void Image::clear_format() {
  format_ = 0;
}
inline ::bosdyn::api::Image_Format Image::_internal_format() const {
  return static_cast< ::bosdyn::api::Image_Format >(format_);
}
inline ::bosdyn::api::Image_Format Image::format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.format)
  return _internal_format();
}
inline void Image::_internal_set_format(::bosdyn::api::Image_Format value) {
  
  format_ = value;
}
inline void Image::set_format(::bosdyn::api::Image_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.format)
}

// .bosdyn.api.Image.PixelFormat pixel_format = 6;
inline void Image::clear_pixel_format() {
  pixel_format_ = 0;
}
inline ::bosdyn::api::Image_PixelFormat Image::_internal_pixel_format() const {
  return static_cast< ::bosdyn::api::Image_PixelFormat >(pixel_format_);
}
inline ::bosdyn::api::Image_PixelFormat Image::pixel_format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Image.pixel_format)
  return _internal_pixel_format();
}
inline void Image::_internal_set_pixel_format(::bosdyn::api::Image_PixelFormat value) {
  
  pixel_format_ = value;
}
inline void Image::set_pixel_format(::bosdyn::api::Image_PixelFormat value) {
  _internal_set_pixel_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Image.pixel_format)
}

// -------------------------------------------------------------------

// ImageCapture

// .google.protobuf.Timestamp acquisition_time = 30;
inline bool ImageCapture::_internal_has_acquisition_time() const {
  return this != internal_default_instance() && acquisition_time_ != nullptr;
}
inline bool ImageCapture::has_acquisition_time() const {
  return _internal_has_acquisition_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ImageCapture::_internal_acquisition_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = acquisition_time_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ImageCapture::acquisition_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.acquisition_time)
  return _internal_acquisition_time();
}
inline void ImageCapture::unsafe_arena_set_allocated_acquisition_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_time_);
  }
  acquisition_time_ = acquisition_time;
  if (acquisition_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageCapture.acquisition_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ImageCapture::release_acquisition_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = acquisition_time_;
  acquisition_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ImageCapture::unsafe_arena_release_acquisition_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.acquisition_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = acquisition_time_;
  acquisition_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ImageCapture::_internal_mutable_acquisition_time() {
  
  if (acquisition_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    acquisition_time_ = p;
  }
  return acquisition_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ImageCapture::mutable_acquisition_time() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.acquisition_time)
  return _internal_mutable_acquisition_time();
}
inline void ImageCapture::set_allocated_acquisition_time(PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_time_);
  }
  if (acquisition_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_time)->GetArena();
    if (message_arena != submessage_arena) {
      acquisition_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquisition_time, submessage_arena);
    }
    
  } else {
    
  }
  acquisition_time_ = acquisition_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.acquisition_time)
}

// .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
inline bool ImageCapture::_internal_has_transforms_snapshot() const {
  return this != internal_default_instance() && transforms_snapshot_ != nullptr;
}
inline bool ImageCapture::has_transforms_snapshot() const {
  return _internal_has_transforms_snapshot();
}
inline const ::bosdyn::api::FrameTreeSnapshot& ImageCapture::_internal_transforms_snapshot() const {
  const ::bosdyn::api::FrameTreeSnapshot* p = transforms_snapshot_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::FrameTreeSnapshot*>(
      &::bosdyn::api::_FrameTreeSnapshot_default_instance_);
}
inline const ::bosdyn::api::FrameTreeSnapshot& ImageCapture::transforms_snapshot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.transforms_snapshot)
  return _internal_transforms_snapshot();
}
inline void ImageCapture::unsafe_arena_set_allocated_transforms_snapshot(
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot_);
  }
  transforms_snapshot_ = transforms_snapshot;
  if (transforms_snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageCapture.transforms_snapshot)
}
inline ::bosdyn::api::FrameTreeSnapshot* ImageCapture::release_transforms_snapshot() {
  
  ::bosdyn::api::FrameTreeSnapshot* temp = transforms_snapshot_;
  transforms_snapshot_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* ImageCapture::unsafe_arena_release_transforms_snapshot() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.transforms_snapshot)
  
  ::bosdyn::api::FrameTreeSnapshot* temp = transforms_snapshot_;
  transforms_snapshot_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* ImageCapture::_internal_mutable_transforms_snapshot() {
  
  if (transforms_snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(GetArena());
    transforms_snapshot_ = p;
  }
  return transforms_snapshot_;
}
inline ::bosdyn::api::FrameTreeSnapshot* ImageCapture::mutable_transforms_snapshot() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.transforms_snapshot)
  return _internal_mutable_transforms_snapshot();
}
inline void ImageCapture::set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot_);
  }
  if (transforms_snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot)->GetArena();
    if (message_arena != submessage_arena) {
      transforms_snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transforms_snapshot, submessage_arena);
    }
    
  } else {
    
  }
  transforms_snapshot_ = transforms_snapshot;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.transforms_snapshot)
}

// string frame_name_image_sensor = 5;
inline void ImageCapture::clear_frame_name_image_sensor() {
  frame_name_image_sensor_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageCapture::frame_name_image_sensor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.frame_name_image_sensor)
  return _internal_frame_name_image_sensor();
}
inline void ImageCapture::set_frame_name_image_sensor(const std::string& value) {
  _internal_set_frame_name_image_sensor(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageCapture.frame_name_image_sensor)
}
inline std::string* ImageCapture::mutable_frame_name_image_sensor() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.frame_name_image_sensor)
  return _internal_mutable_frame_name_image_sensor();
}
inline const std::string& ImageCapture::_internal_frame_name_image_sensor() const {
  return frame_name_image_sensor_.Get();
}
inline void ImageCapture::_internal_set_frame_name_image_sensor(const std::string& value) {
  
  frame_name_image_sensor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageCapture::set_frame_name_image_sensor(std::string&& value) {
  
  frame_name_image_sensor_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.ImageCapture.frame_name_image_sensor)
}
inline void ImageCapture::set_frame_name_image_sensor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  frame_name_image_sensor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.ImageCapture.frame_name_image_sensor)
}
inline void ImageCapture::set_frame_name_image_sensor(const char* value,
    size_t size) {
  
  frame_name_image_sensor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.ImageCapture.frame_name_image_sensor)
}
inline std::string* ImageCapture::_internal_mutable_frame_name_image_sensor() {
  
  return frame_name_image_sensor_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageCapture::release_frame_name_image_sensor() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.frame_name_image_sensor)
  return frame_name_image_sensor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageCapture::set_allocated_frame_name_image_sensor(std::string* frame_name_image_sensor) {
  if (frame_name_image_sensor != nullptr) {
    
  } else {
    
  }
  frame_name_image_sensor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), frame_name_image_sensor,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.frame_name_image_sensor)
}

// .bosdyn.api.Image image = 3;
inline bool ImageCapture::_internal_has_image() const {
  return this != internal_default_instance() && image_ != nullptr;
}
inline bool ImageCapture::has_image() const {
  return _internal_has_image();
}
inline void ImageCapture::clear_image() {
  if (GetArena() == nullptr && image_ != nullptr) {
    delete image_;
  }
  image_ = nullptr;
}
inline const ::bosdyn::api::Image& ImageCapture::_internal_image() const {
  const ::bosdyn::api::Image* p = image_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Image*>(
      &::bosdyn::api::_Image_default_instance_);
}
inline const ::bosdyn::api::Image& ImageCapture::image() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageCapture.image)
  return _internal_image();
}
inline void ImageCapture::unsafe_arena_set_allocated_image(
    ::bosdyn::api::Image* image) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageCapture.image)
}
inline ::bosdyn::api::Image* ImageCapture::release_image() {
  
  ::bosdyn::api::Image* temp = image_;
  image_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Image* ImageCapture::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageCapture.image)
  
  ::bosdyn::api::Image* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Image* ImageCapture::_internal_mutable_image() {
  
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Image>(GetArena());
    image_ = p;
  }
  return image_;
}
inline ::bosdyn::api::Image* ImageCapture::mutable_image() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageCapture.image)
  return _internal_mutable_image();
}
inline void ImageCapture::set_allocated_image(::bosdyn::api::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageCapture.image)
}

// -------------------------------------------------------------------

// ImageSource_PinholeModel_CameraIntrinsics

// .bosdyn.api.Vec2 focal_length = 1;
inline bool ImageSource_PinholeModel_CameraIntrinsics::_internal_has_focal_length() const {
  return this != internal_default_instance() && focal_length_ != nullptr;
}
inline bool ImageSource_PinholeModel_CameraIntrinsics::has_focal_length() const {
  return _internal_has_focal_length();
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::_internal_focal_length() const {
  const ::bosdyn::api::Vec2* p = focal_length_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec2*>(
      &::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::focal_length() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
  return _internal_focal_length();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_set_allocated_focal_length(
    ::bosdyn::api::Vec2* focal_length) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(focal_length_);
  }
  focal_length_ = focal_length;
  if (focal_length) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::release_focal_length() {
  
  ::bosdyn::api::Vec2* temp = focal_length_;
  focal_length_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_release_focal_length() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
  
  ::bosdyn::api::Vec2* temp = focal_length_;
  focal_length_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::_internal_mutable_focal_length() {
  
  if (focal_length_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArena());
    focal_length_ = p;
  }
  return focal_length_;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::mutable_focal_length() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
  return _internal_mutable_focal_length();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::set_allocated_focal_length(::bosdyn::api::Vec2* focal_length) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(focal_length_);
  }
  if (focal_length) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(focal_length)->GetArena();
    if (message_arena != submessage_arena) {
      focal_length = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, focal_length, submessage_arena);
    }
    
  } else {
    
  }
  focal_length_ = focal_length;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.focal_length)
}

// .bosdyn.api.Vec2 principal_point = 2;
inline bool ImageSource_PinholeModel_CameraIntrinsics::_internal_has_principal_point() const {
  return this != internal_default_instance() && principal_point_ != nullptr;
}
inline bool ImageSource_PinholeModel_CameraIntrinsics::has_principal_point() const {
  return _internal_has_principal_point();
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::_internal_principal_point() const {
  const ::bosdyn::api::Vec2* p = principal_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec2*>(
      &::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::principal_point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
  return _internal_principal_point();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_set_allocated_principal_point(
    ::bosdyn::api::Vec2* principal_point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(principal_point_);
  }
  principal_point_ = principal_point;
  if (principal_point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::release_principal_point() {
  
  ::bosdyn::api::Vec2* temp = principal_point_;
  principal_point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_release_principal_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
  
  ::bosdyn::api::Vec2* temp = principal_point_;
  principal_point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::_internal_mutable_principal_point() {
  
  if (principal_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArena());
    principal_point_ = p;
  }
  return principal_point_;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::mutable_principal_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
  return _internal_mutable_principal_point();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::set_allocated_principal_point(::bosdyn::api::Vec2* principal_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(principal_point_);
  }
  if (principal_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(principal_point)->GetArena();
    if (message_arena != submessage_arena) {
      principal_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, principal_point, submessage_arena);
    }
    
  } else {
    
  }
  principal_point_ = principal_point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.principal_point)
}

// .bosdyn.api.Vec2 skew = 3;
inline bool ImageSource_PinholeModel_CameraIntrinsics::_internal_has_skew() const {
  return this != internal_default_instance() && skew_ != nullptr;
}
inline bool ImageSource_PinholeModel_CameraIntrinsics::has_skew() const {
  return _internal_has_skew();
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::_internal_skew() const {
  const ::bosdyn::api::Vec2* p = skew_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec2*>(
      &::bosdyn::api::_Vec2_default_instance_);
}
inline const ::bosdyn::api::Vec2& ImageSource_PinholeModel_CameraIntrinsics::skew() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
  return _internal_skew();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_set_allocated_skew(
    ::bosdyn::api::Vec2* skew) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(skew_);
  }
  skew_ = skew;
  if (skew) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::release_skew() {
  
  ::bosdyn::api::Vec2* temp = skew_;
  skew_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::unsafe_arena_release_skew() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
  
  ::bosdyn::api::Vec2* temp = skew_;
  skew_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::_internal_mutable_skew() {
  
  if (skew_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec2>(GetArena());
    skew_ = p;
  }
  return skew_;
}
inline ::bosdyn::api::Vec2* ImageSource_PinholeModel_CameraIntrinsics::mutable_skew() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
  return _internal_mutable_skew();
}
inline void ImageSource_PinholeModel_CameraIntrinsics::set_allocated_skew(::bosdyn::api::Vec2* skew) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(skew_);
  }
  if (skew) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(skew)->GetArena();
    if (message_arena != submessage_arena) {
      skew = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skew, submessage_arena);
    }
    
  } else {
    
  }
  skew_ = skew;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics.skew)
}

// -------------------------------------------------------------------

// ImageSource_PinholeModel

// .bosdyn.api.ImageSource.PinholeModel.CameraIntrinsics intrinsics = 1;
inline bool ImageSource_PinholeModel::_internal_has_intrinsics() const {
  return this != internal_default_instance() && intrinsics_ != nullptr;
}
inline bool ImageSource_PinholeModel::has_intrinsics() const {
  return _internal_has_intrinsics();
}
inline void ImageSource_PinholeModel::clear_intrinsics() {
  if (GetArena() == nullptr && intrinsics_ != nullptr) {
    delete intrinsics_;
  }
  intrinsics_ = nullptr;
}
inline const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics& ImageSource_PinholeModel::_internal_intrinsics() const {
  const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* p = intrinsics_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics*>(
      &::bosdyn::api::_ImageSource_PinholeModel_CameraIntrinsics_default_instance_);
}
inline const ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics& ImageSource_PinholeModel::intrinsics() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.PinholeModel.intrinsics)
  return _internal_intrinsics();
}
inline void ImageSource_PinholeModel::unsafe_arena_set_allocated_intrinsics(
    ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(intrinsics_);
  }
  intrinsics_ = intrinsics;
  if (intrinsics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.PinholeModel.intrinsics)
}
inline ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* ImageSource_PinholeModel::release_intrinsics() {
  
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* temp = intrinsics_;
  intrinsics_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* ImageSource_PinholeModel::unsafe_arena_release_intrinsics() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.PinholeModel.intrinsics)
  
  ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* temp = intrinsics_;
  intrinsics_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* ImageSource_PinholeModel::_internal_mutable_intrinsics() {
  
  if (intrinsics_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics>(GetArena());
    intrinsics_ = p;
  }
  return intrinsics_;
}
inline ::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* ImageSource_PinholeModel::mutable_intrinsics() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.PinholeModel.intrinsics)
  return _internal_mutable_intrinsics();
}
inline void ImageSource_PinholeModel::set_allocated_intrinsics(::bosdyn::api::ImageSource_PinholeModel_CameraIntrinsics* intrinsics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete intrinsics_;
  }
  if (intrinsics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(intrinsics);
    if (message_arena != submessage_arena) {
      intrinsics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intrinsics, submessage_arena);
    }
    
  } else {
    
  }
  intrinsics_ = intrinsics;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.PinholeModel.intrinsics)
}

// -------------------------------------------------------------------

// ImageSource

// string name = 2;
inline void ImageSource::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageSource::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.name)
  return _internal_name();
}
inline void ImageSource::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.name)
}
inline std::string* ImageSource::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.name)
  return _internal_mutable_name();
}
inline const std::string& ImageSource::_internal_name() const {
  return name_.Get();
}
inline void ImageSource::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageSource::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.ImageSource.name)
}
inline void ImageSource::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.ImageSource.name)
}
inline void ImageSource::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.ImageSource.name)
}
inline std::string* ImageSource::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageSource::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageSource::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageSource.name)
}

// int32 cols = 4;
inline void ImageSource::clear_cols() {
  cols_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImageSource::_internal_cols() const {
  return cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImageSource::cols() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.cols)
  return _internal_cols();
}
inline void ImageSource::_internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cols_ = value;
}
inline void ImageSource::set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.cols)
}

// int32 rows = 5;
inline void ImageSource::clear_rows() {
  rows_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImageSource::_internal_rows() const {
  return rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImageSource::rows() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.rows)
  return _internal_rows();
}
inline void ImageSource::_internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rows_ = value;
}
inline void ImageSource::set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.rows)
}

// double depth_scale = 6;
inline void ImageSource::clear_depth_scale() {
  depth_scale_ = 0;
}
inline double ImageSource::_internal_depth_scale() const {
  return depth_scale_;
}
inline double ImageSource::depth_scale() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.depth_scale)
  return _internal_depth_scale();
}
inline void ImageSource::_internal_set_depth_scale(double value) {
  
  depth_scale_ = value;
}
inline void ImageSource::set_depth_scale(double value) {
  _internal_set_depth_scale(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.depth_scale)
}

// .bosdyn.api.ImageSource.PinholeModel pinhole = 8;
inline bool ImageSource::_internal_has_pinhole() const {
  return camera_models_case() == kPinhole;
}
inline bool ImageSource::has_pinhole() const {
  return _internal_has_pinhole();
}
inline void ImageSource::set_has_pinhole() {
  _oneof_case_[0] = kPinhole;
}
inline void ImageSource::clear_pinhole() {
  if (_internal_has_pinhole()) {
    if (GetArena() == nullptr) {
      delete camera_models_.pinhole_;
    }
    clear_has_camera_models();
  }
}
inline ::bosdyn::api::ImageSource_PinholeModel* ImageSource::release_pinhole() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageSource.pinhole)
  if (_internal_has_pinhole()) {
    clear_has_camera_models();
      ::bosdyn::api::ImageSource_PinholeModel* temp = camera_models_.pinhole_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    camera_models_.pinhole_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::ImageSource_PinholeModel& ImageSource::_internal_pinhole() const {
  return _internal_has_pinhole()
      ? *camera_models_.pinhole_
      : *reinterpret_cast< ::bosdyn::api::ImageSource_PinholeModel*>(&::bosdyn::api::_ImageSource_PinholeModel_default_instance_);
}
inline const ::bosdyn::api::ImageSource_PinholeModel& ImageSource::pinhole() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.pinhole)
  return _internal_pinhole();
}
inline ::bosdyn::api::ImageSource_PinholeModel* ImageSource::unsafe_arena_release_pinhole() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.ImageSource.pinhole)
  if (_internal_has_pinhole()) {
    clear_has_camera_models();
    ::bosdyn::api::ImageSource_PinholeModel* temp = camera_models_.pinhole_;
    camera_models_.pinhole_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ImageSource::unsafe_arena_set_allocated_pinhole(::bosdyn::api::ImageSource_PinholeModel* pinhole) {
  clear_camera_models();
  if (pinhole) {
    set_has_pinhole();
    camera_models_.pinhole_ = pinhole;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageSource.pinhole)
}
inline ::bosdyn::api::ImageSource_PinholeModel* ImageSource::_internal_mutable_pinhole() {
  if (!_internal_has_pinhole()) {
    clear_camera_models();
    set_has_pinhole();
    camera_models_.pinhole_ = CreateMaybeMessage< ::bosdyn::api::ImageSource_PinholeModel >(GetArena());
  }
  return camera_models_.pinhole_;
}
inline ::bosdyn::api::ImageSource_PinholeModel* ImageSource::mutable_pinhole() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageSource.pinhole)
  return _internal_mutable_pinhole();
}

// .bosdyn.api.ImageSource.ImageType image_type = 9;
inline void ImageSource::clear_image_type() {
  image_type_ = 0;
}
inline ::bosdyn::api::ImageSource_ImageType ImageSource::_internal_image_type() const {
  return static_cast< ::bosdyn::api::ImageSource_ImageType >(image_type_);
}
inline ::bosdyn::api::ImageSource_ImageType ImageSource::image_type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageSource.image_type)
  return _internal_image_type();
}
inline void ImageSource::_internal_set_image_type(::bosdyn::api::ImageSource_ImageType value) {
  
  image_type_ = value;
}
inline void ImageSource::set_image_type(::bosdyn::api::ImageSource_ImageType value) {
  _internal_set_image_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageSource.image_type)
}

inline bool ImageSource::has_camera_models() const {
  return camera_models_case() != CAMERA_MODELS_NOT_SET;
}
inline void ImageSource::clear_has_camera_models() {
  _oneof_case_[0] = CAMERA_MODELS_NOT_SET;
}
inline ImageSource::CameraModelsCase ImageSource::camera_models_case() const {
  return ImageSource::CameraModelsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ListImageSourcesRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListImageSourcesRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListImageSourcesRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListImageSourcesRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListImageSourcesRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListImageSourcesRequest.header)
  return _internal_header();
}
inline void ListImageSourcesRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListImageSourcesRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListImageSourcesRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListImageSourcesRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListImageSourcesRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListImageSourcesRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* ListImageSourcesRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListImageSourcesRequest.header)
  return _internal_mutable_header();
}
inline void ListImageSourcesRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListImageSourcesRequest.header)
}

// -------------------------------------------------------------------

// ListImageSourcesResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListImageSourcesResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListImageSourcesResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListImageSourcesResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListImageSourcesResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListImageSourcesResponse.header)
  return _internal_header();
}
inline void ListImageSourcesResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListImageSourcesResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListImageSourcesResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListImageSourcesResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListImageSourcesResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListImageSourcesResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* ListImageSourcesResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListImageSourcesResponse.header)
  return _internal_mutable_header();
}
inline void ListImageSourcesResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListImageSourcesResponse.header)
}

// repeated .bosdyn.api.ImageSource image_sources = 2;
inline int ListImageSourcesResponse::_internal_image_sources_size() const {
  return image_sources_.size();
}
inline int ListImageSourcesResponse::image_sources_size() const {
  return _internal_image_sources_size();
}
inline void ListImageSourcesResponse::clear_image_sources() {
  image_sources_.Clear();
}
inline ::bosdyn::api::ImageSource* ListImageSourcesResponse::mutable_image_sources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListImageSourcesResponse.image_sources)
  return image_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >*
ListImageSourcesResponse::mutable_image_sources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListImageSourcesResponse.image_sources)
  return &image_sources_;
}
inline const ::bosdyn::api::ImageSource& ListImageSourcesResponse::_internal_image_sources(int index) const {
  return image_sources_.Get(index);
}
inline const ::bosdyn::api::ImageSource& ListImageSourcesResponse::image_sources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListImageSourcesResponse.image_sources)
  return _internal_image_sources(index);
}
inline ::bosdyn::api::ImageSource* ListImageSourcesResponse::_internal_add_image_sources() {
  return image_sources_.Add();
}
inline ::bosdyn::api::ImageSource* ListImageSourcesResponse::add_image_sources() {
  // @@protoc_insertion_point(field_add:bosdyn.api.ListImageSourcesResponse.image_sources)
  return _internal_add_image_sources();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageSource >&
ListImageSourcesResponse::image_sources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListImageSourcesResponse.image_sources)
  return image_sources_;
}

// -------------------------------------------------------------------

// ImageRequest

// string image_source_name = 1;
inline void ImageRequest::clear_image_source_name() {
  image_source_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ImageRequest::image_source_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageRequest.image_source_name)
  return _internal_image_source_name();
}
inline void ImageRequest::set_image_source_name(const std::string& value) {
  _internal_set_image_source_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageRequest.image_source_name)
}
inline std::string* ImageRequest::mutable_image_source_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageRequest.image_source_name)
  return _internal_mutable_image_source_name();
}
inline const std::string& ImageRequest::_internal_image_source_name() const {
  return image_source_name_.Get();
}
inline void ImageRequest::_internal_set_image_source_name(const std::string& value) {
  
  image_source_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ImageRequest::set_image_source_name(std::string&& value) {
  
  image_source_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.ImageRequest.image_source_name)
}
inline void ImageRequest::set_image_source_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  image_source_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.ImageRequest.image_source_name)
}
inline void ImageRequest::set_image_source_name(const char* value,
    size_t size) {
  
  image_source_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.ImageRequest.image_source_name)
}
inline std::string* ImageRequest::_internal_mutable_image_source_name() {
  
  return image_source_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ImageRequest::release_image_source_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageRequest.image_source_name)
  return image_source_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ImageRequest::set_allocated_image_source_name(std::string* image_source_name) {
  if (image_source_name != nullptr) {
    
  } else {
    
  }
  image_source_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_source_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageRequest.image_source_name)
}

// double quality_percent = 2;
inline void ImageRequest::clear_quality_percent() {
  quality_percent_ = 0;
}
inline double ImageRequest::_internal_quality_percent() const {
  return quality_percent_;
}
inline double ImageRequest::quality_percent() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageRequest.quality_percent)
  return _internal_quality_percent();
}
inline void ImageRequest::_internal_set_quality_percent(double value) {
  
  quality_percent_ = value;
}
inline void ImageRequest::set_quality_percent(double value) {
  _internal_set_quality_percent(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageRequest.quality_percent)
}

// .bosdyn.api.Image.Format image_format = 3;
inline void ImageRequest::clear_image_format() {
  image_format_ = 0;
}
inline ::bosdyn::api::Image_Format ImageRequest::_internal_image_format() const {
  return static_cast< ::bosdyn::api::Image_Format >(image_format_);
}
inline ::bosdyn::api::Image_Format ImageRequest::image_format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageRequest.image_format)
  return _internal_image_format();
}
inline void ImageRequest::_internal_set_image_format(::bosdyn::api::Image_Format value) {
  
  image_format_ = value;
}
inline void ImageRequest::set_image_format(::bosdyn::api::Image_Format value) {
  _internal_set_image_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageRequest.image_format)
}

// -------------------------------------------------------------------

// GetImageRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetImageRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetImageRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetImageRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetImageRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetImageRequest.header)
  return _internal_header();
}
inline void GetImageRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetImageRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetImageRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetImageRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetImageRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetImageRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* GetImageRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetImageRequest.header)
  return _internal_mutable_header();
}
inline void GetImageRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetImageRequest.header)
}

// repeated .bosdyn.api.ImageRequest image_requests = 2;
inline int GetImageRequest::_internal_image_requests_size() const {
  return image_requests_.size();
}
inline int GetImageRequest::image_requests_size() const {
  return _internal_image_requests_size();
}
inline void GetImageRequest::clear_image_requests() {
  image_requests_.Clear();
}
inline ::bosdyn::api::ImageRequest* GetImageRequest::mutable_image_requests(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetImageRequest.image_requests)
  return image_requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest >*
GetImageRequest::mutable_image_requests() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetImageRequest.image_requests)
  return &image_requests_;
}
inline const ::bosdyn::api::ImageRequest& GetImageRequest::_internal_image_requests(int index) const {
  return image_requests_.Get(index);
}
inline const ::bosdyn::api::ImageRequest& GetImageRequest::image_requests(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetImageRequest.image_requests)
  return _internal_image_requests(index);
}
inline ::bosdyn::api::ImageRequest* GetImageRequest::_internal_add_image_requests() {
  return image_requests_.Add();
}
inline ::bosdyn::api::ImageRequest* GetImageRequest::add_image_requests() {
  // @@protoc_insertion_point(field_add:bosdyn.api.GetImageRequest.image_requests)
  return _internal_add_image_requests();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageRequest >&
GetImageRequest::image_requests() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetImageRequest.image_requests)
  return image_requests_;
}

// -------------------------------------------------------------------

// ImageResponse

// .bosdyn.api.ImageCapture shot = 1;
inline bool ImageResponse::_internal_has_shot() const {
  return this != internal_default_instance() && shot_ != nullptr;
}
inline bool ImageResponse::has_shot() const {
  return _internal_has_shot();
}
inline void ImageResponse::clear_shot() {
  if (GetArena() == nullptr && shot_ != nullptr) {
    delete shot_;
  }
  shot_ = nullptr;
}
inline const ::bosdyn::api::ImageCapture& ImageResponse::_internal_shot() const {
  const ::bosdyn::api::ImageCapture* p = shot_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ImageCapture*>(
      &::bosdyn::api::_ImageCapture_default_instance_);
}
inline const ::bosdyn::api::ImageCapture& ImageResponse::shot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageResponse.shot)
  return _internal_shot();
}
inline void ImageResponse::unsafe_arena_set_allocated_shot(
    ::bosdyn::api::ImageCapture* shot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shot_);
  }
  shot_ = shot;
  if (shot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageResponse.shot)
}
inline ::bosdyn::api::ImageCapture* ImageResponse::release_shot() {
  
  ::bosdyn::api::ImageCapture* temp = shot_;
  shot_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ImageCapture* ImageResponse::unsafe_arena_release_shot() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageResponse.shot)
  
  ::bosdyn::api::ImageCapture* temp = shot_;
  shot_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageCapture* ImageResponse::_internal_mutable_shot() {
  
  if (shot_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageCapture>(GetArena());
    shot_ = p;
  }
  return shot_;
}
inline ::bosdyn::api::ImageCapture* ImageResponse::mutable_shot() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageResponse.shot)
  return _internal_mutable_shot();
}
inline void ImageResponse::set_allocated_shot(::bosdyn::api::ImageCapture* shot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete shot_;
  }
  if (shot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(shot);
    if (message_arena != submessage_arena) {
      shot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shot, submessage_arena);
    }
    
  } else {
    
  }
  shot_ = shot;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageResponse.shot)
}

// .bosdyn.api.ImageSource source = 2;
inline bool ImageResponse::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool ImageResponse::has_source() const {
  return _internal_has_source();
}
inline void ImageResponse::clear_source() {
  if (GetArena() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::bosdyn::api::ImageSource& ImageResponse::_internal_source() const {
  const ::bosdyn::api::ImageSource* p = source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ImageSource*>(
      &::bosdyn::api::_ImageSource_default_instance_);
}
inline const ::bosdyn::api::ImageSource& ImageResponse::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageResponse.source)
  return _internal_source();
}
inline void ImageResponse::unsafe_arena_set_allocated_source(
    ::bosdyn::api::ImageSource* source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ImageResponse.source)
}
inline ::bosdyn::api::ImageSource* ImageResponse::release_source() {
  
  ::bosdyn::api::ImageSource* temp = source_;
  source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ImageSource* ImageResponse::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ImageResponse.source)
  
  ::bosdyn::api::ImageSource* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ImageSource* ImageResponse::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ImageSource>(GetArena());
    source_ = p;
  }
  return source_;
}
inline ::bosdyn::api::ImageSource* ImageResponse::mutable_source() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ImageResponse.source)
  return _internal_mutable_source();
}
inline void ImageResponse::set_allocated_source(::bosdyn::api::ImageSource* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ImageResponse.source)
}

// .bosdyn.api.ImageResponse.Status status = 4;
inline void ImageResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::ImageResponse_Status ImageResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::ImageResponse_Status >(status_);
}
inline ::bosdyn::api::ImageResponse_Status ImageResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ImageResponse.status)
  return _internal_status();
}
inline void ImageResponse::_internal_set_status(::bosdyn::api::ImageResponse_Status value) {
  
  status_ = value;
}
inline void ImageResponse::set_status(::bosdyn::api::ImageResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.ImageResponse.status)
}

// -------------------------------------------------------------------

// GetImageResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetImageResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetImageResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetImageResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetImageResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetImageResponse.header)
  return _internal_header();
}
inline void GetImageResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetImageResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetImageResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetImageResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetImageResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetImageResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* GetImageResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetImageResponse.header)
  return _internal_mutable_header();
}
inline void GetImageResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetImageResponse.header)
}

// repeated .bosdyn.api.ImageResponse image_responses = 2;
inline int GetImageResponse::_internal_image_responses_size() const {
  return image_responses_.size();
}
inline int GetImageResponse::image_responses_size() const {
  return _internal_image_responses_size();
}
inline void GetImageResponse::clear_image_responses() {
  image_responses_.Clear();
}
inline ::bosdyn::api::ImageResponse* GetImageResponse::mutable_image_responses(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetImageResponse.image_responses)
  return image_responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse >*
GetImageResponse::mutable_image_responses() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.GetImageResponse.image_responses)
  return &image_responses_;
}
inline const ::bosdyn::api::ImageResponse& GetImageResponse::_internal_image_responses(int index) const {
  return image_responses_.Get(index);
}
inline const ::bosdyn::api::ImageResponse& GetImageResponse::image_responses(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetImageResponse.image_responses)
  return _internal_image_responses(index);
}
inline ::bosdyn::api::ImageResponse* GetImageResponse::_internal_add_image_responses() {
  return image_responses_.Add();
}
inline ::bosdyn::api::ImageResponse* GetImageResponse::add_image_responses() {
  // @@protoc_insertion_point(field_add:bosdyn.api.GetImageResponse.image_responses)
  return _internal_add_image_responses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::ImageResponse >&
GetImageResponse::image_responses() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.GetImageResponse.image_responses)
  return image_responses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::Image_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::Image_Format>() {
  return ::bosdyn::api::Image_Format_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::Image_PixelFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::Image_PixelFormat>() {
  return ::bosdyn::api::Image_PixelFormat_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ImageSource_ImageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ImageSource_ImageType>() {
  return ::bosdyn::api::ImageSource_ImageType_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::ImageResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::ImageResponse_Status>() {
  return ::bosdyn::api::ImageResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fimage_2eproto
