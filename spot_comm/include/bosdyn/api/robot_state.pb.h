// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/robot_state.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fstate_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fstate_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/parameter.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2frobot_5fstate_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto;
namespace bosdyn {
namespace api {
class BatteryState;
class BatteryStateDefaultTypeInternal;
extern BatteryStateDefaultTypeInternal _BatteryState_default_instance_;
class BehaviorFault;
class BehaviorFaultDefaultTypeInternal;
extern BehaviorFaultDefaultTypeInternal _BehaviorFault_default_instance_;
class BehaviorFaultState;
class BehaviorFaultStateDefaultTypeInternal;
extern BehaviorFaultStateDefaultTypeInternal _BehaviorFaultState_default_instance_;
class CommsState;
class CommsStateDefaultTypeInternal;
extern CommsStateDefaultTypeInternal _CommsState_default_instance_;
class EStopState;
class EStopStateDefaultTypeInternal;
extern EStopStateDefaultTypeInternal _EStopState_default_instance_;
class FootState;
class FootStateDefaultTypeInternal;
extern FootStateDefaultTypeInternal _FootState_default_instance_;
class HardwareConfiguration;
class HardwareConfigurationDefaultTypeInternal;
extern HardwareConfigurationDefaultTypeInternal _HardwareConfiguration_default_instance_;
class JointState;
class JointStateDefaultTypeInternal;
extern JointStateDefaultTypeInternal _JointState_default_instance_;
class KinematicState;
class KinematicStateDefaultTypeInternal;
extern KinematicStateDefaultTypeInternal _KinematicState_default_instance_;
class PowerState;
class PowerStateDefaultTypeInternal;
extern PowerStateDefaultTypeInternal _PowerState_default_instance_;
class RobotHardwareConfigurationRequest;
class RobotHardwareConfigurationRequestDefaultTypeInternal;
extern RobotHardwareConfigurationRequestDefaultTypeInternal _RobotHardwareConfigurationRequest_default_instance_;
class RobotHardwareConfigurationResponse;
class RobotHardwareConfigurationResponseDefaultTypeInternal;
extern RobotHardwareConfigurationResponseDefaultTypeInternal _RobotHardwareConfigurationResponse_default_instance_;
class RobotLinkModelRequest;
class RobotLinkModelRequestDefaultTypeInternal;
extern RobotLinkModelRequestDefaultTypeInternal _RobotLinkModelRequest_default_instance_;
class RobotLinkModelResponse;
class RobotLinkModelResponseDefaultTypeInternal;
extern RobotLinkModelResponseDefaultTypeInternal _RobotLinkModelResponse_default_instance_;
class RobotMetrics;
class RobotMetricsDefaultTypeInternal;
extern RobotMetricsDefaultTypeInternal _RobotMetrics_default_instance_;
class RobotMetricsRequest;
class RobotMetricsRequestDefaultTypeInternal;
extern RobotMetricsRequestDefaultTypeInternal _RobotMetricsRequest_default_instance_;
class RobotMetricsResponse;
class RobotMetricsResponseDefaultTypeInternal;
extern RobotMetricsResponseDefaultTypeInternal _RobotMetricsResponse_default_instance_;
class RobotState;
class RobotStateDefaultTypeInternal;
extern RobotStateDefaultTypeInternal _RobotState_default_instance_;
class RobotStateRequest;
class RobotStateRequestDefaultTypeInternal;
extern RobotStateRequestDefaultTypeInternal _RobotStateRequest_default_instance_;
class RobotStateResponse;
class RobotStateResponseDefaultTypeInternal;
extern RobotStateResponseDefaultTypeInternal _RobotStateResponse_default_instance_;
class Skeleton;
class SkeletonDefaultTypeInternal;
extern SkeletonDefaultTypeInternal _Skeleton_default_instance_;
class Skeleton_Link;
class Skeleton_LinkDefaultTypeInternal;
extern Skeleton_LinkDefaultTypeInternal _Skeleton_Link_default_instance_;
class Skeleton_Link_ObjModel;
class Skeleton_Link_ObjModelDefaultTypeInternal;
extern Skeleton_Link_ObjModelDefaultTypeInternal _Skeleton_Link_ObjModel_default_instance_;
class SystemFault;
class SystemFaultDefaultTypeInternal;
extern SystemFaultDefaultTypeInternal _SystemFault_default_instance_;
class SystemFaultState;
class SystemFaultStateDefaultTypeInternal;
extern SystemFaultStateDefaultTypeInternal _SystemFaultState_default_instance_;
class SystemFaultState_AggregatedEntry_DoNotUse;
class SystemFaultState_AggregatedEntry_DoNotUseDefaultTypeInternal;
extern SystemFaultState_AggregatedEntry_DoNotUseDefaultTypeInternal _SystemFaultState_AggregatedEntry_DoNotUse_default_instance_;
class WiFiState;
class WiFiStateDefaultTypeInternal;
extern WiFiStateDefaultTypeInternal _WiFiState_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::BatteryState* Arena::CreateMaybeMessage<::bosdyn::api::BatteryState>(Arena*);
template<> ::bosdyn::api::BehaviorFault* Arena::CreateMaybeMessage<::bosdyn::api::BehaviorFault>(Arena*);
template<> ::bosdyn::api::BehaviorFaultState* Arena::CreateMaybeMessage<::bosdyn::api::BehaviorFaultState>(Arena*);
template<> ::bosdyn::api::CommsState* Arena::CreateMaybeMessage<::bosdyn::api::CommsState>(Arena*);
template<> ::bosdyn::api::EStopState* Arena::CreateMaybeMessage<::bosdyn::api::EStopState>(Arena*);
template<> ::bosdyn::api::FootState* Arena::CreateMaybeMessage<::bosdyn::api::FootState>(Arena*);
template<> ::bosdyn::api::HardwareConfiguration* Arena::CreateMaybeMessage<::bosdyn::api::HardwareConfiguration>(Arena*);
template<> ::bosdyn::api::JointState* Arena::CreateMaybeMessage<::bosdyn::api::JointState>(Arena*);
template<> ::bosdyn::api::KinematicState* Arena::CreateMaybeMessage<::bosdyn::api::KinematicState>(Arena*);
template<> ::bosdyn::api::PowerState* Arena::CreateMaybeMessage<::bosdyn::api::PowerState>(Arena*);
template<> ::bosdyn::api::RobotHardwareConfigurationRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotHardwareConfigurationRequest>(Arena*);
template<> ::bosdyn::api::RobotHardwareConfigurationResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotHardwareConfigurationResponse>(Arena*);
template<> ::bosdyn::api::RobotLinkModelRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotLinkModelRequest>(Arena*);
template<> ::bosdyn::api::RobotLinkModelResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotLinkModelResponse>(Arena*);
template<> ::bosdyn::api::RobotMetrics* Arena::CreateMaybeMessage<::bosdyn::api::RobotMetrics>(Arena*);
template<> ::bosdyn::api::RobotMetricsRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotMetricsRequest>(Arena*);
template<> ::bosdyn::api::RobotMetricsResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotMetricsResponse>(Arena*);
template<> ::bosdyn::api::RobotState* Arena::CreateMaybeMessage<::bosdyn::api::RobotState>(Arena*);
template<> ::bosdyn::api::RobotStateRequest* Arena::CreateMaybeMessage<::bosdyn::api::RobotStateRequest>(Arena*);
template<> ::bosdyn::api::RobotStateResponse* Arena::CreateMaybeMessage<::bosdyn::api::RobotStateResponse>(Arena*);
template<> ::bosdyn::api::Skeleton* Arena::CreateMaybeMessage<::bosdyn::api::Skeleton>(Arena*);
template<> ::bosdyn::api::Skeleton_Link* Arena::CreateMaybeMessage<::bosdyn::api::Skeleton_Link>(Arena*);
template<> ::bosdyn::api::Skeleton_Link_ObjModel* Arena::CreateMaybeMessage<::bosdyn::api::Skeleton_Link_ObjModel>(Arena*);
template<> ::bosdyn::api::SystemFault* Arena::CreateMaybeMessage<::bosdyn::api::SystemFault>(Arena*);
template<> ::bosdyn::api::SystemFaultState* Arena::CreateMaybeMessage<::bosdyn::api::SystemFaultState>(Arena*);
template<> ::bosdyn::api::SystemFaultState_AggregatedEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::SystemFaultState_AggregatedEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::WiFiState* Arena::CreateMaybeMessage<::bosdyn::api::WiFiState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum PowerState_MotorPowerState : int {
  PowerState_MotorPowerState_STATE_UNKNOWN = 0,
  PowerState_MotorPowerState_STATE_OFF = 1,
  PowerState_MotorPowerState_STATE_ON = 2,
  PowerState_MotorPowerState_STATE_POWERING_ON = 3,
  PowerState_MotorPowerState_STATE_POWERING_OFF = 4,
  PowerState_MotorPowerState_STATE_ERROR = 5,
  PowerState_MotorPowerState_PowerState_MotorPowerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PowerState_MotorPowerState_PowerState_MotorPowerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PowerState_MotorPowerState_IsValid(int value);
constexpr PowerState_MotorPowerState PowerState_MotorPowerState_MotorPowerState_MIN = PowerState_MotorPowerState_STATE_UNKNOWN;
constexpr PowerState_MotorPowerState PowerState_MotorPowerState_MotorPowerState_MAX = PowerState_MotorPowerState_STATE_ERROR;
constexpr int PowerState_MotorPowerState_MotorPowerState_ARRAYSIZE = PowerState_MotorPowerState_MotorPowerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerState_MotorPowerState_descriptor();
template<typename T>
inline const std::string& PowerState_MotorPowerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerState_MotorPowerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerState_MotorPowerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerState_MotorPowerState_descriptor(), enum_t_value);
}
inline bool PowerState_MotorPowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerState_MotorPowerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerState_MotorPowerState>(
    PowerState_MotorPowerState_descriptor(), name, value);
}
enum PowerState_ShorePowerState : int {
  PowerState_ShorePowerState_STATE_UNKNOWN_SHORE_POWER = 0,
  PowerState_ShorePowerState_STATE_ON_SHORE_POWER = 1,
  PowerState_ShorePowerState_STATE_OFF_SHORE_POWER = 2,
  PowerState_ShorePowerState_PowerState_ShorePowerState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PowerState_ShorePowerState_PowerState_ShorePowerState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PowerState_ShorePowerState_IsValid(int value);
constexpr PowerState_ShorePowerState PowerState_ShorePowerState_ShorePowerState_MIN = PowerState_ShorePowerState_STATE_UNKNOWN_SHORE_POWER;
constexpr PowerState_ShorePowerState PowerState_ShorePowerState_ShorePowerState_MAX = PowerState_ShorePowerState_STATE_OFF_SHORE_POWER;
constexpr int PowerState_ShorePowerState_ShorePowerState_ARRAYSIZE = PowerState_ShorePowerState_ShorePowerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PowerState_ShorePowerState_descriptor();
template<typename T>
inline const std::string& PowerState_ShorePowerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PowerState_ShorePowerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PowerState_ShorePowerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PowerState_ShorePowerState_descriptor(), enum_t_value);
}
inline bool PowerState_ShorePowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PowerState_ShorePowerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PowerState_ShorePowerState>(
    PowerState_ShorePowerState_descriptor(), name, value);
}
enum SystemFault_Severity : int {
  SystemFault_Severity_SEVERITY_UNKNOWN = 0,
  SystemFault_Severity_SEVERITY_INFO = 1,
  SystemFault_Severity_SEVERITY_WARN = 2,
  SystemFault_Severity_SEVERITY_CRITICAL = 3,
  SystemFault_Severity_SystemFault_Severity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SystemFault_Severity_SystemFault_Severity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SystemFault_Severity_IsValid(int value);
constexpr SystemFault_Severity SystemFault_Severity_Severity_MIN = SystemFault_Severity_SEVERITY_UNKNOWN;
constexpr SystemFault_Severity SystemFault_Severity_Severity_MAX = SystemFault_Severity_SEVERITY_CRITICAL;
constexpr int SystemFault_Severity_Severity_ARRAYSIZE = SystemFault_Severity_Severity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemFault_Severity_descriptor();
template<typename T>
inline const std::string& SystemFault_Severity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemFault_Severity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemFault_Severity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemFault_Severity_descriptor(), enum_t_value);
}
inline bool SystemFault_Severity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemFault_Severity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemFault_Severity>(
    SystemFault_Severity_descriptor(), name, value);
}
enum EStopState_Type : int {
  EStopState_Type_TYPE_UNKNOWN = 0,
  EStopState_Type_TYPE_HARDWARE = 1,
  EStopState_Type_TYPE_SOFTWARE = 2,
  EStopState_Type_EStopState_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EStopState_Type_EStopState_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EStopState_Type_IsValid(int value);
constexpr EStopState_Type EStopState_Type_Type_MIN = EStopState_Type_TYPE_UNKNOWN;
constexpr EStopState_Type EStopState_Type_Type_MAX = EStopState_Type_TYPE_SOFTWARE;
constexpr int EStopState_Type_Type_ARRAYSIZE = EStopState_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStopState_Type_descriptor();
template<typename T>
inline const std::string& EStopState_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStopState_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStopState_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStopState_Type_descriptor(), enum_t_value);
}
inline bool EStopState_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStopState_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStopState_Type>(
    EStopState_Type_descriptor(), name, value);
}
enum EStopState_State : int {
  EStopState_State_STATE_UNKNOWN = 0,
  EStopState_State_STATE_ESTOPPED = 1,
  EStopState_State_STATE_NOT_ESTOPPED = 2,
  EStopState_State_EStopState_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EStopState_State_EStopState_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EStopState_State_IsValid(int value);
constexpr EStopState_State EStopState_State_State_MIN = EStopState_State_STATE_UNKNOWN;
constexpr EStopState_State EStopState_State_State_MAX = EStopState_State_STATE_NOT_ESTOPPED;
constexpr int EStopState_State_State_ARRAYSIZE = EStopState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStopState_State_descriptor();
template<typename T>
inline const std::string& EStopState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStopState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStopState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStopState_State_descriptor(), enum_t_value);
}
inline bool EStopState_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStopState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStopState_State>(
    EStopState_State_descriptor(), name, value);
}
enum BatteryState_Status : int {
  BatteryState_Status_STATUS_UNKNOWN = 0,
  BatteryState_Status_STATUS_MISSING = 1,
  BatteryState_Status_STATUS_CHARGING = 2,
  BatteryState_Status_STATUS_DISCHARGING = 3,
  BatteryState_Status_STATUS_BOOTING = 4,
  BatteryState_Status_BatteryState_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BatteryState_Status_BatteryState_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BatteryState_Status_IsValid(int value);
constexpr BatteryState_Status BatteryState_Status_Status_MIN = BatteryState_Status_STATUS_UNKNOWN;
constexpr BatteryState_Status BatteryState_Status_Status_MAX = BatteryState_Status_STATUS_BOOTING;
constexpr int BatteryState_Status_Status_ARRAYSIZE = BatteryState_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatteryState_Status_descriptor();
template<typename T>
inline const std::string& BatteryState_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryState_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryState_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatteryState_Status_descriptor(), enum_t_value);
}
inline bool BatteryState_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatteryState_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatteryState_Status>(
    BatteryState_Status_descriptor(), name, value);
}
enum BehaviorFault_Cause : int {
  BehaviorFault_Cause_CAUSE_UNKNOWN = 0,
  BehaviorFault_Cause_CAUSE_FALL = 1,
  BehaviorFault_Cause_CAUSE_HARDWARE = 2,
  BehaviorFault_Cause_BehaviorFault_Cause_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BehaviorFault_Cause_BehaviorFault_Cause_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BehaviorFault_Cause_IsValid(int value);
constexpr BehaviorFault_Cause BehaviorFault_Cause_Cause_MIN = BehaviorFault_Cause_CAUSE_UNKNOWN;
constexpr BehaviorFault_Cause BehaviorFault_Cause_Cause_MAX = BehaviorFault_Cause_CAUSE_HARDWARE;
constexpr int BehaviorFault_Cause_Cause_ARRAYSIZE = BehaviorFault_Cause_Cause_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BehaviorFault_Cause_descriptor();
template<typename T>
inline const std::string& BehaviorFault_Cause_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BehaviorFault_Cause>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BehaviorFault_Cause_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BehaviorFault_Cause_descriptor(), enum_t_value);
}
inline bool BehaviorFault_Cause_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BehaviorFault_Cause* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BehaviorFault_Cause>(
    BehaviorFault_Cause_descriptor(), name, value);
}
enum BehaviorFault_Status : int {
  BehaviorFault_Status_STATUS_UNKNOWN = 0,
  BehaviorFault_Status_STATUS_CLEARABLE = 1,
  BehaviorFault_Status_STATUS_UNCLEARABLE = 2,
  BehaviorFault_Status_BehaviorFault_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BehaviorFault_Status_BehaviorFault_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BehaviorFault_Status_IsValid(int value);
constexpr BehaviorFault_Status BehaviorFault_Status_Status_MIN = BehaviorFault_Status_STATUS_UNKNOWN;
constexpr BehaviorFault_Status BehaviorFault_Status_Status_MAX = BehaviorFault_Status_STATUS_UNCLEARABLE;
constexpr int BehaviorFault_Status_Status_ARRAYSIZE = BehaviorFault_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BehaviorFault_Status_descriptor();
template<typename T>
inline const std::string& BehaviorFault_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BehaviorFault_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BehaviorFault_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BehaviorFault_Status_descriptor(), enum_t_value);
}
inline bool BehaviorFault_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BehaviorFault_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BehaviorFault_Status>(
    BehaviorFault_Status_descriptor(), name, value);
}
enum WiFiState_Mode : int {
  WiFiState_Mode_MODE_UNKNOWN = 0,
  WiFiState_Mode_MODE_ACCESS_POINT = 1,
  WiFiState_Mode_MODE_CLIENT = 2,
  WiFiState_Mode_WiFiState_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WiFiState_Mode_WiFiState_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WiFiState_Mode_IsValid(int value);
constexpr WiFiState_Mode WiFiState_Mode_Mode_MIN = WiFiState_Mode_MODE_UNKNOWN;
constexpr WiFiState_Mode WiFiState_Mode_Mode_MAX = WiFiState_Mode_MODE_CLIENT;
constexpr int WiFiState_Mode_Mode_ARRAYSIZE = WiFiState_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WiFiState_Mode_descriptor();
template<typename T>
inline const std::string& WiFiState_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WiFiState_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WiFiState_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WiFiState_Mode_descriptor(), enum_t_value);
}
inline bool WiFiState_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WiFiState_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WiFiState_Mode>(
    WiFiState_Mode_descriptor(), name, value);
}
enum FootState_Contact : int {
  FootState_Contact_CONTACT_UNKNOWN = 0,
  FootState_Contact_CONTACT_MADE = 1,
  FootState_Contact_CONTACT_LOST = 2,
  FootState_Contact_FootState_Contact_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FootState_Contact_FootState_Contact_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FootState_Contact_IsValid(int value);
constexpr FootState_Contact FootState_Contact_Contact_MIN = FootState_Contact_CONTACT_UNKNOWN;
constexpr FootState_Contact FootState_Contact_Contact_MAX = FootState_Contact_CONTACT_LOST;
constexpr int FootState_Contact_Contact_ARRAYSIZE = FootState_Contact_Contact_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FootState_Contact_descriptor();
template<typename T>
inline const std::string& FootState_Contact_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FootState_Contact>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FootState_Contact_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FootState_Contact_descriptor(), enum_t_value);
}
inline bool FootState_Contact_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FootState_Contact* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FootState_Contact>(
    FootState_Contact_descriptor(), name, value);
}
// ===================================================================

class Skeleton_Link_ObjModel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Skeleton.Link.ObjModel) */ {
 public:
  inline Skeleton_Link_ObjModel() : Skeleton_Link_ObjModel(nullptr) {}
  virtual ~Skeleton_Link_ObjModel();

  Skeleton_Link_ObjModel(const Skeleton_Link_ObjModel& from);
  Skeleton_Link_ObjModel(Skeleton_Link_ObjModel&& from) noexcept
    : Skeleton_Link_ObjModel() {
    *this = ::std::move(from);
  }

  inline Skeleton_Link_ObjModel& operator=(const Skeleton_Link_ObjModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skeleton_Link_ObjModel& operator=(Skeleton_Link_ObjModel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Skeleton_Link_ObjModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Skeleton_Link_ObjModel* internal_default_instance() {
    return reinterpret_cast<const Skeleton_Link_ObjModel*>(
               &_Skeleton_Link_ObjModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Skeleton_Link_ObjModel& a, Skeleton_Link_ObjModel& b) {
    a.Swap(&b);
  }
  inline void Swap(Skeleton_Link_ObjModel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Skeleton_Link_ObjModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Skeleton_Link_ObjModel* New() const final {
    return CreateMaybeMessage<Skeleton_Link_ObjModel>(nullptr);
  }

  Skeleton_Link_ObjModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Skeleton_Link_ObjModel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Skeleton_Link_ObjModel& from);
  void MergeFrom(const Skeleton_Link_ObjModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skeleton_Link_ObjModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Skeleton.Link.ObjModel";
  }
  protected:
  explicit Skeleton_Link_ObjModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 1,
    kFileContentsFieldNumber = 2,
  };
  // string file_name = 1;
  void clear_file_name();
  const std::string& file_name() const;
  void set_file_name(const std::string& value);
  void set_file_name(std::string&& value);
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  std::string* mutable_file_name();
  std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string file_contents = 2;
  void clear_file_contents();
  const std::string& file_contents() const;
  void set_file_contents(const std::string& value);
  void set_file_contents(std::string&& value);
  void set_file_contents(const char* value);
  void set_file_contents(const char* value, size_t size);
  std::string* mutable_file_contents();
  std::string* release_file_contents();
  void set_allocated_file_contents(std::string* file_contents);
  private:
  const std::string& _internal_file_contents() const;
  void _internal_set_file_contents(const std::string& value);
  std::string* _internal_mutable_file_contents();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Skeleton.Link.ObjModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_contents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class Skeleton_Link PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Skeleton.Link) */ {
 public:
  inline Skeleton_Link() : Skeleton_Link(nullptr) {}
  virtual ~Skeleton_Link();

  Skeleton_Link(const Skeleton_Link& from);
  Skeleton_Link(Skeleton_Link&& from) noexcept
    : Skeleton_Link() {
    *this = ::std::move(from);
  }

  inline Skeleton_Link& operator=(const Skeleton_Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skeleton_Link& operator=(Skeleton_Link&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Skeleton_Link& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Skeleton_Link* internal_default_instance() {
    return reinterpret_cast<const Skeleton_Link*>(
               &_Skeleton_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Skeleton_Link& a, Skeleton_Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Skeleton_Link* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Skeleton_Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Skeleton_Link* New() const final {
    return CreateMaybeMessage<Skeleton_Link>(nullptr);
  }

  Skeleton_Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Skeleton_Link>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Skeleton_Link& from);
  void MergeFrom(const Skeleton_Link& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skeleton_Link* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Skeleton.Link";
  }
  protected:
  explicit Skeleton_Link(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Skeleton_Link_ObjModel ObjModel;

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kObjModelFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.Skeleton.Link.ObjModel obj_model = 2;
  bool has_obj_model() const;
  private:
  bool _internal_has_obj_model() const;
  public:
  void clear_obj_model();
  const ::bosdyn::api::Skeleton_Link_ObjModel& obj_model() const;
  ::bosdyn::api::Skeleton_Link_ObjModel* release_obj_model();
  ::bosdyn::api::Skeleton_Link_ObjModel* mutable_obj_model();
  void set_allocated_obj_model(::bosdyn::api::Skeleton_Link_ObjModel* obj_model);
  private:
  const ::bosdyn::api::Skeleton_Link_ObjModel& _internal_obj_model() const;
  ::bosdyn::api::Skeleton_Link_ObjModel* _internal_mutable_obj_model();
  public:
  void unsafe_arena_set_allocated_obj_model(
      ::bosdyn::api::Skeleton_Link_ObjModel* obj_model);
  ::bosdyn::api::Skeleton_Link_ObjModel* unsafe_arena_release_obj_model();

  // @@protoc_insertion_point(class_scope:bosdyn.api.Skeleton.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::bosdyn::api::Skeleton_Link_ObjModel* obj_model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class Skeleton PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Skeleton) */ {
 public:
  inline Skeleton() : Skeleton(nullptr) {}
  virtual ~Skeleton();

  Skeleton(const Skeleton& from);
  Skeleton(Skeleton&& from) noexcept
    : Skeleton() {
    *this = ::std::move(from);
  }

  inline Skeleton& operator=(const Skeleton& from) {
    CopyFrom(from);
    return *this;
  }
  inline Skeleton& operator=(Skeleton&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Skeleton& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Skeleton* internal_default_instance() {
    return reinterpret_cast<const Skeleton*>(
               &_Skeleton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Skeleton& a, Skeleton& b) {
    a.Swap(&b);
  }
  inline void Swap(Skeleton* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Skeleton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Skeleton* New() const final {
    return CreateMaybeMessage<Skeleton>(nullptr);
  }

  Skeleton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Skeleton>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Skeleton& from);
  void MergeFrom(const Skeleton& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Skeleton* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Skeleton";
  }
  protected:
  explicit Skeleton(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Skeleton_Link Link;

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 2,
    kUrdfFieldNumber = 3,
  };
  // repeated .bosdyn.api.Skeleton.Link links = 2;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::bosdyn::api::Skeleton_Link* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link >*
      mutable_links();
  private:
  const ::bosdyn::api::Skeleton_Link& _internal_links(int index) const;
  ::bosdyn::api::Skeleton_Link* _internal_add_links();
  public:
  const ::bosdyn::api::Skeleton_Link& links(int index) const;
  ::bosdyn::api::Skeleton_Link* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link >&
      links() const;

  // string urdf = 3;
  void clear_urdf();
  const std::string& urdf() const;
  void set_urdf(const std::string& value);
  void set_urdf(std::string&& value);
  void set_urdf(const char* value);
  void set_urdf(const char* value, size_t size);
  std::string* mutable_urdf();
  std::string* release_urdf();
  void set_allocated_urdf(std::string* urdf);
  private:
  const std::string& _internal_urdf() const;
  void _internal_set_urdf(const std::string& value);
  std::string* _internal_mutable_urdf();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Skeleton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link > links_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr urdf_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class HardwareConfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.HardwareConfiguration) */ {
 public:
  inline HardwareConfiguration() : HardwareConfiguration(nullptr) {}
  virtual ~HardwareConfiguration();

  HardwareConfiguration(const HardwareConfiguration& from);
  HardwareConfiguration(HardwareConfiguration&& from) noexcept
    : HardwareConfiguration() {
    *this = ::std::move(from);
  }

  inline HardwareConfiguration& operator=(const HardwareConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareConfiguration& operator=(HardwareConfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HardwareConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HardwareConfiguration* internal_default_instance() {
    return reinterpret_cast<const HardwareConfiguration*>(
               &_HardwareConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HardwareConfiguration& a, HardwareConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(HardwareConfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HardwareConfiguration* New() const final {
    return CreateMaybeMessage<HardwareConfiguration>(nullptr);
  }

  HardwareConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HardwareConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HardwareConfiguration& from);
  void MergeFrom(const HardwareConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardwareConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.HardwareConfiguration";
  }
  protected:
  explicit HardwareConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkeletonFieldNumber = 1,
  };
  // .bosdyn.api.Skeleton skeleton = 1;
  bool has_skeleton() const;
  private:
  bool _internal_has_skeleton() const;
  public:
  void clear_skeleton();
  const ::bosdyn::api::Skeleton& skeleton() const;
  ::bosdyn::api::Skeleton* release_skeleton();
  ::bosdyn::api::Skeleton* mutable_skeleton();
  void set_allocated_skeleton(::bosdyn::api::Skeleton* skeleton);
  private:
  const ::bosdyn::api::Skeleton& _internal_skeleton() const;
  ::bosdyn::api::Skeleton* _internal_mutable_skeleton();
  public:
  void unsafe_arena_set_allocated_skeleton(
      ::bosdyn::api::Skeleton* skeleton);
  ::bosdyn::api::Skeleton* unsafe_arena_release_skeleton();

  // @@protoc_insertion_point(class_scope:bosdyn.api.HardwareConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Skeleton* skeleton_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotState) */ {
 public:
  inline RobotState() : RobotState(nullptr) {}
  virtual ~RobotState();

  RobotState(const RobotState& from);
  RobotState(RobotState&& from) noexcept
    : RobotState() {
    *this = ::std::move(from);
  }

  inline RobotState& operator=(const RobotState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotState& operator=(RobotState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotState* internal_default_instance() {
    return reinterpret_cast<const RobotState*>(
               &_RobotState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RobotState& a, RobotState& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotState* New() const final {
    return CreateMaybeMessage<RobotState>(nullptr);
  }

  RobotState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotState& from);
  void MergeFrom(const RobotState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotState";
  }
  protected:
  explicit RobotState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBatteryStatesFieldNumber = 2,
    kCommsStatesFieldNumber = 3,
    kEstopStatesFieldNumber = 5,
    kFootStateFieldNumber = 8,
    kPowerStateFieldNumber = 1,
    kSystemFaultStateFieldNumber = 4,
    kKinematicStateFieldNumber = 6,
    kBehaviorFaultStateFieldNumber = 7,
  };
  // repeated .bosdyn.api.BatteryState battery_states = 2;
  int battery_states_size() const;
  private:
  int _internal_battery_states_size() const;
  public:
  void clear_battery_states();
  ::bosdyn::api::BatteryState* mutable_battery_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState >*
      mutable_battery_states();
  private:
  const ::bosdyn::api::BatteryState& _internal_battery_states(int index) const;
  ::bosdyn::api::BatteryState* _internal_add_battery_states();
  public:
  const ::bosdyn::api::BatteryState& battery_states(int index) const;
  ::bosdyn::api::BatteryState* add_battery_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState >&
      battery_states() const;

  // repeated .bosdyn.api.CommsState comms_states = 3;
  int comms_states_size() const;
  private:
  int _internal_comms_states_size() const;
  public:
  void clear_comms_states();
  ::bosdyn::api::CommsState* mutable_comms_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState >*
      mutable_comms_states();
  private:
  const ::bosdyn::api::CommsState& _internal_comms_states(int index) const;
  ::bosdyn::api::CommsState* _internal_add_comms_states();
  public:
  const ::bosdyn::api::CommsState& comms_states(int index) const;
  ::bosdyn::api::CommsState* add_comms_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState >&
      comms_states() const;

  // repeated .bosdyn.api.EStopState estop_states = 5;
  int estop_states_size() const;
  private:
  int _internal_estop_states_size() const;
  public:
  void clear_estop_states();
  ::bosdyn::api::EStopState* mutable_estop_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState >*
      mutable_estop_states();
  private:
  const ::bosdyn::api::EStopState& _internal_estop_states(int index) const;
  ::bosdyn::api::EStopState* _internal_add_estop_states();
  public:
  const ::bosdyn::api::EStopState& estop_states(int index) const;
  ::bosdyn::api::EStopState* add_estop_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState >&
      estop_states() const;

  // repeated .bosdyn.api.FootState foot_state = 8;
  int foot_state_size() const;
  private:
  int _internal_foot_state_size() const;
  public:
  void clear_foot_state();
  ::bosdyn::api::FootState* mutable_foot_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState >*
      mutable_foot_state();
  private:
  const ::bosdyn::api::FootState& _internal_foot_state(int index) const;
  ::bosdyn::api::FootState* _internal_add_foot_state();
  public:
  const ::bosdyn::api::FootState& foot_state(int index) const;
  ::bosdyn::api::FootState* add_foot_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState >&
      foot_state() const;

  // .bosdyn.api.PowerState power_state = 1;
  bool has_power_state() const;
  private:
  bool _internal_has_power_state() const;
  public:
  void clear_power_state();
  const ::bosdyn::api::PowerState& power_state() const;
  ::bosdyn::api::PowerState* release_power_state();
  ::bosdyn::api::PowerState* mutable_power_state();
  void set_allocated_power_state(::bosdyn::api::PowerState* power_state);
  private:
  const ::bosdyn::api::PowerState& _internal_power_state() const;
  ::bosdyn::api::PowerState* _internal_mutable_power_state();
  public:
  void unsafe_arena_set_allocated_power_state(
      ::bosdyn::api::PowerState* power_state);
  ::bosdyn::api::PowerState* unsafe_arena_release_power_state();

  // .bosdyn.api.SystemFaultState system_fault_state = 4;
  bool has_system_fault_state() const;
  private:
  bool _internal_has_system_fault_state() const;
  public:
  void clear_system_fault_state();
  const ::bosdyn::api::SystemFaultState& system_fault_state() const;
  ::bosdyn::api::SystemFaultState* release_system_fault_state();
  ::bosdyn::api::SystemFaultState* mutable_system_fault_state();
  void set_allocated_system_fault_state(::bosdyn::api::SystemFaultState* system_fault_state);
  private:
  const ::bosdyn::api::SystemFaultState& _internal_system_fault_state() const;
  ::bosdyn::api::SystemFaultState* _internal_mutable_system_fault_state();
  public:
  void unsafe_arena_set_allocated_system_fault_state(
      ::bosdyn::api::SystemFaultState* system_fault_state);
  ::bosdyn::api::SystemFaultState* unsafe_arena_release_system_fault_state();

  // .bosdyn.api.KinematicState kinematic_state = 6;
  bool has_kinematic_state() const;
  private:
  bool _internal_has_kinematic_state() const;
  public:
  void clear_kinematic_state();
  const ::bosdyn::api::KinematicState& kinematic_state() const;
  ::bosdyn::api::KinematicState* release_kinematic_state();
  ::bosdyn::api::KinematicState* mutable_kinematic_state();
  void set_allocated_kinematic_state(::bosdyn::api::KinematicState* kinematic_state);
  private:
  const ::bosdyn::api::KinematicState& _internal_kinematic_state() const;
  ::bosdyn::api::KinematicState* _internal_mutable_kinematic_state();
  public:
  void unsafe_arena_set_allocated_kinematic_state(
      ::bosdyn::api::KinematicState* kinematic_state);
  ::bosdyn::api::KinematicState* unsafe_arena_release_kinematic_state();

  // .bosdyn.api.BehaviorFaultState behavior_fault_state = 7;
  bool has_behavior_fault_state() const;
  private:
  bool _internal_has_behavior_fault_state() const;
  public:
  void clear_behavior_fault_state();
  const ::bosdyn::api::BehaviorFaultState& behavior_fault_state() const;
  ::bosdyn::api::BehaviorFaultState* release_behavior_fault_state();
  ::bosdyn::api::BehaviorFaultState* mutable_behavior_fault_state();
  void set_allocated_behavior_fault_state(::bosdyn::api::BehaviorFaultState* behavior_fault_state);
  private:
  const ::bosdyn::api::BehaviorFaultState& _internal_behavior_fault_state() const;
  ::bosdyn::api::BehaviorFaultState* _internal_mutable_behavior_fault_state();
  public:
  void unsafe_arena_set_allocated_behavior_fault_state(
      ::bosdyn::api::BehaviorFaultState* behavior_fault_state);
  ::bosdyn::api::BehaviorFaultState* unsafe_arena_release_behavior_fault_state();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState > battery_states_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState > comms_states_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState > estop_states_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState > foot_state_;
  ::bosdyn::api::PowerState* power_state_;
  ::bosdyn::api::SystemFaultState* system_fault_state_;
  ::bosdyn::api::KinematicState* kinematic_state_;
  ::bosdyn::api::BehaviorFaultState* behavior_fault_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class PowerState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PowerState) */ {
 public:
  inline PowerState() : PowerState(nullptr) {}
  virtual ~PowerState();

  PowerState(const PowerState& from);
  PowerState(PowerState&& from) noexcept
    : PowerState() {
    *this = ::std::move(from);
  }

  inline PowerState& operator=(const PowerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PowerState& operator=(PowerState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PowerState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowerState* internal_default_instance() {
    return reinterpret_cast<const PowerState*>(
               &_PowerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PowerState& a, PowerState& b) {
    a.Swap(&b);
  }
  inline void Swap(PowerState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PowerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PowerState* New() const final {
    return CreateMaybeMessage<PowerState>(nullptr);
  }

  PowerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PowerState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PowerState& from);
  void MergeFrom(const PowerState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowerState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PowerState";
  }
  protected:
  explicit PowerState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PowerState_MotorPowerState MotorPowerState;
  static constexpr MotorPowerState STATE_UNKNOWN =
    PowerState_MotorPowerState_STATE_UNKNOWN;
  static constexpr MotorPowerState STATE_OFF =
    PowerState_MotorPowerState_STATE_OFF;
  static constexpr MotorPowerState STATE_ON =
    PowerState_MotorPowerState_STATE_ON;
  static constexpr MotorPowerState STATE_POWERING_ON =
    PowerState_MotorPowerState_STATE_POWERING_ON;
  static constexpr MotorPowerState STATE_POWERING_OFF =
    PowerState_MotorPowerState_STATE_POWERING_OFF;
  static constexpr MotorPowerState STATE_ERROR =
    PowerState_MotorPowerState_STATE_ERROR;
  static inline bool MotorPowerState_IsValid(int value) {
    return PowerState_MotorPowerState_IsValid(value);
  }
  static constexpr MotorPowerState MotorPowerState_MIN =
    PowerState_MotorPowerState_MotorPowerState_MIN;
  static constexpr MotorPowerState MotorPowerState_MAX =
    PowerState_MotorPowerState_MotorPowerState_MAX;
  static constexpr int MotorPowerState_ARRAYSIZE =
    PowerState_MotorPowerState_MotorPowerState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorPowerState_descriptor() {
    return PowerState_MotorPowerState_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorPowerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorPowerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorPowerState_Name.");
    return PowerState_MotorPowerState_Name(enum_t_value);
  }
  static inline bool MotorPowerState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorPowerState* value) {
    return PowerState_MotorPowerState_Parse(name, value);
  }

  typedef PowerState_ShorePowerState ShorePowerState;
  static constexpr ShorePowerState STATE_UNKNOWN_SHORE_POWER =
    PowerState_ShorePowerState_STATE_UNKNOWN_SHORE_POWER;
  static constexpr ShorePowerState STATE_ON_SHORE_POWER =
    PowerState_ShorePowerState_STATE_ON_SHORE_POWER;
  static constexpr ShorePowerState STATE_OFF_SHORE_POWER =
    PowerState_ShorePowerState_STATE_OFF_SHORE_POWER;
  static inline bool ShorePowerState_IsValid(int value) {
    return PowerState_ShorePowerState_IsValid(value);
  }
  static constexpr ShorePowerState ShorePowerState_MIN =
    PowerState_ShorePowerState_ShorePowerState_MIN;
  static constexpr ShorePowerState ShorePowerState_MAX =
    PowerState_ShorePowerState_ShorePowerState_MAX;
  static constexpr int ShorePowerState_ARRAYSIZE =
    PowerState_ShorePowerState_ShorePowerState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShorePowerState_descriptor() {
    return PowerState_ShorePowerState_descriptor();
  }
  template<typename T>
  static inline const std::string& ShorePowerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShorePowerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShorePowerState_Name.");
    return PowerState_ShorePowerState_Name(enum_t_value);
  }
  static inline bool ShorePowerState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ShorePowerState* value) {
    return PowerState_ShorePowerState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLocomotionChargePercentageFieldNumber = 4,
    kLocomotionEstimatedRuntimeFieldNumber = 5,
    kMotorPowerStateFieldNumber = 2,
    kShorePowerStateFieldNumber = 3,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .google.protobuf.DoubleValue locomotion_charge_percentage = 4;
  bool has_locomotion_charge_percentage() const;
  private:
  bool _internal_has_locomotion_charge_percentage() const;
  public:
  void clear_locomotion_charge_percentage();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& locomotion_charge_percentage() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_locomotion_charge_percentage();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_locomotion_charge_percentage();
  void set_allocated_locomotion_charge_percentage(PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_locomotion_charge_percentage() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_locomotion_charge_percentage();
  public:
  void unsafe_arena_set_allocated_locomotion_charge_percentage(
      PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_locomotion_charge_percentage();

  // .google.protobuf.Duration locomotion_estimated_runtime = 5;
  bool has_locomotion_estimated_runtime() const;
  private:
  bool _internal_has_locomotion_estimated_runtime() const;
  public:
  void clear_locomotion_estimated_runtime();
  const PROTOBUF_NAMESPACE_ID::Duration& locomotion_estimated_runtime() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_locomotion_estimated_runtime();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_locomotion_estimated_runtime();
  void set_allocated_locomotion_estimated_runtime(PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_locomotion_estimated_runtime() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_locomotion_estimated_runtime();
  public:
  void unsafe_arena_set_allocated_locomotion_estimated_runtime(
      PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_locomotion_estimated_runtime();

  // .bosdyn.api.PowerState.MotorPowerState motor_power_state = 2;
  void clear_motor_power_state();
  ::bosdyn::api::PowerState_MotorPowerState motor_power_state() const;
  void set_motor_power_state(::bosdyn::api::PowerState_MotorPowerState value);
  private:
  ::bosdyn::api::PowerState_MotorPowerState _internal_motor_power_state() const;
  void _internal_set_motor_power_state(::bosdyn::api::PowerState_MotorPowerState value);
  public:

  // .bosdyn.api.PowerState.ShorePowerState shore_power_state = 3;
  void clear_shore_power_state();
  ::bosdyn::api::PowerState_ShorePowerState shore_power_state() const;
  void set_shore_power_state(::bosdyn::api::PowerState_ShorePowerState value);
  private:
  ::bosdyn::api::PowerState_ShorePowerState _internal_shore_power_state() const;
  void _internal_set_shore_power_state(::bosdyn::api::PowerState_ShorePowerState value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PowerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage_;
  PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime_;
  int motor_power_state_;
  int shore_power_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class SystemFaultState_AggregatedEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemFaultState_AggregatedEntry_DoNotUse, 
    std::string, ::bosdyn::api::SystemFault_Severity,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemFaultState_AggregatedEntry_DoNotUse, 
    std::string, ::bosdyn::api::SystemFault_Severity,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
    0 > SuperType;
  SystemFaultState_AggregatedEntry_DoNotUse();
  explicit SystemFaultState_AggregatedEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SystemFaultState_AggregatedEntry_DoNotUse& other);
  static const SystemFaultState_AggregatedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SystemFaultState_AggregatedEntry_DoNotUse*>(&_SystemFaultState_AggregatedEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.SystemFaultState.AggregatedEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[6];
  }

  public:
};

// -------------------------------------------------------------------

class SystemFaultState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SystemFaultState) */ {
 public:
  inline SystemFaultState() : SystemFaultState(nullptr) {}
  virtual ~SystemFaultState();

  SystemFaultState(const SystemFaultState& from);
  SystemFaultState(SystemFaultState&& from) noexcept
    : SystemFaultState() {
    *this = ::std::move(from);
  }

  inline SystemFaultState& operator=(const SystemFaultState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemFaultState& operator=(SystemFaultState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SystemFaultState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemFaultState* internal_default_instance() {
    return reinterpret_cast<const SystemFaultState*>(
               &_SystemFaultState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SystemFaultState& a, SystemFaultState& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemFaultState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemFaultState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemFaultState* New() const final {
    return CreateMaybeMessage<SystemFaultState>(nullptr);
  }

  SystemFaultState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemFaultState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SystemFaultState& from);
  void MergeFrom(const SystemFaultState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemFaultState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SystemFaultState";
  }
  protected:
  explicit SystemFaultState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFaultsFieldNumber = 1,
    kHistoricalFaultsFieldNumber = 2,
    kAggregatedFieldNumber = 3,
  };
  // repeated .bosdyn.api.SystemFault faults = 1;
  int faults_size() const;
  private:
  int _internal_faults_size() const;
  public:
  void clear_faults();
  ::bosdyn::api::SystemFault* mutable_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
      mutable_faults();
  private:
  const ::bosdyn::api::SystemFault& _internal_faults(int index) const;
  ::bosdyn::api::SystemFault* _internal_add_faults();
  public:
  const ::bosdyn::api::SystemFault& faults(int index) const;
  ::bosdyn::api::SystemFault* add_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
      faults() const;

  // repeated .bosdyn.api.SystemFault historical_faults = 2;
  int historical_faults_size() const;
  private:
  int _internal_historical_faults_size() const;
  public:
  void clear_historical_faults();
  ::bosdyn::api::SystemFault* mutable_historical_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
      mutable_historical_faults();
  private:
  const ::bosdyn::api::SystemFault& _internal_historical_faults(int index) const;
  ::bosdyn::api::SystemFault* _internal_add_historical_faults();
  public:
  const ::bosdyn::api::SystemFault& historical_faults(int index) const;
  ::bosdyn::api::SystemFault* add_historical_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
      historical_faults() const;

  // map<string, .bosdyn.api.SystemFault.Severity> aggregated = 3;
  int aggregated_size() const;
  private:
  int _internal_aggregated_size() const;
  public:
  void clear_aggregated();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >&
      _internal_aggregated() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >*
      _internal_mutable_aggregated();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >&
      aggregated() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >*
      mutable_aggregated();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SystemFaultState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault > faults_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault > historical_faults_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SystemFaultState_AggregatedEntry_DoNotUse,
      std::string, ::bosdyn::api::SystemFault_Severity,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
      0 > aggregated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class SystemFault PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SystemFault) */ {
 public:
  inline SystemFault() : SystemFault(nullptr) {}
  virtual ~SystemFault();

  SystemFault(const SystemFault& from);
  SystemFault(SystemFault&& from) noexcept
    : SystemFault() {
    *this = ::std::move(from);
  }

  inline SystemFault& operator=(const SystemFault& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemFault& operator=(SystemFault&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SystemFault& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemFault* internal_default_instance() {
    return reinterpret_cast<const SystemFault*>(
               &_SystemFault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SystemFault& a, SystemFault& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemFault* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemFault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SystemFault* New() const final {
    return CreateMaybeMessage<SystemFault>(nullptr);
  }

  SystemFault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SystemFault>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SystemFault& from);
  void MergeFrom(const SystemFault& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemFault* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SystemFault";
  }
  protected:
  explicit SystemFault(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SystemFault_Severity Severity;
  static constexpr Severity SEVERITY_UNKNOWN =
    SystemFault_Severity_SEVERITY_UNKNOWN;
  static constexpr Severity SEVERITY_INFO =
    SystemFault_Severity_SEVERITY_INFO;
  static constexpr Severity SEVERITY_WARN =
    SystemFault_Severity_SEVERITY_WARN;
  static constexpr Severity SEVERITY_CRITICAL =
    SystemFault_Severity_SEVERITY_CRITICAL;
  static inline bool Severity_IsValid(int value) {
    return SystemFault_Severity_IsValid(value);
  }
  static constexpr Severity Severity_MIN =
    SystemFault_Severity_Severity_MIN;
  static constexpr Severity Severity_MAX =
    SystemFault_Severity_Severity_MAX;
  static constexpr int Severity_ARRAYSIZE =
    SystemFault_Severity_Severity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Severity_descriptor() {
    return SystemFault_Severity_descriptor();
  }
  template<typename T>
  static inline const std::string& Severity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Severity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Severity_Name.");
    return SystemFault_Severity_Name(enum_t_value);
  }
  static inline bool Severity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Severity* value) {
    return SystemFault_Severity_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 6,
    kNameFieldNumber = 1,
    kErrorMessageFieldNumber = 5,
    kOnsetTimestampFieldNumber = 2,
    kDurationFieldNumber = 3,
    kCodeFieldNumber = 4,
    kSeverityFieldNumber = 7,
    kUidFieldNumber = 8,
  };
  // repeated string attributes = 6;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  const std::string& attributes(int index) const;
  std::string* mutable_attributes(int index);
  void set_attributes(int index, const std::string& value);
  void set_attributes(int index, std::string&& value);
  void set_attributes(int index, const char* value);
  void set_attributes(int index, const char* value, size_t size);
  std::string* add_attributes();
  void add_attributes(const std::string& value);
  void add_attributes(std::string&& value);
  void add_attributes(const char* value);
  void add_attributes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attributes();
  private:
  const std::string& _internal_attributes(int index) const;
  std::string* _internal_add_attributes();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string error_message = 5;
  void clear_error_message();
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .google.protobuf.Timestamp onset_timestamp = 2;
  bool has_onset_timestamp() const;
  private:
  bool _internal_has_onset_timestamp() const;
  public:
  void clear_onset_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& onset_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_onset_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_onset_timestamp();
  void set_allocated_onset_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_onset_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_onset_timestamp();
  public:
  void unsafe_arena_set_allocated_onset_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_onset_timestamp();

  // .google.protobuf.Duration duration = 3;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      PROTOBUF_NAMESPACE_ID::Duration* duration);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // int32 code = 4;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .bosdyn.api.SystemFault.Severity severity = 7;
  void clear_severity();
  ::bosdyn::api::SystemFault_Severity severity() const;
  void set_severity(::bosdyn::api::SystemFault_Severity value);
  private:
  ::bosdyn::api::SystemFault_Severity _internal_severity() const;
  void _internal_set_severity(::bosdyn::api::SystemFault_Severity value);
  public:

  // uint64 uid = 8;
  void clear_uid();
  ::PROTOBUF_NAMESPACE_ID::uint64 uid() const;
  void set_uid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_uid() const;
  void _internal_set_uid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SystemFault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp_;
  PROTOBUF_NAMESPACE_ID::Duration* duration_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  int severity_;
  ::PROTOBUF_NAMESPACE_ID::uint64 uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class EStopState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EStopState) */ {
 public:
  inline EStopState() : EStopState(nullptr) {}
  virtual ~EStopState();

  EStopState(const EStopState& from);
  EStopState(EStopState&& from) noexcept
    : EStopState() {
    *this = ::std::move(from);
  }

  inline EStopState& operator=(const EStopState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EStopState& operator=(EStopState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EStopState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EStopState* internal_default_instance() {
    return reinterpret_cast<const EStopState*>(
               &_EStopState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EStopState& a, EStopState& b) {
    a.Swap(&b);
  }
  inline void Swap(EStopState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EStopState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EStopState* New() const final {
    return CreateMaybeMessage<EStopState>(nullptr);
  }

  EStopState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EStopState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EStopState& from);
  void MergeFrom(const EStopState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EStopState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EStopState";
  }
  protected:
  explicit EStopState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EStopState_Type Type;
  static constexpr Type TYPE_UNKNOWN =
    EStopState_Type_TYPE_UNKNOWN;
  static constexpr Type TYPE_HARDWARE =
    EStopState_Type_TYPE_HARDWARE;
  static constexpr Type TYPE_SOFTWARE =
    EStopState_Type_TYPE_SOFTWARE;
  static inline bool Type_IsValid(int value) {
    return EStopState_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    EStopState_Type_Type_MIN;
  static constexpr Type Type_MAX =
    EStopState_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    EStopState_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return EStopState_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return EStopState_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return EStopState_Type_Parse(name, value);
  }

  typedef EStopState_State State;
  static constexpr State STATE_UNKNOWN =
    EStopState_State_STATE_UNKNOWN;
  static constexpr State STATE_ESTOPPED =
    EStopState_State_STATE_ESTOPPED;
  static constexpr State STATE_NOT_ESTOPPED =
    EStopState_State_STATE_NOT_ESTOPPED;
  static inline bool State_IsValid(int value) {
    return EStopState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    EStopState_State_State_MIN;
  static constexpr State State_MAX =
    EStopState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    EStopState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return EStopState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return EStopState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return EStopState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStateDescriptionFieldNumber = 5,
    kTimestampFieldNumber = 1,
    kTypeFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string state_description = 5;
  void clear_state_description();
  const std::string& state_description() const;
  void set_state_description(const std::string& value);
  void set_state_description(std::string&& value);
  void set_state_description(const char* value);
  void set_state_description(const char* value, size_t size);
  std::string* mutable_state_description();
  std::string* release_state_description();
  void set_allocated_state_description(std::string* state_description);
  private:
  const std::string& _internal_state_description() const;
  void _internal_set_state_description(const std::string& value);
  std::string* _internal_mutable_state_description();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .bosdyn.api.EStopState.Type type = 3;
  void clear_type();
  ::bosdyn::api::EStopState_Type type() const;
  void set_type(::bosdyn::api::EStopState_Type value);
  private:
  ::bosdyn::api::EStopState_Type _internal_type() const;
  void _internal_set_type(::bosdyn::api::EStopState_Type value);
  public:

  // .bosdyn.api.EStopState.State state = 4;
  void clear_state();
  ::bosdyn::api::EStopState_State state() const;
  void set_state(::bosdyn::api::EStopState_State value);
  private:
  ::bosdyn::api::EStopState_State _internal_state() const;
  void _internal_set_state(::bosdyn::api::EStopState_State value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EStopState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_description_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  int type_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class BatteryState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BatteryState) */ {
 public:
  inline BatteryState() : BatteryState(nullptr) {}
  virtual ~BatteryState();

  BatteryState(const BatteryState& from);
  BatteryState(BatteryState&& from) noexcept
    : BatteryState() {
    *this = ::std::move(from);
  }

  inline BatteryState& operator=(const BatteryState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryState& operator=(BatteryState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BatteryState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatteryState* internal_default_instance() {
    return reinterpret_cast<const BatteryState*>(
               &_BatteryState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BatteryState& a, BatteryState& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatteryState* New() const final {
    return CreateMaybeMessage<BatteryState>(nullptr);
  }

  BatteryState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatteryState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatteryState& from);
  void MergeFrom(const BatteryState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BatteryState";
  }
  protected:
  explicit BatteryState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BatteryState_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    BatteryState_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_MISSING =
    BatteryState_Status_STATUS_MISSING;
  static constexpr Status STATUS_CHARGING =
    BatteryState_Status_STATUS_CHARGING;
  static constexpr Status STATUS_DISCHARGING =
    BatteryState_Status_STATUS_DISCHARGING;
  static constexpr Status STATUS_BOOTING =
    BatteryState_Status_STATUS_BOOTING;
  static inline bool Status_IsValid(int value) {
    return BatteryState_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    BatteryState_Status_Status_MIN;
  static constexpr Status Status_MAX =
    BatteryState_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    BatteryState_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return BatteryState_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return BatteryState_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return BatteryState_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTemperaturesFieldNumber = 7,
    kIdentifierFieldNumber = 2,
    kTimestampFieldNumber = 1,
    kChargePercentageFieldNumber = 3,
    kEstimatedRuntimeFieldNumber = 4,
    kCurrentFieldNumber = 5,
    kVoltageFieldNumber = 6,
    kStatusFieldNumber = 8,
  };
  // repeated double temperatures = 7;
  int temperatures_size() const;
  private:
  int _internal_temperatures_size() const;
  public:
  void clear_temperatures();
  private:
  double _internal_temperatures(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_temperatures() const;
  void _internal_add_temperatures(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_temperatures();
  public:
  double temperatures(int index) const;
  void set_temperatures(int index, double value);
  void add_temperatures(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      temperatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_temperatures();

  // string identifier = 2;
  void clear_identifier();
  const std::string& identifier() const;
  void set_identifier(const std::string& value);
  void set_identifier(std::string&& value);
  void set_identifier(const char* value);
  void set_identifier(const char* value, size_t size);
  std::string* mutable_identifier();
  std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .google.protobuf.DoubleValue charge_percentage = 3;
  bool has_charge_percentage() const;
  private:
  bool _internal_has_charge_percentage() const;
  public:
  void clear_charge_percentage();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& charge_percentage() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_charge_percentage();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_charge_percentage();
  void set_allocated_charge_percentage(PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_charge_percentage() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_charge_percentage();
  public:
  void unsafe_arena_set_allocated_charge_percentage(
      PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_charge_percentage();

  // .google.protobuf.Duration estimated_runtime = 4;
  bool has_estimated_runtime() const;
  private:
  bool _internal_has_estimated_runtime() const;
  public:
  void clear_estimated_runtime();
  const PROTOBUF_NAMESPACE_ID::Duration& estimated_runtime() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_estimated_runtime();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_estimated_runtime();
  void set_allocated_estimated_runtime(PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_estimated_runtime() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_estimated_runtime();
  public:
  void unsafe_arena_set_allocated_estimated_runtime(
      PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_estimated_runtime();

  // .google.protobuf.DoubleValue current = 5;
  bool has_current() const;
  private:
  bool _internal_has_current() const;
  public:
  void clear_current();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& current() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_current();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_current();
  void set_allocated_current(PROTOBUF_NAMESPACE_ID::DoubleValue* current);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_current() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_current();
  public:
  void unsafe_arena_set_allocated_current(
      PROTOBUF_NAMESPACE_ID::DoubleValue* current);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_current();

  // .google.protobuf.DoubleValue voltage = 6;
  bool has_voltage() const;
  private:
  bool _internal_has_voltage() const;
  public:
  void clear_voltage();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& voltage() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_voltage();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_voltage();
  void set_allocated_voltage(PROTOBUF_NAMESPACE_ID::DoubleValue* voltage);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_voltage() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_voltage();
  public:
  void unsafe_arena_set_allocated_voltage(
      PROTOBUF_NAMESPACE_ID::DoubleValue* voltage);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_voltage();

  // .bosdyn.api.BatteryState.Status status = 8;
  void clear_status();
  ::bosdyn::api::BatteryState_Status status() const;
  void set_status(::bosdyn::api::BatteryState_Status value);
  private:
  ::bosdyn::api::BatteryState_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::BatteryState_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.BatteryState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > temperatures_;
  mutable std::atomic<int> _temperatures_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage_;
  PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* current_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* voltage_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class KinematicState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.KinematicState) */ {
 public:
  inline KinematicState() : KinematicState(nullptr) {}
  virtual ~KinematicState();

  KinematicState(const KinematicState& from);
  KinematicState(KinematicState&& from) noexcept
    : KinematicState() {
    *this = ::std::move(from);
  }

  inline KinematicState& operator=(const KinematicState& from) {
    CopyFrom(from);
    return *this;
  }
  inline KinematicState& operator=(KinematicState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KinematicState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KinematicState* internal_default_instance() {
    return reinterpret_cast<const KinematicState*>(
               &_KinematicState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(KinematicState& a, KinematicState& b) {
    a.Swap(&b);
  }
  inline void Swap(KinematicState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KinematicState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KinematicState* New() const final {
    return CreateMaybeMessage<KinematicState>(nullptr);
  }

  KinematicState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KinematicState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KinematicState& from);
  void MergeFrom(const KinematicState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KinematicState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.KinematicState";
  }
  protected:
  explicit KinematicState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointStatesFieldNumber = 2,
    kVelocityOfBodyInVisionFieldNumber = 8,
    kVelocityOfBodyInOdomFieldNumber = 12,
    kAcquisitionTimestampFieldNumber = 30,
    kTransformsSnapshotFieldNumber = 31,
  };
  // repeated .bosdyn.api.JointState joint_states = 2;
  int joint_states_size() const;
  private:
  int _internal_joint_states_size() const;
  public:
  void clear_joint_states();
  ::bosdyn::api::JointState* mutable_joint_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState >*
      mutable_joint_states();
  private:
  const ::bosdyn::api::JointState& _internal_joint_states(int index) const;
  ::bosdyn::api::JointState* _internal_add_joint_states();
  public:
  const ::bosdyn::api::JointState& joint_states(int index) const;
  ::bosdyn::api::JointState* add_joint_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState >&
      joint_states() const;

  // .bosdyn.api.SE3Velocity velocity_of_body_in_vision = 8;
  bool has_velocity_of_body_in_vision() const;
  private:
  bool _internal_has_velocity_of_body_in_vision() const;
  public:
  void clear_velocity_of_body_in_vision();
  const ::bosdyn::api::SE3Velocity& velocity_of_body_in_vision() const;
  ::bosdyn::api::SE3Velocity* release_velocity_of_body_in_vision();
  ::bosdyn::api::SE3Velocity* mutable_velocity_of_body_in_vision();
  void set_allocated_velocity_of_body_in_vision(::bosdyn::api::SE3Velocity* velocity_of_body_in_vision);
  private:
  const ::bosdyn::api::SE3Velocity& _internal_velocity_of_body_in_vision() const;
  ::bosdyn::api::SE3Velocity* _internal_mutable_velocity_of_body_in_vision();
  public:
  void unsafe_arena_set_allocated_velocity_of_body_in_vision(
      ::bosdyn::api::SE3Velocity* velocity_of_body_in_vision);
  ::bosdyn::api::SE3Velocity* unsafe_arena_release_velocity_of_body_in_vision();

  // .bosdyn.api.SE3Velocity velocity_of_body_in_odom = 12;
  bool has_velocity_of_body_in_odom() const;
  private:
  bool _internal_has_velocity_of_body_in_odom() const;
  public:
  void clear_velocity_of_body_in_odom();
  const ::bosdyn::api::SE3Velocity& velocity_of_body_in_odom() const;
  ::bosdyn::api::SE3Velocity* release_velocity_of_body_in_odom();
  ::bosdyn::api::SE3Velocity* mutable_velocity_of_body_in_odom();
  void set_allocated_velocity_of_body_in_odom(::bosdyn::api::SE3Velocity* velocity_of_body_in_odom);
  private:
  const ::bosdyn::api::SE3Velocity& _internal_velocity_of_body_in_odom() const;
  ::bosdyn::api::SE3Velocity* _internal_mutable_velocity_of_body_in_odom();
  public:
  void unsafe_arena_set_allocated_velocity_of_body_in_odom(
      ::bosdyn::api::SE3Velocity* velocity_of_body_in_odom);
  ::bosdyn::api::SE3Velocity* unsafe_arena_release_velocity_of_body_in_odom();

  // .google.protobuf.Timestamp acquisition_timestamp = 30;
  bool has_acquisition_timestamp() const;
  private:
  bool _internal_has_acquisition_timestamp() const;
  public:
  void clear_acquisition_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& acquisition_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_acquisition_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_acquisition_timestamp();
  void set_allocated_acquisition_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_acquisition_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_acquisition_timestamp();
  public:
  void unsafe_arena_set_allocated_acquisition_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_acquisition_timestamp();

  // .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
  bool has_transforms_snapshot() const;
  private:
  bool _internal_has_transforms_snapshot() const;
  public:
  void clear_transforms_snapshot();
  const ::bosdyn::api::FrameTreeSnapshot& transforms_snapshot() const;
  ::bosdyn::api::FrameTreeSnapshot* release_transforms_snapshot();
  ::bosdyn::api::FrameTreeSnapshot* mutable_transforms_snapshot();
  void set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  private:
  const ::bosdyn::api::FrameTreeSnapshot& _internal_transforms_snapshot() const;
  ::bosdyn::api::FrameTreeSnapshot* _internal_mutable_transforms_snapshot();
  public:
  void unsafe_arena_set_allocated_transforms_snapshot(
      ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot);
  ::bosdyn::api::FrameTreeSnapshot* unsafe_arena_release_transforms_snapshot();

  // @@protoc_insertion_point(class_scope:bosdyn.api.KinematicState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState > joint_states_;
  ::bosdyn::api::SE3Velocity* velocity_of_body_in_vision_;
  ::bosdyn::api::SE3Velocity* velocity_of_body_in_odom_;
  PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp_;
  ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class JointState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.JointState) */ {
 public:
  inline JointState() : JointState(nullptr) {}
  virtual ~JointState();

  JointState(const JointState& from);
  JointState(JointState&& from) noexcept
    : JointState() {
    *this = ::std::move(from);
  }

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointState& operator=(JointState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JointState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointState* internal_default_instance() {
    return reinterpret_cast<const JointState*>(
               &_JointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(JointState& a, JointState& b) {
    a.Swap(&b);
  }
  inline void Swap(JointState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointState* New() const final {
    return CreateMaybeMessage<JointState>(nullptr);
  }

  JointState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JointState& from);
  void MergeFrom(const JointState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.JointState";
  }
  protected:
  explicit JointState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPositionFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kLoadFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.DoubleValue position = 2;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& position() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_position();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_position();
  void set_allocated_position(PROTOBUF_NAMESPACE_ID::DoubleValue* position);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_position() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      PROTOBUF_NAMESPACE_ID::DoubleValue* position);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_position();

  // .google.protobuf.DoubleValue velocity = 3;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& velocity() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_velocity();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_velocity();
  void set_allocated_velocity(PROTOBUF_NAMESPACE_ID::DoubleValue* velocity);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_velocity() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      PROTOBUF_NAMESPACE_ID::DoubleValue* velocity);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_velocity();

  // .google.protobuf.DoubleValue acceleration = 4;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& acceleration() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_acceleration();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_acceleration();
  void set_allocated_acceleration(PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_acceleration() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_acceleration();

  // .google.protobuf.DoubleValue load = 5;
  bool has_load() const;
  private:
  bool _internal_has_load() const;
  public:
  void clear_load();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& load() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* release_load();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_load();
  void set_allocated_load(PROTOBUF_NAMESPACE_ID::DoubleValue* load);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_load() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_load();
  public:
  void unsafe_arena_set_allocated_load(
      PROTOBUF_NAMESPACE_ID::DoubleValue* load);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_load();

  // @@protoc_insertion_point(class_scope:bosdyn.api.JointState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* position_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* velocity_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* load_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class BehaviorFaultState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BehaviorFaultState) */ {
 public:
  inline BehaviorFaultState() : BehaviorFaultState(nullptr) {}
  virtual ~BehaviorFaultState();

  BehaviorFaultState(const BehaviorFaultState& from);
  BehaviorFaultState(BehaviorFaultState&& from) noexcept
    : BehaviorFaultState() {
    *this = ::std::move(from);
  }

  inline BehaviorFaultState& operator=(const BehaviorFaultState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BehaviorFaultState& operator=(BehaviorFaultState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BehaviorFaultState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BehaviorFaultState* internal_default_instance() {
    return reinterpret_cast<const BehaviorFaultState*>(
               &_BehaviorFaultState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BehaviorFaultState& a, BehaviorFaultState& b) {
    a.Swap(&b);
  }
  inline void Swap(BehaviorFaultState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BehaviorFaultState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BehaviorFaultState* New() const final {
    return CreateMaybeMessage<BehaviorFaultState>(nullptr);
  }

  BehaviorFaultState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BehaviorFaultState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BehaviorFaultState& from);
  void MergeFrom(const BehaviorFaultState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BehaviorFaultState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BehaviorFaultState";
  }
  protected:
  explicit BehaviorFaultState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFaultsFieldNumber = 1,
  };
  // repeated .bosdyn.api.BehaviorFault faults = 1;
  int faults_size() const;
  private:
  int _internal_faults_size() const;
  public:
  void clear_faults();
  ::bosdyn::api::BehaviorFault* mutable_faults(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >*
      mutable_faults();
  private:
  const ::bosdyn::api::BehaviorFault& _internal_faults(int index) const;
  ::bosdyn::api::BehaviorFault* _internal_add_faults();
  public:
  const ::bosdyn::api::BehaviorFault& faults(int index) const;
  ::bosdyn::api::BehaviorFault* add_faults();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >&
      faults() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.BehaviorFaultState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault > faults_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class BehaviorFault PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.BehaviorFault) */ {
 public:
  inline BehaviorFault() : BehaviorFault(nullptr) {}
  virtual ~BehaviorFault();

  BehaviorFault(const BehaviorFault& from);
  BehaviorFault(BehaviorFault&& from) noexcept
    : BehaviorFault() {
    *this = ::std::move(from);
  }

  inline BehaviorFault& operator=(const BehaviorFault& from) {
    CopyFrom(from);
    return *this;
  }
  inline BehaviorFault& operator=(BehaviorFault&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BehaviorFault& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BehaviorFault* internal_default_instance() {
    return reinterpret_cast<const BehaviorFault*>(
               &_BehaviorFault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BehaviorFault& a, BehaviorFault& b) {
    a.Swap(&b);
  }
  inline void Swap(BehaviorFault* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BehaviorFault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BehaviorFault* New() const final {
    return CreateMaybeMessage<BehaviorFault>(nullptr);
  }

  BehaviorFault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BehaviorFault>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BehaviorFault& from);
  void MergeFrom(const BehaviorFault& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BehaviorFault* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.BehaviorFault";
  }
  protected:
  explicit BehaviorFault(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BehaviorFault_Cause Cause;
  static constexpr Cause CAUSE_UNKNOWN =
    BehaviorFault_Cause_CAUSE_UNKNOWN;
  static constexpr Cause CAUSE_FALL =
    BehaviorFault_Cause_CAUSE_FALL;
  static constexpr Cause CAUSE_HARDWARE =
    BehaviorFault_Cause_CAUSE_HARDWARE;
  static inline bool Cause_IsValid(int value) {
    return BehaviorFault_Cause_IsValid(value);
  }
  static constexpr Cause Cause_MIN =
    BehaviorFault_Cause_Cause_MIN;
  static constexpr Cause Cause_MAX =
    BehaviorFault_Cause_Cause_MAX;
  static constexpr int Cause_ARRAYSIZE =
    BehaviorFault_Cause_Cause_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Cause_descriptor() {
    return BehaviorFault_Cause_descriptor();
  }
  template<typename T>
  static inline const std::string& Cause_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Cause>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Cause_Name.");
    return BehaviorFault_Cause_Name(enum_t_value);
  }
  static inline bool Cause_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Cause* value) {
    return BehaviorFault_Cause_Parse(name, value);
  }

  typedef BehaviorFault_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    BehaviorFault_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_CLEARABLE =
    BehaviorFault_Status_STATUS_CLEARABLE;
  static constexpr Status STATUS_UNCLEARABLE =
    BehaviorFault_Status_STATUS_UNCLEARABLE;
  static inline bool Status_IsValid(int value) {
    return BehaviorFault_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    BehaviorFault_Status_Status_MIN;
  static constexpr Status Status_MAX =
    BehaviorFault_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    BehaviorFault_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return BehaviorFault_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return BehaviorFault_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return BehaviorFault_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOnsetTimestampFieldNumber = 2,
    kBehaviorFaultIdFieldNumber = 1,
    kCauseFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // .google.protobuf.Timestamp onset_timestamp = 2;
  bool has_onset_timestamp() const;
  private:
  bool _internal_has_onset_timestamp() const;
  public:
  void clear_onset_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& onset_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_onset_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_onset_timestamp();
  void set_allocated_onset_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_onset_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_onset_timestamp();
  public:
  void unsafe_arena_set_allocated_onset_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_onset_timestamp();

  // uint32 behavior_fault_id = 1;
  void clear_behavior_fault_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 behavior_fault_id() const;
  void set_behavior_fault_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_behavior_fault_id() const;
  void _internal_set_behavior_fault_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .bosdyn.api.BehaviorFault.Cause cause = 3;
  void clear_cause();
  ::bosdyn::api::BehaviorFault_Cause cause() const;
  void set_cause(::bosdyn::api::BehaviorFault_Cause value);
  private:
  ::bosdyn::api::BehaviorFault_Cause _internal_cause() const;
  void _internal_set_cause(::bosdyn::api::BehaviorFault_Cause value);
  public:

  // .bosdyn.api.BehaviorFault.Status status = 4;
  void clear_status();
  ::bosdyn::api::BehaviorFault_Status status() const;
  void set_status(::bosdyn::api::BehaviorFault_Status value);
  private:
  ::bosdyn::api::BehaviorFault_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::BehaviorFault_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.BehaviorFault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 behavior_fault_id_;
  int cause_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotMetrics PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotMetrics) */ {
 public:
  inline RobotMetrics() : RobotMetrics(nullptr) {}
  virtual ~RobotMetrics();

  RobotMetrics(const RobotMetrics& from);
  RobotMetrics(RobotMetrics&& from) noexcept
    : RobotMetrics() {
    *this = ::std::move(from);
  }

  inline RobotMetrics& operator=(const RobotMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotMetrics& operator=(RobotMetrics&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotMetrics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotMetrics* internal_default_instance() {
    return reinterpret_cast<const RobotMetrics*>(
               &_RobotMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RobotMetrics& a, RobotMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotMetrics* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotMetrics* New() const final {
    return CreateMaybeMessage<RobotMetrics>(nullptr);
  }

  RobotMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotMetrics>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotMetrics& from);
  void MergeFrom(const RobotMetrics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotMetrics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotMetrics";
  }
  protected:
  explicit RobotMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricsFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // repeated .bosdyn.api.Parameter metrics = 2;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::bosdyn::api::Parameter* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >*
      mutable_metrics();
  private:
  const ::bosdyn::api::Parameter& _internal_metrics(int index) const;
  ::bosdyn::api::Parameter* _internal_add_metrics();
  public:
  const ::bosdyn::api::Parameter& metrics(int index) const;
  ::bosdyn::api::Parameter* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >&
      metrics() const;

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter > metrics_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class CommsState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.CommsState) */ {
 public:
  inline CommsState() : CommsState(nullptr) {}
  virtual ~CommsState();

  CommsState(const CommsState& from);
  CommsState(CommsState&& from) noexcept
    : CommsState() {
    *this = ::std::move(from);
  }

  inline CommsState& operator=(const CommsState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommsState& operator=(CommsState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommsState& default_instance();

  enum StateCase {
    kWifiState = 2,
    STATE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommsState* internal_default_instance() {
    return reinterpret_cast<const CommsState*>(
               &_CommsState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CommsState& a, CommsState& b) {
    a.Swap(&b);
  }
  inline void Swap(CommsState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommsState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommsState* New() const final {
    return CreateMaybeMessage<CommsState>(nullptr);
  }

  CommsState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommsState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommsState& from);
  void MergeFrom(const CommsState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommsState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.CommsState";
  }
  protected:
  explicit CommsState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kWifiStateFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .bosdyn.api.WiFiState wifi_state = 2;
  bool has_wifi_state() const;
  private:
  bool _internal_has_wifi_state() const;
  public:
  void clear_wifi_state();
  const ::bosdyn::api::WiFiState& wifi_state() const;
  ::bosdyn::api::WiFiState* release_wifi_state();
  ::bosdyn::api::WiFiState* mutable_wifi_state();
  void set_allocated_wifi_state(::bosdyn::api::WiFiState* wifi_state);
  private:
  const ::bosdyn::api::WiFiState& _internal_wifi_state() const;
  ::bosdyn::api::WiFiState* _internal_mutable_wifi_state();
  public:
  void unsafe_arena_set_allocated_wifi_state(
      ::bosdyn::api::WiFiState* wifi_state);
  ::bosdyn::api::WiFiState* unsafe_arena_release_wifi_state();

  void clear_state();
  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.CommsState)
 private:
  class _Internal;
  void set_has_wifi_state();

  inline bool has_state() const;
  inline void clear_has_state();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  union StateUnion {
    StateUnion() {}
    ::bosdyn::api::WiFiState* wifi_state_;
  } state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class WiFiState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.WiFiState) */ {
 public:
  inline WiFiState() : WiFiState(nullptr) {}
  virtual ~WiFiState();

  WiFiState(const WiFiState& from);
  WiFiState(WiFiState&& from) noexcept
    : WiFiState() {
    *this = ::std::move(from);
  }

  inline WiFiState& operator=(const WiFiState& from) {
    CopyFrom(from);
    return *this;
  }
  inline WiFiState& operator=(WiFiState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WiFiState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WiFiState* internal_default_instance() {
    return reinterpret_cast<const WiFiState*>(
               &_WiFiState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WiFiState& a, WiFiState& b) {
    a.Swap(&b);
  }
  inline void Swap(WiFiState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WiFiState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WiFiState* New() const final {
    return CreateMaybeMessage<WiFiState>(nullptr);
  }

  WiFiState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WiFiState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WiFiState& from);
  void MergeFrom(const WiFiState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WiFiState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.WiFiState";
  }
  protected:
  explicit WiFiState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef WiFiState_Mode Mode;
  static constexpr Mode MODE_UNKNOWN =
    WiFiState_Mode_MODE_UNKNOWN;
  static constexpr Mode MODE_ACCESS_POINT =
    WiFiState_Mode_MODE_ACCESS_POINT;
  static constexpr Mode MODE_CLIENT =
    WiFiState_Mode_MODE_CLIENT;
  static inline bool Mode_IsValid(int value) {
    return WiFiState_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    WiFiState_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    WiFiState_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    WiFiState_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return WiFiState_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return WiFiState_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return WiFiState_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEssidFieldNumber = 2,
    kCurrentModeFieldNumber = 1,
  };
  // string essid = 2;
  void clear_essid();
  const std::string& essid() const;
  void set_essid(const std::string& value);
  void set_essid(std::string&& value);
  void set_essid(const char* value);
  void set_essid(const char* value, size_t size);
  std::string* mutable_essid();
  std::string* release_essid();
  void set_allocated_essid(std::string* essid);
  private:
  const std::string& _internal_essid() const;
  void _internal_set_essid(const std::string& value);
  std::string* _internal_mutable_essid();
  public:

  // .bosdyn.api.WiFiState.Mode current_mode = 1;
  void clear_current_mode();
  ::bosdyn::api::WiFiState_Mode current_mode() const;
  void set_current_mode(::bosdyn::api::WiFiState_Mode value);
  private:
  ::bosdyn::api::WiFiState_Mode _internal_current_mode() const;
  void _internal_set_current_mode(::bosdyn::api::WiFiState_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.WiFiState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr essid_;
  int current_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class FootState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.FootState) */ {
 public:
  inline FootState() : FootState(nullptr) {}
  virtual ~FootState();

  FootState(const FootState& from);
  FootState(FootState&& from) noexcept
    : FootState() {
    *this = ::std::move(from);
  }

  inline FootState& operator=(const FootState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FootState& operator=(FootState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FootState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FootState* internal_default_instance() {
    return reinterpret_cast<const FootState*>(
               &_FootState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FootState& a, FootState& b) {
    a.Swap(&b);
  }
  inline void Swap(FootState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FootState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FootState* New() const final {
    return CreateMaybeMessage<FootState>(nullptr);
  }

  FootState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FootState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FootState& from);
  void MergeFrom(const FootState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FootState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.FootState";
  }
  protected:
  explicit FootState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FootState_Contact Contact;
  static constexpr Contact CONTACT_UNKNOWN =
    FootState_Contact_CONTACT_UNKNOWN;
  static constexpr Contact CONTACT_MADE =
    FootState_Contact_CONTACT_MADE;
  static constexpr Contact CONTACT_LOST =
    FootState_Contact_CONTACT_LOST;
  static inline bool Contact_IsValid(int value) {
    return FootState_Contact_IsValid(value);
  }
  static constexpr Contact Contact_MIN =
    FootState_Contact_Contact_MIN;
  static constexpr Contact Contact_MAX =
    FootState_Contact_Contact_MAX;
  static constexpr int Contact_ARRAYSIZE =
    FootState_Contact_Contact_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Contact_descriptor() {
    return FootState_Contact_descriptor();
  }
  template<typename T>
  static inline const std::string& Contact_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Contact>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Contact_Name.");
    return FootState_Contact_Name(enum_t_value);
  }
  static inline bool Contact_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Contact* value) {
    return FootState_Contact_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFootPositionRtBodyFieldNumber = 1,
    kContactFieldNumber = 2,
  };
  // .bosdyn.api.Vec3 foot_position_rt_body = 1;
  bool has_foot_position_rt_body() const;
  private:
  bool _internal_has_foot_position_rt_body() const;
  public:
  void clear_foot_position_rt_body();
  const ::bosdyn::api::Vec3& foot_position_rt_body() const;
  ::bosdyn::api::Vec3* release_foot_position_rt_body();
  ::bosdyn::api::Vec3* mutable_foot_position_rt_body();
  void set_allocated_foot_position_rt_body(::bosdyn::api::Vec3* foot_position_rt_body);
  private:
  const ::bosdyn::api::Vec3& _internal_foot_position_rt_body() const;
  ::bosdyn::api::Vec3* _internal_mutable_foot_position_rt_body();
  public:
  void unsafe_arena_set_allocated_foot_position_rt_body(
      ::bosdyn::api::Vec3* foot_position_rt_body);
  ::bosdyn::api::Vec3* unsafe_arena_release_foot_position_rt_body();

  // .bosdyn.api.FootState.Contact contact = 2;
  void clear_contact();
  ::bosdyn::api::FootState_Contact contact() const;
  void set_contact(::bosdyn::api::FootState_Contact value);
  private:
  ::bosdyn::api::FootState_Contact _internal_contact() const;
  void _internal_set_contact(::bosdyn::api::FootState_Contact value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.FootState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::Vec3* foot_position_rt_body_;
  int contact_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotStateRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotStateRequest) */ {
 public:
  inline RobotStateRequest() : RobotStateRequest(nullptr) {}
  virtual ~RobotStateRequest();

  RobotStateRequest(const RobotStateRequest& from);
  RobotStateRequest(RobotStateRequest&& from) noexcept
    : RobotStateRequest() {
    *this = ::std::move(from);
  }

  inline RobotStateRequest& operator=(const RobotStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotStateRequest& operator=(RobotStateRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotStateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotStateRequest* internal_default_instance() {
    return reinterpret_cast<const RobotStateRequest*>(
               &_RobotStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RobotStateRequest& a, RobotStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotStateRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotStateRequest* New() const final {
    return CreateMaybeMessage<RobotStateRequest>(nullptr);
  }

  RobotStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotStateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotStateRequest& from);
  void MergeFrom(const RobotStateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotStateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotStateRequest";
  }
  protected:
  explicit RobotStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotStateResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotStateResponse) */ {
 public:
  inline RobotStateResponse() : RobotStateResponse(nullptr) {}
  virtual ~RobotStateResponse();

  RobotStateResponse(const RobotStateResponse& from);
  RobotStateResponse(RobotStateResponse&& from) noexcept
    : RobotStateResponse() {
    *this = ::std::move(from);
  }

  inline RobotStateResponse& operator=(const RobotStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotStateResponse& operator=(RobotStateResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotStateResponse* internal_default_instance() {
    return reinterpret_cast<const RobotStateResponse*>(
               &_RobotStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RobotStateResponse& a, RobotStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotStateResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotStateResponse* New() const final {
    return CreateMaybeMessage<RobotStateResponse>(nullptr);
  }

  RobotStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotStateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotStateResponse& from);
  void MergeFrom(const RobotStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotStateResponse";
  }
  protected:
  explicit RobotStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRobotStateFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RobotState robot_state = 2;
  bool has_robot_state() const;
  private:
  bool _internal_has_robot_state() const;
  public:
  void clear_robot_state();
  const ::bosdyn::api::RobotState& robot_state() const;
  ::bosdyn::api::RobotState* release_robot_state();
  ::bosdyn::api::RobotState* mutable_robot_state();
  void set_allocated_robot_state(::bosdyn::api::RobotState* robot_state);
  private:
  const ::bosdyn::api::RobotState& _internal_robot_state() const;
  ::bosdyn::api::RobotState* _internal_mutable_robot_state();
  public:
  void unsafe_arena_set_allocated_robot_state(
      ::bosdyn::api::RobotState* robot_state);
  ::bosdyn::api::RobotState* unsafe_arena_release_robot_state();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::RobotState* robot_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotMetricsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotMetricsRequest) */ {
 public:
  inline RobotMetricsRequest() : RobotMetricsRequest(nullptr) {}
  virtual ~RobotMetricsRequest();

  RobotMetricsRequest(const RobotMetricsRequest& from);
  RobotMetricsRequest(RobotMetricsRequest&& from) noexcept
    : RobotMetricsRequest() {
    *this = ::std::move(from);
  }

  inline RobotMetricsRequest& operator=(const RobotMetricsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotMetricsRequest& operator=(RobotMetricsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotMetricsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotMetricsRequest* internal_default_instance() {
    return reinterpret_cast<const RobotMetricsRequest*>(
               &_RobotMetricsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RobotMetricsRequest& a, RobotMetricsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotMetricsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotMetricsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotMetricsRequest* New() const final {
    return CreateMaybeMessage<RobotMetricsRequest>(nullptr);
  }

  RobotMetricsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotMetricsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotMetricsRequest& from);
  void MergeFrom(const RobotMetricsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotMetricsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotMetricsRequest";
  }
  protected:
  explicit RobotMetricsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotMetricsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotMetricsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotMetricsResponse) */ {
 public:
  inline RobotMetricsResponse() : RobotMetricsResponse(nullptr) {}
  virtual ~RobotMetricsResponse();

  RobotMetricsResponse(const RobotMetricsResponse& from);
  RobotMetricsResponse(RobotMetricsResponse&& from) noexcept
    : RobotMetricsResponse() {
    *this = ::std::move(from);
  }

  inline RobotMetricsResponse& operator=(const RobotMetricsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotMetricsResponse& operator=(RobotMetricsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotMetricsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotMetricsResponse* internal_default_instance() {
    return reinterpret_cast<const RobotMetricsResponse*>(
               &_RobotMetricsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RobotMetricsResponse& a, RobotMetricsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotMetricsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotMetricsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotMetricsResponse* New() const final {
    return CreateMaybeMessage<RobotMetricsResponse>(nullptr);
  }

  RobotMetricsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotMetricsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotMetricsResponse& from);
  void MergeFrom(const RobotMetricsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotMetricsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotMetricsResponse";
  }
  protected:
  explicit RobotMetricsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRobotMetricsFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RobotMetrics robot_metrics = 2;
  bool has_robot_metrics() const;
  private:
  bool _internal_has_robot_metrics() const;
  public:
  void clear_robot_metrics();
  const ::bosdyn::api::RobotMetrics& robot_metrics() const;
  ::bosdyn::api::RobotMetrics* release_robot_metrics();
  ::bosdyn::api::RobotMetrics* mutable_robot_metrics();
  void set_allocated_robot_metrics(::bosdyn::api::RobotMetrics* robot_metrics);
  private:
  const ::bosdyn::api::RobotMetrics& _internal_robot_metrics() const;
  ::bosdyn::api::RobotMetrics* _internal_mutable_robot_metrics();
  public:
  void unsafe_arena_set_allocated_robot_metrics(
      ::bosdyn::api::RobotMetrics* robot_metrics);
  ::bosdyn::api::RobotMetrics* unsafe_arena_release_robot_metrics();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotMetricsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::RobotMetrics* robot_metrics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotHardwareConfigurationRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotHardwareConfigurationRequest) */ {
 public:
  inline RobotHardwareConfigurationRequest() : RobotHardwareConfigurationRequest(nullptr) {}
  virtual ~RobotHardwareConfigurationRequest();

  RobotHardwareConfigurationRequest(const RobotHardwareConfigurationRequest& from);
  RobotHardwareConfigurationRequest(RobotHardwareConfigurationRequest&& from) noexcept
    : RobotHardwareConfigurationRequest() {
    *this = ::std::move(from);
  }

  inline RobotHardwareConfigurationRequest& operator=(const RobotHardwareConfigurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotHardwareConfigurationRequest& operator=(RobotHardwareConfigurationRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotHardwareConfigurationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotHardwareConfigurationRequest* internal_default_instance() {
    return reinterpret_cast<const RobotHardwareConfigurationRequest*>(
               &_RobotHardwareConfigurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(RobotHardwareConfigurationRequest& a, RobotHardwareConfigurationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotHardwareConfigurationRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotHardwareConfigurationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotHardwareConfigurationRequest* New() const final {
    return CreateMaybeMessage<RobotHardwareConfigurationRequest>(nullptr);
  }

  RobotHardwareConfigurationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotHardwareConfigurationRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotHardwareConfigurationRequest& from);
  void MergeFrom(const RobotHardwareConfigurationRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotHardwareConfigurationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotHardwareConfigurationRequest";
  }
  protected:
  explicit RobotHardwareConfigurationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotHardwareConfigurationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotHardwareConfigurationResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotHardwareConfigurationResponse) */ {
 public:
  inline RobotHardwareConfigurationResponse() : RobotHardwareConfigurationResponse(nullptr) {}
  virtual ~RobotHardwareConfigurationResponse();

  RobotHardwareConfigurationResponse(const RobotHardwareConfigurationResponse& from);
  RobotHardwareConfigurationResponse(RobotHardwareConfigurationResponse&& from) noexcept
    : RobotHardwareConfigurationResponse() {
    *this = ::std::move(from);
  }

  inline RobotHardwareConfigurationResponse& operator=(const RobotHardwareConfigurationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotHardwareConfigurationResponse& operator=(RobotHardwareConfigurationResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotHardwareConfigurationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotHardwareConfigurationResponse* internal_default_instance() {
    return reinterpret_cast<const RobotHardwareConfigurationResponse*>(
               &_RobotHardwareConfigurationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RobotHardwareConfigurationResponse& a, RobotHardwareConfigurationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotHardwareConfigurationResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotHardwareConfigurationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotHardwareConfigurationResponse* New() const final {
    return CreateMaybeMessage<RobotHardwareConfigurationResponse>(nullptr);
  }

  RobotHardwareConfigurationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotHardwareConfigurationResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotHardwareConfigurationResponse& from);
  void MergeFrom(const RobotHardwareConfigurationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotHardwareConfigurationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotHardwareConfigurationResponse";
  }
  protected:
  explicit RobotHardwareConfigurationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kHardwareConfigurationFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.HardwareConfiguration hardware_configuration = 2;
  bool has_hardware_configuration() const;
  private:
  bool _internal_has_hardware_configuration() const;
  public:
  void clear_hardware_configuration();
  const ::bosdyn::api::HardwareConfiguration& hardware_configuration() const;
  ::bosdyn::api::HardwareConfiguration* release_hardware_configuration();
  ::bosdyn::api::HardwareConfiguration* mutable_hardware_configuration();
  void set_allocated_hardware_configuration(::bosdyn::api::HardwareConfiguration* hardware_configuration);
  private:
  const ::bosdyn::api::HardwareConfiguration& _internal_hardware_configuration() const;
  ::bosdyn::api::HardwareConfiguration* _internal_mutable_hardware_configuration();
  public:
  void unsafe_arena_set_allocated_hardware_configuration(
      ::bosdyn::api::HardwareConfiguration* hardware_configuration);
  ::bosdyn::api::HardwareConfiguration* unsafe_arena_release_hardware_configuration();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotHardwareConfigurationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::HardwareConfiguration* hardware_configuration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotLinkModelRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotLinkModelRequest) */ {
 public:
  inline RobotLinkModelRequest() : RobotLinkModelRequest(nullptr) {}
  virtual ~RobotLinkModelRequest();

  RobotLinkModelRequest(const RobotLinkModelRequest& from);
  RobotLinkModelRequest(RobotLinkModelRequest&& from) noexcept
    : RobotLinkModelRequest() {
    *this = ::std::move(from);
  }

  inline RobotLinkModelRequest& operator=(const RobotLinkModelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotLinkModelRequest& operator=(RobotLinkModelRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotLinkModelRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotLinkModelRequest* internal_default_instance() {
    return reinterpret_cast<const RobotLinkModelRequest*>(
               &_RobotLinkModelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RobotLinkModelRequest& a, RobotLinkModelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotLinkModelRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotLinkModelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotLinkModelRequest* New() const final {
    return CreateMaybeMessage<RobotLinkModelRequest>(nullptr);
  }

  RobotLinkModelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotLinkModelRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotLinkModelRequest& from);
  void MergeFrom(const RobotLinkModelRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotLinkModelRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotLinkModelRequest";
  }
  protected:
  explicit RobotLinkModelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkNameFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string link_name = 2;
  void clear_link_name();
  const std::string& link_name() const;
  void set_link_name(const std::string& value);
  void set_link_name(std::string&& value);
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  std::string* mutable_link_name();
  std::string* release_link_name();
  void set_allocated_link_name(std::string* link_name);
  private:
  const std::string& _internal_link_name() const;
  void _internal_set_link_name(const std::string& value);
  std::string* _internal_mutable_link_name();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotLinkModelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_name_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// -------------------------------------------------------------------

class RobotLinkModelResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RobotLinkModelResponse) */ {
 public:
  inline RobotLinkModelResponse() : RobotLinkModelResponse(nullptr) {}
  virtual ~RobotLinkModelResponse();

  RobotLinkModelResponse(const RobotLinkModelResponse& from);
  RobotLinkModelResponse(RobotLinkModelResponse&& from) noexcept
    : RobotLinkModelResponse() {
    *this = ::std::move(from);
  }

  inline RobotLinkModelResponse& operator=(const RobotLinkModelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotLinkModelResponse& operator=(RobotLinkModelResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotLinkModelResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotLinkModelResponse* internal_default_instance() {
    return reinterpret_cast<const RobotLinkModelResponse*>(
               &_RobotLinkModelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RobotLinkModelResponse& a, RobotLinkModelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotLinkModelResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotLinkModelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotLinkModelResponse* New() const final {
    return CreateMaybeMessage<RobotLinkModelResponse>(nullptr);
  }

  RobotLinkModelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotLinkModelResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotLinkModelResponse& from);
  void MergeFrom(const RobotLinkModelResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotLinkModelResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RobotLinkModelResponse";
  }
  protected:
  explicit RobotLinkModelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2frobot_5fstate_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLinkModelFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.Skeleton.Link.ObjModel link_model = 2;
  bool has_link_model() const;
  private:
  bool _internal_has_link_model() const;
  public:
  void clear_link_model();
  const ::bosdyn::api::Skeleton_Link_ObjModel& link_model() const;
  ::bosdyn::api::Skeleton_Link_ObjModel* release_link_model();
  ::bosdyn::api::Skeleton_Link_ObjModel* mutable_link_model();
  void set_allocated_link_model(::bosdyn::api::Skeleton_Link_ObjModel* link_model);
  private:
  const ::bosdyn::api::Skeleton_Link_ObjModel& _internal_link_model() const;
  ::bosdyn::api::Skeleton_Link_ObjModel* _internal_mutable_link_model();
  public:
  void unsafe_arena_set_allocated_link_model(
      ::bosdyn::api::Skeleton_Link_ObjModel* link_model);
  ::bosdyn::api::Skeleton_Link_ObjModel* unsafe_arena_release_link_model();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RobotLinkModelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::Skeleton_Link_ObjModel* link_model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2frobot_5fstate_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Skeleton_Link_ObjModel

// string file_name = 1;
inline void Skeleton_Link_ObjModel::clear_file_name() {
  file_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Skeleton_Link_ObjModel::file_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.Link.ObjModel.file_name)
  return _internal_file_name();
}
inline void Skeleton_Link_ObjModel::set_file_name(const std::string& value) {
  _internal_set_file_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Skeleton.Link.ObjModel.file_name)
}
inline std::string* Skeleton_Link_ObjModel::mutable_file_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.Link.ObjModel.file_name)
  return _internal_mutable_file_name();
}
inline const std::string& Skeleton_Link_ObjModel::_internal_file_name() const {
  return file_name_.Get();
}
inline void Skeleton_Link_ObjModel::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Skeleton_Link_ObjModel::set_file_name(std::string&& value) {
  
  file_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Skeleton.Link.ObjModel.file_name)
}
inline void Skeleton_Link_ObjModel::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Skeleton.Link.ObjModel.file_name)
}
inline void Skeleton_Link_ObjModel::set_file_name(const char* value,
    size_t size) {
  
  file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Skeleton.Link.ObjModel.file_name)
}
inline std::string* Skeleton_Link_ObjModel::_internal_mutable_file_name() {
  
  return file_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Skeleton_Link_ObjModel::release_file_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.Link.ObjModel.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Skeleton_Link_ObjModel::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.Link.ObjModel.file_name)
}

// string file_contents = 2;
inline void Skeleton_Link_ObjModel::clear_file_contents() {
  file_contents_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Skeleton_Link_ObjModel::file_contents() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
  return _internal_file_contents();
}
inline void Skeleton_Link_ObjModel::set_file_contents(const std::string& value) {
  _internal_set_file_contents(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
}
inline std::string* Skeleton_Link_ObjModel::mutable_file_contents() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
  return _internal_mutable_file_contents();
}
inline const std::string& Skeleton_Link_ObjModel::_internal_file_contents() const {
  return file_contents_.Get();
}
inline void Skeleton_Link_ObjModel::_internal_set_file_contents(const std::string& value) {
  
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Skeleton_Link_ObjModel::set_file_contents(std::string&& value) {
  
  file_contents_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
}
inline void Skeleton_Link_ObjModel::set_file_contents(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
}
inline void Skeleton_Link_ObjModel::set_file_contents(const char* value,
    size_t size) {
  
  file_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
}
inline std::string* Skeleton_Link_ObjModel::_internal_mutable_file_contents() {
  
  return file_contents_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Skeleton_Link_ObjModel::release_file_contents() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
  return file_contents_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Skeleton_Link_ObjModel::set_allocated_file_contents(std::string* file_contents) {
  if (file_contents != nullptr) {
    
  } else {
    
  }
  file_contents_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_contents,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.Link.ObjModel.file_contents)
}

// -------------------------------------------------------------------

// Skeleton_Link

// string name = 1;
inline void Skeleton_Link::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Skeleton_Link::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.Link.name)
  return _internal_name();
}
inline void Skeleton_Link::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Skeleton.Link.name)
}
inline std::string* Skeleton_Link::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.Link.name)
  return _internal_mutable_name();
}
inline const std::string& Skeleton_Link::_internal_name() const {
  return name_.Get();
}
inline void Skeleton_Link::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Skeleton_Link::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Skeleton.Link.name)
}
inline void Skeleton_Link::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Skeleton.Link.name)
}
inline void Skeleton_Link::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Skeleton.Link.name)
}
inline std::string* Skeleton_Link::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Skeleton_Link::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.Link.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Skeleton_Link::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.Link.name)
}

// .bosdyn.api.Skeleton.Link.ObjModel obj_model = 2;
inline bool Skeleton_Link::_internal_has_obj_model() const {
  return this != internal_default_instance() && obj_model_ != nullptr;
}
inline bool Skeleton_Link::has_obj_model() const {
  return _internal_has_obj_model();
}
inline void Skeleton_Link::clear_obj_model() {
  if (GetArena() == nullptr && obj_model_ != nullptr) {
    delete obj_model_;
  }
  obj_model_ = nullptr;
}
inline const ::bosdyn::api::Skeleton_Link_ObjModel& Skeleton_Link::_internal_obj_model() const {
  const ::bosdyn::api::Skeleton_Link_ObjModel* p = obj_model_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Skeleton_Link_ObjModel*>(
      &::bosdyn::api::_Skeleton_Link_ObjModel_default_instance_);
}
inline const ::bosdyn::api::Skeleton_Link_ObjModel& Skeleton_Link::obj_model() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.Link.obj_model)
  return _internal_obj_model();
}
inline void Skeleton_Link::unsafe_arena_set_allocated_obj_model(
    ::bosdyn::api::Skeleton_Link_ObjModel* obj_model) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(obj_model_);
  }
  obj_model_ = obj_model;
  if (obj_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Skeleton.Link.obj_model)
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* Skeleton_Link::release_obj_model() {
  
  ::bosdyn::api::Skeleton_Link_ObjModel* temp = obj_model_;
  obj_model_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* Skeleton_Link::unsafe_arena_release_obj_model() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.Link.obj_model)
  
  ::bosdyn::api::Skeleton_Link_ObjModel* temp = obj_model_;
  obj_model_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* Skeleton_Link::_internal_mutable_obj_model() {
  
  if (obj_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Skeleton_Link_ObjModel>(GetArena());
    obj_model_ = p;
  }
  return obj_model_;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* Skeleton_Link::mutable_obj_model() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.Link.obj_model)
  return _internal_mutable_obj_model();
}
inline void Skeleton_Link::set_allocated_obj_model(::bosdyn::api::Skeleton_Link_ObjModel* obj_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete obj_model_;
  }
  if (obj_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(obj_model);
    if (message_arena != submessage_arena) {
      obj_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obj_model, submessage_arena);
    }
    
  } else {
    
  }
  obj_model_ = obj_model;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.Link.obj_model)
}

// -------------------------------------------------------------------

// Skeleton

// repeated .bosdyn.api.Skeleton.Link links = 2;
inline int Skeleton::_internal_links_size() const {
  return links_.size();
}
inline int Skeleton::links_size() const {
  return _internal_links_size();
}
inline void Skeleton::clear_links() {
  links_.Clear();
}
inline ::bosdyn::api::Skeleton_Link* Skeleton::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.links)
  return links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link >*
Skeleton::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Skeleton.links)
  return &links_;
}
inline const ::bosdyn::api::Skeleton_Link& Skeleton::_internal_links(int index) const {
  return links_.Get(index);
}
inline const ::bosdyn::api::Skeleton_Link& Skeleton::links(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.links)
  return _internal_links(index);
}
inline ::bosdyn::api::Skeleton_Link* Skeleton::_internal_add_links() {
  return links_.Add();
}
inline ::bosdyn::api::Skeleton_Link* Skeleton::add_links() {
  // @@protoc_insertion_point(field_add:bosdyn.api.Skeleton.links)
  return _internal_add_links();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Skeleton_Link >&
Skeleton::links() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Skeleton.links)
  return links_;
}

// string urdf = 3;
inline void Skeleton::clear_urdf() {
  urdf_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Skeleton::urdf() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Skeleton.urdf)
  return _internal_urdf();
}
inline void Skeleton::set_urdf(const std::string& value) {
  _internal_set_urdf(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Skeleton.urdf)
}
inline std::string* Skeleton::mutable_urdf() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Skeleton.urdf)
  return _internal_mutable_urdf();
}
inline const std::string& Skeleton::_internal_urdf() const {
  return urdf_.Get();
}
inline void Skeleton::_internal_set_urdf(const std::string& value) {
  
  urdf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Skeleton::set_urdf(std::string&& value) {
  
  urdf_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Skeleton.urdf)
}
inline void Skeleton::set_urdf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  urdf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Skeleton.urdf)
}
inline void Skeleton::set_urdf(const char* value,
    size_t size) {
  
  urdf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Skeleton.urdf)
}
inline std::string* Skeleton::_internal_mutable_urdf() {
  
  return urdf_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Skeleton::release_urdf() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Skeleton.urdf)
  return urdf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Skeleton::set_allocated_urdf(std::string* urdf) {
  if (urdf != nullptr) {
    
  } else {
    
  }
  urdf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), urdf,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Skeleton.urdf)
}

// -------------------------------------------------------------------

// HardwareConfiguration

// .bosdyn.api.Skeleton skeleton = 1;
inline bool HardwareConfiguration::_internal_has_skeleton() const {
  return this != internal_default_instance() && skeleton_ != nullptr;
}
inline bool HardwareConfiguration::has_skeleton() const {
  return _internal_has_skeleton();
}
inline void HardwareConfiguration::clear_skeleton() {
  if (GetArena() == nullptr && skeleton_ != nullptr) {
    delete skeleton_;
  }
  skeleton_ = nullptr;
}
inline const ::bosdyn::api::Skeleton& HardwareConfiguration::_internal_skeleton() const {
  const ::bosdyn::api::Skeleton* p = skeleton_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Skeleton*>(
      &::bosdyn::api::_Skeleton_default_instance_);
}
inline const ::bosdyn::api::Skeleton& HardwareConfiguration::skeleton() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.HardwareConfiguration.skeleton)
  return _internal_skeleton();
}
inline void HardwareConfiguration::unsafe_arena_set_allocated_skeleton(
    ::bosdyn::api::Skeleton* skeleton) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(skeleton_);
  }
  skeleton_ = skeleton;
  if (skeleton) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.HardwareConfiguration.skeleton)
}
inline ::bosdyn::api::Skeleton* HardwareConfiguration::release_skeleton() {
  
  ::bosdyn::api::Skeleton* temp = skeleton_;
  skeleton_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Skeleton* HardwareConfiguration::unsafe_arena_release_skeleton() {
  // @@protoc_insertion_point(field_release:bosdyn.api.HardwareConfiguration.skeleton)
  
  ::bosdyn::api::Skeleton* temp = skeleton_;
  skeleton_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Skeleton* HardwareConfiguration::_internal_mutable_skeleton() {
  
  if (skeleton_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Skeleton>(GetArena());
    skeleton_ = p;
  }
  return skeleton_;
}
inline ::bosdyn::api::Skeleton* HardwareConfiguration::mutable_skeleton() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.HardwareConfiguration.skeleton)
  return _internal_mutable_skeleton();
}
inline void HardwareConfiguration::set_allocated_skeleton(::bosdyn::api::Skeleton* skeleton) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete skeleton_;
  }
  if (skeleton) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(skeleton);
    if (message_arena != submessage_arena) {
      skeleton = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, skeleton, submessage_arena);
    }
    
  } else {
    
  }
  skeleton_ = skeleton;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.HardwareConfiguration.skeleton)
}

// -------------------------------------------------------------------

// RobotState

// .bosdyn.api.PowerState power_state = 1;
inline bool RobotState::_internal_has_power_state() const {
  return this != internal_default_instance() && power_state_ != nullptr;
}
inline bool RobotState::has_power_state() const {
  return _internal_has_power_state();
}
inline void RobotState::clear_power_state() {
  if (GetArena() == nullptr && power_state_ != nullptr) {
    delete power_state_;
  }
  power_state_ = nullptr;
}
inline const ::bosdyn::api::PowerState& RobotState::_internal_power_state() const {
  const ::bosdyn::api::PowerState* p = power_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::PowerState*>(
      &::bosdyn::api::_PowerState_default_instance_);
}
inline const ::bosdyn::api::PowerState& RobotState::power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.power_state)
  return _internal_power_state();
}
inline void RobotState::unsafe_arena_set_allocated_power_state(
    ::bosdyn::api::PowerState* power_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(power_state_);
  }
  power_state_ = power_state;
  if (power_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.power_state)
}
inline ::bosdyn::api::PowerState* RobotState::release_power_state() {
  
  ::bosdyn::api::PowerState* temp = power_state_;
  power_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::PowerState* RobotState::unsafe_arena_release_power_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.power_state)
  
  ::bosdyn::api::PowerState* temp = power_state_;
  power_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PowerState* RobotState::_internal_mutable_power_state() {
  
  if (power_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PowerState>(GetArena());
    power_state_ = p;
  }
  return power_state_;
}
inline ::bosdyn::api::PowerState* RobotState::mutable_power_state() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.power_state)
  return _internal_mutable_power_state();
}
inline void RobotState::set_allocated_power_state(::bosdyn::api::PowerState* power_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete power_state_;
  }
  if (power_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(power_state);
    if (message_arena != submessage_arena) {
      power_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, power_state, submessage_arena);
    }
    
  } else {
    
  }
  power_state_ = power_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.power_state)
}

// repeated .bosdyn.api.BatteryState battery_states = 2;
inline int RobotState::_internal_battery_states_size() const {
  return battery_states_.size();
}
inline int RobotState::battery_states_size() const {
  return _internal_battery_states_size();
}
inline void RobotState::clear_battery_states() {
  battery_states_.Clear();
}
inline ::bosdyn::api::BatteryState* RobotState::mutable_battery_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.battery_states)
  return battery_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState >*
RobotState::mutable_battery_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotState.battery_states)
  return &battery_states_;
}
inline const ::bosdyn::api::BatteryState& RobotState::_internal_battery_states(int index) const {
  return battery_states_.Get(index);
}
inline const ::bosdyn::api::BatteryState& RobotState::battery_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.battery_states)
  return _internal_battery_states(index);
}
inline ::bosdyn::api::BatteryState* RobotState::_internal_add_battery_states() {
  return battery_states_.Add();
}
inline ::bosdyn::api::BatteryState* RobotState::add_battery_states() {
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotState.battery_states)
  return _internal_add_battery_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BatteryState >&
RobotState::battery_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotState.battery_states)
  return battery_states_;
}

// repeated .bosdyn.api.CommsState comms_states = 3;
inline int RobotState::_internal_comms_states_size() const {
  return comms_states_.size();
}
inline int RobotState::comms_states_size() const {
  return _internal_comms_states_size();
}
inline void RobotState::clear_comms_states() {
  comms_states_.Clear();
}
inline ::bosdyn::api::CommsState* RobotState::mutable_comms_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.comms_states)
  return comms_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState >*
RobotState::mutable_comms_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotState.comms_states)
  return &comms_states_;
}
inline const ::bosdyn::api::CommsState& RobotState::_internal_comms_states(int index) const {
  return comms_states_.Get(index);
}
inline const ::bosdyn::api::CommsState& RobotState::comms_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.comms_states)
  return _internal_comms_states(index);
}
inline ::bosdyn::api::CommsState* RobotState::_internal_add_comms_states() {
  return comms_states_.Add();
}
inline ::bosdyn::api::CommsState* RobotState::add_comms_states() {
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotState.comms_states)
  return _internal_add_comms_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::CommsState >&
RobotState::comms_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotState.comms_states)
  return comms_states_;
}

// .bosdyn.api.SystemFaultState system_fault_state = 4;
inline bool RobotState::_internal_has_system_fault_state() const {
  return this != internal_default_instance() && system_fault_state_ != nullptr;
}
inline bool RobotState::has_system_fault_state() const {
  return _internal_has_system_fault_state();
}
inline void RobotState::clear_system_fault_state() {
  if (GetArena() == nullptr && system_fault_state_ != nullptr) {
    delete system_fault_state_;
  }
  system_fault_state_ = nullptr;
}
inline const ::bosdyn::api::SystemFaultState& RobotState::_internal_system_fault_state() const {
  const ::bosdyn::api::SystemFaultState* p = system_fault_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SystemFaultState*>(
      &::bosdyn::api::_SystemFaultState_default_instance_);
}
inline const ::bosdyn::api::SystemFaultState& RobotState::system_fault_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.system_fault_state)
  return _internal_system_fault_state();
}
inline void RobotState::unsafe_arena_set_allocated_system_fault_state(
    ::bosdyn::api::SystemFaultState* system_fault_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(system_fault_state_);
  }
  system_fault_state_ = system_fault_state;
  if (system_fault_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.system_fault_state)
}
inline ::bosdyn::api::SystemFaultState* RobotState::release_system_fault_state() {
  
  ::bosdyn::api::SystemFaultState* temp = system_fault_state_;
  system_fault_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SystemFaultState* RobotState::unsafe_arena_release_system_fault_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.system_fault_state)
  
  ::bosdyn::api::SystemFaultState* temp = system_fault_state_;
  system_fault_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SystemFaultState* RobotState::_internal_mutable_system_fault_state() {
  
  if (system_fault_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SystemFaultState>(GetArena());
    system_fault_state_ = p;
  }
  return system_fault_state_;
}
inline ::bosdyn::api::SystemFaultState* RobotState::mutable_system_fault_state() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.system_fault_state)
  return _internal_mutable_system_fault_state();
}
inline void RobotState::set_allocated_system_fault_state(::bosdyn::api::SystemFaultState* system_fault_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete system_fault_state_;
  }
  if (system_fault_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(system_fault_state);
    if (message_arena != submessage_arena) {
      system_fault_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_fault_state, submessage_arena);
    }
    
  } else {
    
  }
  system_fault_state_ = system_fault_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.system_fault_state)
}

// repeated .bosdyn.api.EStopState estop_states = 5;
inline int RobotState::_internal_estop_states_size() const {
  return estop_states_.size();
}
inline int RobotState::estop_states_size() const {
  return _internal_estop_states_size();
}
inline void RobotState::clear_estop_states() {
  estop_states_.Clear();
}
inline ::bosdyn::api::EStopState* RobotState::mutable_estop_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.estop_states)
  return estop_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState >*
RobotState::mutable_estop_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotState.estop_states)
  return &estop_states_;
}
inline const ::bosdyn::api::EStopState& RobotState::_internal_estop_states(int index) const {
  return estop_states_.Get(index);
}
inline const ::bosdyn::api::EStopState& RobotState::estop_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.estop_states)
  return _internal_estop_states(index);
}
inline ::bosdyn::api::EStopState* RobotState::_internal_add_estop_states() {
  return estop_states_.Add();
}
inline ::bosdyn::api::EStopState* RobotState::add_estop_states() {
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotState.estop_states)
  return _internal_add_estop_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EStopState >&
RobotState::estop_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotState.estop_states)
  return estop_states_;
}

// .bosdyn.api.KinematicState kinematic_state = 6;
inline bool RobotState::_internal_has_kinematic_state() const {
  return this != internal_default_instance() && kinematic_state_ != nullptr;
}
inline bool RobotState::has_kinematic_state() const {
  return _internal_has_kinematic_state();
}
inline void RobotState::clear_kinematic_state() {
  if (GetArena() == nullptr && kinematic_state_ != nullptr) {
    delete kinematic_state_;
  }
  kinematic_state_ = nullptr;
}
inline const ::bosdyn::api::KinematicState& RobotState::_internal_kinematic_state() const {
  const ::bosdyn::api::KinematicState* p = kinematic_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::KinematicState*>(
      &::bosdyn::api::_KinematicState_default_instance_);
}
inline const ::bosdyn::api::KinematicState& RobotState::kinematic_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.kinematic_state)
  return _internal_kinematic_state();
}
inline void RobotState::unsafe_arena_set_allocated_kinematic_state(
    ::bosdyn::api::KinematicState* kinematic_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kinematic_state_);
  }
  kinematic_state_ = kinematic_state;
  if (kinematic_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.kinematic_state)
}
inline ::bosdyn::api::KinematicState* RobotState::release_kinematic_state() {
  
  ::bosdyn::api::KinematicState* temp = kinematic_state_;
  kinematic_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::KinematicState* RobotState::unsafe_arena_release_kinematic_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.kinematic_state)
  
  ::bosdyn::api::KinematicState* temp = kinematic_state_;
  kinematic_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::KinematicState* RobotState::_internal_mutable_kinematic_state() {
  
  if (kinematic_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::KinematicState>(GetArena());
    kinematic_state_ = p;
  }
  return kinematic_state_;
}
inline ::bosdyn::api::KinematicState* RobotState::mutable_kinematic_state() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.kinematic_state)
  return _internal_mutable_kinematic_state();
}
inline void RobotState::set_allocated_kinematic_state(::bosdyn::api::KinematicState* kinematic_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete kinematic_state_;
  }
  if (kinematic_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(kinematic_state);
    if (message_arena != submessage_arena) {
      kinematic_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kinematic_state, submessage_arena);
    }
    
  } else {
    
  }
  kinematic_state_ = kinematic_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.kinematic_state)
}

// .bosdyn.api.BehaviorFaultState behavior_fault_state = 7;
inline bool RobotState::_internal_has_behavior_fault_state() const {
  return this != internal_default_instance() && behavior_fault_state_ != nullptr;
}
inline bool RobotState::has_behavior_fault_state() const {
  return _internal_has_behavior_fault_state();
}
inline void RobotState::clear_behavior_fault_state() {
  if (GetArena() == nullptr && behavior_fault_state_ != nullptr) {
    delete behavior_fault_state_;
  }
  behavior_fault_state_ = nullptr;
}
inline const ::bosdyn::api::BehaviorFaultState& RobotState::_internal_behavior_fault_state() const {
  const ::bosdyn::api::BehaviorFaultState* p = behavior_fault_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::BehaviorFaultState*>(
      &::bosdyn::api::_BehaviorFaultState_default_instance_);
}
inline const ::bosdyn::api::BehaviorFaultState& RobotState::behavior_fault_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.behavior_fault_state)
  return _internal_behavior_fault_state();
}
inline void RobotState::unsafe_arena_set_allocated_behavior_fault_state(
    ::bosdyn::api::BehaviorFaultState* behavior_fault_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(behavior_fault_state_);
  }
  behavior_fault_state_ = behavior_fault_state;
  if (behavior_fault_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotState.behavior_fault_state)
}
inline ::bosdyn::api::BehaviorFaultState* RobotState::release_behavior_fault_state() {
  
  ::bosdyn::api::BehaviorFaultState* temp = behavior_fault_state_;
  behavior_fault_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::BehaviorFaultState* RobotState::unsafe_arena_release_behavior_fault_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotState.behavior_fault_state)
  
  ::bosdyn::api::BehaviorFaultState* temp = behavior_fault_state_;
  behavior_fault_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::BehaviorFaultState* RobotState::_internal_mutable_behavior_fault_state() {
  
  if (behavior_fault_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::BehaviorFaultState>(GetArena());
    behavior_fault_state_ = p;
  }
  return behavior_fault_state_;
}
inline ::bosdyn::api::BehaviorFaultState* RobotState::mutable_behavior_fault_state() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.behavior_fault_state)
  return _internal_mutable_behavior_fault_state();
}
inline void RobotState::set_allocated_behavior_fault_state(::bosdyn::api::BehaviorFaultState* behavior_fault_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete behavior_fault_state_;
  }
  if (behavior_fault_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(behavior_fault_state);
    if (message_arena != submessage_arena) {
      behavior_fault_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, behavior_fault_state, submessage_arena);
    }
    
  } else {
    
  }
  behavior_fault_state_ = behavior_fault_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotState.behavior_fault_state)
}

// repeated .bosdyn.api.FootState foot_state = 8;
inline int RobotState::_internal_foot_state_size() const {
  return foot_state_.size();
}
inline int RobotState::foot_state_size() const {
  return _internal_foot_state_size();
}
inline void RobotState::clear_foot_state() {
  foot_state_.Clear();
}
inline ::bosdyn::api::FootState* RobotState::mutable_foot_state(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotState.foot_state)
  return foot_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState >*
RobotState::mutable_foot_state() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotState.foot_state)
  return &foot_state_;
}
inline const ::bosdyn::api::FootState& RobotState::_internal_foot_state(int index) const {
  return foot_state_.Get(index);
}
inline const ::bosdyn::api::FootState& RobotState::foot_state(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotState.foot_state)
  return _internal_foot_state(index);
}
inline ::bosdyn::api::FootState* RobotState::_internal_add_foot_state() {
  return foot_state_.Add();
}
inline ::bosdyn::api::FootState* RobotState::add_foot_state() {
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotState.foot_state)
  return _internal_add_foot_state();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::FootState >&
RobotState::foot_state() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotState.foot_state)
  return foot_state_;
}

// -------------------------------------------------------------------

// PowerState

// .google.protobuf.Timestamp timestamp = 1;
inline bool PowerState::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool PowerState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PowerState::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PowerState::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.timestamp)
  return _internal_timestamp();
}
inline void PowerState::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerState.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PowerState::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PowerState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerState.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PowerState::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PowerState::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerState.timestamp)
  return _internal_mutable_timestamp();
}
inline void PowerState::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerState.timestamp)
}

// .bosdyn.api.PowerState.MotorPowerState motor_power_state = 2;
inline void PowerState::clear_motor_power_state() {
  motor_power_state_ = 0;
}
inline ::bosdyn::api::PowerState_MotorPowerState PowerState::_internal_motor_power_state() const {
  return static_cast< ::bosdyn::api::PowerState_MotorPowerState >(motor_power_state_);
}
inline ::bosdyn::api::PowerState_MotorPowerState PowerState::motor_power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.motor_power_state)
  return _internal_motor_power_state();
}
inline void PowerState::_internal_set_motor_power_state(::bosdyn::api::PowerState_MotorPowerState value) {
  
  motor_power_state_ = value;
}
inline void PowerState::set_motor_power_state(::bosdyn::api::PowerState_MotorPowerState value) {
  _internal_set_motor_power_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerState.motor_power_state)
}

// .bosdyn.api.PowerState.ShorePowerState shore_power_state = 3;
inline void PowerState::clear_shore_power_state() {
  shore_power_state_ = 0;
}
inline ::bosdyn::api::PowerState_ShorePowerState PowerState::_internal_shore_power_state() const {
  return static_cast< ::bosdyn::api::PowerState_ShorePowerState >(shore_power_state_);
}
inline ::bosdyn::api::PowerState_ShorePowerState PowerState::shore_power_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.shore_power_state)
  return _internal_shore_power_state();
}
inline void PowerState::_internal_set_shore_power_state(::bosdyn::api::PowerState_ShorePowerState value) {
  
  shore_power_state_ = value;
}
inline void PowerState::set_shore_power_state(::bosdyn::api::PowerState_ShorePowerState value) {
  _internal_set_shore_power_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PowerState.shore_power_state)
}

// .google.protobuf.DoubleValue locomotion_charge_percentage = 4;
inline bool PowerState::_internal_has_locomotion_charge_percentage() const {
  return this != internal_default_instance() && locomotion_charge_percentage_ != nullptr;
}
inline bool PowerState::has_locomotion_charge_percentage() const {
  return _internal_has_locomotion_charge_percentage();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& PowerState::_internal_locomotion_charge_percentage() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = locomotion_charge_percentage_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& PowerState::locomotion_charge_percentage() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.locomotion_charge_percentage)
  return _internal_locomotion_charge_percentage();
}
inline void PowerState::unsafe_arena_set_allocated_locomotion_charge_percentage(
    PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locomotion_charge_percentage_);
  }
  locomotion_charge_percentage_ = locomotion_charge_percentage;
  if (locomotion_charge_percentage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerState.locomotion_charge_percentage)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* PowerState::release_locomotion_charge_percentage() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = locomotion_charge_percentage_;
  locomotion_charge_percentage_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* PowerState::unsafe_arena_release_locomotion_charge_percentage() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerState.locomotion_charge_percentage)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = locomotion_charge_percentage_;
  locomotion_charge_percentage_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* PowerState::_internal_mutable_locomotion_charge_percentage() {
  
  if (locomotion_charge_percentage_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    locomotion_charge_percentage_ = p;
  }
  return locomotion_charge_percentage_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* PowerState::mutable_locomotion_charge_percentage() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerState.locomotion_charge_percentage)
  return _internal_mutable_locomotion_charge_percentage();
}
inline void PowerState::set_allocated_locomotion_charge_percentage(PROTOBUF_NAMESPACE_ID::DoubleValue* locomotion_charge_percentage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(locomotion_charge_percentage_);
  }
  if (locomotion_charge_percentage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locomotion_charge_percentage)->GetArena();
    if (message_arena != submessage_arena) {
      locomotion_charge_percentage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locomotion_charge_percentage, submessage_arena);
    }
    
  } else {
    
  }
  locomotion_charge_percentage_ = locomotion_charge_percentage;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerState.locomotion_charge_percentage)
}

// .google.protobuf.Duration locomotion_estimated_runtime = 5;
inline bool PowerState::_internal_has_locomotion_estimated_runtime() const {
  return this != internal_default_instance() && locomotion_estimated_runtime_ != nullptr;
}
inline bool PowerState::has_locomotion_estimated_runtime() const {
  return _internal_has_locomotion_estimated_runtime();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& PowerState::_internal_locomotion_estimated_runtime() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = locomotion_estimated_runtime_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration*>(
      &PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& PowerState::locomotion_estimated_runtime() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PowerState.locomotion_estimated_runtime)
  return _internal_locomotion_estimated_runtime();
}
inline void PowerState::unsafe_arena_set_allocated_locomotion_estimated_runtime(
    PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locomotion_estimated_runtime_);
  }
  locomotion_estimated_runtime_ = locomotion_estimated_runtime;
  if (locomotion_estimated_runtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PowerState.locomotion_estimated_runtime)
}
inline PROTOBUF_NAMESPACE_ID::Duration* PowerState::release_locomotion_estimated_runtime() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = locomotion_estimated_runtime_;
  locomotion_estimated_runtime_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* PowerState::unsafe_arena_release_locomotion_estimated_runtime() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PowerState.locomotion_estimated_runtime)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = locomotion_estimated_runtime_;
  locomotion_estimated_runtime_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* PowerState::_internal_mutable_locomotion_estimated_runtime() {
  
  if (locomotion_estimated_runtime_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    locomotion_estimated_runtime_ = p;
  }
  return locomotion_estimated_runtime_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* PowerState::mutable_locomotion_estimated_runtime() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PowerState.locomotion_estimated_runtime)
  return _internal_mutable_locomotion_estimated_runtime();
}
inline void PowerState::set_allocated_locomotion_estimated_runtime(PROTOBUF_NAMESPACE_ID::Duration* locomotion_estimated_runtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(locomotion_estimated_runtime_);
  }
  if (locomotion_estimated_runtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locomotion_estimated_runtime)->GetArena();
    if (message_arena != submessage_arena) {
      locomotion_estimated_runtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locomotion_estimated_runtime, submessage_arena);
    }
    
  } else {
    
  }
  locomotion_estimated_runtime_ = locomotion_estimated_runtime;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PowerState.locomotion_estimated_runtime)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SystemFaultState

// repeated .bosdyn.api.SystemFault faults = 1;
inline int SystemFaultState::_internal_faults_size() const {
  return faults_.size();
}
inline int SystemFaultState::faults_size() const {
  return _internal_faults_size();
}
inline void SystemFaultState::clear_faults() {
  faults_.Clear();
}
inline ::bosdyn::api::SystemFault* SystemFaultState::mutable_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFaultState.faults)
  return faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
SystemFaultState::mutable_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.SystemFaultState.faults)
  return &faults_;
}
inline const ::bosdyn::api::SystemFault& SystemFaultState::_internal_faults(int index) const {
  return faults_.Get(index);
}
inline const ::bosdyn::api::SystemFault& SystemFaultState::faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFaultState.faults)
  return _internal_faults(index);
}
inline ::bosdyn::api::SystemFault* SystemFaultState::_internal_add_faults() {
  return faults_.Add();
}
inline ::bosdyn::api::SystemFault* SystemFaultState::add_faults() {
  // @@protoc_insertion_point(field_add:bosdyn.api.SystemFaultState.faults)
  return _internal_add_faults();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
SystemFaultState::faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.SystemFaultState.faults)
  return faults_;
}

// repeated .bosdyn.api.SystemFault historical_faults = 2;
inline int SystemFaultState::_internal_historical_faults_size() const {
  return historical_faults_.size();
}
inline int SystemFaultState::historical_faults_size() const {
  return _internal_historical_faults_size();
}
inline void SystemFaultState::clear_historical_faults() {
  historical_faults_.Clear();
}
inline ::bosdyn::api::SystemFault* SystemFaultState::mutable_historical_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFaultState.historical_faults)
  return historical_faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >*
SystemFaultState::mutable_historical_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.SystemFaultState.historical_faults)
  return &historical_faults_;
}
inline const ::bosdyn::api::SystemFault& SystemFaultState::_internal_historical_faults(int index) const {
  return historical_faults_.Get(index);
}
inline const ::bosdyn::api::SystemFault& SystemFaultState::historical_faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFaultState.historical_faults)
  return _internal_historical_faults(index);
}
inline ::bosdyn::api::SystemFault* SystemFaultState::_internal_add_historical_faults() {
  return historical_faults_.Add();
}
inline ::bosdyn::api::SystemFault* SystemFaultState::add_historical_faults() {
  // @@protoc_insertion_point(field_add:bosdyn.api.SystemFaultState.historical_faults)
  return _internal_add_historical_faults();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::SystemFault >&
SystemFaultState::historical_faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.SystemFaultState.historical_faults)
  return historical_faults_;
}

// map<string, .bosdyn.api.SystemFault.Severity> aggregated = 3;
inline int SystemFaultState::_internal_aggregated_size() const {
  return aggregated_.size();
}
inline int SystemFaultState::aggregated_size() const {
  return _internal_aggregated_size();
}
inline void SystemFaultState::clear_aggregated() {
  aggregated_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >&
SystemFaultState::_internal_aggregated() const {
  return aggregated_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >&
SystemFaultState::aggregated() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.SystemFaultState.aggregated)
  return _internal_aggregated();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >*
SystemFaultState::_internal_mutable_aggregated() {
  return aggregated_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::SystemFault_Severity >*
SystemFaultState::mutable_aggregated() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.SystemFaultState.aggregated)
  return _internal_mutable_aggregated();
}

// -------------------------------------------------------------------

// SystemFault

// string name = 1;
inline void SystemFault::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SystemFault::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.name)
  return _internal_name();
}
inline void SystemFault::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.name)
}
inline std::string* SystemFault::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.name)
  return _internal_mutable_name();
}
inline const std::string& SystemFault::_internal_name() const {
  return name_.Get();
}
inline void SystemFault::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SystemFault::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.SystemFault.name)
}
inline void SystemFault::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.SystemFault.name)
}
inline void SystemFault::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.SystemFault.name)
}
inline std::string* SystemFault::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SystemFault::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SystemFault.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SystemFault::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SystemFault.name)
}

// .google.protobuf.Timestamp onset_timestamp = 2;
inline bool SystemFault::_internal_has_onset_timestamp() const {
  return this != internal_default_instance() && onset_timestamp_ != nullptr;
}
inline bool SystemFault::has_onset_timestamp() const {
  return _internal_has_onset_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& SystemFault::_internal_onset_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = onset_timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& SystemFault::onset_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.onset_timestamp)
  return _internal_onset_timestamp();
}
inline void SystemFault::unsafe_arena_set_allocated_onset_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp_);
  }
  onset_timestamp_ = onset_timestamp;
  if (onset_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SystemFault.onset_timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SystemFault::release_onset_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = onset_timestamp_;
  onset_timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SystemFault::unsafe_arena_release_onset_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SystemFault.onset_timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = onset_timestamp_;
  onset_timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SystemFault::_internal_mutable_onset_timestamp() {
  
  if (onset_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    onset_timestamp_ = p;
  }
  return onset_timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SystemFault::mutable_onset_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.onset_timestamp)
  return _internal_mutable_onset_timestamp();
}
inline void SystemFault::set_allocated_onset_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp_);
  }
  if (onset_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      onset_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, onset_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  onset_timestamp_ = onset_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SystemFault.onset_timestamp)
}

// .google.protobuf.Duration duration = 3;
inline bool SystemFault::_internal_has_duration() const {
  return this != internal_default_instance() && duration_ != nullptr;
}
inline bool SystemFault::has_duration() const {
  return _internal_has_duration();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& SystemFault::_internal_duration() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration*>(
      &PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& SystemFault::duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.duration)
  return _internal_duration();
}
inline void SystemFault::unsafe_arena_set_allocated_duration(
    PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SystemFault.duration)
}
inline PROTOBUF_NAMESPACE_ID::Duration* SystemFault::release_duration() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* SystemFault::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SystemFault.duration)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* SystemFault::_internal_mutable_duration() {
  
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* SystemFault::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.duration)
  return _internal_mutable_duration();
}
inline void SystemFault::set_allocated_duration(PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration)->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SystemFault.duration)
}

// int32 code = 4;
inline void SystemFault::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SystemFault::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SystemFault::code() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.code)
  return _internal_code();
}
inline void SystemFault::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void SystemFault::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.code)
}

// uint64 uid = 8;
inline void SystemFault::clear_uid() {
  uid_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SystemFault::_internal_uid() const {
  return uid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SystemFault::uid() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.uid)
  return _internal_uid();
}
inline void SystemFault::_internal_set_uid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  uid_ = value;
}
inline void SystemFault::set_uid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.uid)
}

// string error_message = 5;
inline void SystemFault::clear_error_message() {
  error_message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SystemFault::error_message() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.error_message)
  return _internal_error_message();
}
inline void SystemFault::set_error_message(const std::string& value) {
  _internal_set_error_message(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.error_message)
}
inline std::string* SystemFault::mutable_error_message() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.error_message)
  return _internal_mutable_error_message();
}
inline const std::string& SystemFault::_internal_error_message() const {
  return error_message_.Get();
}
inline void SystemFault::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SystemFault::set_error_message(std::string&& value) {
  
  error_message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.SystemFault.error_message)
}
inline void SystemFault::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.SystemFault.error_message)
}
inline void SystemFault::set_error_message(const char* value,
    size_t size) {
  
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.SystemFault.error_message)
}
inline std::string* SystemFault::_internal_mutable_error_message() {
  
  return error_message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SystemFault::release_error_message() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SystemFault.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SystemFault::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SystemFault.error_message)
}

// repeated string attributes = 6;
inline int SystemFault::_internal_attributes_size() const {
  return attributes_.size();
}
inline int SystemFault::attributes_size() const {
  return _internal_attributes_size();
}
inline void SystemFault::clear_attributes() {
  attributes_.Clear();
}
inline std::string* SystemFault::add_attributes() {
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.SystemFault.attributes)
  return _internal_add_attributes();
}
inline const std::string& SystemFault::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const std::string& SystemFault::attributes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.attributes)
  return _internal_attributes(index);
}
inline std::string* SystemFault::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SystemFault.attributes)
  return attributes_.Mutable(index);
}
inline void SystemFault::set_attributes(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.attributes)
  attributes_.Mutable(index)->assign(value);
}
inline void SystemFault::set_attributes(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.attributes)
  attributes_.Mutable(index)->assign(std::move(value));
}
inline void SystemFault::set_attributes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::set_attributes(int index, const char* value, size_t size) {
  attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.SystemFault.attributes)
}
inline std::string* SystemFault::_internal_add_attributes() {
  return attributes_.Add();
}
inline void SystemFault::add_attributes(const std::string& value) {
  attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::add_attributes(std::string&& value) {
  attributes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::add_attributes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.SystemFault.attributes)
}
inline void SystemFault::add_attributes(const char* value, size_t size) {
  attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.SystemFault.attributes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SystemFault::attributes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.SystemFault.attributes)
  return attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SystemFault::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.SystemFault.attributes)
  return &attributes_;
}

// .bosdyn.api.SystemFault.Severity severity = 7;
inline void SystemFault::clear_severity() {
  severity_ = 0;
}
inline ::bosdyn::api::SystemFault_Severity SystemFault::_internal_severity() const {
  return static_cast< ::bosdyn::api::SystemFault_Severity >(severity_);
}
inline ::bosdyn::api::SystemFault_Severity SystemFault::severity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SystemFault.severity)
  return _internal_severity();
}
inline void SystemFault::_internal_set_severity(::bosdyn::api::SystemFault_Severity value) {
  
  severity_ = value;
}
inline void SystemFault::set_severity(::bosdyn::api::SystemFault_Severity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SystemFault.severity)
}

// -------------------------------------------------------------------

// EStopState

// .google.protobuf.Timestamp timestamp = 1;
inline bool EStopState::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool EStopState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& EStopState::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& EStopState::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.timestamp)
  return _internal_timestamp();
}
inline void EStopState::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EStopState.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* EStopState::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* EStopState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EStopState.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* EStopState::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* EStopState::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EStopState.timestamp)
  return _internal_mutable_timestamp();
}
inline void EStopState::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EStopState.timestamp)
}

// string name = 2;
inline void EStopState::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EStopState::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.name)
  return _internal_name();
}
inline void EStopState::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EStopState.name)
}
inline std::string* EStopState::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EStopState.name)
  return _internal_mutable_name();
}
inline const std::string& EStopState::_internal_name() const {
  return name_.Get();
}
inline void EStopState::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EStopState::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.EStopState.name)
}
inline void EStopState::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.EStopState.name)
}
inline void EStopState::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.EStopState.name)
}
inline std::string* EStopState::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EStopState::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EStopState.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EStopState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EStopState.name)
}

// .bosdyn.api.EStopState.Type type = 3;
inline void EStopState::clear_type() {
  type_ = 0;
}
inline ::bosdyn::api::EStopState_Type EStopState::_internal_type() const {
  return static_cast< ::bosdyn::api::EStopState_Type >(type_);
}
inline ::bosdyn::api::EStopState_Type EStopState::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.type)
  return _internal_type();
}
inline void EStopState::_internal_set_type(::bosdyn::api::EStopState_Type value) {
  
  type_ = value;
}
inline void EStopState::set_type(::bosdyn::api::EStopState_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EStopState.type)
}

// .bosdyn.api.EStopState.State state = 4;
inline void EStopState::clear_state() {
  state_ = 0;
}
inline ::bosdyn::api::EStopState_State EStopState::_internal_state() const {
  return static_cast< ::bosdyn::api::EStopState_State >(state_);
}
inline ::bosdyn::api::EStopState_State EStopState::state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.state)
  return _internal_state();
}
inline void EStopState::_internal_set_state(::bosdyn::api::EStopState_State value) {
  
  state_ = value;
}
inline void EStopState::set_state(::bosdyn::api::EStopState_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EStopState.state)
}

// string state_description = 5;
inline void EStopState::clear_state_description() {
  state_description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EStopState::state_description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EStopState.state_description)
  return _internal_state_description();
}
inline void EStopState::set_state_description(const std::string& value) {
  _internal_set_state_description(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EStopState.state_description)
}
inline std::string* EStopState::mutable_state_description() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EStopState.state_description)
  return _internal_mutable_state_description();
}
inline const std::string& EStopState::_internal_state_description() const {
  return state_description_.Get();
}
inline void EStopState::_internal_set_state_description(const std::string& value) {
  
  state_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EStopState::set_state_description(std::string&& value) {
  
  state_description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.EStopState.state_description)
}
inline void EStopState::set_state_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.EStopState.state_description)
}
inline void EStopState::set_state_description(const char* value,
    size_t size) {
  
  state_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.EStopState.state_description)
}
inline std::string* EStopState::_internal_mutable_state_description() {
  
  return state_description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EStopState::release_state_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EStopState.state_description)
  return state_description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EStopState::set_allocated_state_description(std::string* state_description) {
  if (state_description != nullptr) {
    
  } else {
    
  }
  state_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state_description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EStopState.state_description)
}

// -------------------------------------------------------------------

// BatteryState

// .google.protobuf.Timestamp timestamp = 1;
inline bool BatteryState::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool BatteryState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& BatteryState::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& BatteryState::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.timestamp)
  return _internal_timestamp();
}
inline void BatteryState::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BatteryState::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BatteryState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BatteryState::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BatteryState::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.timestamp)
  return _internal_mutable_timestamp();
}
inline void BatteryState::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.timestamp)
}

// string identifier = 2;
inline void BatteryState::clear_identifier() {
  identifier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BatteryState::identifier() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.identifier)
  return _internal_identifier();
}
inline void BatteryState::set_identifier(const std::string& value) {
  _internal_set_identifier(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BatteryState.identifier)
}
inline std::string* BatteryState::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.identifier)
  return _internal_mutable_identifier();
}
inline const std::string& BatteryState::_internal_identifier() const {
  return identifier_.Get();
}
inline void BatteryState::_internal_set_identifier(const std::string& value) {
  
  identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BatteryState::set_identifier(std::string&& value) {
  
  identifier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.BatteryState.identifier)
}
inline void BatteryState::set_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.BatteryState.identifier)
}
inline void BatteryState::set_identifier(const char* value,
    size_t size) {
  
  identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.BatteryState.identifier)
}
inline std::string* BatteryState::_internal_mutable_identifier() {
  
  return identifier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BatteryState::release_identifier() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.identifier)
  return identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BatteryState::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    
  } else {
    
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.identifier)
}

// .google.protobuf.DoubleValue charge_percentage = 3;
inline bool BatteryState::_internal_has_charge_percentage() const {
  return this != internal_default_instance() && charge_percentage_ != nullptr;
}
inline bool BatteryState::has_charge_percentage() const {
  return _internal_has_charge_percentage();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::_internal_charge_percentage() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = charge_percentage_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::charge_percentage() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.charge_percentage)
  return _internal_charge_percentage();
}
inline void BatteryState::unsafe_arena_set_allocated_charge_percentage(
    PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charge_percentage_);
  }
  charge_percentage_ = charge_percentage;
  if (charge_percentage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.charge_percentage)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::release_charge_percentage() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = charge_percentage_;
  charge_percentage_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::unsafe_arena_release_charge_percentage() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.charge_percentage)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = charge_percentage_;
  charge_percentage_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::_internal_mutable_charge_percentage() {
  
  if (charge_percentage_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    charge_percentage_ = p;
  }
  return charge_percentage_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::mutable_charge_percentage() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.charge_percentage)
  return _internal_mutable_charge_percentage();
}
inline void BatteryState::set_allocated_charge_percentage(PROTOBUF_NAMESPACE_ID::DoubleValue* charge_percentage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(charge_percentage_);
  }
  if (charge_percentage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(charge_percentage)->GetArena();
    if (message_arena != submessage_arena) {
      charge_percentage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, charge_percentage, submessage_arena);
    }
    
  } else {
    
  }
  charge_percentage_ = charge_percentage;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.charge_percentage)
}

// .google.protobuf.Duration estimated_runtime = 4;
inline bool BatteryState::_internal_has_estimated_runtime() const {
  return this != internal_default_instance() && estimated_runtime_ != nullptr;
}
inline bool BatteryState::has_estimated_runtime() const {
  return _internal_has_estimated_runtime();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& BatteryState::_internal_estimated_runtime() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = estimated_runtime_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration*>(
      &PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& BatteryState::estimated_runtime() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.estimated_runtime)
  return _internal_estimated_runtime();
}
inline void BatteryState::unsafe_arena_set_allocated_estimated_runtime(
    PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(estimated_runtime_);
  }
  estimated_runtime_ = estimated_runtime;
  if (estimated_runtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.estimated_runtime)
}
inline PROTOBUF_NAMESPACE_ID::Duration* BatteryState::release_estimated_runtime() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = estimated_runtime_;
  estimated_runtime_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* BatteryState::unsafe_arena_release_estimated_runtime() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.estimated_runtime)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = estimated_runtime_;
  estimated_runtime_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* BatteryState::_internal_mutable_estimated_runtime() {
  
  if (estimated_runtime_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    estimated_runtime_ = p;
  }
  return estimated_runtime_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* BatteryState::mutable_estimated_runtime() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.estimated_runtime)
  return _internal_mutable_estimated_runtime();
}
inline void BatteryState::set_allocated_estimated_runtime(PROTOBUF_NAMESPACE_ID::Duration* estimated_runtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(estimated_runtime_);
  }
  if (estimated_runtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(estimated_runtime)->GetArena();
    if (message_arena != submessage_arena) {
      estimated_runtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, estimated_runtime, submessage_arena);
    }
    
  } else {
    
  }
  estimated_runtime_ = estimated_runtime;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.estimated_runtime)
}

// .google.protobuf.DoubleValue current = 5;
inline bool BatteryState::_internal_has_current() const {
  return this != internal_default_instance() && current_ != nullptr;
}
inline bool BatteryState::has_current() const {
  return _internal_has_current();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::_internal_current() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = current_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::current() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.current)
  return _internal_current();
}
inline void BatteryState::unsafe_arena_set_allocated_current(
    PROTOBUF_NAMESPACE_ID::DoubleValue* current) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_);
  }
  current_ = current;
  if (current) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.current)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::release_current() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = current_;
  current_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::unsafe_arena_release_current() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.current)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = current_;
  current_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::_internal_mutable_current() {
  
  if (current_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    current_ = p;
  }
  return current_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::mutable_current() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.current)
  return _internal_mutable_current();
}
inline void BatteryState::set_allocated_current(PROTOBUF_NAMESPACE_ID::DoubleValue* current) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_);
  }
  if (current) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current)->GetArena();
    if (message_arena != submessage_arena) {
      current = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current, submessage_arena);
    }
    
  } else {
    
  }
  current_ = current;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.current)
}

// .google.protobuf.DoubleValue voltage = 6;
inline bool BatteryState::_internal_has_voltage() const {
  return this != internal_default_instance() && voltage_ != nullptr;
}
inline bool BatteryState::has_voltage() const {
  return _internal_has_voltage();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::_internal_voltage() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = voltage_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& BatteryState::voltage() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.voltage)
  return _internal_voltage();
}
inline void BatteryState::unsafe_arena_set_allocated_voltage(
    PROTOBUF_NAMESPACE_ID::DoubleValue* voltage) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltage_);
  }
  voltage_ = voltage;
  if (voltage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BatteryState.voltage)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::release_voltage() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = voltage_;
  voltage_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::unsafe_arena_release_voltage() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BatteryState.voltage)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = voltage_;
  voltage_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::_internal_mutable_voltage() {
  
  if (voltage_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    voltage_ = p;
  }
  return voltage_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* BatteryState::mutable_voltage() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BatteryState.voltage)
  return _internal_mutable_voltage();
}
inline void BatteryState::set_allocated_voltage(PROTOBUF_NAMESPACE_ID::DoubleValue* voltage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltage_);
  }
  if (voltage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(voltage)->GetArena();
    if (message_arena != submessage_arena) {
      voltage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voltage, submessage_arena);
    }
    
  } else {
    
  }
  voltage_ = voltage;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BatteryState.voltage)
}

// repeated double temperatures = 7;
inline int BatteryState::_internal_temperatures_size() const {
  return temperatures_.size();
}
inline int BatteryState::temperatures_size() const {
  return _internal_temperatures_size();
}
inline void BatteryState::clear_temperatures() {
  temperatures_.Clear();
}
inline double BatteryState::_internal_temperatures(int index) const {
  return temperatures_.Get(index);
}
inline double BatteryState::temperatures(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.temperatures)
  return _internal_temperatures(index);
}
inline void BatteryState::set_temperatures(int index, double value) {
  temperatures_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BatteryState.temperatures)
}
inline void BatteryState::_internal_add_temperatures(double value) {
  temperatures_.Add(value);
}
inline void BatteryState::add_temperatures(double value) {
  _internal_add_temperatures(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.BatteryState.temperatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
BatteryState::_internal_temperatures() const {
  return temperatures_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
BatteryState::temperatures() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.BatteryState.temperatures)
  return _internal_temperatures();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
BatteryState::_internal_mutable_temperatures() {
  return &temperatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
BatteryState::mutable_temperatures() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.BatteryState.temperatures)
  return _internal_mutable_temperatures();
}

// .bosdyn.api.BatteryState.Status status = 8;
inline void BatteryState::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::BatteryState_Status BatteryState::_internal_status() const {
  return static_cast< ::bosdyn::api::BatteryState_Status >(status_);
}
inline ::bosdyn::api::BatteryState_Status BatteryState::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BatteryState.status)
  return _internal_status();
}
inline void BatteryState::_internal_set_status(::bosdyn::api::BatteryState_Status value) {
  
  status_ = value;
}
inline void BatteryState::set_status(::bosdyn::api::BatteryState_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BatteryState.status)
}

// -------------------------------------------------------------------

// KinematicState

// repeated .bosdyn.api.JointState joint_states = 2;
inline int KinematicState::_internal_joint_states_size() const {
  return joint_states_.size();
}
inline int KinematicState::joint_states_size() const {
  return _internal_joint_states_size();
}
inline void KinematicState::clear_joint_states() {
  joint_states_.Clear();
}
inline ::bosdyn::api::JointState* KinematicState::mutable_joint_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.joint_states)
  return joint_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState >*
KinematicState::mutable_joint_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.KinematicState.joint_states)
  return &joint_states_;
}
inline const ::bosdyn::api::JointState& KinematicState::_internal_joint_states(int index) const {
  return joint_states_.Get(index);
}
inline const ::bosdyn::api::JointState& KinematicState::joint_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.joint_states)
  return _internal_joint_states(index);
}
inline ::bosdyn::api::JointState* KinematicState::_internal_add_joint_states() {
  return joint_states_.Add();
}
inline ::bosdyn::api::JointState* KinematicState::add_joint_states() {
  // @@protoc_insertion_point(field_add:bosdyn.api.KinematicState.joint_states)
  return _internal_add_joint_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointState >&
KinematicState::joint_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.KinematicState.joint_states)
  return joint_states_;
}

// .google.protobuf.Timestamp acquisition_timestamp = 30;
inline bool KinematicState::_internal_has_acquisition_timestamp() const {
  return this != internal_default_instance() && acquisition_timestamp_ != nullptr;
}
inline bool KinematicState::has_acquisition_timestamp() const {
  return _internal_has_acquisition_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& KinematicState::_internal_acquisition_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = acquisition_timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& KinematicState::acquisition_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.acquisition_timestamp)
  return _internal_acquisition_timestamp();
}
inline void KinematicState::unsafe_arena_set_allocated_acquisition_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_timestamp_);
  }
  acquisition_timestamp_ = acquisition_timestamp;
  if (acquisition_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.KinematicState.acquisition_timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* KinematicState::release_acquisition_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = acquisition_timestamp_;
  acquisition_timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* KinematicState::unsafe_arena_release_acquisition_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.KinematicState.acquisition_timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = acquisition_timestamp_;
  acquisition_timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* KinematicState::_internal_mutable_acquisition_timestamp() {
  
  if (acquisition_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    acquisition_timestamp_ = p;
  }
  return acquisition_timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* KinematicState::mutable_acquisition_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.acquisition_timestamp)
  return _internal_mutable_acquisition_timestamp();
}
inline void KinematicState::set_allocated_acquisition_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* acquisition_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_timestamp_);
  }
  if (acquisition_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acquisition_timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      acquisition_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquisition_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  acquisition_timestamp_ = acquisition_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.KinematicState.acquisition_timestamp)
}

// .bosdyn.api.FrameTreeSnapshot transforms_snapshot = 31;
inline bool KinematicState::_internal_has_transforms_snapshot() const {
  return this != internal_default_instance() && transforms_snapshot_ != nullptr;
}
inline bool KinematicState::has_transforms_snapshot() const {
  return _internal_has_transforms_snapshot();
}
inline const ::bosdyn::api::FrameTreeSnapshot& KinematicState::_internal_transforms_snapshot() const {
  const ::bosdyn::api::FrameTreeSnapshot* p = transforms_snapshot_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::FrameTreeSnapshot*>(
      &::bosdyn::api::_FrameTreeSnapshot_default_instance_);
}
inline const ::bosdyn::api::FrameTreeSnapshot& KinematicState::transforms_snapshot() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.transforms_snapshot)
  return _internal_transforms_snapshot();
}
inline void KinematicState::unsafe_arena_set_allocated_transforms_snapshot(
    ::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot_);
  }
  transforms_snapshot_ = transforms_snapshot;
  if (transforms_snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.KinematicState.transforms_snapshot)
}
inline ::bosdyn::api::FrameTreeSnapshot* KinematicState::release_transforms_snapshot() {
  
  ::bosdyn::api::FrameTreeSnapshot* temp = transforms_snapshot_;
  transforms_snapshot_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* KinematicState::unsafe_arena_release_transforms_snapshot() {
  // @@protoc_insertion_point(field_release:bosdyn.api.KinematicState.transforms_snapshot)
  
  ::bosdyn::api::FrameTreeSnapshot* temp = transforms_snapshot_;
  transforms_snapshot_ = nullptr;
  return temp;
}
inline ::bosdyn::api::FrameTreeSnapshot* KinematicState::_internal_mutable_transforms_snapshot() {
  
  if (transforms_snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::FrameTreeSnapshot>(GetArena());
    transforms_snapshot_ = p;
  }
  return transforms_snapshot_;
}
inline ::bosdyn::api::FrameTreeSnapshot* KinematicState::mutable_transforms_snapshot() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.transforms_snapshot)
  return _internal_mutable_transforms_snapshot();
}
inline void KinematicState::set_allocated_transforms_snapshot(::bosdyn::api::FrameTreeSnapshot* transforms_snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot_);
  }
  if (transforms_snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transforms_snapshot)->GetArena();
    if (message_arena != submessage_arena) {
      transforms_snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transforms_snapshot, submessage_arena);
    }
    
  } else {
    
  }
  transforms_snapshot_ = transforms_snapshot;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.KinematicState.transforms_snapshot)
}

// .bosdyn.api.SE3Velocity velocity_of_body_in_vision = 8;
inline bool KinematicState::_internal_has_velocity_of_body_in_vision() const {
  return this != internal_default_instance() && velocity_of_body_in_vision_ != nullptr;
}
inline bool KinematicState::has_velocity_of_body_in_vision() const {
  return _internal_has_velocity_of_body_in_vision();
}
inline const ::bosdyn::api::SE3Velocity& KinematicState::_internal_velocity_of_body_in_vision() const {
  const ::bosdyn::api::SE3Velocity* p = velocity_of_body_in_vision_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Velocity*>(
      &::bosdyn::api::_SE3Velocity_default_instance_);
}
inline const ::bosdyn::api::SE3Velocity& KinematicState::velocity_of_body_in_vision() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.velocity_of_body_in_vision)
  return _internal_velocity_of_body_in_vision();
}
inline void KinematicState::unsafe_arena_set_allocated_velocity_of_body_in_vision(
    ::bosdyn::api::SE3Velocity* velocity_of_body_in_vision) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_body_in_vision_);
  }
  velocity_of_body_in_vision_ = velocity_of_body_in_vision;
  if (velocity_of_body_in_vision) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.KinematicState.velocity_of_body_in_vision)
}
inline ::bosdyn::api::SE3Velocity* KinematicState::release_velocity_of_body_in_vision() {
  
  ::bosdyn::api::SE3Velocity* temp = velocity_of_body_in_vision_;
  velocity_of_body_in_vision_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::unsafe_arena_release_velocity_of_body_in_vision() {
  // @@protoc_insertion_point(field_release:bosdyn.api.KinematicState.velocity_of_body_in_vision)
  
  ::bosdyn::api::SE3Velocity* temp = velocity_of_body_in_vision_;
  velocity_of_body_in_vision_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::_internal_mutable_velocity_of_body_in_vision() {
  
  if (velocity_of_body_in_vision_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Velocity>(GetArena());
    velocity_of_body_in_vision_ = p;
  }
  return velocity_of_body_in_vision_;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::mutable_velocity_of_body_in_vision() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.velocity_of_body_in_vision)
  return _internal_mutable_velocity_of_body_in_vision();
}
inline void KinematicState::set_allocated_velocity_of_body_in_vision(::bosdyn::api::SE3Velocity* velocity_of_body_in_vision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_body_in_vision_);
  }
  if (velocity_of_body_in_vision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_body_in_vision)->GetArena();
    if (message_arena != submessage_arena) {
      velocity_of_body_in_vision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_of_body_in_vision, submessage_arena);
    }
    
  } else {
    
  }
  velocity_of_body_in_vision_ = velocity_of_body_in_vision;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.KinematicState.velocity_of_body_in_vision)
}

// .bosdyn.api.SE3Velocity velocity_of_body_in_odom = 12;
inline bool KinematicState::_internal_has_velocity_of_body_in_odom() const {
  return this != internal_default_instance() && velocity_of_body_in_odom_ != nullptr;
}
inline bool KinematicState::has_velocity_of_body_in_odom() const {
  return _internal_has_velocity_of_body_in_odom();
}
inline const ::bosdyn::api::SE3Velocity& KinematicState::_internal_velocity_of_body_in_odom() const {
  const ::bosdyn::api::SE3Velocity* p = velocity_of_body_in_odom_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Velocity*>(
      &::bosdyn::api::_SE3Velocity_default_instance_);
}
inline const ::bosdyn::api::SE3Velocity& KinematicState::velocity_of_body_in_odom() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.KinematicState.velocity_of_body_in_odom)
  return _internal_velocity_of_body_in_odom();
}
inline void KinematicState::unsafe_arena_set_allocated_velocity_of_body_in_odom(
    ::bosdyn::api::SE3Velocity* velocity_of_body_in_odom) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_body_in_odom_);
  }
  velocity_of_body_in_odom_ = velocity_of_body_in_odom;
  if (velocity_of_body_in_odom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.KinematicState.velocity_of_body_in_odom)
}
inline ::bosdyn::api::SE3Velocity* KinematicState::release_velocity_of_body_in_odom() {
  
  ::bosdyn::api::SE3Velocity* temp = velocity_of_body_in_odom_;
  velocity_of_body_in_odom_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::unsafe_arena_release_velocity_of_body_in_odom() {
  // @@protoc_insertion_point(field_release:bosdyn.api.KinematicState.velocity_of_body_in_odom)
  
  ::bosdyn::api::SE3Velocity* temp = velocity_of_body_in_odom_;
  velocity_of_body_in_odom_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::_internal_mutable_velocity_of_body_in_odom() {
  
  if (velocity_of_body_in_odom_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Velocity>(GetArena());
    velocity_of_body_in_odom_ = p;
  }
  return velocity_of_body_in_odom_;
}
inline ::bosdyn::api::SE3Velocity* KinematicState::mutable_velocity_of_body_in_odom() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.KinematicState.velocity_of_body_in_odom)
  return _internal_mutable_velocity_of_body_in_odom();
}
inline void KinematicState::set_allocated_velocity_of_body_in_odom(::bosdyn::api::SE3Velocity* velocity_of_body_in_odom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_body_in_odom_);
  }
  if (velocity_of_body_in_odom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_of_body_in_odom)->GetArena();
    if (message_arena != submessage_arena) {
      velocity_of_body_in_odom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_of_body_in_odom, submessage_arena);
    }
    
  } else {
    
  }
  velocity_of_body_in_odom_ = velocity_of_body_in_odom;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.KinematicState.velocity_of_body_in_odom)
}

// -------------------------------------------------------------------

// JointState

// string name = 1;
inline void JointState::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& JointState::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.name)
  return _internal_name();
}
inline void JointState::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.JointState.name)
}
inline std::string* JointState::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.name)
  return _internal_mutable_name();
}
inline const std::string& JointState::_internal_name() const {
  return name_.Get();
}
inline void JointState::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void JointState::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.JointState.name)
}
inline void JointState::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.JointState.name)
}
inline void JointState::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.JointState.name)
}
inline std::string* JointState::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* JointState::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void JointState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.name)
}

// .google.protobuf.DoubleValue position = 2;
inline bool JointState::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool JointState::has_position() const {
  return _internal_has_position();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::_internal_position() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::position() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.position)
  return _internal_position();
}
inline void JointState::unsafe_arena_set_allocated_position(
    PROTOBUF_NAMESPACE_ID::DoubleValue* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.JointState.position)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::release_position() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.position)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = position_;
  position_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    position_ = p;
  }
  return position_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::mutable_position() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.position)
  return _internal_mutable_position();
}
inline void JointState::set_allocated_position(PROTOBUF_NAMESPACE_ID::DoubleValue* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position)->GetArena();
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.position)
}

// .google.protobuf.DoubleValue velocity = 3;
inline bool JointState::_internal_has_velocity() const {
  return this != internal_default_instance() && velocity_ != nullptr;
}
inline bool JointState::has_velocity() const {
  return _internal_has_velocity();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::_internal_velocity() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = velocity_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::velocity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.velocity)
  return _internal_velocity();
}
inline void JointState::unsafe_arena_set_allocated_velocity(
    PROTOBUF_NAMESPACE_ID::DoubleValue* velocity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.JointState.velocity)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::release_velocity() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = velocity_;
  velocity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.velocity)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = velocity_;
  velocity_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::_internal_mutable_velocity() {
  
  if (velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    velocity_ = p;
  }
  return velocity_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::mutable_velocity() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.velocity)
  return _internal_mutable_velocity();
}
inline void JointState::set_allocated_velocity(PROTOBUF_NAMESPACE_ID::DoubleValue* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity)->GetArena();
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.velocity)
}

// .google.protobuf.DoubleValue acceleration = 4;
inline bool JointState::_internal_has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != nullptr;
}
inline bool JointState::has_acceleration() const {
  return _internal_has_acceleration();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::_internal_acceleration() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = acceleration_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::acceleration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.acceleration)
  return _internal_acceleration();
}
inline void JointState::unsafe_arena_set_allocated_acceleration(
    PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.JointState.acceleration)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::release_acceleration() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = acceleration_;
  acceleration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.acceleration)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = acceleration_;
  acceleration_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::_internal_mutable_acceleration() {
  
  if (acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    acceleration_ = p;
  }
  return acceleration_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::mutable_acceleration() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.acceleration)
  return _internal_mutable_acceleration();
}
inline void JointState::set_allocated_acceleration(PROTOBUF_NAMESPACE_ID::DoubleValue* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration)->GetArena();
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.acceleration)
}

// .google.protobuf.DoubleValue load = 5;
inline bool JointState::_internal_has_load() const {
  return this != internal_default_instance() && load_ != nullptr;
}
inline bool JointState::has_load() const {
  return _internal_has_load();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::_internal_load() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = load_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue*>(
      &PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& JointState::load() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointState.load)
  return _internal_load();
}
inline void JointState::unsafe_arena_set_allocated_load(
    PROTOBUF_NAMESPACE_ID::DoubleValue* load) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(load_);
  }
  load_ = load;
  if (load) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.JointState.load)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::release_load() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = load_;
  load_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::unsafe_arena_release_load() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointState.load)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = load_;
  load_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::_internal_mutable_load() {
  
  if (load_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArena());
    load_ = p;
  }
  return load_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* JointState::mutable_load() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointState.load)
  return _internal_mutable_load();
}
inline void JointState::set_allocated_load(PROTOBUF_NAMESPACE_ID::DoubleValue* load) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(load_);
  }
  if (load) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(load)->GetArena();
    if (message_arena != submessage_arena) {
      load = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, load, submessage_arena);
    }
    
  } else {
    
  }
  load_ = load;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointState.load)
}

// -------------------------------------------------------------------

// BehaviorFaultState

// repeated .bosdyn.api.BehaviorFault faults = 1;
inline int BehaviorFaultState::_internal_faults_size() const {
  return faults_.size();
}
inline int BehaviorFaultState::faults_size() const {
  return _internal_faults_size();
}
inline void BehaviorFaultState::clear_faults() {
  faults_.Clear();
}
inline ::bosdyn::api::BehaviorFault* BehaviorFaultState::mutable_faults(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BehaviorFaultState.faults)
  return faults_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >*
BehaviorFaultState::mutable_faults() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.BehaviorFaultState.faults)
  return &faults_;
}
inline const ::bosdyn::api::BehaviorFault& BehaviorFaultState::_internal_faults(int index) const {
  return faults_.Get(index);
}
inline const ::bosdyn::api::BehaviorFault& BehaviorFaultState::faults(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFaultState.faults)
  return _internal_faults(index);
}
inline ::bosdyn::api::BehaviorFault* BehaviorFaultState::_internal_add_faults() {
  return faults_.Add();
}
inline ::bosdyn::api::BehaviorFault* BehaviorFaultState::add_faults() {
  // @@protoc_insertion_point(field_add:bosdyn.api.BehaviorFaultState.faults)
  return _internal_add_faults();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::BehaviorFault >&
BehaviorFaultState::faults() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.BehaviorFaultState.faults)
  return faults_;
}

// -------------------------------------------------------------------

// BehaviorFault

// uint32 behavior_fault_id = 1;
inline void BehaviorFault::clear_behavior_fault_id() {
  behavior_fault_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BehaviorFault::_internal_behavior_fault_id() const {
  return behavior_fault_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BehaviorFault::behavior_fault_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFault.behavior_fault_id)
  return _internal_behavior_fault_id();
}
inline void BehaviorFault::_internal_set_behavior_fault_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  behavior_fault_id_ = value;
}
inline void BehaviorFault::set_behavior_fault_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_behavior_fault_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BehaviorFault.behavior_fault_id)
}

// .google.protobuf.Timestamp onset_timestamp = 2;
inline bool BehaviorFault::_internal_has_onset_timestamp() const {
  return this != internal_default_instance() && onset_timestamp_ != nullptr;
}
inline bool BehaviorFault::has_onset_timestamp() const {
  return _internal_has_onset_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& BehaviorFault::_internal_onset_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = onset_timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& BehaviorFault::onset_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFault.onset_timestamp)
  return _internal_onset_timestamp();
}
inline void BehaviorFault::unsafe_arena_set_allocated_onset_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp_);
  }
  onset_timestamp_ = onset_timestamp;
  if (onset_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.BehaviorFault.onset_timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BehaviorFault::release_onset_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = onset_timestamp_;
  onset_timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BehaviorFault::unsafe_arena_release_onset_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.BehaviorFault.onset_timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = onset_timestamp_;
  onset_timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BehaviorFault::_internal_mutable_onset_timestamp() {
  
  if (onset_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    onset_timestamp_ = p;
  }
  return onset_timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* BehaviorFault::mutable_onset_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.BehaviorFault.onset_timestamp)
  return _internal_mutable_onset_timestamp();
}
inline void BehaviorFault::set_allocated_onset_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* onset_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp_);
  }
  if (onset_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(onset_timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      onset_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, onset_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  onset_timestamp_ = onset_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.BehaviorFault.onset_timestamp)
}

// .bosdyn.api.BehaviorFault.Cause cause = 3;
inline void BehaviorFault::clear_cause() {
  cause_ = 0;
}
inline ::bosdyn::api::BehaviorFault_Cause BehaviorFault::_internal_cause() const {
  return static_cast< ::bosdyn::api::BehaviorFault_Cause >(cause_);
}
inline ::bosdyn::api::BehaviorFault_Cause BehaviorFault::cause() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFault.cause)
  return _internal_cause();
}
inline void BehaviorFault::_internal_set_cause(::bosdyn::api::BehaviorFault_Cause value) {
  
  cause_ = value;
}
inline void BehaviorFault::set_cause(::bosdyn::api::BehaviorFault_Cause value) {
  _internal_set_cause(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BehaviorFault.cause)
}

// .bosdyn.api.BehaviorFault.Status status = 4;
inline void BehaviorFault::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::BehaviorFault_Status BehaviorFault::_internal_status() const {
  return static_cast< ::bosdyn::api::BehaviorFault_Status >(status_);
}
inline ::bosdyn::api::BehaviorFault_Status BehaviorFault::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.BehaviorFault.status)
  return _internal_status();
}
inline void BehaviorFault::_internal_set_status(::bosdyn::api::BehaviorFault_Status value) {
  
  status_ = value;
}
inline void BehaviorFault::set_status(::bosdyn::api::BehaviorFault_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.BehaviorFault.status)
}

// -------------------------------------------------------------------

// RobotMetrics

// .google.protobuf.Timestamp timestamp = 1;
inline bool RobotMetrics::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool RobotMetrics::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& RobotMetrics::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& RobotMetrics::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetrics.timestamp)
  return _internal_timestamp();
}
inline void RobotMetrics::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotMetrics.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RobotMetrics::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RobotMetrics::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotMetrics.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RobotMetrics::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RobotMetrics::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetrics.timestamp)
  return _internal_mutable_timestamp();
}
inline void RobotMetrics::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotMetrics.timestamp)
}

// repeated .bosdyn.api.Parameter metrics = 2;
inline int RobotMetrics::_internal_metrics_size() const {
  return metrics_.size();
}
inline int RobotMetrics::metrics_size() const {
  return _internal_metrics_size();
}
inline ::bosdyn::api::Parameter* RobotMetrics::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetrics.metrics)
  return metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >*
RobotMetrics::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.RobotMetrics.metrics)
  return &metrics_;
}
inline const ::bosdyn::api::Parameter& RobotMetrics::_internal_metrics(int index) const {
  return metrics_.Get(index);
}
inline const ::bosdyn::api::Parameter& RobotMetrics::metrics(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetrics.metrics)
  return _internal_metrics(index);
}
inline ::bosdyn::api::Parameter* RobotMetrics::_internal_add_metrics() {
  return metrics_.Add();
}
inline ::bosdyn::api::Parameter* RobotMetrics::add_metrics() {
  // @@protoc_insertion_point(field_add:bosdyn.api.RobotMetrics.metrics)
  return _internal_add_metrics();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Parameter >&
RobotMetrics::metrics() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.RobotMetrics.metrics)
  return metrics_;
}

// -------------------------------------------------------------------

// CommsState

// .google.protobuf.Timestamp timestamp = 1;
inline bool CommsState::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool CommsState::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& CommsState::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& CommsState::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CommsState.timestamp)
  return _internal_timestamp();
}
inline void CommsState::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.CommsState.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* CommsState::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* CommsState::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CommsState.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* CommsState::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* CommsState::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CommsState.timestamp)
  return _internal_mutable_timestamp();
}
inline void CommsState::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.CommsState.timestamp)
}

// .bosdyn.api.WiFiState wifi_state = 2;
inline bool CommsState::_internal_has_wifi_state() const {
  return state_case() == kWifiState;
}
inline bool CommsState::has_wifi_state() const {
  return _internal_has_wifi_state();
}
inline void CommsState::set_has_wifi_state() {
  _oneof_case_[0] = kWifiState;
}
inline void CommsState::clear_wifi_state() {
  if (_internal_has_wifi_state()) {
    if (GetArena() == nullptr) {
      delete state_.wifi_state_;
    }
    clear_has_state();
  }
}
inline ::bosdyn::api::WiFiState* CommsState::release_wifi_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.CommsState.wifi_state)
  if (_internal_has_wifi_state()) {
    clear_has_state();
      ::bosdyn::api::WiFiState* temp = state_.wifi_state_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    state_.wifi_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::WiFiState& CommsState::_internal_wifi_state() const {
  return _internal_has_wifi_state()
      ? *state_.wifi_state_
      : *reinterpret_cast< ::bosdyn::api::WiFiState*>(&::bosdyn::api::_WiFiState_default_instance_);
}
inline const ::bosdyn::api::WiFiState& CommsState::wifi_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.CommsState.wifi_state)
  return _internal_wifi_state();
}
inline ::bosdyn::api::WiFiState* CommsState::unsafe_arena_release_wifi_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.CommsState.wifi_state)
  if (_internal_has_wifi_state()) {
    clear_has_state();
    ::bosdyn::api::WiFiState* temp = state_.wifi_state_;
    state_.wifi_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommsState::unsafe_arena_set_allocated_wifi_state(::bosdyn::api::WiFiState* wifi_state) {
  clear_state();
  if (wifi_state) {
    set_has_wifi_state();
    state_.wifi_state_ = wifi_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.CommsState.wifi_state)
}
inline ::bosdyn::api::WiFiState* CommsState::_internal_mutable_wifi_state() {
  if (!_internal_has_wifi_state()) {
    clear_state();
    set_has_wifi_state();
    state_.wifi_state_ = CreateMaybeMessage< ::bosdyn::api::WiFiState >(GetArena());
  }
  return state_.wifi_state_;
}
inline ::bosdyn::api::WiFiState* CommsState::mutable_wifi_state() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.CommsState.wifi_state)
  return _internal_mutable_wifi_state();
}

inline bool CommsState::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void CommsState::clear_has_state() {
  _oneof_case_[0] = STATE_NOT_SET;
}
inline CommsState::StateCase CommsState::state_case() const {
  return CommsState::StateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WiFiState

// .bosdyn.api.WiFiState.Mode current_mode = 1;
inline void WiFiState::clear_current_mode() {
  current_mode_ = 0;
}
inline ::bosdyn::api::WiFiState_Mode WiFiState::_internal_current_mode() const {
  return static_cast< ::bosdyn::api::WiFiState_Mode >(current_mode_);
}
inline ::bosdyn::api::WiFiState_Mode WiFiState::current_mode() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WiFiState.current_mode)
  return _internal_current_mode();
}
inline void WiFiState::_internal_set_current_mode(::bosdyn::api::WiFiState_Mode value) {
  
  current_mode_ = value;
}
inline void WiFiState::set_current_mode(::bosdyn::api::WiFiState_Mode value) {
  _internal_set_current_mode(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.WiFiState.current_mode)
}

// string essid = 2;
inline void WiFiState::clear_essid() {
  essid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& WiFiState::essid() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.WiFiState.essid)
  return _internal_essid();
}
inline void WiFiState::set_essid(const std::string& value) {
  _internal_set_essid(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.WiFiState.essid)
}
inline std::string* WiFiState::mutable_essid() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.WiFiState.essid)
  return _internal_mutable_essid();
}
inline const std::string& WiFiState::_internal_essid() const {
  return essid_.Get();
}
inline void WiFiState::_internal_set_essid(const std::string& value) {
  
  essid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void WiFiState::set_essid(std::string&& value) {
  
  essid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.WiFiState.essid)
}
inline void WiFiState::set_essid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  essid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.WiFiState.essid)
}
inline void WiFiState::set_essid(const char* value,
    size_t size) {
  
  essid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.WiFiState.essid)
}
inline std::string* WiFiState::_internal_mutable_essid() {
  
  return essid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* WiFiState::release_essid() {
  // @@protoc_insertion_point(field_release:bosdyn.api.WiFiState.essid)
  return essid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void WiFiState::set_allocated_essid(std::string* essid) {
  if (essid != nullptr) {
    
  } else {
    
  }
  essid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), essid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.WiFiState.essid)
}

// -------------------------------------------------------------------

// FootState

// .bosdyn.api.Vec3 foot_position_rt_body = 1;
inline bool FootState::_internal_has_foot_position_rt_body() const {
  return this != internal_default_instance() && foot_position_rt_body_ != nullptr;
}
inline bool FootState::has_foot_position_rt_body() const {
  return _internal_has_foot_position_rt_body();
}
inline const ::bosdyn::api::Vec3& FootState::_internal_foot_position_rt_body() const {
  const ::bosdyn::api::Vec3* p = foot_position_rt_body_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& FootState::foot_position_rt_body() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.foot_position_rt_body)
  return _internal_foot_position_rt_body();
}
inline void FootState::unsafe_arena_set_allocated_foot_position_rt_body(
    ::bosdyn::api::Vec3* foot_position_rt_body) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(foot_position_rt_body_);
  }
  foot_position_rt_body_ = foot_position_rt_body;
  if (foot_position_rt_body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.FootState.foot_position_rt_body)
}
inline ::bosdyn::api::Vec3* FootState::release_foot_position_rt_body() {
  
  ::bosdyn::api::Vec3* temp = foot_position_rt_body_;
  foot_position_rt_body_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* FootState::unsafe_arena_release_foot_position_rt_body() {
  // @@protoc_insertion_point(field_release:bosdyn.api.FootState.foot_position_rt_body)
  
  ::bosdyn::api::Vec3* temp = foot_position_rt_body_;
  foot_position_rt_body_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* FootState::_internal_mutable_foot_position_rt_body() {
  
  if (foot_position_rt_body_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    foot_position_rt_body_ = p;
  }
  return foot_position_rt_body_;
}
inline ::bosdyn::api::Vec3* FootState::mutable_foot_position_rt_body() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.FootState.foot_position_rt_body)
  return _internal_mutable_foot_position_rt_body();
}
inline void FootState::set_allocated_foot_position_rt_body(::bosdyn::api::Vec3* foot_position_rt_body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(foot_position_rt_body_);
  }
  if (foot_position_rt_body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(foot_position_rt_body)->GetArena();
    if (message_arena != submessage_arena) {
      foot_position_rt_body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foot_position_rt_body, submessage_arena);
    }
    
  } else {
    
  }
  foot_position_rt_body_ = foot_position_rt_body;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.FootState.foot_position_rt_body)
}

// .bosdyn.api.FootState.Contact contact = 2;
inline void FootState::clear_contact() {
  contact_ = 0;
}
inline ::bosdyn::api::FootState_Contact FootState::_internal_contact() const {
  return static_cast< ::bosdyn::api::FootState_Contact >(contact_);
}
inline ::bosdyn::api::FootState_Contact FootState::contact() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.FootState.contact)
  return _internal_contact();
}
inline void FootState::_internal_set_contact(::bosdyn::api::FootState_Contact value) {
  
  contact_ = value;
}
inline void FootState::set_contact(::bosdyn::api::FootState_Contact value) {
  _internal_set_contact(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.FootState.contact)
}

// -------------------------------------------------------------------

// RobotStateRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotStateRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotStateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotStateRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotStateRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotStateRequest.header)
  return _internal_header();
}
inline void RobotStateRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotStateRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotStateRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotStateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotStateRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotStateRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RobotStateRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotStateRequest.header)
  return _internal_mutable_header();
}
inline void RobotStateRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotStateRequest.header)
}

// -------------------------------------------------------------------

// RobotStateResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotStateResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotStateResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotStateResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotStateResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotStateResponse.header)
  return _internal_header();
}
inline void RobotStateResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotStateResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotStateResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotStateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotStateResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotStateResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RobotStateResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotStateResponse.header)
  return _internal_mutable_header();
}
inline void RobotStateResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotStateResponse.header)
}

// .bosdyn.api.RobotState robot_state = 2;
inline bool RobotStateResponse::_internal_has_robot_state() const {
  return this != internal_default_instance() && robot_state_ != nullptr;
}
inline bool RobotStateResponse::has_robot_state() const {
  return _internal_has_robot_state();
}
inline void RobotStateResponse::clear_robot_state() {
  if (GetArena() == nullptr && robot_state_ != nullptr) {
    delete robot_state_;
  }
  robot_state_ = nullptr;
}
inline const ::bosdyn::api::RobotState& RobotStateResponse::_internal_robot_state() const {
  const ::bosdyn::api::RobotState* p = robot_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RobotState*>(
      &::bosdyn::api::_RobotState_default_instance_);
}
inline const ::bosdyn::api::RobotState& RobotStateResponse::robot_state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotStateResponse.robot_state)
  return _internal_robot_state();
}
inline void RobotStateResponse::unsafe_arena_set_allocated_robot_state(
    ::bosdyn::api::RobotState* robot_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_state_);
  }
  robot_state_ = robot_state;
  if (robot_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotStateResponse.robot_state)
}
inline ::bosdyn::api::RobotState* RobotStateResponse::release_robot_state() {
  
  ::bosdyn::api::RobotState* temp = robot_state_;
  robot_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RobotState* RobotStateResponse::unsafe_arena_release_robot_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotStateResponse.robot_state)
  
  ::bosdyn::api::RobotState* temp = robot_state_;
  robot_state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotState* RobotStateResponse::_internal_mutable_robot_state() {
  
  if (robot_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotState>(GetArena());
    robot_state_ = p;
  }
  return robot_state_;
}
inline ::bosdyn::api::RobotState* RobotStateResponse::mutable_robot_state() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotStateResponse.robot_state)
  return _internal_mutable_robot_state();
}
inline void RobotStateResponse::set_allocated_robot_state(::bosdyn::api::RobotState* robot_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete robot_state_;
  }
  if (robot_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(robot_state);
    if (message_arena != submessage_arena) {
      robot_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_state, submessage_arena);
    }
    
  } else {
    
  }
  robot_state_ = robot_state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotStateResponse.robot_state)
}

// -------------------------------------------------------------------

// RobotMetricsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotMetricsRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotMetricsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotMetricsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotMetricsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetricsRequest.header)
  return _internal_header();
}
inline void RobotMetricsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotMetricsRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotMetricsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotMetricsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotMetricsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotMetricsRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RobotMetricsRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetricsRequest.header)
  return _internal_mutable_header();
}
inline void RobotMetricsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotMetricsRequest.header)
}

// -------------------------------------------------------------------

// RobotMetricsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotMetricsResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotMetricsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotMetricsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotMetricsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetricsResponse.header)
  return _internal_header();
}
inline void RobotMetricsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotMetricsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotMetricsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotMetricsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotMetricsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotMetricsResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RobotMetricsResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetricsResponse.header)
  return _internal_mutable_header();
}
inline void RobotMetricsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotMetricsResponse.header)
}

// .bosdyn.api.RobotMetrics robot_metrics = 2;
inline bool RobotMetricsResponse::_internal_has_robot_metrics() const {
  return this != internal_default_instance() && robot_metrics_ != nullptr;
}
inline bool RobotMetricsResponse::has_robot_metrics() const {
  return _internal_has_robot_metrics();
}
inline void RobotMetricsResponse::clear_robot_metrics() {
  if (GetArena() == nullptr && robot_metrics_ != nullptr) {
    delete robot_metrics_;
  }
  robot_metrics_ = nullptr;
}
inline const ::bosdyn::api::RobotMetrics& RobotMetricsResponse::_internal_robot_metrics() const {
  const ::bosdyn::api::RobotMetrics* p = robot_metrics_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RobotMetrics*>(
      &::bosdyn::api::_RobotMetrics_default_instance_);
}
inline const ::bosdyn::api::RobotMetrics& RobotMetricsResponse::robot_metrics() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotMetricsResponse.robot_metrics)
  return _internal_robot_metrics();
}
inline void RobotMetricsResponse::unsafe_arena_set_allocated_robot_metrics(
    ::bosdyn::api::RobotMetrics* robot_metrics) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(robot_metrics_);
  }
  robot_metrics_ = robot_metrics;
  if (robot_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotMetricsResponse.robot_metrics)
}
inline ::bosdyn::api::RobotMetrics* RobotMetricsResponse::release_robot_metrics() {
  
  ::bosdyn::api::RobotMetrics* temp = robot_metrics_;
  robot_metrics_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RobotMetrics* RobotMetricsResponse::unsafe_arena_release_robot_metrics() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotMetricsResponse.robot_metrics)
  
  ::bosdyn::api::RobotMetrics* temp = robot_metrics_;
  robot_metrics_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotMetrics* RobotMetricsResponse::_internal_mutable_robot_metrics() {
  
  if (robot_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotMetrics>(GetArena());
    robot_metrics_ = p;
  }
  return robot_metrics_;
}
inline ::bosdyn::api::RobotMetrics* RobotMetricsResponse::mutable_robot_metrics() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotMetricsResponse.robot_metrics)
  return _internal_mutable_robot_metrics();
}
inline void RobotMetricsResponse::set_allocated_robot_metrics(::bosdyn::api::RobotMetrics* robot_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete robot_metrics_;
  }
  if (robot_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(robot_metrics);
    if (message_arena != submessage_arena) {
      robot_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_metrics, submessage_arena);
    }
    
  } else {
    
  }
  robot_metrics_ = robot_metrics;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotMetricsResponse.robot_metrics)
}

// -------------------------------------------------------------------

// RobotHardwareConfigurationRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotHardwareConfigurationRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotHardwareConfigurationRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotHardwareConfigurationRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotHardwareConfigurationRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotHardwareConfigurationRequest.header)
  return _internal_header();
}
inline void RobotHardwareConfigurationRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotHardwareConfigurationRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotHardwareConfigurationRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotHardwareConfigurationRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotHardwareConfigurationRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotHardwareConfigurationRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RobotHardwareConfigurationRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotHardwareConfigurationRequest.header)
  return _internal_mutable_header();
}
inline void RobotHardwareConfigurationRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotHardwareConfigurationRequest.header)
}

// -------------------------------------------------------------------

// RobotHardwareConfigurationResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotHardwareConfigurationResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotHardwareConfigurationResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotHardwareConfigurationResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotHardwareConfigurationResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotHardwareConfigurationResponse.header)
  return _internal_header();
}
inline void RobotHardwareConfigurationResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotHardwareConfigurationResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotHardwareConfigurationResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotHardwareConfigurationResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotHardwareConfigurationResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotHardwareConfigurationResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RobotHardwareConfigurationResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotHardwareConfigurationResponse.header)
  return _internal_mutable_header();
}
inline void RobotHardwareConfigurationResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotHardwareConfigurationResponse.header)
}

// .bosdyn.api.HardwareConfiguration hardware_configuration = 2;
inline bool RobotHardwareConfigurationResponse::_internal_has_hardware_configuration() const {
  return this != internal_default_instance() && hardware_configuration_ != nullptr;
}
inline bool RobotHardwareConfigurationResponse::has_hardware_configuration() const {
  return _internal_has_hardware_configuration();
}
inline void RobotHardwareConfigurationResponse::clear_hardware_configuration() {
  if (GetArena() == nullptr && hardware_configuration_ != nullptr) {
    delete hardware_configuration_;
  }
  hardware_configuration_ = nullptr;
}
inline const ::bosdyn::api::HardwareConfiguration& RobotHardwareConfigurationResponse::_internal_hardware_configuration() const {
  const ::bosdyn::api::HardwareConfiguration* p = hardware_configuration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::HardwareConfiguration*>(
      &::bosdyn::api::_HardwareConfiguration_default_instance_);
}
inline const ::bosdyn::api::HardwareConfiguration& RobotHardwareConfigurationResponse::hardware_configuration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
  return _internal_hardware_configuration();
}
inline void RobotHardwareConfigurationResponse::unsafe_arena_set_allocated_hardware_configuration(
    ::bosdyn::api::HardwareConfiguration* hardware_configuration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hardware_configuration_);
  }
  hardware_configuration_ = hardware_configuration;
  if (hardware_configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
}
inline ::bosdyn::api::HardwareConfiguration* RobotHardwareConfigurationResponse::release_hardware_configuration() {
  
  ::bosdyn::api::HardwareConfiguration* temp = hardware_configuration_;
  hardware_configuration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::HardwareConfiguration* RobotHardwareConfigurationResponse::unsafe_arena_release_hardware_configuration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
  
  ::bosdyn::api::HardwareConfiguration* temp = hardware_configuration_;
  hardware_configuration_ = nullptr;
  return temp;
}
inline ::bosdyn::api::HardwareConfiguration* RobotHardwareConfigurationResponse::_internal_mutable_hardware_configuration() {
  
  if (hardware_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::HardwareConfiguration>(GetArena());
    hardware_configuration_ = p;
  }
  return hardware_configuration_;
}
inline ::bosdyn::api::HardwareConfiguration* RobotHardwareConfigurationResponse::mutable_hardware_configuration() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
  return _internal_mutable_hardware_configuration();
}
inline void RobotHardwareConfigurationResponse::set_allocated_hardware_configuration(::bosdyn::api::HardwareConfiguration* hardware_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hardware_configuration_;
  }
  if (hardware_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hardware_configuration);
    if (message_arena != submessage_arena) {
      hardware_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hardware_configuration, submessage_arena);
    }
    
  } else {
    
  }
  hardware_configuration_ = hardware_configuration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotHardwareConfigurationResponse.hardware_configuration)
}

// -------------------------------------------------------------------

// RobotLinkModelRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RobotLinkModelRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotLinkModelRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RobotLinkModelRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RobotLinkModelRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotLinkModelRequest.header)
  return _internal_header();
}
inline void RobotLinkModelRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotLinkModelRequest.header)
}
inline ::bosdyn::api::RequestHeader* RobotLinkModelRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotLinkModelRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotLinkModelRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RobotLinkModelRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RobotLinkModelRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotLinkModelRequest.header)
  return _internal_mutable_header();
}
inline void RobotLinkModelRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotLinkModelRequest.header)
}

// string link_name = 2;
inline void RobotLinkModelRequest::clear_link_name() {
  link_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RobotLinkModelRequest::link_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotLinkModelRequest.link_name)
  return _internal_link_name();
}
inline void RobotLinkModelRequest::set_link_name(const std::string& value) {
  _internal_set_link_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RobotLinkModelRequest.link_name)
}
inline std::string* RobotLinkModelRequest::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotLinkModelRequest.link_name)
  return _internal_mutable_link_name();
}
inline const std::string& RobotLinkModelRequest::_internal_link_name() const {
  return link_name_.Get();
}
inline void RobotLinkModelRequest::_internal_set_link_name(const std::string& value) {
  
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RobotLinkModelRequest::set_link_name(std::string&& value) {
  
  link_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.RobotLinkModelRequest.link_name)
}
inline void RobotLinkModelRequest::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.RobotLinkModelRequest.link_name)
}
inline void RobotLinkModelRequest::set_link_name(const char* value,
    size_t size) {
  
  link_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.RobotLinkModelRequest.link_name)
}
inline std::string* RobotLinkModelRequest::_internal_mutable_link_name() {
  
  return link_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RobotLinkModelRequest::release_link_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotLinkModelRequest.link_name)
  return link_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RobotLinkModelRequest::set_allocated_link_name(std::string* link_name) {
  if (link_name != nullptr) {
    
  } else {
    
  }
  link_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotLinkModelRequest.link_name)
}

// -------------------------------------------------------------------

// RobotLinkModelResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RobotLinkModelResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RobotLinkModelResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RobotLinkModelResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RobotLinkModelResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotLinkModelResponse.header)
  return _internal_header();
}
inline void RobotLinkModelResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotLinkModelResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RobotLinkModelResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotLinkModelResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotLinkModelResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RobotLinkModelResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RobotLinkModelResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotLinkModelResponse.header)
  return _internal_mutable_header();
}
inline void RobotLinkModelResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotLinkModelResponse.header)
}

// .bosdyn.api.Skeleton.Link.ObjModel link_model = 2;
inline bool RobotLinkModelResponse::_internal_has_link_model() const {
  return this != internal_default_instance() && link_model_ != nullptr;
}
inline bool RobotLinkModelResponse::has_link_model() const {
  return _internal_has_link_model();
}
inline void RobotLinkModelResponse::clear_link_model() {
  if (GetArena() == nullptr && link_model_ != nullptr) {
    delete link_model_;
  }
  link_model_ = nullptr;
}
inline const ::bosdyn::api::Skeleton_Link_ObjModel& RobotLinkModelResponse::_internal_link_model() const {
  const ::bosdyn::api::Skeleton_Link_ObjModel* p = link_model_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Skeleton_Link_ObjModel*>(
      &::bosdyn::api::_Skeleton_Link_ObjModel_default_instance_);
}
inline const ::bosdyn::api::Skeleton_Link_ObjModel& RobotLinkModelResponse::link_model() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RobotLinkModelResponse.link_model)
  return _internal_link_model();
}
inline void RobotLinkModelResponse::unsafe_arena_set_allocated_link_model(
    ::bosdyn::api::Skeleton_Link_ObjModel* link_model) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link_model_);
  }
  link_model_ = link_model;
  if (link_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RobotLinkModelResponse.link_model)
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* RobotLinkModelResponse::release_link_model() {
  
  ::bosdyn::api::Skeleton_Link_ObjModel* temp = link_model_;
  link_model_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* RobotLinkModelResponse::unsafe_arena_release_link_model() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RobotLinkModelResponse.link_model)
  
  ::bosdyn::api::Skeleton_Link_ObjModel* temp = link_model_;
  link_model_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* RobotLinkModelResponse::_internal_mutable_link_model() {
  
  if (link_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Skeleton_Link_ObjModel>(GetArena());
    link_model_ = p;
  }
  return link_model_;
}
inline ::bosdyn::api::Skeleton_Link_ObjModel* RobotLinkModelResponse::mutable_link_model() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RobotLinkModelResponse.link_model)
  return _internal_mutable_link_model();
}
inline void RobotLinkModelResponse::set_allocated_link_model(::bosdyn::api::Skeleton_Link_ObjModel* link_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete link_model_;
  }
  if (link_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(link_model);
    if (message_arena != submessage_arena) {
      link_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_model, submessage_arena);
    }
    
  } else {
    
  }
  link_model_ = link_model;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RobotLinkModelResponse.link_model)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::PowerState_MotorPowerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerState_MotorPowerState>() {
  return ::bosdyn::api::PowerState_MotorPowerState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::PowerState_ShorePowerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::PowerState_ShorePowerState>() {
  return ::bosdyn::api::PowerState_ShorePowerState_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SystemFault_Severity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SystemFault_Severity>() {
  return ::bosdyn::api::SystemFault_Severity_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::EStopState_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::EStopState_Type>() {
  return ::bosdyn::api::EStopState_Type_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::EStopState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::EStopState_State>() {
  return ::bosdyn::api::EStopState_State_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::BatteryState_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::BatteryState_Status>() {
  return ::bosdyn::api::BatteryState_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::BehaviorFault_Cause> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::BehaviorFault_Cause>() {
  return ::bosdyn::api::BehaviorFault_Cause_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::BehaviorFault_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::BehaviorFault_Status>() {
  return ::bosdyn::api::BehaviorFault_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::WiFiState_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::WiFiState_Mode>() {
  return ::bosdyn::api::WiFiState_Mode_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::FootState_Contact> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::FootState_Contact>() {
  return ::bosdyn::api::FootState_Contact_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2frobot_5fstate_2eproto
