// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bosdyn/api/spot_cam/service.proto
// Original file comments:
// Copyright (c) 2020 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).
//
#ifndef GRPC_bosdyn_2fapi_2fspot_5fcam_2fservice_2eproto__INCLUDED
#define GRPC_bosdyn_2fapi_2fspot_5fcam_2fservice_2eproto__INCLUDED

#include "bosdyn/api/spot_cam/service.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace bosdyn {
namespace api {
namespace spot_cam {

// Change the layout of of the video stream between available presets.
class CompositorService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.CompositorService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // SetScreen changes the current view that is streamed over the network
    virtual ::grpc::Status SetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::bosdyn::api::spot_cam::SetScreenResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetScreenResponse>> AsyncSetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetScreenResponse>>(AsyncSetScreenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetScreenResponse>> PrepareAsyncSetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetScreenResponse>>(PrepareAsyncSetScreenRaw(context, request, cq));
    }
    // GetScreen returns the currently-selected screen
    virtual ::grpc::Status GetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::bosdyn::api::spot_cam::GetScreenResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetScreenResponse>> AsyncGetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetScreenResponse>>(AsyncGetScreenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetScreenResponse>> PrepareAsyncGetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetScreenResponse>>(PrepareAsyncGetScreenRaw(context, request, cq));
    }
    // ListScreens returns a list of available screens
    virtual ::grpc::Status ListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::bosdyn::api::spot_cam::ListScreensResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListScreensResponse>> AsyncListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListScreensResponse>>(AsyncListScreensRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListScreensResponse>> PrepareAsyncListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListScreensResponse>>(PrepareAsyncListScreensRaw(context, request, cq));
    }
    // GetVisibleCameras returns a list of currently visible windows, with any available metadata
    virtual ::grpc::Status GetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>> AsyncGetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>>(AsyncGetVisibleCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>> PrepareAsyncGetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>>(PrepareAsyncGetVisibleCamerasRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // SetScreen changes the current view that is streamed over the network
      virtual void SetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetScreen returns the currently-selected screen
      virtual void GetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // ListScreens returns a list of available screens
      virtual void ListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListScreens(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListScreens(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListScreens(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetVisibleCameras returns a list of currently visible windows, with any available metadata
      virtual void GetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVisibleCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVisibleCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVisibleCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetScreenResponse>* AsyncSetScreenRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetScreenResponse>* PrepareAsyncSetScreenRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetScreenResponse>* AsyncGetScreenRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetScreenResponse>* PrepareAsyncGetScreenRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListScreensResponse>* AsyncListScreensRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListScreensResponse>* PrepareAsyncListScreensRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>* AsyncGetVisibleCamerasRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>* PrepareAsyncGetVisibleCamerasRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::bosdyn::api::spot_cam::SetScreenResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetScreenResponse>> AsyncSetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetScreenResponse>>(AsyncSetScreenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetScreenResponse>> PrepareAsyncSetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetScreenResponse>>(PrepareAsyncSetScreenRaw(context, request, cq));
    }
    ::grpc::Status GetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::bosdyn::api::spot_cam::GetScreenResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetScreenResponse>> AsyncGetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetScreenResponse>>(AsyncGetScreenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetScreenResponse>> PrepareAsyncGetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetScreenResponse>>(PrepareAsyncGetScreenRaw(context, request, cq));
    }
    ::grpc::Status ListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::bosdyn::api::spot_cam::ListScreensResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListScreensResponse>> AsyncListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListScreensResponse>>(AsyncListScreensRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListScreensResponse>> PrepareAsyncListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListScreensResponse>>(PrepareAsyncListScreensRaw(context, request, cq));
    }
    ::grpc::Status GetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>> AsyncGetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>>(AsyncGetVisibleCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>> PrepareAsyncGetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>>(PrepareAsyncGetVisibleCamerasRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, std::function<void(::grpc::Status)>) override;
      void SetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetScreenResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, std::function<void(::grpc::Status)>) override;
      void GetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetScreen(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetScreen(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetScreenResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, std::function<void(::grpc::Status)>) override;
      void ListScreens(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListScreens(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListScreens(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListScreens(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListScreensResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVisibleCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVisibleCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVisibleCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVisibleCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetScreenResponse>* AsyncSetScreenRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetScreenResponse>* PrepareAsyncSetScreenRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetScreenResponse>* AsyncGetScreenRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetScreenResponse>* PrepareAsyncGetScreenRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListScreensResponse>* AsyncListScreensRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListScreensResponse>* PrepareAsyncListScreensRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>* AsyncGetVisibleCamerasRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>* PrepareAsyncGetVisibleCamerasRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetScreen_;
    const ::grpc::internal::RpcMethod rpcmethod_GetScreen_;
    const ::grpc::internal::RpcMethod rpcmethod_ListScreens_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVisibleCameras_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // SetScreen changes the current view that is streamed over the network
    virtual ::grpc::Status SetScreen(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetScreenRequest* request, ::bosdyn::api::spot_cam::SetScreenResponse* response);
    // GetScreen returns the currently-selected screen
    virtual ::grpc::Status GetScreen(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetScreenRequest* request, ::bosdyn::api::spot_cam::GetScreenResponse* response);
    // ListScreens returns a list of available screens
    virtual ::grpc::Status ListScreens(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::ListScreensRequest* request, ::bosdyn::api::spot_cam::ListScreensResponse* response);
    // GetVisibleCameras returns a list of currently visible windows, with any available metadata
    virtual ::grpc::Status GetVisibleCameras(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetScreen() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::SetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetScreen(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetScreenRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetScreenResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetScreen() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::GetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetScreen(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetScreenRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetScreenResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListScreens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListScreens() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ListScreens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScreens(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListScreensRequest* /*request*/, ::bosdyn::api::spot_cam::ListScreensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListScreens(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::ListScreensRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::ListScreensResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVisibleCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVisibleCameras() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetVisibleCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisibleCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisibleCameras(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetScreen<WithAsyncMethod_GetScreen<WithAsyncMethod_ListScreens<WithAsyncMethod_GetVisibleCameras<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetScreen() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetScreenRequest, ::bosdyn::api::spot_cam::SetScreenResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetScreenRequest* request, ::bosdyn::api::spot_cam::SetScreenResponse* response) { return this->SetScreen(context, request, response); }));}
    void SetMessageAllocatorFor_SetScreen(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetScreenRequest, ::bosdyn::api::spot_cam::SetScreenResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetScreenRequest, ::bosdyn::api::spot_cam::SetScreenResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::SetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetScreen(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::SetScreenResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetScreen(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::SetScreenResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetScreen() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetScreenRequest, ::bosdyn::api::spot_cam::GetScreenResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetScreenRequest* request, ::bosdyn::api::spot_cam::GetScreenResponse* response) { return this->GetScreen(context, request, response); }));}
    void SetMessageAllocatorFor_GetScreen(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetScreenRequest, ::bosdyn::api::spot_cam::GetScreenResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetScreenRequest, ::bosdyn::api::spot_cam::GetScreenResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::GetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetScreen(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::GetScreenResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetScreen(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::GetScreenResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListScreens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListScreens() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ListScreensRequest, ::bosdyn::api::spot_cam::ListScreensResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::ListScreensRequest* request, ::bosdyn::api::spot_cam::ListScreensResponse* response) { return this->ListScreens(context, request, response); }));}
    void SetMessageAllocatorFor_ListScreens(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::ListScreensRequest, ::bosdyn::api::spot_cam::ListScreensResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ListScreensRequest, ::bosdyn::api::spot_cam::ListScreensResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListScreens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScreens(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListScreensRequest* /*request*/, ::bosdyn::api::spot_cam::ListScreensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListScreens(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListScreensRequest* /*request*/, ::bosdyn::api::spot_cam::ListScreensResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListScreens(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListScreensRequest* /*request*/, ::bosdyn::api::spot_cam::ListScreensResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVisibleCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVisibleCameras() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetVisibleCamerasRequest, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* request, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* response) { return this->GetVisibleCameras(context, request, response); }));}
    void SetMessageAllocatorFor_GetVisibleCameras(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetVisibleCamerasRequest, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetVisibleCamerasRequest, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVisibleCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisibleCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVisibleCameras(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVisibleCameras(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SetScreen<ExperimentalWithCallbackMethod_GetScreen<ExperimentalWithCallbackMethod_ListScreens<ExperimentalWithCallbackMethod_GetVisibleCameras<Service > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SetScreen<ExperimentalWithCallbackMethod_GetScreen<ExperimentalWithCallbackMethod_ListScreens<ExperimentalWithCallbackMethod_GetVisibleCameras<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetScreen() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::SetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetScreen() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::GetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListScreens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListScreens() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ListScreens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScreens(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListScreensRequest* /*request*/, ::bosdyn::api::spot_cam::ListScreensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVisibleCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVisibleCameras() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetVisibleCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisibleCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetScreen() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::SetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetScreen(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetScreen() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::GetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetScreen(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListScreens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListScreens() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ListScreens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScreens(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListScreensRequest* /*request*/, ::bosdyn::api::spot_cam::ListScreensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListScreens(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVisibleCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVisibleCameras() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetVisibleCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisibleCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVisibleCameras(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetScreen() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetScreen(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::SetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetScreen(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetScreen(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetScreen() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetScreen(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::GetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetScreen(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetScreen(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListScreens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListScreens() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListScreens(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListScreens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListScreens(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListScreensRequest* /*request*/, ::bosdyn::api::spot_cam::ListScreensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListScreens(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListScreens(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVisibleCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVisibleCameras() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVisibleCameras(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVisibleCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVisibleCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVisibleCameras(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVisibleCameras(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetScreen() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetScreenRequest, ::bosdyn::api::spot_cam::SetScreenResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetScreenRequest, ::bosdyn::api::spot_cam::SetScreenResponse>* streamer) {
                       return this->StreamedSetScreen(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::SetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetScreen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetScreenRequest,::bosdyn::api::spot_cam::SetScreenResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetScreen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetScreen() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetScreenRequest, ::bosdyn::api::spot_cam::GetScreenResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetScreenRequest, ::bosdyn::api::spot_cam::GetScreenResponse>* streamer) {
                       return this->StreamedGetScreen(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetScreen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetScreen(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetScreenRequest* /*request*/, ::bosdyn::api::spot_cam::GetScreenResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetScreen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetScreenRequest,::bosdyn::api::spot_cam::GetScreenResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListScreens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListScreens() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::ListScreensRequest, ::bosdyn::api::spot_cam::ListScreensResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::ListScreensRequest, ::bosdyn::api::spot_cam::ListScreensResponse>* streamer) {
                       return this->StreamedListScreens(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListScreens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListScreens(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListScreensRequest* /*request*/, ::bosdyn::api::spot_cam::ListScreensResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListScreens(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::ListScreensRequest,::bosdyn::api::spot_cam::ListScreensResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVisibleCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVisibleCameras() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetVisibleCamerasRequest, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetVisibleCamerasRequest, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse>* streamer) {
                       return this->StreamedGetVisibleCameras(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVisibleCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVisibleCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVisibleCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::GetVisibleCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVisibleCameras(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetVisibleCamerasRequest,::bosdyn::api::spot_cam::GetVisibleCamerasResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetScreen<WithStreamedUnaryMethod_GetScreen<WithStreamedUnaryMethod_ListScreens<WithStreamedUnaryMethod_GetVisibleCameras<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetScreen<WithStreamedUnaryMethod_GetScreen<WithStreamedUnaryMethod_ListScreens<WithStreamedUnaryMethod_GetVisibleCameras<Service > > > > StreamedService;
};

// Set quality parameters for the stream, such as compression and image postprocessing settings.
class StreamQualityService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.StreamQualityService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetStreamParamsResponse>> AsyncSetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetStreamParamsResponse>>(AsyncSetStreamParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetStreamParamsResponse>> PrepareAsyncSetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetStreamParamsResponse>>(PrepareAsyncSetStreamParamsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStreamParamsResponse>> AsyncGetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStreamParamsResponse>>(AsyncGetStreamParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStreamParamsResponse>> PrepareAsyncGetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStreamParamsResponse>>(PrepareAsyncGetStreamParamsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void SetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetStreamParamsResponse>* AsyncSetStreamParamsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetStreamParamsResponse>* PrepareAsyncSetStreamParamsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStreamParamsResponse>* AsyncGetStreamParamsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStreamParamsResponse>* PrepareAsyncGetStreamParamsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetStreamParamsResponse>> AsyncSetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetStreamParamsResponse>>(AsyncSetStreamParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetStreamParamsResponse>> PrepareAsyncSetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetStreamParamsResponse>>(PrepareAsyncSetStreamParamsRaw(context, request, cq));
    }
    ::grpc::Status GetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStreamParamsResponse>> AsyncGetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStreamParamsResponse>>(AsyncGetStreamParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStreamParamsResponse>> PrepareAsyncGetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStreamParamsResponse>>(PrepareAsyncGetStreamParamsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void SetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStreamParams(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStreamParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetStreamParamsResponse>* AsyncSetStreamParamsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetStreamParamsResponse>* PrepareAsyncSetStreamParamsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStreamParamsResponse>* AsyncGetStreamParamsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStreamParamsResponse>* PrepareAsyncGetStreamParamsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetStreamParams_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStreamParams_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SetStreamParams(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response);
    virtual ::grpc::Status GetStreamParams(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetStreamParams() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::SetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStreamParams(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetStreamParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStreamParams() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::GetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStreamParams(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetStreamParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetStreamParams<WithAsyncMethod_GetStreamParams<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetStreamParams() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetStreamParamsRequest, ::bosdyn::api::spot_cam::SetStreamParamsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* request, ::bosdyn::api::spot_cam::SetStreamParamsResponse* response) { return this->SetStreamParams(context, request, response); }));}
    void SetMessageAllocatorFor_SetStreamParams(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetStreamParamsRequest, ::bosdyn::api::spot_cam::SetStreamParamsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetStreamParamsRequest, ::bosdyn::api::spot_cam::SetStreamParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::SetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetStreamParams(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::SetStreamParamsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetStreamParams(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::SetStreamParamsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetStreamParams() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetStreamParamsRequest, ::bosdyn::api::spot_cam::GetStreamParamsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* request, ::bosdyn::api::spot_cam::GetStreamParamsResponse* response) { return this->GetStreamParams(context, request, response); }));}
    void SetMessageAllocatorFor_GetStreamParams(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetStreamParamsRequest, ::bosdyn::api::spot_cam::GetStreamParamsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetStreamParamsRequest, ::bosdyn::api::spot_cam::GetStreamParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::GetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStreamParams(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::GetStreamParamsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStreamParams(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::GetStreamParamsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SetStreamParams<ExperimentalWithCallbackMethod_GetStreamParams<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SetStreamParams<ExperimentalWithCallbackMethod_GetStreamParams<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetStreamParams() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::SetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStreamParams() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::GetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetStreamParams() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::SetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetStreamParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStreamParams() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::GetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStreamParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetStreamParams() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetStreamParams(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::SetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetStreamParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetStreamParams(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetStreamParams() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStreamParams(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::GetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStreamParams(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStreamParams(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetStreamParams() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetStreamParamsRequest, ::bosdyn::api::spot_cam::SetStreamParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetStreamParamsRequest, ::bosdyn::api::spot_cam::SetStreamParamsResponse>* streamer) {
                       return this->StreamedSetStreamParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::SetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetStreamParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetStreamParamsRequest,::bosdyn::api::spot_cam::SetStreamParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStreamParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStreamParams() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetStreamParamsRequest, ::bosdyn::api::spot_cam::GetStreamParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetStreamParamsRequest, ::bosdyn::api::spot_cam::GetStreamParamsResponse>* streamer) {
                       return this->StreamedGetStreamParams(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStreamParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStreamParams(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStreamParamsRequest* /*request*/, ::bosdyn::api::spot_cam::GetStreamParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStreamParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetStreamParamsRequest,::bosdyn::api::spot_cam::GetStreamParamsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetStreamParams<WithStreamedUnaryMethod_GetStreamParams<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetStreamParams<WithStreamedUnaryMethod_GetStreamParams<Service > > StreamedService;
};

// Turn hardware components' power on or off.
class PowerService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.PowerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPowerStatusResponse>> AsyncSetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPowerStatusResponse>>(AsyncSetPowerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPowerStatusResponse>> PrepareAsyncSetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPowerStatusResponse>>(PrepareAsyncSetPowerStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPowerStatusResponse>> AsyncGetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPowerStatusResponse>>(AsyncGetPowerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPowerStatusResponse>> PrepareAsyncGetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPowerStatusResponse>>(PrepareAsyncGetPowerStatusRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void SetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPowerStatusResponse>* AsyncSetPowerStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPowerStatusResponse>* PrepareAsyncSetPowerStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPowerStatusResponse>* AsyncGetPowerStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPowerStatusResponse>* PrepareAsyncGetPowerStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPowerStatusResponse>> AsyncSetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPowerStatusResponse>>(AsyncSetPowerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPowerStatusResponse>> PrepareAsyncSetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPowerStatusResponse>>(PrepareAsyncSetPowerStatusRaw(context, request, cq));
    }
    ::grpc::Status GetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPowerStatusResponse>> AsyncGetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPowerStatusResponse>>(AsyncGetPowerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPowerStatusResponse>> PrepareAsyncGetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPowerStatusResponse>>(PrepareAsyncGetPowerStatusRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void SetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPowerStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPowerStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPowerStatusResponse>* AsyncSetPowerStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPowerStatusResponse>* PrepareAsyncSetPowerStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPowerStatusResponse>* AsyncGetPowerStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPowerStatusResponse>* PrepareAsyncGetPowerStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetPowerStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPowerStatus_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SetPowerStatus(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response);
    virtual ::grpc::Status GetPowerStatus(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPowerStatus() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::SetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPowerStatus(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetPowerStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPowerStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPowerStatus(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetPowerStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetPowerStatus<WithAsyncMethod_GetPowerStatus<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetPowerStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetPowerStatusRequest, ::bosdyn::api::spot_cam::SetPowerStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* request, ::bosdyn::api::spot_cam::SetPowerStatusResponse* response) { return this->SetPowerStatus(context, request, response); }));}
    void SetMessageAllocatorFor_SetPowerStatus(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetPowerStatusRequest, ::bosdyn::api::spot_cam::SetPowerStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetPowerStatusRequest, ::bosdyn::api::spot_cam::SetPowerStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::SetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetPowerStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::SetPowerStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetPowerStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::SetPowerStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPowerStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetPowerStatusRequest, ::bosdyn::api::spot_cam::GetPowerStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* request, ::bosdyn::api::spot_cam::GetPowerStatusResponse* response) { return this->GetPowerStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetPowerStatus(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetPowerStatusRequest, ::bosdyn::api::spot_cam::GetPowerStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetPowerStatusRequest, ::bosdyn::api::spot_cam::GetPowerStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPowerStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetPowerStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPowerStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetPowerStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SetPowerStatus<ExperimentalWithCallbackMethod_GetPowerStatus<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SetPowerStatus<ExperimentalWithCallbackMethod_GetPowerStatus<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPowerStatus() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::SetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPowerStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPowerStatus() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::SetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPowerStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPowerStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPowerStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPowerStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPowerStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::SetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetPowerStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetPowerStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPowerStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPowerStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPowerStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPowerStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPowerStatus() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetPowerStatusRequest, ::bosdyn::api::spot_cam::SetPowerStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetPowerStatusRequest, ::bosdyn::api::spot_cam::SetPowerStatusResponse>* streamer) {
                       return this->StreamedSetPowerStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::SetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPowerStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetPowerStatusRequest,::bosdyn::api::spot_cam::SetPowerStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPowerStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetPowerStatusRequest, ::bosdyn::api::spot_cam::GetPowerStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetPowerStatusRequest, ::bosdyn::api::spot_cam::GetPowerStatusResponse>* streamer) {
                       return this->StreamedGetPowerStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPowerStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPowerStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetPowerStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPowerStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetPowerStatusRequest,::bosdyn::api::spot_cam::GetPowerStatusResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetPowerStatus<WithStreamedUnaryMethod_GetPowerStatus<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetPowerStatus<WithStreamedUnaryMethod_GetPowerStatus<Service > > StreamedService;
};

// Change the brightness level of individual LEDs.
class LightingService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.LightingService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>> AsyncSetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>>(AsyncSetLEDBrightnessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>> PrepareAsyncSetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>>(PrepareAsyncSetLEDBrightnessRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>> AsyncGetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>>(AsyncGetLEDBrightnessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>> PrepareAsyncGetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>>(PrepareAsyncGetLEDBrightnessRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void SetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>* AsyncSetLEDBrightnessRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>* PrepareAsyncSetLEDBrightnessRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>* AsyncGetLEDBrightnessRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>* PrepareAsyncGetLEDBrightnessRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>> AsyncSetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>>(AsyncSetLEDBrightnessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>> PrepareAsyncSetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>>(PrepareAsyncSetLEDBrightnessRaw(context, request, cq));
    }
    ::grpc::Status GetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>> AsyncGetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>>(AsyncGetLEDBrightnessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>> PrepareAsyncGetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>>(PrepareAsyncGetLEDBrightnessRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, std::function<void(::grpc::Status)>) override;
      void SetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, std::function<void(::grpc::Status)>) override;
      void GetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLEDBrightness(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLEDBrightness(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>* AsyncSetLEDBrightnessRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>* PrepareAsyncSetLEDBrightnessRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>* AsyncGetLEDBrightnessRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>* PrepareAsyncGetLEDBrightnessRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetLEDBrightness_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLEDBrightness_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SetLEDBrightness(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response);
    virtual ::grpc::Status GetLEDBrightness(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetLEDBrightness() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetLEDBrightness(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLEDBrightness() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLEDBrightness(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetLEDBrightness<WithAsyncMethod_GetLEDBrightness<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetLEDBrightness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetLEDBrightnessRequest, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* response) { return this->SetLEDBrightness(context, request, response); }));}
    void SetMessageAllocatorFor_SetLEDBrightness(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetLEDBrightnessRequest, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetLEDBrightnessRequest, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetLEDBrightness(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetLEDBrightness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetLEDBrightness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetLEDBrightnessRequest, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* request, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* response) { return this->GetLEDBrightness(context, request, response); }));}
    void SetMessageAllocatorFor_GetLEDBrightness(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetLEDBrightnessRequest, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetLEDBrightnessRequest, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLEDBrightness(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLEDBrightness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SetLEDBrightness<ExperimentalWithCallbackMethod_GetLEDBrightness<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SetLEDBrightness<ExperimentalWithCallbackMethod_GetLEDBrightness<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetLEDBrightness() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLEDBrightness() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetLEDBrightness() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetLEDBrightness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLEDBrightness() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLEDBrightness(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetLEDBrightness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetLEDBrightness(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetLEDBrightness(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetLEDBrightness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLEDBrightness() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLEDBrightness(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLEDBrightness(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLEDBrightness(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetLEDBrightness() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetLEDBrightnessRequest, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetLEDBrightnessRequest, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse>* streamer) {
                       return this->StreamedSetLEDBrightness(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::SetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetLEDBrightness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetLEDBrightnessRequest,::bosdyn::api::spot_cam::SetLEDBrightnessResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLEDBrightness : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLEDBrightness() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetLEDBrightnessRequest, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetLEDBrightnessRequest, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse>* streamer) {
                       return this->StreamedGetLEDBrightness(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLEDBrightness() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLEDBrightness(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetLEDBrightnessRequest* /*request*/, ::bosdyn::api::spot_cam::GetLEDBrightnessResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLEDBrightness(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetLEDBrightnessRequest,::bosdyn::api::spot_cam::GetLEDBrightnessResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetLEDBrightness<WithStreamedUnaryMethod_GetLEDBrightness<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetLEDBrightness<WithStreamedUnaryMethod_GetLEDBrightness<Service > > StreamedService;
};

// Trigger data acquisitions, and retrieve resulting data.
class MediaLogService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.MediaLogService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Store queues up a Logpoint, which is a bit of media that the user wishes to store to disk
    // (still images are supported for now, more media types will be supported in the future)
    virtual ::grpc::Status Store(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::bosdyn::api::spot_cam::StoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::StoreResponse>> AsyncStore(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::StoreResponse>>(AsyncStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::StoreResponse>> PrepareAsyncStore(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::StoreResponse>>(PrepareAsyncStoreRaw(context, request, cq));
    }
    // GetStatus reads the 'name' field of the Logpoint contained in GetStatusRequest, and fills in
    // the rest of the fields. Mainly useful for getting the 'state' of the logpoint.
    virtual ::grpc::Status GetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::bosdyn::api::spot_cam::GetStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStatusResponse>> AsyncGetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStatusResponse>>(AsyncGetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStatusResponse>> PrepareAsyncGetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStatusResponse>>(PrepareAsyncGetStatusRaw(context, request, cq));
    }
    // Tag updates the 'tag' field of the Logpoint that's passed, which must exist.
    virtual ::grpc::Status Tag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::bosdyn::api::spot_cam::TagResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::TagResponse>> AsyncTag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::TagResponse>>(AsyncTagRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::TagResponse>> PrepareAsyncTag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::TagResponse>>(PrepareAsyncTagRaw(context, request, cq));
    }
    // EnableDebug starts the periodic logging of health data to the database; this increases disk utilization, but will record data that is useful post-mortum
    virtual ::grpc::Status EnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::bosdyn::api::spot_cam::DebugResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DebugResponse>> AsyncEnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DebugResponse>>(AsyncEnableDebugRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DebugResponse>> PrepareAsyncEnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DebugResponse>>(PrepareAsyncEnableDebugRaw(context, request, cq));
    }
    // ListCameras returns a list of strings that identify valid cameras for logging
    virtual ::grpc::Status ListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::bosdyn::api::spot_cam::ListCamerasResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListCamerasResponse>> AsyncListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListCamerasResponse>>(AsyncListCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListCamerasResponse>> PrepareAsyncListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListCamerasResponse>>(PrepareAsyncListCamerasRaw(context, request, cq));
    }
    // Retrieve returns all raw data associated with a given logpoint
    std::unique_ptr< ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>> RetrieveRawData(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>>(RetrieveRawDataRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>> AsyncRetrieveRawData(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>>(AsyncRetrieveRawDataRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>> PrepareAsyncRetrieveRawData(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>>(PrepareAsyncRetrieveRawDataRaw(context, request, cq));
    }
    // Retrieve returns all data associated with a given logpoint
    std::unique_ptr< ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>> Retrieve(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>>(RetrieveRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>> AsyncRetrieve(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>>(AsyncRetrieveRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>> PrepareAsyncRetrieve(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>>(PrepareAsyncRetrieveRaw(context, request, cq));
    }
    // Delete removes a Logpoint from the system
    virtual ::grpc::Status Delete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::bosdyn::api::spot_cam::DeleteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteResponse>> AsyncDelete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteResponse>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteResponse>> PrepareAsyncDelete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteResponse>>(PrepareAsyncDeleteRaw(context, request, cq));
    }
    // ListLogpoints returns a list of all logpoints in the database.
    // Warning: this may be a lot of data.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>> ListLogpoints(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>>(ListLogpointsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>> AsyncListLogpoints(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>>(AsyncListLogpointsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>> PrepareAsyncListLogpoints(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>>(PrepareAsyncListLogpointsRaw(context, request, cq));
    }
    // SetPassphrase sets the eCryptFS passphrase used by the filesystem.
    // there is no symmetry here, because key material is write-only
    virtual ::grpc::Status SetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPassphraseResponse>> AsyncSetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPassphraseResponse>>(AsyncSetPassphraseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPassphraseResponse>> PrepareAsyncSetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPassphraseResponse>>(PrepareAsyncSetPassphraseRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Store queues up a Logpoint, which is a bit of media that the user wishes to store to disk
      // (still images are supported for now, more media types will be supported in the future)
      virtual void Store(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest* request, ::bosdyn::api::spot_cam::StoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Store(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::StoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Store(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest* request, ::bosdyn::api::spot_cam::StoreResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Store(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest* request, ::bosdyn::api::spot_cam::StoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Store(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::StoreResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Store(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::StoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetStatus reads the 'name' field of the Logpoint contained in GetStatusRequest, and fills in
      // the rest of the fields. Mainly useful for getting the 'state' of the logpoint.
      virtual void GetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Tag updates the 'tag' field of the Logpoint that's passed, which must exist.
      virtual void Tag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest* request, ::bosdyn::api::spot_cam::TagResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Tag(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::TagResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Tag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest* request, ::bosdyn::api::spot_cam::TagResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Tag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest* request, ::bosdyn::api::spot_cam::TagResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Tag(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::TagResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Tag(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::TagResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // EnableDebug starts the periodic logging of health data to the database; this increases disk utilization, but will record data that is useful post-mortum
      virtual void EnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest* request, ::bosdyn::api::spot_cam::DebugResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableDebug(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DebugResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest* request, ::bosdyn::api::spot_cam::DebugResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest* request, ::bosdyn::api::spot_cam::DebugResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EnableDebug(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DebugResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EnableDebug(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DebugResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // ListCameras returns a list of strings that identify valid cameras for logging
      virtual void ListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Retrieve returns all raw data associated with a given logpoint
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RetrieveRawData(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::RetrieveRawDataRequest* request, ::grpc::ClientReadReactor< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* reactor) = 0;
      #else
      virtual void RetrieveRawData(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::RetrieveRawDataRequest* request, ::grpc::experimental::ClientReadReactor< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* reactor) = 0;
      #endif
      // Retrieve returns all data associated with a given logpoint
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Retrieve(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::RetrieveRequest* request, ::grpc::ClientReadReactor< ::bosdyn::api::spot_cam::RetrieveResponse>* reactor) = 0;
      #else
      virtual void Retrieve(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::RetrieveRequest* request, ::grpc::experimental::ClientReadReactor< ::bosdyn::api::spot_cam::RetrieveResponse>* reactor) = 0;
      #endif
      // Delete removes a Logpoint from the system
      virtual void Delete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest* request, ::bosdyn::api::spot_cam::DeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Delete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest* request, ::bosdyn::api::spot_cam::DeleteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Delete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest* request, ::bosdyn::api::spot_cam::DeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // ListLogpoints returns a list of all logpoints in the database.
      // Warning: this may be a lot of data.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListLogpoints(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::ListLogpointsRequest* request, ::grpc::ClientReadReactor< ::bosdyn::api::spot_cam::ListLogpointsResponse>* reactor) = 0;
      #else
      virtual void ListLogpoints(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::ListLogpointsRequest* request, ::grpc::experimental::ClientReadReactor< ::bosdyn::api::spot_cam::ListLogpointsResponse>* reactor) = 0;
      #endif
      // SetPassphrase sets the eCryptFS passphrase used by the filesystem.
      // there is no symmetry here, because key material is write-only
      virtual void SetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPassphrase(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetPassphrase(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetPassphrase(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::StoreResponse>* AsyncStoreRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::StoreResponse>* PrepareAsyncStoreRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStatusResponse>* AsyncGetStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetStatusResponse>* PrepareAsyncGetStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::TagResponse>* AsyncTagRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::TagResponse>* PrepareAsyncTagRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DebugResponse>* AsyncEnableDebugRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DebugResponse>* PrepareAsyncEnableDebugRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListCamerasResponse>* AsyncListCamerasRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListCamerasResponse>* PrepareAsyncListCamerasRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* RetrieveRawDataRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* AsyncRetrieveRawDataRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* PrepareAsyncRetrieveRawDataRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>* RetrieveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>* AsyncRetrieveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::RetrieveResponse>* PrepareAsyncRetrieveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteResponse>* AsyncDeleteRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteResponse>* PrepareAsyncDeleteRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>* ListLogpointsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>* AsyncListLogpointsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::bosdyn::api::spot_cam::ListLogpointsResponse>* PrepareAsyncListLogpointsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPassphraseResponse>* AsyncSetPassphraseRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPassphraseResponse>* PrepareAsyncSetPassphraseRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Store(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::bosdyn::api::spot_cam::StoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::StoreResponse>> AsyncStore(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::StoreResponse>>(AsyncStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::StoreResponse>> PrepareAsyncStore(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::StoreResponse>>(PrepareAsyncStoreRaw(context, request, cq));
    }
    ::grpc::Status GetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::bosdyn::api::spot_cam::GetStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStatusResponse>> AsyncGetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStatusResponse>>(AsyncGetStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStatusResponse>> PrepareAsyncGetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStatusResponse>>(PrepareAsyncGetStatusRaw(context, request, cq));
    }
    ::grpc::Status Tag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::bosdyn::api::spot_cam::TagResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::TagResponse>> AsyncTag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::TagResponse>>(AsyncTagRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::TagResponse>> PrepareAsyncTag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::TagResponse>>(PrepareAsyncTagRaw(context, request, cq));
    }
    ::grpc::Status EnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::bosdyn::api::spot_cam::DebugResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DebugResponse>> AsyncEnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DebugResponse>>(AsyncEnableDebugRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DebugResponse>> PrepareAsyncEnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DebugResponse>>(PrepareAsyncEnableDebugRaw(context, request, cq));
    }
    ::grpc::Status ListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::bosdyn::api::spot_cam::ListCamerasResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListCamerasResponse>> AsyncListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListCamerasResponse>>(AsyncListCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListCamerasResponse>> PrepareAsyncListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListCamerasResponse>>(PrepareAsyncListCamerasRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>> RetrieveRawData(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>>(RetrieveRawDataRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>> AsyncRetrieveRawData(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>>(AsyncRetrieveRawDataRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>> PrepareAsyncRetrieveRawData(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>>(PrepareAsyncRetrieveRawDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::bosdyn::api::spot_cam::RetrieveResponse>> Retrieve(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::bosdyn::api::spot_cam::RetrieveResponse>>(RetrieveRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveResponse>> AsyncRetrieve(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveResponse>>(AsyncRetrieveRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveResponse>> PrepareAsyncRetrieve(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveResponse>>(PrepareAsyncRetrieveRaw(context, request, cq));
    }
    ::grpc::Status Delete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::bosdyn::api::spot_cam::DeleteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteResponse>> AsyncDelete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteResponse>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteResponse>> PrepareAsyncDelete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteResponse>>(PrepareAsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>> ListLogpoints(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>>(ListLogpointsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>> AsyncListLogpoints(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>>(AsyncListLogpointsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>> PrepareAsyncListLogpoints(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>>(PrepareAsyncListLogpointsRaw(context, request, cq));
    }
    ::grpc::Status SetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPassphraseResponse>> AsyncSetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPassphraseResponse>>(AsyncSetPassphraseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPassphraseResponse>> PrepareAsyncSetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPassphraseResponse>>(PrepareAsyncSetPassphraseRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Store(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest* request, ::bosdyn::api::spot_cam::StoreResponse* response, std::function<void(::grpc::Status)>) override;
      void Store(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::StoreResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Store(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest* request, ::bosdyn::api::spot_cam::StoreResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Store(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest* request, ::bosdyn::api::spot_cam::StoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Store(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::StoreResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Store(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::StoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Tag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest* request, ::bosdyn::api::spot_cam::TagResponse* response, std::function<void(::grpc::Status)>) override;
      void Tag(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::TagResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Tag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest* request, ::bosdyn::api::spot_cam::TagResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Tag(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest* request, ::bosdyn::api::spot_cam::TagResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Tag(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::TagResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Tag(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::TagResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest* request, ::bosdyn::api::spot_cam::DebugResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableDebug(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DebugResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest* request, ::bosdyn::api::spot_cam::DebugResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EnableDebug(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest* request, ::bosdyn::api::spot_cam::DebugResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EnableDebug(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DebugResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EnableDebug(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DebugResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, std::function<void(::grpc::Status)>) override;
      void ListCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListCameras(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListCameras(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RetrieveRawData(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::RetrieveRawDataRequest* request, ::grpc::ClientReadReactor< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* reactor) override;
      #else
      void RetrieveRawData(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::RetrieveRawDataRequest* request, ::grpc::experimental::ClientReadReactor< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Retrieve(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::RetrieveRequest* request, ::grpc::ClientReadReactor< ::bosdyn::api::spot_cam::RetrieveResponse>* reactor) override;
      #else
      void Retrieve(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::RetrieveRequest* request, ::grpc::experimental::ClientReadReactor< ::bosdyn::api::spot_cam::RetrieveResponse>* reactor) override;
      #endif
      void Delete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest* request, ::bosdyn::api::spot_cam::DeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Delete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest* request, ::bosdyn::api::spot_cam::DeleteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Delete(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest* request, ::bosdyn::api::spot_cam::DeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListLogpoints(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::ListLogpointsRequest* request, ::grpc::ClientReadReactor< ::bosdyn::api::spot_cam::ListLogpointsResponse>* reactor) override;
      #else
      void ListLogpoints(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::ListLogpointsRequest* request, ::grpc::experimental::ClientReadReactor< ::bosdyn::api::spot_cam::ListLogpointsResponse>* reactor) override;
      #endif
      void SetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, std::function<void(::grpc::Status)>) override;
      void SetPassphrase(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetPassphrase(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetPassphrase(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetPassphrase(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::StoreResponse>* AsyncStoreRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::StoreResponse>* PrepareAsyncStoreRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::StoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStatusResponse>* AsyncGetStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetStatusResponse>* PrepareAsyncGetStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::TagResponse>* AsyncTagRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::TagResponse>* PrepareAsyncTagRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::TagRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DebugResponse>* AsyncEnableDebugRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DebugResponse>* PrepareAsyncEnableDebugRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DebugRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListCamerasResponse>* AsyncListCamerasRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListCamerasResponse>* PrepareAsyncListCamerasRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* RetrieveRawDataRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request) override;
    ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* AsyncRetrieveRawDataRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* PrepareAsyncRetrieveRawDataRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::bosdyn::api::spot_cam::RetrieveResponse>* RetrieveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request) override;
    ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveResponse>* AsyncRetrieveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::RetrieveResponse>* PrepareAsyncRetrieveRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteResponse>* AsyncDeleteRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteResponse>* PrepareAsyncDeleteRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>* ListLogpointsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request) override;
    ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>* AsyncListLogpointsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::bosdyn::api::spot_cam::ListLogpointsResponse>* PrepareAsyncListLogpointsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPassphraseResponse>* AsyncSetPassphraseRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPassphraseResponse>* PrepareAsyncSetPassphraseRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Store_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_Tag_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableDebug_;
    const ::grpc::internal::RpcMethod rpcmethod_ListCameras_;
    const ::grpc::internal::RpcMethod rpcmethod_RetrieveRawData_;
    const ::grpc::internal::RpcMethod rpcmethod_Retrieve_;
    const ::grpc::internal::RpcMethod rpcmethod_Delete_;
    const ::grpc::internal::RpcMethod rpcmethod_ListLogpoints_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPassphrase_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Store queues up a Logpoint, which is a bit of media that the user wishes to store to disk
    // (still images are supported for now, more media types will be supported in the future)
    virtual ::grpc::Status Store(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::StoreRequest* request, ::bosdyn::api::spot_cam::StoreResponse* response);
    // GetStatus reads the 'name' field of the Logpoint contained in GetStatusRequest, and fills in
    // the rest of the fields. Mainly useful for getting the 'state' of the logpoint.
    virtual ::grpc::Status GetStatus(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetStatusRequest* request, ::bosdyn::api::spot_cam::GetStatusResponse* response);
    // Tag updates the 'tag' field of the Logpoint that's passed, which must exist.
    virtual ::grpc::Status Tag(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::TagRequest* request, ::bosdyn::api::spot_cam::TagResponse* response);
    // EnableDebug starts the periodic logging of health data to the database; this increases disk utilization, but will record data that is useful post-mortum
    virtual ::grpc::Status EnableDebug(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::DebugRequest* request, ::bosdyn::api::spot_cam::DebugResponse* response);
    // ListCameras returns a list of strings that identify valid cameras for logging
    virtual ::grpc::Status ListCameras(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response);
    // Retrieve returns all raw data associated with a given logpoint
    virtual ::grpc::Status RetrieveRawData(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* request, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* writer);
    // Retrieve returns all data associated with a given logpoint
    virtual ::grpc::Status Retrieve(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::RetrieveRequest* request, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveResponse>* writer);
    // Delete removes a Logpoint from the system
    virtual ::grpc::Status Delete(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::DeleteRequest* request, ::bosdyn::api::spot_cam::DeleteResponse* response);
    // ListLogpoints returns a list of all logpoints in the database.
    // Warning: this may be a lot of data.
    virtual ::grpc::Status ListLogpoints(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::ListLogpointsRequest* request, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::ListLogpointsResponse>* writer);
    // SetPassphrase sets the eCryptFS passphrase used by the filesystem.
    // there is no symmetry here, because key material is write-only
    virtual ::grpc::Status SetPassphrase(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Store : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Store() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Store() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Store(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::StoreRequest* /*request*/, ::bosdyn::api::spot_cam::StoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStore(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::StoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::StoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStatus(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Tag : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Tag() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Tag() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tag(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::TagRequest* /*request*/, ::bosdyn::api::spot_cam::TagResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTag(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::TagRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::TagResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableDebug : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableDebug() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_EnableDebug() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableDebug(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DebugRequest* /*request*/, ::bosdyn::api::spot_cam::DebugResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableDebug(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::DebugRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::DebugResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListCameras() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ListCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::ListCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListCameras(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::ListCamerasResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RetrieveRawData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RetrieveRawData() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_RetrieveRawData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetrieveRawData(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRetrieveRawData(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::RetrieveRawDataRequest* request, ::grpc::ServerAsyncWriter< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Retrieve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Retrieve() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Retrieve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retrieve(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRetrieve(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::RetrieveRequest* request, ::grpc::ServerAsyncWriter< ::bosdyn::api::spot_cam::RetrieveResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Delete() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelete(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::DeleteRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::DeleteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLogpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListLogpoints() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ListLogpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLogpoints(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListLogpointsRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::ListLogpointsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLogpoints(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::ListLogpointsRequest* request, ::grpc::ServerAsyncWriter< ::bosdyn::api::spot_cam::ListLogpointsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPassphrase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPassphrase() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_SetPassphrase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPassphrase(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPassphraseRequest* /*request*/, ::bosdyn::api::spot_cam::SetPassphraseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPassphrase(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetPassphraseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Store<WithAsyncMethod_GetStatus<WithAsyncMethod_Tag<WithAsyncMethod_EnableDebug<WithAsyncMethod_ListCameras<WithAsyncMethod_RetrieveRawData<WithAsyncMethod_Retrieve<WithAsyncMethod_Delete<WithAsyncMethod_ListLogpoints<WithAsyncMethod_SetPassphrase<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Store : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Store() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::StoreRequest, ::bosdyn::api::spot_cam::StoreResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::StoreRequest* request, ::bosdyn::api::spot_cam::StoreResponse* response) { return this->Store(context, request, response); }));}
    void SetMessageAllocatorFor_Store(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::StoreRequest, ::bosdyn::api::spot_cam::StoreResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::StoreRequest, ::bosdyn::api::spot_cam::StoreResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Store() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Store(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::StoreRequest* /*request*/, ::bosdyn::api::spot_cam::StoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Store(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::StoreRequest* /*request*/, ::bosdyn::api::spot_cam::StoreResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Store(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::StoreRequest* /*request*/, ::bosdyn::api::spot_cam::StoreResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetStatusRequest, ::bosdyn::api::spot_cam::GetStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetStatusRequest* request, ::bosdyn::api::spot_cam::GetStatusResponse* response) { return this->GetStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetStatus(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetStatusRequest, ::bosdyn::api::spot_cam::GetStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetStatusRequest, ::bosdyn::api::spot_cam::GetStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Tag : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Tag() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::TagRequest, ::bosdyn::api::spot_cam::TagResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::TagRequest* request, ::bosdyn::api::spot_cam::TagResponse* response) { return this->Tag(context, request, response); }));}
    void SetMessageAllocatorFor_Tag(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::TagRequest, ::bosdyn::api::spot_cam::TagResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::TagRequest, ::bosdyn::api::spot_cam::TagResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Tag() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tag(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::TagRequest* /*request*/, ::bosdyn::api::spot_cam::TagResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Tag(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::TagRequest* /*request*/, ::bosdyn::api::spot_cam::TagResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Tag(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::TagRequest* /*request*/, ::bosdyn::api::spot_cam::TagResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EnableDebug : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EnableDebug() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::DebugRequest, ::bosdyn::api::spot_cam::DebugResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::DebugRequest* request, ::bosdyn::api::spot_cam::DebugResponse* response) { return this->EnableDebug(context, request, response); }));}
    void SetMessageAllocatorFor_EnableDebug(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::DebugRequest, ::bosdyn::api::spot_cam::DebugResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::DebugRequest, ::bosdyn::api::spot_cam::DebugResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EnableDebug() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableDebug(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DebugRequest* /*request*/, ::bosdyn::api::spot_cam::DebugResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EnableDebug(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::DebugRequest* /*request*/, ::bosdyn::api::spot_cam::DebugResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EnableDebug(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::DebugRequest* /*request*/, ::bosdyn::api::spot_cam::DebugResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListCameras() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ListCamerasRequest, ::bosdyn::api::spot_cam::ListCamerasResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::ListCamerasRequest* request, ::bosdyn::api::spot_cam::ListCamerasResponse* response) { return this->ListCameras(context, request, response); }));}
    void SetMessageAllocatorFor_ListCameras(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::ListCamerasRequest, ::bosdyn::api::spot_cam::ListCamerasResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ListCamerasRequest, ::bosdyn::api::spot_cam::ListCamerasResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::ListCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListCameras(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::ListCamerasResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListCameras(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::ListCamerasResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RetrieveRawData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RetrieveRawData() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::bosdyn::api::spot_cam::RetrieveRawDataRequest, ::bosdyn::api::spot_cam::RetrieveRawDataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* request) { return this->RetrieveRawData(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_RetrieveRawData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetrieveRawData(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* RetrieveRawData(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* RetrieveRawData(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Retrieve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Retrieve() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::bosdyn::api::spot_cam::RetrieveRequest, ::bosdyn::api::spot_cam::RetrieveResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::RetrieveRequest* request) { return this->Retrieve(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_Retrieve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retrieve(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::bosdyn::api::spot_cam::RetrieveResponse>* Retrieve(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::bosdyn::api::spot_cam::RetrieveResponse>* Retrieve(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Delete() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::DeleteRequest, ::bosdyn::api::spot_cam::DeleteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::DeleteRequest* request, ::bosdyn::api::spot_cam::DeleteResponse* response) { return this->Delete(context, request, response); }));}
    void SetMessageAllocatorFor_Delete(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::DeleteRequest, ::bosdyn::api::spot_cam::DeleteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::DeleteRequest, ::bosdyn::api::spot_cam::DeleteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Delete(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Delete(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListLogpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListLogpoints() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::bosdyn::api::spot_cam::ListLogpointsRequest, ::bosdyn::api::spot_cam::ListLogpointsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::ListLogpointsRequest* request) { return this->ListLogpoints(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ListLogpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLogpoints(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListLogpointsRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::ListLogpointsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::bosdyn::api::spot_cam::ListLogpointsResponse>* ListLogpoints(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListLogpointsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::bosdyn::api::spot_cam::ListLogpointsResponse>* ListLogpoints(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListLogpointsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPassphrase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetPassphrase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetPassphraseRequest, ::bosdyn::api::spot_cam::SetPassphraseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetPassphraseRequest* request, ::bosdyn::api::spot_cam::SetPassphraseResponse* response) { return this->SetPassphrase(context, request, response); }));}
    void SetMessageAllocatorFor_SetPassphrase(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetPassphraseRequest, ::bosdyn::api::spot_cam::SetPassphraseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetPassphraseRequest, ::bosdyn::api::spot_cam::SetPassphraseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPassphrase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPassphrase(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPassphraseRequest* /*request*/, ::bosdyn::api::spot_cam::SetPassphraseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetPassphrase(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPassphraseRequest* /*request*/, ::bosdyn::api::spot_cam::SetPassphraseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetPassphrase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPassphraseRequest* /*request*/, ::bosdyn::api::spot_cam::SetPassphraseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Store<ExperimentalWithCallbackMethod_GetStatus<ExperimentalWithCallbackMethod_Tag<ExperimentalWithCallbackMethod_EnableDebug<ExperimentalWithCallbackMethod_ListCameras<ExperimentalWithCallbackMethod_RetrieveRawData<ExperimentalWithCallbackMethod_Retrieve<ExperimentalWithCallbackMethod_Delete<ExperimentalWithCallbackMethod_ListLogpoints<ExperimentalWithCallbackMethod_SetPassphrase<Service > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Store<ExperimentalWithCallbackMethod_GetStatus<ExperimentalWithCallbackMethod_Tag<ExperimentalWithCallbackMethod_EnableDebug<ExperimentalWithCallbackMethod_ListCameras<ExperimentalWithCallbackMethod_RetrieveRawData<ExperimentalWithCallbackMethod_Retrieve<ExperimentalWithCallbackMethod_Delete<ExperimentalWithCallbackMethod_ListLogpoints<ExperimentalWithCallbackMethod_SetPassphrase<Service > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Store : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Store() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Store() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Store(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::StoreRequest* /*request*/, ::bosdyn::api::spot_cam::StoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Tag : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Tag() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Tag() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tag(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::TagRequest* /*request*/, ::bosdyn::api::spot_cam::TagResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableDebug : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableDebug() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_EnableDebug() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableDebug(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DebugRequest* /*request*/, ::bosdyn::api::spot_cam::DebugResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListCameras() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ListCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::ListCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RetrieveRawData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RetrieveRawData() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_RetrieveRawData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetrieveRawData(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Retrieve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Retrieve() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Retrieve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retrieve(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Delete() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLogpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListLogpoints() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ListLogpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLogpoints(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListLogpointsRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::ListLogpointsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPassphrase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPassphrase() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_SetPassphrase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPassphrase(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPassphraseRequest* /*request*/, ::bosdyn::api::spot_cam::SetPassphraseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Store : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Store() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Store() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Store(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::StoreRequest* /*request*/, ::bosdyn::api::spot_cam::StoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Tag : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Tag() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Tag() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tag(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::TagRequest* /*request*/, ::bosdyn::api::spot_cam::TagResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTag(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableDebug : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableDebug() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_EnableDebug() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableDebug(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DebugRequest* /*request*/, ::bosdyn::api::spot_cam::DebugResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableDebug(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListCameras() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ListCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::ListCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListCameras(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RetrieveRawData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RetrieveRawData() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_RetrieveRawData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetrieveRawData(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRetrieveRawData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Retrieve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Retrieve() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Retrieve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retrieve(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRetrieve(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Delete() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListLogpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListLogpoints() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ListLogpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLogpoints(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListLogpointsRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::ListLogpointsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLogpoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPassphrase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPassphrase() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_SetPassphrase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPassphrase(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPassphraseRequest* /*request*/, ::bosdyn::api::spot_cam::SetPassphraseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPassphrase(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Store : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Store() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Store(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Store() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Store(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::StoreRequest* /*request*/, ::bosdyn::api::spot_cam::StoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Store(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Store(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Tag : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Tag() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Tag(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Tag() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tag(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::TagRequest* /*request*/, ::bosdyn::api::spot_cam::TagResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Tag(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Tag(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EnableDebug : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EnableDebug() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableDebug(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EnableDebug() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableDebug(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DebugRequest* /*request*/, ::bosdyn::api::spot_cam::DebugResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EnableDebug(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EnableDebug(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListCameras() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListCameras(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::ListCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListCameras(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListCameras(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RetrieveRawData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RetrieveRawData() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->RetrieveRawData(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_RetrieveRawData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetrieveRawData(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* RetrieveRawData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* RetrieveRawData(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Retrieve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Retrieve() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->Retrieve(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_Retrieve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Retrieve(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Retrieve(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* Retrieve(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Delete() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Delete(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Delete(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Delete(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListLogpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListLogpoints() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ListLogpoints(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListLogpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLogpoints(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListLogpointsRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::ListLogpointsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ListLogpoints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ListLogpoints(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPassphrase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPassphrase() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPassphrase(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPassphrase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPassphrase(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPassphraseRequest* /*request*/, ::bosdyn::api::spot_cam::SetPassphraseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetPassphrase(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetPassphrase(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Store : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Store() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::StoreRequest, ::bosdyn::api::spot_cam::StoreResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::StoreRequest, ::bosdyn::api::spot_cam::StoreResponse>* streamer) {
                       return this->StreamedStore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Store() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Store(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::StoreRequest* /*request*/, ::bosdyn::api::spot_cam::StoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::StoreRequest,::bosdyn::api::spot_cam::StoreResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetStatusRequest, ::bosdyn::api::spot_cam::GetStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetStatusRequest, ::bosdyn::api::spot_cam::GetStatusResponse>* streamer) {
                       return this->StreamedGetStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetStatusRequest,::bosdyn::api::spot_cam::GetStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Tag : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Tag() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::TagRequest, ::bosdyn::api::spot_cam::TagResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::TagRequest, ::bosdyn::api::spot_cam::TagResponse>* streamer) {
                       return this->StreamedTag(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Tag() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Tag(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::TagRequest* /*request*/, ::bosdyn::api::spot_cam::TagResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTag(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::TagRequest,::bosdyn::api::spot_cam::TagResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableDebug : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableDebug() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::DebugRequest, ::bosdyn::api::spot_cam::DebugResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::DebugRequest, ::bosdyn::api::spot_cam::DebugResponse>* streamer) {
                       return this->StreamedEnableDebug(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableDebug() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableDebug(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DebugRequest* /*request*/, ::bosdyn::api::spot_cam::DebugResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableDebug(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::DebugRequest,::bosdyn::api::spot_cam::DebugResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListCameras : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListCameras() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::ListCamerasRequest, ::bosdyn::api::spot_cam::ListCamerasResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::ListCamerasRequest, ::bosdyn::api::spot_cam::ListCamerasResponse>* streamer) {
                       return this->StreamedListCameras(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListCameras() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListCameras(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListCamerasRequest* /*request*/, ::bosdyn::api::spot_cam::ListCamerasResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListCameras(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::ListCamerasRequest,::bosdyn::api::spot_cam::ListCamerasResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Delete() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::DeleteRequest, ::bosdyn::api::spot_cam::DeleteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::DeleteRequest, ::bosdyn::api::spot_cam::DeleteResponse>* streamer) {
                       return this->StreamedDelete(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDelete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::DeleteRequest,::bosdyn::api::spot_cam::DeleteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPassphrase : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPassphrase() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetPassphraseRequest, ::bosdyn::api::spot_cam::SetPassphraseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetPassphraseRequest, ::bosdyn::api::spot_cam::SetPassphraseResponse>* streamer) {
                       return this->StreamedSetPassphrase(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPassphrase() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPassphrase(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPassphraseRequest* /*request*/, ::bosdyn::api::spot_cam::SetPassphraseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPassphrase(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetPassphraseRequest,::bosdyn::api::spot_cam::SetPassphraseResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Store<WithStreamedUnaryMethod_GetStatus<WithStreamedUnaryMethod_Tag<WithStreamedUnaryMethod_EnableDebug<WithStreamedUnaryMethod_ListCameras<WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_SetPassphrase<Service > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_RetrieveRawData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_RetrieveRawData() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::bosdyn::api::spot_cam::RetrieveRawDataRequest, ::bosdyn::api::spot_cam::RetrieveRawDataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::bosdyn::api::spot_cam::RetrieveRawDataRequest, ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* streamer) {
                       return this->StreamedRetrieveRawData(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_RetrieveRawData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RetrieveRawData(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRawDataRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveRawDataResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRetrieveRawData(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::bosdyn::api::spot_cam::RetrieveRawDataRequest,::bosdyn::api::spot_cam::RetrieveRawDataResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_Retrieve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Retrieve() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::bosdyn::api::spot_cam::RetrieveRequest, ::bosdyn::api::spot_cam::RetrieveResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::bosdyn::api::spot_cam::RetrieveRequest, ::bosdyn::api::spot_cam::RetrieveResponse>* streamer) {
                       return this->StreamedRetrieve(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Retrieve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Retrieve(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::RetrieveRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::RetrieveResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedRetrieve(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::bosdyn::api::spot_cam::RetrieveRequest,::bosdyn::api::spot_cam::RetrieveResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ListLogpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ListLogpoints() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::bosdyn::api::spot_cam::ListLogpointsRequest, ::bosdyn::api::spot_cam::ListLogpointsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::bosdyn::api::spot_cam::ListLogpointsRequest, ::bosdyn::api::spot_cam::ListLogpointsResponse>* streamer) {
                       return this->StreamedListLogpoints(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ListLogpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListLogpoints(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListLogpointsRequest* /*request*/, ::grpc::ServerWriter< ::bosdyn::api::spot_cam::ListLogpointsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedListLogpoints(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::bosdyn::api::spot_cam::ListLogpointsRequest,::bosdyn::api::spot_cam::ListLogpointsResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_RetrieveRawData<WithSplitStreamingMethod_Retrieve<WithSplitStreamingMethod_ListLogpoints<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Store<WithStreamedUnaryMethod_GetStatus<WithStreamedUnaryMethod_Tag<WithStreamedUnaryMethod_EnableDebug<WithStreamedUnaryMethod_ListCameras<WithSplitStreamingMethod_RetrieveRawData<WithSplitStreamingMethod_Retrieve<WithStreamedUnaryMethod_Delete<WithSplitStreamingMethod_ListLogpoints<WithStreamedUnaryMethod_SetPassphrase<Service > > > > > > > > > > StreamedService;
};

// Control real and virtual ptz mechanisms.
class PtzService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.PtzService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // SetPosition points the referenced camera to a given vector (in PTZ-space)
    virtual ::grpc::Status SetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzPositionResponse>> AsyncSetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzPositionResponse>>(AsyncSetPtzPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzPositionResponse>> PrepareAsyncSetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzPositionResponse>>(PrepareAsyncSetPtzPositionRaw(context, request, cq));
    }
    // GetPosition returns the current settings of the referenced camera
    virtual ::grpc::Status GetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzPositionResponse>> AsyncGetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzPositionResponse>>(AsyncGetPtzPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzPositionResponse>> PrepareAsyncGetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzPositionResponse>>(PrepareAsyncGetPtzPositionRaw(context, request, cq));
    }
    virtual ::grpc::Status SetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>> AsyncSetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>>(AsyncSetPtzVelocityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>> PrepareAsyncSetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>>(PrepareAsyncSetPtzVelocityRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>> AsyncGetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>>(AsyncGetPtzVelocityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>> PrepareAsyncGetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>>(PrepareAsyncGetPtzVelocityRaw(context, request, cq));
    }
    virtual ::grpc::Status ListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::bosdyn::api::spot_cam::ListPtzResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListPtzResponse>> AsyncListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListPtzResponse>>(AsyncListPtzRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListPtzResponse>> PrepareAsyncListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListPtzResponse>>(PrepareAsyncListPtzRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // SetPosition points the referenced camera to a given vector (in PTZ-space)
      virtual void SetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetPosition returns the current settings of the referenced camera
      virtual void GetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListPtz(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListPtz(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListPtz(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzPositionResponse>* AsyncSetPtzPositionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzPositionResponse>* PrepareAsyncSetPtzPositionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzPositionResponse>* AsyncGetPtzPositionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzPositionResponse>* PrepareAsyncGetPtzPositionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>* AsyncSetPtzVelocityRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>* PrepareAsyncSetPtzVelocityRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>* AsyncGetPtzVelocityRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>* PrepareAsyncGetPtzVelocityRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListPtzResponse>* AsyncListPtzRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListPtzResponse>* PrepareAsyncListPtzRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzPositionResponse>> AsyncSetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzPositionResponse>>(AsyncSetPtzPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzPositionResponse>> PrepareAsyncSetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzPositionResponse>>(PrepareAsyncSetPtzPositionRaw(context, request, cq));
    }
    ::grpc::Status GetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzPositionResponse>> AsyncGetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzPositionResponse>>(AsyncGetPtzPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzPositionResponse>> PrepareAsyncGetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzPositionResponse>>(PrepareAsyncGetPtzPositionRaw(context, request, cq));
    }
    ::grpc::Status SetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>> AsyncSetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>>(AsyncSetPtzVelocityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>> PrepareAsyncSetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>>(PrepareAsyncSetPtzVelocityRaw(context, request, cq));
    }
    ::grpc::Status GetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>> AsyncGetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>>(AsyncGetPtzVelocityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>> PrepareAsyncGetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>>(PrepareAsyncGetPtzVelocityRaw(context, request, cq));
    }
    ::grpc::Status ListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::bosdyn::api::spot_cam::ListPtzResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListPtzResponse>> AsyncListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListPtzResponse>>(AsyncListPtzRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListPtzResponse>> PrepareAsyncListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListPtzResponse>>(PrepareAsyncListPtzRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, std::function<void(::grpc::Status)>) override;
      void SetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPtzPosition(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPtzPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, std::function<void(::grpc::Status)>) override;
      void SetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPtzVelocity(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPtzVelocity(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, std::function<void(::grpc::Status)>) override;
      void ListPtz(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListPtz(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListPtz(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListPtz(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListPtzResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzPositionResponse>* AsyncSetPtzPositionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzPositionResponse>* PrepareAsyncSetPtzPositionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzPositionResponse>* AsyncGetPtzPositionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzPositionResponse>* PrepareAsyncGetPtzPositionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>* AsyncSetPtzVelocityRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>* PrepareAsyncSetPtzVelocityRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>* AsyncGetPtzVelocityRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>* PrepareAsyncGetPtzVelocityRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListPtzResponse>* AsyncListPtzRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListPtzResponse>* PrepareAsyncListPtzRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetPtzPosition_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPtzPosition_;
    const ::grpc::internal::RpcMethod rpcmethod_SetPtzVelocity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPtzVelocity_;
    const ::grpc::internal::RpcMethod rpcmethod_ListPtz_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // SetPosition points the referenced camera to a given vector (in PTZ-space)
    virtual ::grpc::Status SetPtzPosition(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response);
    // GetPosition returns the current settings of the referenced camera
    virtual ::grpc::Status GetPtzPosition(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response);
    virtual ::grpc::Status SetPtzVelocity(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response);
    virtual ::grpc::Status GetPtzVelocity(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response);
    virtual ::grpc::Status ListPtz(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::ListPtzRequest* request, ::bosdyn::api::spot_cam::ListPtzResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPtzPosition() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPtzPosition(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetPtzPositionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPtzPosition() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPtzPosition(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetPtzPositionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetPtzVelocity() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPtzVelocity(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetPtzVelocityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPtzVelocity() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPtzVelocity(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetPtzVelocityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListPtz : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListPtz() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ListPtz() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPtz(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListPtzRequest* /*request*/, ::bosdyn::api::spot_cam::ListPtzResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPtz(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::ListPtzRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::ListPtzResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetPtzPosition<WithAsyncMethod_GetPtzPosition<WithAsyncMethod_SetPtzVelocity<WithAsyncMethod_GetPtzVelocity<WithAsyncMethod_ListPtz<Service > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetPtzPosition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetPtzPositionRequest, ::bosdyn::api::spot_cam::SetPtzPositionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* request, ::bosdyn::api::spot_cam::SetPtzPositionResponse* response) { return this->SetPtzPosition(context, request, response); }));}
    void SetMessageAllocatorFor_SetPtzPosition(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetPtzPositionRequest, ::bosdyn::api::spot_cam::SetPtzPositionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetPtzPositionRequest, ::bosdyn::api::spot_cam::SetPtzPositionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetPtzPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzPositionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetPtzPosition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzPositionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPtzPosition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetPtzPositionRequest, ::bosdyn::api::spot_cam::GetPtzPositionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* request, ::bosdyn::api::spot_cam::GetPtzPositionResponse* response) { return this->GetPtzPosition(context, request, response); }));}
    void SetMessageAllocatorFor_GetPtzPosition(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetPtzPositionRequest, ::bosdyn::api::spot_cam::GetPtzPositionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetPtzPositionRequest, ::bosdyn::api::spot_cam::GetPtzPositionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPtzPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzPositionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPtzPosition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzPositionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetPtzVelocity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetPtzVelocityRequest, ::bosdyn::api::spot_cam::SetPtzVelocityResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* response) { return this->SetPtzVelocity(context, request, response); }));}
    void SetMessageAllocatorFor_SetPtzVelocity(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetPtzVelocityRequest, ::bosdyn::api::spot_cam::SetPtzVelocityResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetPtzVelocityRequest, ::bosdyn::api::spot_cam::SetPtzVelocityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetPtzVelocity(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetPtzVelocity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPtzVelocity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetPtzVelocityRequest, ::bosdyn::api::spot_cam::GetPtzVelocityResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* request, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* response) { return this->GetPtzVelocity(context, request, response); }));}
    void SetMessageAllocatorFor_GetPtzVelocity(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetPtzVelocityRequest, ::bosdyn::api::spot_cam::GetPtzVelocityResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetPtzVelocityRequest, ::bosdyn::api::spot_cam::GetPtzVelocityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPtzVelocity(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPtzVelocity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListPtz : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListPtz() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ListPtzRequest, ::bosdyn::api::spot_cam::ListPtzResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::ListPtzRequest* request, ::bosdyn::api::spot_cam::ListPtzResponse* response) { return this->ListPtz(context, request, response); }));}
    void SetMessageAllocatorFor_ListPtz(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::ListPtzRequest, ::bosdyn::api::spot_cam::ListPtzResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ListPtzRequest, ::bosdyn::api::spot_cam::ListPtzResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListPtz() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPtz(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListPtzRequest* /*request*/, ::bosdyn::api::spot_cam::ListPtzResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListPtz(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListPtzRequest* /*request*/, ::bosdyn::api::spot_cam::ListPtzResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListPtz(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListPtzRequest* /*request*/, ::bosdyn::api::spot_cam::ListPtzResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SetPtzPosition<ExperimentalWithCallbackMethod_GetPtzPosition<ExperimentalWithCallbackMethod_SetPtzVelocity<ExperimentalWithCallbackMethod_GetPtzVelocity<ExperimentalWithCallbackMethod_ListPtz<Service > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SetPtzPosition<ExperimentalWithCallbackMethod_GetPtzPosition<ExperimentalWithCallbackMethod_SetPtzVelocity<ExperimentalWithCallbackMethod_GetPtzVelocity<ExperimentalWithCallbackMethod_ListPtz<Service > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPtzPosition() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPtzPosition() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetPtzVelocity() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPtzVelocity() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListPtz : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListPtz() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ListPtz() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPtz(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListPtzRequest* /*request*/, ::bosdyn::api::spot_cam::ListPtzResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPtzPosition() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPtzPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPtzPosition() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPtzPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetPtzVelocity() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetPtzVelocity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPtzVelocity() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPtzVelocity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListPtz : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListPtz() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ListPtz() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPtz(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListPtzRequest* /*request*/, ::bosdyn::api::spot_cam::ListPtzResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListPtz(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPtzPosition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPtzPosition(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetPtzPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetPtzPosition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPtzPosition() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPtzPosition(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPtzPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPtzPosition(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetPtzVelocity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetPtzVelocity(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetPtzVelocity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetPtzVelocity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPtzVelocity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPtzVelocity(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPtzVelocity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPtzVelocity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListPtz : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListPtz() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListPtz(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListPtz() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListPtz(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListPtzRequest* /*request*/, ::bosdyn::api::spot_cam::ListPtzResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListPtz(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListPtz(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPtzPosition() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetPtzPositionRequest, ::bosdyn::api::spot_cam::SetPtzPositionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetPtzPositionRequest, ::bosdyn::api::spot_cam::SetPtzPositionResponse>* streamer) {
                       return this->StreamedSetPtzPosition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPtzPosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetPtzPositionRequest,::bosdyn::api::spot_cam::SetPtzPositionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPtzPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPtzPosition() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetPtzPositionRequest, ::bosdyn::api::spot_cam::GetPtzPositionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetPtzPositionRequest, ::bosdyn::api::spot_cam::GetPtzPositionResponse>* streamer) {
                       return this->StreamedGetPtzPosition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPtzPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPtzPosition(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzPositionRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPtzPosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetPtzPositionRequest,::bosdyn::api::spot_cam::GetPtzPositionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetPtzVelocity() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetPtzVelocityRequest, ::bosdyn::api::spot_cam::SetPtzVelocityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetPtzVelocityRequest, ::bosdyn::api::spot_cam::SetPtzVelocityResponse>* streamer) {
                       return this->StreamedSetPtzVelocity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::SetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetPtzVelocity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetPtzVelocityRequest,::bosdyn::api::spot_cam::SetPtzVelocityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPtzVelocity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPtzVelocity() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetPtzVelocityRequest, ::bosdyn::api::spot_cam::GetPtzVelocityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetPtzVelocityRequest, ::bosdyn::api::spot_cam::GetPtzVelocityResponse>* streamer) {
                       return this->StreamedGetPtzVelocity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPtzVelocity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPtzVelocity(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetPtzVelocityRequest* /*request*/, ::bosdyn::api::spot_cam::GetPtzVelocityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPtzVelocity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetPtzVelocityRequest,::bosdyn::api::spot_cam::GetPtzVelocityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListPtz : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListPtz() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::ListPtzRequest, ::bosdyn::api::spot_cam::ListPtzResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::ListPtzRequest, ::bosdyn::api::spot_cam::ListPtzResponse>* streamer) {
                       return this->StreamedListPtz(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListPtz() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListPtz(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListPtzRequest* /*request*/, ::bosdyn::api::spot_cam::ListPtzResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListPtz(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::ListPtzRequest,::bosdyn::api::spot_cam::ListPtzResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetPtzPosition<WithStreamedUnaryMethod_GetPtzPosition<WithStreamedUnaryMethod_SetPtzVelocity<WithStreamedUnaryMethod_GetPtzVelocity<WithStreamedUnaryMethod_ListPtz<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetPtzPosition<WithStreamedUnaryMethod_GetPtzPosition<WithStreamedUnaryMethod_SetPtzVelocity<WithStreamedUnaryMethod_GetPtzVelocity<WithStreamedUnaryMethod_ListPtz<Service > > > > > StreamedService;
};

// Upload and play sounds over the SpotCam's speakers.
class AudioService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.AudioService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Given a soundRequest that identifies a single sound present in the system's sound effects table, PlaySound executes the sound effect.
    virtual ::grpc::Status PlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::bosdyn::api::spot_cam::PlaySoundResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::PlaySoundResponse>> AsyncPlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::PlaySoundResponse>>(AsyncPlaySoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::PlaySoundResponse>> PrepareAsyncPlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::PlaySoundResponse>>(PrepareAsyncPlaySoundRaw(context, request, cq));
    }
    // LoadSound loads a sound effect into the system's sound table. The stream must contain a wav file, with a RIFF header describing it.
    // The arguement is a stream, to allow for sounds that are bigger then the MTU of the network; in this case, the complete stream must
    // contain the entire sound. If the stream ends early, an error will be returned. The header and sound fields of the entire stream must
    // be the same.
    std::unique_ptr< ::grpc::ClientWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>> LoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>>(LoadSoundRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>> AsyncLoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>>(AsyncLoadSoundRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>> PrepareAsyncLoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>>(PrepareAsyncLoadSoundRaw(context, response, cq));
    }
    // Delete the sound identified in the argument from the system's sound table.
    virtual ::grpc::Status DeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteSoundResponse>> AsyncDeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteSoundResponse>>(AsyncDeleteSoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteSoundResponse>> PrepareAsyncDeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteSoundResponse>>(PrepareAsyncDeleteSoundRaw(context, request, cq));
    }
    // ListSounds returns a list of all of the sound effects that the system knows about.
    virtual ::grpc::Status ListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::bosdyn::api::spot_cam::ListSoundsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListSoundsResponse>> AsyncListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListSoundsResponse>>(AsyncListSoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListSoundsResponse>> PrepareAsyncListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListSoundsResponse>>(PrepareAsyncListSoundsRaw(context, request, cq));
    }
    // Set the overall volume level for playing sounds.
    virtual ::grpc::Status SetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::bosdyn::api::spot_cam::SetVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetVolumeResponse>> AsyncSetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetVolumeResponse>>(AsyncSetVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetVolumeResponse>> PrepareAsyncSetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetVolumeResponse>>(PrepareAsyncSetVolumeRaw(context, request, cq));
    }
    // Set the overall volume level for playing sounds.
    virtual ::grpc::Status GetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::bosdyn::api::spot_cam::GetVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVolumeResponse>> AsyncGetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVolumeResponse>>(AsyncGetVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVolumeResponse>> PrepareAsyncGetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVolumeResponse>>(PrepareAsyncGetVolumeRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Given a soundRequest that identifies a single sound present in the system's sound effects table, PlaySound executes the sound effect.
      virtual void PlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlaySound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PlaySound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PlaySound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // LoadSound loads a sound effect into the system's sound table. The stream must contain a wav file, with a RIFF header describing it.
      // The arguement is a stream, to allow for sounds that are bigger then the MTU of the network; in this case, the complete stream must
      // contain the entire sound. If the stream ends early, an error will be returned. The header and sound fields of the entire stream must
      // be the same.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::ClientWriteReactor< ::bosdyn::api::spot_cam::LoadSoundRequest>* reactor) = 0;
      #else
      virtual void LoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::experimental::ClientWriteReactor< ::bosdyn::api::spot_cam::LoadSoundRequest>* reactor) = 0;
      #endif
      // Delete the sound identified in the argument from the system's sound table.
      virtual void DeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteSound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteSound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteSound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // ListSounds returns a list of all of the sound effects that the system knows about.
      virtual void ListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListSounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListSounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListSounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Set the overall volume level for playing sounds.
      virtual void SetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Set the overall volume level for playing sounds.
      virtual void GetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::PlaySoundResponse>* AsyncPlaySoundRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::PlaySoundResponse>* PrepareAsyncPlaySoundRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>* LoadSoundRaw(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>* AsyncLoadSoundRaw(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::bosdyn::api::spot_cam::LoadSoundRequest>* PrepareAsyncLoadSoundRaw(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteSoundResponse>* AsyncDeleteSoundRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::DeleteSoundResponse>* PrepareAsyncDeleteSoundRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListSoundsResponse>* AsyncListSoundsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ListSoundsResponse>* PrepareAsyncListSoundsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetVolumeResponse>* AsyncSetVolumeRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetVolumeResponse>* PrepareAsyncSetVolumeRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVolumeResponse>* AsyncGetVolumeRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetVolumeResponse>* PrepareAsyncGetVolumeRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status PlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::bosdyn::api::spot_cam::PlaySoundResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::PlaySoundResponse>> AsyncPlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::PlaySoundResponse>>(AsyncPlaySoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::PlaySoundResponse>> PrepareAsyncPlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::PlaySoundResponse>>(PrepareAsyncPlaySoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>> LoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>>(LoadSoundRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>> AsyncLoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>>(AsyncLoadSoundRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>> PrepareAsyncLoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>>(PrepareAsyncLoadSoundRaw(context, response, cq));
    }
    ::grpc::Status DeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteSoundResponse>> AsyncDeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteSoundResponse>>(AsyncDeleteSoundRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteSoundResponse>> PrepareAsyncDeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteSoundResponse>>(PrepareAsyncDeleteSoundRaw(context, request, cq));
    }
    ::grpc::Status ListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::bosdyn::api::spot_cam::ListSoundsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListSoundsResponse>> AsyncListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListSoundsResponse>>(AsyncListSoundsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListSoundsResponse>> PrepareAsyncListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListSoundsResponse>>(PrepareAsyncListSoundsRaw(context, request, cq));
    }
    ::grpc::Status SetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::bosdyn::api::spot_cam::SetVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetVolumeResponse>> AsyncSetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetVolumeResponse>>(AsyncSetVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetVolumeResponse>> PrepareAsyncSetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetVolumeResponse>>(PrepareAsyncSetVolumeRaw(context, request, cq));
    }
    ::grpc::Status GetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::bosdyn::api::spot_cam::GetVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVolumeResponse>> AsyncGetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVolumeResponse>>(AsyncGetVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVolumeResponse>> PrepareAsyncGetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVolumeResponse>>(PrepareAsyncGetVolumeRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void PlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, std::function<void(::grpc::Status)>) override;
      void PlaySound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PlaySound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PlaySound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PlaySound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::ClientWriteReactor< ::bosdyn::api::spot_cam::LoadSoundRequest>* reactor) override;
      #else
      void LoadSound(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::experimental::ClientWriteReactor< ::bosdyn::api::spot_cam::LoadSoundRequest>* reactor) override;
      #endif
      void DeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteSound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteSound(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteSound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteSound(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListSounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListSounds(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListSounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListSounds(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void SetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVolume(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::PlaySoundResponse>* AsyncPlaySoundRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::PlaySoundResponse>* PrepareAsyncPlaySoundRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>* LoadSoundRaw(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response) override;
    ::grpc::ClientAsyncWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>* AsyncLoadSoundRaw(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::bosdyn::api::spot_cam::LoadSoundRequest>* PrepareAsyncLoadSoundRaw(::grpc::ClientContext* context, ::bosdyn::api::spot_cam::LoadSoundResponse* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteSoundResponse>* AsyncDeleteSoundRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::DeleteSoundResponse>* PrepareAsyncDeleteSoundRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListSoundsResponse>* AsyncListSoundsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ListSoundsResponse>* PrepareAsyncListSoundsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetVolumeResponse>* AsyncSetVolumeRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetVolumeResponse>* PrepareAsyncSetVolumeRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVolumeResponse>* AsyncGetVolumeRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetVolumeResponse>* PrepareAsyncGetVolumeRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PlaySound_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadSound_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteSound_;
    const ::grpc::internal::RpcMethod rpcmethod_ListSounds_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVolume_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Given a soundRequest that identifies a single sound present in the system's sound effects table, PlaySound executes the sound effect.
    virtual ::grpc::Status PlaySound(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response);
    // LoadSound loads a sound effect into the system's sound table. The stream must contain a wav file, with a RIFF header describing it.
    // The arguement is a stream, to allow for sounds that are bigger then the MTU of the network; in this case, the complete stream must
    // contain the entire sound. If the stream ends early, an error will be returned. The header and sound fields of the entire stream must
    // be the same.
    virtual ::grpc::Status LoadSound(::grpc::ServerContext* context, ::grpc::ServerReader< ::bosdyn::api::spot_cam::LoadSoundRequest>* reader, ::bosdyn::api::spot_cam::LoadSoundResponse* response);
    // Delete the sound identified in the argument from the system's sound table.
    virtual ::grpc::Status DeleteSound(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response);
    // ListSounds returns a list of all of the sound effects that the system knows about.
    virtual ::grpc::Status ListSounds(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response);
    // Set the overall volume level for playing sounds.
    virtual ::grpc::Status SetVolume(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response);
    // Set the overall volume level for playing sounds.
    virtual ::grpc::Status GetVolume(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PlaySound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlaySound() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PlaySound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaySound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::PlaySoundRequest* /*request*/, ::bosdyn::api::spot_cam::PlaySoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlaySound(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::PlaySoundResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadSound() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_LoadSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSound(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::bosdyn::api::spot_cam::LoadSoundRequest>* /*reader*/, ::bosdyn::api::spot_cam::LoadSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadSound(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::bosdyn::api::spot_cam::LoadSoundResponse, ::bosdyn::api::spot_cam::LoadSoundRequest>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteSound() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DeleteSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteSoundRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSound(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::DeleteSoundResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListSounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListSounds() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ListSounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSounds(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListSoundsRequest* /*request*/, ::bosdyn::api::spot_cam::ListSoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSounds(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::ListSoundsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetVolume() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::SetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVolume(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVolume() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::GetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVolume(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PlaySound<WithAsyncMethod_LoadSound<WithAsyncMethod_DeleteSound<WithAsyncMethod_ListSounds<WithAsyncMethod_SetVolume<WithAsyncMethod_GetVolume<Service > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PlaySound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PlaySound() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::PlaySoundRequest, ::bosdyn::api::spot_cam::PlaySoundResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::PlaySoundRequest* request, ::bosdyn::api::spot_cam::PlaySoundResponse* response) { return this->PlaySound(context, request, response); }));}
    void SetMessageAllocatorFor_PlaySound(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::PlaySoundRequest, ::bosdyn::api::spot_cam::PlaySoundResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::PlaySoundRequest, ::bosdyn::api::spot_cam::PlaySoundResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PlaySound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaySound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::PlaySoundRequest* /*request*/, ::bosdyn::api::spot_cam::PlaySoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PlaySound(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::PlaySoundRequest* /*request*/, ::bosdyn::api::spot_cam::PlaySoundResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PlaySound(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::PlaySoundRequest* /*request*/, ::bosdyn::api::spot_cam::PlaySoundResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LoadSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LoadSound() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackClientStreamingHandler< ::bosdyn::api::spot_cam::LoadSoundRequest, ::bosdyn::api::spot_cam::LoadSoundResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, ::bosdyn::api::spot_cam::LoadSoundResponse* response) { return this->LoadSound(context, response); }));
    }
    ~ExperimentalWithCallbackMethod_LoadSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSound(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::bosdyn::api::spot_cam::LoadSoundRequest>* /*reader*/, ::bosdyn::api::spot_cam::LoadSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerReadReactor< ::bosdyn::api::spot_cam::LoadSoundRequest>* LoadSound(
      ::grpc::CallbackServerContext* /*context*/, ::bosdyn::api::spot_cam::LoadSoundResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerReadReactor< ::bosdyn::api::spot_cam::LoadSoundRequest>* LoadSound(
      ::grpc::experimental::CallbackServerContext* /*context*/, ::bosdyn::api::spot_cam::LoadSoundResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteSound() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::DeleteSoundRequest, ::bosdyn::api::spot_cam::DeleteSoundResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::DeleteSoundRequest* request, ::bosdyn::api::spot_cam::DeleteSoundResponse* response) { return this->DeleteSound(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteSound(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::DeleteSoundRequest, ::bosdyn::api::spot_cam::DeleteSoundResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::DeleteSoundRequest, ::bosdyn::api::spot_cam::DeleteSoundResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteSoundRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteSound(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteSoundRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteSoundResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteSound(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteSoundRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteSoundResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListSounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListSounds() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ListSoundsRequest, ::bosdyn::api::spot_cam::ListSoundsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::ListSoundsRequest* request, ::bosdyn::api::spot_cam::ListSoundsResponse* response) { return this->ListSounds(context, request, response); }));}
    void SetMessageAllocatorFor_ListSounds(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::ListSoundsRequest, ::bosdyn::api::spot_cam::ListSoundsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ListSoundsRequest, ::bosdyn::api::spot_cam::ListSoundsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListSounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSounds(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListSoundsRequest* /*request*/, ::bosdyn::api::spot_cam::ListSoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSounds(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListSoundsRequest* /*request*/, ::bosdyn::api::spot_cam::ListSoundsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSounds(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListSoundsRequest* /*request*/, ::bosdyn::api::spot_cam::ListSoundsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetVolumeRequest, ::bosdyn::api::spot_cam::SetVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetVolumeRequest* request, ::bosdyn::api::spot_cam::SetVolumeResponse* response) { return this->SetVolume(context, request, response); }));}
    void SetMessageAllocatorFor_SetVolume(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetVolumeRequest, ::bosdyn::api::spot_cam::SetVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetVolumeRequest, ::bosdyn::api::spot_cam::SetVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::SetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::SetVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::SetVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetVolumeRequest, ::bosdyn::api::spot_cam::GetVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetVolumeRequest* request, ::bosdyn::api::spot_cam::GetVolumeResponse* response) { return this->GetVolume(context, request, response); }));}
    void SetMessageAllocatorFor_GetVolume(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetVolumeRequest, ::bosdyn::api::spot_cam::GetVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetVolumeRequest, ::bosdyn::api::spot_cam::GetVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::GetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::GetVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::GetVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_PlaySound<ExperimentalWithCallbackMethod_LoadSound<ExperimentalWithCallbackMethod_DeleteSound<ExperimentalWithCallbackMethod_ListSounds<ExperimentalWithCallbackMethod_SetVolume<ExperimentalWithCallbackMethod_GetVolume<Service > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_PlaySound<ExperimentalWithCallbackMethod_LoadSound<ExperimentalWithCallbackMethod_DeleteSound<ExperimentalWithCallbackMethod_ListSounds<ExperimentalWithCallbackMethod_SetVolume<ExperimentalWithCallbackMethod_GetVolume<Service > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PlaySound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlaySound() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PlaySound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaySound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::PlaySoundRequest* /*request*/, ::bosdyn::api::spot_cam::PlaySoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadSound() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_LoadSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSound(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::bosdyn::api::spot_cam::LoadSoundRequest>* /*reader*/, ::bosdyn::api::spot_cam::LoadSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteSound() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DeleteSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteSoundRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListSounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListSounds() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ListSounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSounds(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListSoundsRequest* /*request*/, ::bosdyn::api::spot_cam::ListSoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetVolume() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::SetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVolume() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::GetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlaySound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlaySound() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PlaySound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaySound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::PlaySoundRequest* /*request*/, ::bosdyn::api::spot_cam::PlaySoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlaySound(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadSound() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_LoadSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSound(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::bosdyn::api::spot_cam::LoadSoundRequest>* /*reader*/, ::bosdyn::api::spot_cam::LoadSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadSound(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteSound() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DeleteSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteSoundRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSound(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListSounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListSounds() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ListSounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSounds(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListSoundsRequest* /*request*/, ::bosdyn::api::spot_cam::ListSoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSounds(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetVolume() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::SetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVolume() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::GetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PlaySound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PlaySound() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlaySound(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PlaySound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlaySound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::PlaySoundRequest* /*request*/, ::bosdyn::api::spot_cam::PlaySoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PlaySound(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PlaySound(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LoadSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LoadSound() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, ::grpc::ByteBuffer* response) { return this->LoadSound(context, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LoadSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadSound(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::bosdyn::api::spot_cam::LoadSoundRequest>* /*reader*/, ::bosdyn::api::spot_cam::LoadSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* LoadSound(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerReadReactor< ::grpc::ByteBuffer>* LoadSound(
      ::grpc::experimental::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteSound() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteSound(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteSoundRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteSound(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteSound(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListSounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListSounds() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListSounds(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListSounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSounds(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListSoundsRequest* /*request*/, ::bosdyn::api::spot_cam::ListSoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSounds(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSounds(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::SetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::GetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlaySound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlaySound() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::PlaySoundRequest, ::bosdyn::api::spot_cam::PlaySoundResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::PlaySoundRequest, ::bosdyn::api::spot_cam::PlaySoundResponse>* streamer) {
                       return this->StreamedPlaySound(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlaySound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlaySound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::PlaySoundRequest* /*request*/, ::bosdyn::api::spot_cam::PlaySoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlaySound(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::PlaySoundRequest,::bosdyn::api::spot_cam::PlaySoundResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteSound : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteSound() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::DeleteSoundRequest, ::bosdyn::api::spot_cam::DeleteSoundResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::DeleteSoundRequest, ::bosdyn::api::spot_cam::DeleteSoundResponse>* streamer) {
                       return this->StreamedDeleteSound(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteSound() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteSound(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::DeleteSoundRequest* /*request*/, ::bosdyn::api::spot_cam::DeleteSoundResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteSound(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::DeleteSoundRequest,::bosdyn::api::spot_cam::DeleteSoundResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListSounds : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListSounds() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::ListSoundsRequest, ::bosdyn::api::spot_cam::ListSoundsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::ListSoundsRequest, ::bosdyn::api::spot_cam::ListSoundsResponse>* streamer) {
                       return this->StreamedListSounds(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListSounds() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListSounds(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ListSoundsRequest* /*request*/, ::bosdyn::api::spot_cam::ListSoundsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListSounds(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::ListSoundsRequest,::bosdyn::api::spot_cam::ListSoundsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetVolume() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetVolumeRequest, ::bosdyn::api::spot_cam::SetVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetVolumeRequest, ::bosdyn::api::spot_cam::SetVolumeResponse>* streamer) {
                       return this->StreamedSetVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::SetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetVolumeRequest,::bosdyn::api::spot_cam::SetVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVolume() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetVolumeRequest, ::bosdyn::api::spot_cam::GetVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetVolumeRequest, ::bosdyn::api::spot_cam::GetVolumeResponse>* streamer) {
                       return this->StreamedGetVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVolume(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetVolumeRequest* /*request*/, ::bosdyn::api::spot_cam::GetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetVolumeRequest,::bosdyn::api::spot_cam::GetVolumeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PlaySound<WithStreamedUnaryMethod_DeleteSound<WithStreamedUnaryMethod_ListSounds<WithStreamedUnaryMethod_SetVolume<WithStreamedUnaryMethod_GetVolume<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PlaySound<WithStreamedUnaryMethod_DeleteSound<WithStreamedUnaryMethod_ListSounds<WithStreamedUnaryMethod_SetVolume<WithStreamedUnaryMethod_GetVolume<Service > > > > > StreamedService;
};

// Query temperature and built-in test results.
class HealthService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.HealthService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // GetTemperature returns a list of thermometers in the system, and the temperature that they measure.
    virtual ::grpc::Status GetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetTemperatureResponse>> AsyncGetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetTemperatureResponse>>(AsyncGetTemperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetTemperatureResponse>> PrepareAsyncGetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetTemperatureResponse>>(PrepareAsyncGetTemperatureRaw(context, request, cq));
    }
    // GetBitStatus returns two lists; a list of system events, and a list of ways that the system is degraded;
    // for instance, a degredation may include a missing PTZ unit, or a missing USB storage device.
    virtual ::grpc::Status GetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetBITStatusResponse>> AsyncGetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetBITStatusResponse>>(AsyncGetBITStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetBITStatusResponse>> PrepareAsyncGetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetBITStatusResponse>>(PrepareAsyncGetBITStatusRaw(context, request, cq));
    }
    // ClearBitEvents clears out the events list of the BITStatus structure.
    virtual ::grpc::Status ClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ClearBITEventsResponse>> AsyncClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ClearBITEventsResponse>>(AsyncClearBITEventsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ClearBITEventsResponse>> PrepareAsyncClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ClearBITEventsResponse>>(PrepareAsyncClearBITEventsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // GetTemperature returns a list of thermometers in the system, and the temperature that they measure.
      virtual void GetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTemperature(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTemperature(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTemperature(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetBitStatus returns two lists; a list of system events, and a list of ways that the system is degraded;
      // for instance, a degredation may include a missing PTZ unit, or a missing USB storage device.
      virtual void GetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetBITStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBITStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBITStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // ClearBitEvents clears out the events list of the BITStatus structure.
      virtual void ClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClearBITEvents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ClearBITEvents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ClearBITEvents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetTemperatureResponse>* AsyncGetTemperatureRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetTemperatureResponse>* PrepareAsyncGetTemperatureRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetBITStatusResponse>* AsyncGetBITStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetBITStatusResponse>* PrepareAsyncGetBITStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ClearBITEventsResponse>* AsyncClearBITEventsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::ClearBITEventsResponse>* PrepareAsyncClearBITEventsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetTemperatureResponse>> AsyncGetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetTemperatureResponse>>(AsyncGetTemperatureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetTemperatureResponse>> PrepareAsyncGetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetTemperatureResponse>>(PrepareAsyncGetTemperatureRaw(context, request, cq));
    }
    ::grpc::Status GetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetBITStatusResponse>> AsyncGetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetBITStatusResponse>>(AsyncGetBITStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetBITStatusResponse>> PrepareAsyncGetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetBITStatusResponse>>(PrepareAsyncGetBITStatusRaw(context, request, cq));
    }
    ::grpc::Status ClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ClearBITEventsResponse>> AsyncClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ClearBITEventsResponse>>(AsyncClearBITEventsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ClearBITEventsResponse>> PrepareAsyncClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ClearBITEventsResponse>>(PrepareAsyncClearBITEventsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTemperature(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTemperature(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTemperature(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTemperature(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, std::function<void(::grpc::Status)>) override;
      void GetBITStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBITStatus(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBITStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBITStatus(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, std::function<void(::grpc::Status)>) override;
      void ClearBITEvents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ClearBITEvents(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ClearBITEvents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ClearBITEvents(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetTemperatureResponse>* AsyncGetTemperatureRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetTemperatureResponse>* PrepareAsyncGetTemperatureRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetBITStatusResponse>* AsyncGetBITStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetBITStatusResponse>* PrepareAsyncGetBITStatusRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ClearBITEventsResponse>* AsyncClearBITEventsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::ClearBITEventsResponse>* PrepareAsyncClearBITEventsRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetTemperature_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBITStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearBITEvents_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // GetTemperature returns a list of thermometers in the system, and the temperature that they measure.
    virtual ::grpc::Status GetTemperature(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response);
    // GetBitStatus returns two lists; a list of system events, and a list of ways that the system is degraded;
    // for instance, a degredation may include a missing PTZ unit, or a missing USB storage device.
    virtual ::grpc::Status GetBITStatus(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response);
    // ClearBitEvents clears out the events list of the BITStatus structure.
    virtual ::grpc::Status ClearBITEvents(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTemperature() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTemperature(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetTemperatureRequest* /*request*/, ::bosdyn::api::spot_cam::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTemperature(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetTemperatureResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBITStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBITStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetBITStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBITStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetBITStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetBITStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBITStatus(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetBITStatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearBITEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClearBITEvents() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ClearBITEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearBITEvents(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* /*request*/, ::bosdyn::api::spot_cam::ClearBITEventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearBITEvents(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::ClearBITEventsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetTemperature<WithAsyncMethod_GetBITStatus<WithAsyncMethod_ClearBITEvents<Service > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTemperature() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetTemperatureRequest, ::bosdyn::api::spot_cam::GetTemperatureResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetTemperatureRequest* request, ::bosdyn::api::spot_cam::GetTemperatureResponse* response) { return this->GetTemperature(context, request, response); }));}
    void SetMessageAllocatorFor_GetTemperature(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetTemperatureRequest, ::bosdyn::api::spot_cam::GetTemperatureResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetTemperatureRequest, ::bosdyn::api::spot_cam::GetTemperatureResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTemperature(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetTemperatureRequest* /*request*/, ::bosdyn::api::spot_cam::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTemperature(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetTemperatureRequest* /*request*/, ::bosdyn::api::spot_cam::GetTemperatureResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTemperature(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetTemperatureRequest* /*request*/, ::bosdyn::api::spot_cam::GetTemperatureResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBITStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBITStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetBITStatusRequest, ::bosdyn::api::spot_cam::GetBITStatusResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetBITStatusRequest* request, ::bosdyn::api::spot_cam::GetBITStatusResponse* response) { return this->GetBITStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetBITStatus(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetBITStatusRequest, ::bosdyn::api::spot_cam::GetBITStatusResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetBITStatusRequest, ::bosdyn::api::spot_cam::GetBITStatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBITStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBITStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetBITStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetBITStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBITStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetBITStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetBITStatusResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBITStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetBITStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetBITStatusResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ClearBITEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ClearBITEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ClearBITEventsRequest, ::bosdyn::api::spot_cam::ClearBITEventsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* request, ::bosdyn::api::spot_cam::ClearBITEventsResponse* response) { return this->ClearBITEvents(context, request, response); }));}
    void SetMessageAllocatorFor_ClearBITEvents(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::ClearBITEventsRequest, ::bosdyn::api::spot_cam::ClearBITEventsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::ClearBITEventsRequest, ::bosdyn::api::spot_cam::ClearBITEventsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ClearBITEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearBITEvents(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* /*request*/, ::bosdyn::api::spot_cam::ClearBITEventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClearBITEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* /*request*/, ::bosdyn::api::spot_cam::ClearBITEventsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClearBITEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* /*request*/, ::bosdyn::api::spot_cam::ClearBITEventsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetTemperature<ExperimentalWithCallbackMethod_GetBITStatus<ExperimentalWithCallbackMethod_ClearBITEvents<Service > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetTemperature<ExperimentalWithCallbackMethod_GetBITStatus<ExperimentalWithCallbackMethod_ClearBITEvents<Service > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTemperature() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTemperature(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetTemperatureRequest* /*request*/, ::bosdyn::api::spot_cam::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBITStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBITStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetBITStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBITStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetBITStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetBITStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearBITEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClearBITEvents() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ClearBITEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearBITEvents(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* /*request*/, ::bosdyn::api::spot_cam::ClearBITEventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTemperature() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTemperature(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetTemperatureRequest* /*request*/, ::bosdyn::api::spot_cam::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTemperature(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBITStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBITStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetBITStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBITStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetBITStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetBITStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBITStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearBITEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClearBITEvents() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ClearBITEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearBITEvents(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* /*request*/, ::bosdyn::api::spot_cam::ClearBITEventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearBITEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTemperature() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTemperature(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTemperature(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetTemperatureRequest* /*request*/, ::bosdyn::api::spot_cam::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTemperature(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTemperature(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBITStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBITStatus() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBITStatus(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBITStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBITStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetBITStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetBITStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBITStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBITStatus(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ClearBITEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ClearBITEvents() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClearBITEvents(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ClearBITEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearBITEvents(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* /*request*/, ::bosdyn::api::spot_cam::ClearBITEventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClearBITEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClearBITEvents(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTemperature : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTemperature() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetTemperatureRequest, ::bosdyn::api::spot_cam::GetTemperatureResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetTemperatureRequest, ::bosdyn::api::spot_cam::GetTemperatureResponse>* streamer) {
                       return this->StreamedGetTemperature(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTemperature() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTemperature(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetTemperatureRequest* /*request*/, ::bosdyn::api::spot_cam::GetTemperatureResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTemperature(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetTemperatureRequest,::bosdyn::api::spot_cam::GetTemperatureResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBITStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBITStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetBITStatusRequest, ::bosdyn::api::spot_cam::GetBITStatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetBITStatusRequest, ::bosdyn::api::spot_cam::GetBITStatusResponse>* streamer) {
                       return this->StreamedGetBITStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBITStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBITStatus(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetBITStatusRequest* /*request*/, ::bosdyn::api::spot_cam::GetBITStatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBITStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetBITStatusRequest,::bosdyn::api::spot_cam::GetBITStatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearBITEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClearBITEvents() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::ClearBITEventsRequest, ::bosdyn::api::spot_cam::ClearBITEventsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::ClearBITEventsRequest, ::bosdyn::api::spot_cam::ClearBITEventsResponse>* streamer) {
                       return this->StreamedClearBITEvents(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClearBITEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearBITEvents(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::ClearBITEventsRequest* /*request*/, ::bosdyn::api::spot_cam::ClearBITEventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearBITEvents(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::ClearBITEventsRequest,::bosdyn::api::spot_cam::ClearBITEventsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetTemperature<WithStreamedUnaryMethod_GetBITStatus<WithStreamedUnaryMethod_ClearBITEvents<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetTemperature<WithStreamedUnaryMethod_GetBITStatus<WithStreamedUnaryMethod_ClearBITEvents<Service > > > StreamedService;
};

// Modify or query network settings of the SpotCam and ICE resolution servers.
class NetworkService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.NetworkService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // SetICEConfiguration sets up parameters for ICE, including addresses for STUN and TURN services
    virtual ::grpc::Status SetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>> AsyncSetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>>(AsyncSetICEConfigurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>> PrepareAsyncSetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>>(PrepareAsyncSetICEConfigurationRaw(context, request, cq));
    }
    // GetICEConfiguration retrieves currently set parameters for ICE, including addresses for STUN and TURN services
    virtual ::grpc::Status GetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>> AsyncGetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>>(AsyncGetICEConfigurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>> PrepareAsyncGetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>>(PrepareAsyncGetICEConfigurationRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // SetICEConfiguration sets up parameters for ICE, including addresses for STUN and TURN services
      virtual void SetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // GetICEConfiguration retrieves currently set parameters for ICE, including addresses for STUN and TURN services
      virtual void GetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>* AsyncSetICEConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>* PrepareAsyncSetICEConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>* AsyncGetICEConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>* PrepareAsyncGetICEConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>> AsyncSetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>>(AsyncSetICEConfigurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>> PrepareAsyncSetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>>(PrepareAsyncSetICEConfigurationRaw(context, request, cq));
    }
    ::grpc::Status GetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>> AsyncGetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>>(AsyncGetICEConfigurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>> PrepareAsyncGetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>>(PrepareAsyncGetICEConfigurationRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void SetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void SetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void GetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetICEConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetICEConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>* AsyncSetICEConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>* PrepareAsyncSetICEConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>* AsyncGetICEConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>* PrepareAsyncGetICEConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetICEConfiguration_;
    const ::grpc::internal::RpcMethod rpcmethod_GetICEConfiguration_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // SetICEConfiguration sets up parameters for ICE, including addresses for STUN and TURN services
    virtual ::grpc::Status SetICEConfiguration(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response);
    // GetICEConfiguration retrieves currently set parameters for ICE, including addresses for STUN and TURN services
    virtual ::grpc::Status GetICEConfiguration(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetICEConfiguration() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetICEConfiguration(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::SetICEConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetICEConfiguration() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetICEConfiguration(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetICEConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetICEConfiguration<WithAsyncMethod_GetICEConfiguration<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetICEConfiguration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetICEConfigurationRequest, ::bosdyn::api::spot_cam::SetICEConfigurationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* response) { return this->SetICEConfiguration(context, request, response); }));}
    void SetMessageAllocatorFor_SetICEConfiguration(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::SetICEConfigurationRequest, ::bosdyn::api::spot_cam::SetICEConfigurationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::SetICEConfigurationRequest, ::bosdyn::api::spot_cam::SetICEConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetICEConfiguration(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetICEConfiguration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetICEConfiguration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetICEConfigurationRequest, ::bosdyn::api::spot_cam::GetICEConfigurationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* request, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* response) { return this->GetICEConfiguration(context, request, response); }));}
    void SetMessageAllocatorFor_GetICEConfiguration(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetICEConfigurationRequest, ::bosdyn::api::spot_cam::GetICEConfigurationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetICEConfigurationRequest, ::bosdyn::api::spot_cam::GetICEConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetICEConfiguration(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetICEConfiguration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_SetICEConfiguration<ExperimentalWithCallbackMethod_GetICEConfiguration<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_SetICEConfiguration<ExperimentalWithCallbackMethod_GetICEConfiguration<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetICEConfiguration() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetICEConfiguration() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetICEConfiguration() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetICEConfiguration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetICEConfiguration() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetICEConfiguration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetICEConfiguration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetICEConfiguration(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetICEConfiguration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetICEConfiguration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetICEConfiguration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetICEConfiguration(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetICEConfiguration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetICEConfiguration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetICEConfiguration() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::SetICEConfigurationRequest, ::bosdyn::api::spot_cam::SetICEConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::SetICEConfigurationRequest, ::bosdyn::api::spot_cam::SetICEConfigurationResponse>* streamer) {
                       return this->StreamedSetICEConfiguration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::SetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::SetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetICEConfiguration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::SetICEConfigurationRequest,::bosdyn::api::spot_cam::SetICEConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetICEConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetICEConfiguration() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetICEConfigurationRequest, ::bosdyn::api::spot_cam::GetICEConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetICEConfigurationRequest, ::bosdyn::api::spot_cam::GetICEConfigurationResponse>* streamer) {
                       return this->StreamedGetICEConfiguration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetICEConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetICEConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetICEConfigurationRequest* /*request*/, ::bosdyn::api::spot_cam::GetICEConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetICEConfiguration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetICEConfigurationRequest,::bosdyn::api::spot_cam::GetICEConfigurationResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetICEConfiguration<WithStreamedUnaryMethod_GetICEConfiguration<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetICEConfiguration<WithStreamedUnaryMethod_GetICEConfiguration<Service > > StreamedService;
};

// Query the version of the software release running on the SpotCam.
class VersionService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.spot_cam.VersionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>> AsyncGetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>>(AsyncGetSoftwareVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>> PrepareAsyncGetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>>(PrepareAsyncGetSoftwareVersionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSoftwareVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetSoftwareVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetSoftwareVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>* AsyncGetSoftwareVersionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>* PrepareAsyncGetSoftwareVersionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>> AsyncGetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>>(AsyncGetSoftwareVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>> PrepareAsyncGetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>>(PrepareAsyncGetSoftwareVersionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSoftwareVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSoftwareVersion(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetSoftwareVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetSoftwareVersion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>* AsyncGetSoftwareVersionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>* PrepareAsyncGetSoftwareVersionRaw(::grpc::ClientContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetSoftwareVersion_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetSoftwareVersion(::grpc::ServerContext* context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSoftwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSoftwareVersion() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetSoftwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSoftwareVersion(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* /*request*/, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSoftwareVersion(::grpc::ServerContext* context, ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetSoftwareVersion<Service > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetSoftwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetSoftwareVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetSoftwareVersionRequest, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* request, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* response) { return this->GetSoftwareVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetSoftwareVersion(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::spot_cam::GetSoftwareVersionRequest, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::spot_cam::GetSoftwareVersionRequest, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetSoftwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSoftwareVersion(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* /*request*/, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSoftwareVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* /*request*/, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSoftwareVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* /*request*/, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetSoftwareVersion<Service > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetSoftwareVersion<Service > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetSoftwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSoftwareVersion() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetSoftwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSoftwareVersion(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* /*request*/, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSoftwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSoftwareVersion() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetSoftwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSoftwareVersion(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* /*request*/, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSoftwareVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetSoftwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetSoftwareVersion() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSoftwareVersion(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetSoftwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSoftwareVersion(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* /*request*/, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetSoftwareVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetSoftwareVersion(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSoftwareVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSoftwareVersion() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::spot_cam::GetSoftwareVersionRequest, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::spot_cam::GetSoftwareVersionRequest, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse>* streamer) {
                       return this->StreamedGetSoftwareVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSoftwareVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSoftwareVersion(::grpc::ServerContext* /*context*/, const ::bosdyn::api::spot_cam::GetSoftwareVersionRequest* /*request*/, ::bosdyn::api::spot_cam::GetSoftwareVersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSoftwareVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::spot_cam::GetSoftwareVersionRequest,::bosdyn::api::spot_cam::GetSoftwareVersionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetSoftwareVersion<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetSoftwareVersion<Service > StreamedService;
};

}  // namespace spot_cam
}  // namespace api
}  // namespace bosdyn


#endif  // GRPC_bosdyn_2fapi_2fspot_5fcam_2fservice_2eproto__INCLUDED
