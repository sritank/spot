// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/spot_cam/logging.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/spot_cam/camera.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/data_chunk.pb.h"
#include "bosdyn/api/image.pb.h"
#include "bosdyn/api/geometry.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
namespace bosdyn {
namespace api {
namespace spot_cam {
class DebugRequest;
class DebugRequestDefaultTypeInternal;
extern DebugRequestDefaultTypeInternal _DebugRequest_default_instance_;
class DebugResponse;
class DebugResponseDefaultTypeInternal;
extern DebugResponseDefaultTypeInternal _DebugResponse_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
class DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class GetStatusRequest;
class GetStatusRequestDefaultTypeInternal;
extern GetStatusRequestDefaultTypeInternal _GetStatusRequest_default_instance_;
class GetStatusResponse;
class GetStatusResponseDefaultTypeInternal;
extern GetStatusResponseDefaultTypeInternal _GetStatusResponse_default_instance_;
class ListCamerasRequest;
class ListCamerasRequestDefaultTypeInternal;
extern ListCamerasRequestDefaultTypeInternal _ListCamerasRequest_default_instance_;
class ListCamerasResponse;
class ListCamerasResponseDefaultTypeInternal;
extern ListCamerasResponseDefaultTypeInternal _ListCamerasResponse_default_instance_;
class ListLogpointsRequest;
class ListLogpointsRequestDefaultTypeInternal;
extern ListLogpointsRequestDefaultTypeInternal _ListLogpointsRequest_default_instance_;
class ListLogpointsResponse;
class ListLogpointsResponseDefaultTypeInternal;
extern ListLogpointsResponseDefaultTypeInternal _ListLogpointsResponse_default_instance_;
class Logpoint;
class LogpointDefaultTypeInternal;
extern LogpointDefaultTypeInternal _Logpoint_default_instance_;
class Logpoint_Calibration;
class Logpoint_CalibrationDefaultTypeInternal;
extern Logpoint_CalibrationDefaultTypeInternal _Logpoint_Calibration_default_instance_;
class Logpoint_ImageParams;
class Logpoint_ImageParamsDefaultTypeInternal;
extern Logpoint_ImageParamsDefaultTypeInternal _Logpoint_ImageParams_default_instance_;
class RetrieveRawDataRequest;
class RetrieveRawDataRequestDefaultTypeInternal;
extern RetrieveRawDataRequestDefaultTypeInternal _RetrieveRawDataRequest_default_instance_;
class RetrieveRawDataResponse;
class RetrieveRawDataResponseDefaultTypeInternal;
extern RetrieveRawDataResponseDefaultTypeInternal _RetrieveRawDataResponse_default_instance_;
class RetrieveRequest;
class RetrieveRequestDefaultTypeInternal;
extern RetrieveRequestDefaultTypeInternal _RetrieveRequest_default_instance_;
class RetrieveResponse;
class RetrieveResponseDefaultTypeInternal;
extern RetrieveResponseDefaultTypeInternal _RetrieveResponse_default_instance_;
class SetPassphraseRequest;
class SetPassphraseRequestDefaultTypeInternal;
extern SetPassphraseRequestDefaultTypeInternal _SetPassphraseRequest_default_instance_;
class SetPassphraseResponse;
class SetPassphraseResponseDefaultTypeInternal;
extern SetPassphraseResponseDefaultTypeInternal _SetPassphraseResponse_default_instance_;
class StoreRequest;
class StoreRequestDefaultTypeInternal;
extern StoreRequestDefaultTypeInternal _StoreRequest_default_instance_;
class StoreResponse;
class StoreResponseDefaultTypeInternal;
extern StoreResponseDefaultTypeInternal _StoreResponse_default_instance_;
class TagRequest;
class TagRequestDefaultTypeInternal;
extern TagRequestDefaultTypeInternal _TagRequest_default_instance_;
class TagResponse;
class TagResponseDefaultTypeInternal;
extern TagResponseDefaultTypeInternal _TagResponse_default_instance_;
}  // namespace spot_cam
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::spot_cam::DebugRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::DebugRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::DebugResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::DebugResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::DeleteRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::DeleteRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::DeleteResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::DeleteResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::GetStatusRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::GetStatusRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::GetStatusResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::GetStatusResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::ListCamerasRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::ListCamerasRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::ListCamerasResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::ListCamerasResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::ListLogpointsRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::ListLogpointsRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::ListLogpointsResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::ListLogpointsResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::Logpoint* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(Arena*);
template<> ::bosdyn::api::spot_cam::Logpoint_Calibration* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint_Calibration>(Arena*);
template<> ::bosdyn::api::spot_cam::Logpoint_ImageParams* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint_ImageParams>(Arena*);
template<> ::bosdyn::api::spot_cam::RetrieveRawDataRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::RetrieveRawDataRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::RetrieveRawDataResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::RetrieveRawDataResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::RetrieveRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::RetrieveRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::RetrieveResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::RetrieveResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::SetPassphraseRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::SetPassphraseRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::SetPassphraseResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::SetPassphraseResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::StoreRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::StoreRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::StoreResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::StoreResponse>(Arena*);
template<> ::bosdyn::api::spot_cam::TagRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::TagRequest>(Arena*);
template<> ::bosdyn::api::spot_cam::TagResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot_cam::TagResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace spot_cam {

enum Logpoint_RecordType : int {
  Logpoint_RecordType_STILLIMAGE = 0,
  Logpoint_RecordType_Logpoint_RecordType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Logpoint_RecordType_Logpoint_RecordType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Logpoint_RecordType_IsValid(int value);
constexpr Logpoint_RecordType Logpoint_RecordType_RecordType_MIN = Logpoint_RecordType_STILLIMAGE;
constexpr Logpoint_RecordType Logpoint_RecordType_RecordType_MAX = Logpoint_RecordType_STILLIMAGE;
constexpr int Logpoint_RecordType_RecordType_ARRAYSIZE = Logpoint_RecordType_RecordType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Logpoint_RecordType_descriptor();
template<typename T>
inline const std::string& Logpoint_RecordType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Logpoint_RecordType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Logpoint_RecordType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Logpoint_RecordType_descriptor(), enum_t_value);
}
inline bool Logpoint_RecordType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Logpoint_RecordType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Logpoint_RecordType>(
    Logpoint_RecordType_descriptor(), name, value);
}
enum Logpoint_LogStatus : int {
  Logpoint_LogStatus_FAILED = 0,
  Logpoint_LogStatus_QUEUED = 1,
  Logpoint_LogStatus_COMPLETE = 2,
  Logpoint_LogStatus_UNKNOWN = -1,
  Logpoint_LogStatus_Logpoint_LogStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Logpoint_LogStatus_Logpoint_LogStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Logpoint_LogStatus_IsValid(int value);
constexpr Logpoint_LogStatus Logpoint_LogStatus_LogStatus_MIN = Logpoint_LogStatus_UNKNOWN;
constexpr Logpoint_LogStatus Logpoint_LogStatus_LogStatus_MAX = Logpoint_LogStatus_COMPLETE;
constexpr int Logpoint_LogStatus_LogStatus_ARRAYSIZE = Logpoint_LogStatus_LogStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Logpoint_LogStatus_descriptor();
template<typename T>
inline const std::string& Logpoint_LogStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Logpoint_LogStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Logpoint_LogStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Logpoint_LogStatus_descriptor(), enum_t_value);
}
inline bool Logpoint_LogStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Logpoint_LogStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Logpoint_LogStatus>(
    Logpoint_LogStatus_descriptor(), name, value);
}
// ===================================================================

class Logpoint_ImageParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.Logpoint.ImageParams) */ {
 public:
  inline Logpoint_ImageParams() : Logpoint_ImageParams(nullptr) {}
  virtual ~Logpoint_ImageParams();

  Logpoint_ImageParams(const Logpoint_ImageParams& from);
  Logpoint_ImageParams(Logpoint_ImageParams&& from) noexcept
    : Logpoint_ImageParams() {
    *this = ::std::move(from);
  }

  inline Logpoint_ImageParams& operator=(const Logpoint_ImageParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logpoint_ImageParams& operator=(Logpoint_ImageParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Logpoint_ImageParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logpoint_ImageParams* internal_default_instance() {
    return reinterpret_cast<const Logpoint_ImageParams*>(
               &_Logpoint_ImageParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Logpoint_ImageParams& a, Logpoint_ImageParams& b) {
    a.Swap(&b);
  }
  inline void Swap(Logpoint_ImageParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Logpoint_ImageParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Logpoint_ImageParams* New() const final {
    return CreateMaybeMessage<Logpoint_ImageParams>(nullptr);
  }

  Logpoint_ImageParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Logpoint_ImageParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Logpoint_ImageParams& from);
  void MergeFrom(const Logpoint_ImageParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logpoint_ImageParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.Logpoint.ImageParams";
  }
  protected:
  explicit Logpoint_ImageParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFormatFieldNumber = 3,
  };
  // int32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .bosdyn.api.Image.PixelFormat format = 3;
  void clear_format();
  ::bosdyn::api::Image_PixelFormat format() const;
  void set_format(::bosdyn::api::Image_PixelFormat value);
  private:
  ::bosdyn::api::Image_PixelFormat _internal_format() const;
  void _internal_set_format(::bosdyn::api::Image_PixelFormat value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.Logpoint.ImageParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  int format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class Logpoint_Calibration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.Logpoint.Calibration) */ {
 public:
  inline Logpoint_Calibration() : Logpoint_Calibration(nullptr) {}
  virtual ~Logpoint_Calibration();

  Logpoint_Calibration(const Logpoint_Calibration& from);
  Logpoint_Calibration(Logpoint_Calibration&& from) noexcept
    : Logpoint_Calibration() {
    *this = ::std::move(from);
  }

  inline Logpoint_Calibration& operator=(const Logpoint_Calibration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logpoint_Calibration& operator=(Logpoint_Calibration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Logpoint_Calibration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logpoint_Calibration* internal_default_instance() {
    return reinterpret_cast<const Logpoint_Calibration*>(
               &_Logpoint_Calibration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Logpoint_Calibration& a, Logpoint_Calibration& b) {
    a.Swap(&b);
  }
  inline void Swap(Logpoint_Calibration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Logpoint_Calibration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Logpoint_Calibration* New() const final {
    return CreateMaybeMessage<Logpoint_Calibration>(nullptr);
  }

  Logpoint_Calibration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Logpoint_Calibration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Logpoint_Calibration& from);
  void MergeFrom(const Logpoint_Calibration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logpoint_Calibration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.Logpoint.Calibration";
  }
  protected:
  explicit Logpoint_Calibration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFrameNameFieldNumber = 7,
    kBaseTfromSensorFieldNumber = 5,
    kIntrinsicsFieldNumber = 6,
    kXoffsetFieldNumber = 1,
    kYoffsetFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // string base_frame_name = 7;
  void clear_base_frame_name();
  const std::string& base_frame_name() const;
  void set_base_frame_name(const std::string& value);
  void set_base_frame_name(std::string&& value);
  void set_base_frame_name(const char* value);
  void set_base_frame_name(const char* value, size_t size);
  std::string* mutable_base_frame_name();
  std::string* release_base_frame_name();
  void set_allocated_base_frame_name(std::string* base_frame_name);
  private:
  const std::string& _internal_base_frame_name() const;
  void _internal_set_base_frame_name(const std::string& value);
  std::string* _internal_mutable_base_frame_name();
  public:

  // .bosdyn.api.SE3Pose base_tfrom_sensor = 5;
  bool has_base_tfrom_sensor() const;
  private:
  bool _internal_has_base_tfrom_sensor() const;
  public:
  void clear_base_tfrom_sensor();
  const ::bosdyn::api::SE3Pose& base_tfrom_sensor() const;
  ::bosdyn::api::SE3Pose* release_base_tfrom_sensor();
  ::bosdyn::api::SE3Pose* mutable_base_tfrom_sensor();
  void set_allocated_base_tfrom_sensor(::bosdyn::api::SE3Pose* base_tfrom_sensor);
  private:
  const ::bosdyn::api::SE3Pose& _internal_base_tfrom_sensor() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_base_tfrom_sensor();
  public:
  void unsafe_arena_set_allocated_base_tfrom_sensor(
      ::bosdyn::api::SE3Pose* base_tfrom_sensor);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_base_tfrom_sensor();

  // .bosdyn.api.spot_cam.Camera.PinholeIntrinsics intrinsics = 6;
  bool has_intrinsics() const;
  private:
  bool _internal_has_intrinsics() const;
  public:
  void clear_intrinsics();
  const ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics& intrinsics() const;
  ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* release_intrinsics();
  ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* mutable_intrinsics();
  void set_allocated_intrinsics(::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* intrinsics);
  private:
  const ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics& _internal_intrinsics() const;
  ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* _internal_mutable_intrinsics();
  public:
  void unsafe_arena_set_allocated_intrinsics(
      ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* intrinsics);
  ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* unsafe_arena_release_intrinsics();

  // int32 xoffset = 1;
  void clear_xoffset();
  ::PROTOBUF_NAMESPACE_ID::int32 xoffset() const;
  void set_xoffset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_xoffset() const;
  void _internal_set_xoffset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 yoffset = 2;
  void clear_yoffset();
  ::PROTOBUF_NAMESPACE_ID::int32 yoffset() const;
  void set_yoffset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_yoffset() const;
  void _internal_set_yoffset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 width = 3;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 height = 4;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.Logpoint.Calibration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_frame_name_;
  ::bosdyn::api::SE3Pose* base_tfrom_sensor_;
  ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* intrinsics_;
  ::PROTOBUF_NAMESPACE_ID::int32 xoffset_;
  ::PROTOBUF_NAMESPACE_ID::int32 yoffset_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class Logpoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.Logpoint) */ {
 public:
  inline Logpoint() : Logpoint(nullptr) {}
  virtual ~Logpoint();

  Logpoint(const Logpoint& from);
  Logpoint(Logpoint&& from) noexcept
    : Logpoint() {
    *this = ::std::move(from);
  }

  inline Logpoint& operator=(const Logpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Logpoint& operator=(Logpoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Logpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Logpoint* internal_default_instance() {
    return reinterpret_cast<const Logpoint*>(
               &_Logpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Logpoint& a, Logpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Logpoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Logpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Logpoint* New() const final {
    return CreateMaybeMessage<Logpoint>(nullptr);
  }

  Logpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Logpoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Logpoint& from);
  void MergeFrom(const Logpoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Logpoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.Logpoint";
  }
  protected:
  explicit Logpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Logpoint_ImageParams ImageParams;
  typedef Logpoint_Calibration Calibration;

  typedef Logpoint_RecordType RecordType;
  static constexpr RecordType STILLIMAGE =
    Logpoint_RecordType_STILLIMAGE;
  static inline bool RecordType_IsValid(int value) {
    return Logpoint_RecordType_IsValid(value);
  }
  static constexpr RecordType RecordType_MIN =
    Logpoint_RecordType_RecordType_MIN;
  static constexpr RecordType RecordType_MAX =
    Logpoint_RecordType_RecordType_MAX;
  static constexpr int RecordType_ARRAYSIZE =
    Logpoint_RecordType_RecordType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RecordType_descriptor() {
    return Logpoint_RecordType_descriptor();
  }
  template<typename T>
  static inline const std::string& RecordType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RecordType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RecordType_Name.");
    return Logpoint_RecordType_Name(enum_t_value);
  }
  static inline bool RecordType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RecordType* value) {
    return Logpoint_RecordType_Parse(name, value);
  }

  typedef Logpoint_LogStatus LogStatus;
  static constexpr LogStatus FAILED =
    Logpoint_LogStatus_FAILED;
  static constexpr LogStatus QUEUED =
    Logpoint_LogStatus_QUEUED;
  static constexpr LogStatus COMPLETE =
    Logpoint_LogStatus_COMPLETE;
  static constexpr LogStatus UNKNOWN =
    Logpoint_LogStatus_UNKNOWN;
  static inline bool LogStatus_IsValid(int value) {
    return Logpoint_LogStatus_IsValid(value);
  }
  static constexpr LogStatus LogStatus_MIN =
    Logpoint_LogStatus_LogStatus_MIN;
  static constexpr LogStatus LogStatus_MAX =
    Logpoint_LogStatus_LogStatus_MAX;
  static constexpr int LogStatus_ARRAYSIZE =
    Logpoint_LogStatus_LogStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LogStatus_descriptor() {
    return Logpoint_LogStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& LogStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogStatus_Name.");
    return Logpoint_LogStatus_Name(enum_t_value);
  }
  static inline bool LogStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LogStatus* value) {
    return Logpoint_LogStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCalibrationFieldNumber = 7,
    kNameFieldNumber = 1,
    kTagFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kImageParamsFieldNumber = 6,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // repeated .bosdyn.api.spot_cam.Logpoint.Calibration calibration = 7;
  int calibration_size() const;
  private:
  int _internal_calibration_size() const;
  public:
  void clear_calibration();
  ::bosdyn::api::spot_cam::Logpoint_Calibration* mutable_calibration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint_Calibration >*
      mutable_calibration();
  private:
  const ::bosdyn::api::spot_cam::Logpoint_Calibration& _internal_calibration(int index) const;
  ::bosdyn::api::spot_cam::Logpoint_Calibration* _internal_add_calibration();
  public:
  const ::bosdyn::api::spot_cam::Logpoint_Calibration& calibration(int index) const;
  ::bosdyn::api::spot_cam::Logpoint_Calibration* add_calibration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint_Calibration >&
      calibration() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string tag = 4;
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // .google.protobuf.Timestamp timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .bosdyn.api.spot_cam.Logpoint.ImageParams image_params = 6;
  bool has_image_params() const;
  private:
  bool _internal_has_image_params() const;
  public:
  void clear_image_params();
  const ::bosdyn::api::spot_cam::Logpoint_ImageParams& image_params() const;
  ::bosdyn::api::spot_cam::Logpoint_ImageParams* release_image_params();
  ::bosdyn::api::spot_cam::Logpoint_ImageParams* mutable_image_params();
  void set_allocated_image_params(::bosdyn::api::spot_cam::Logpoint_ImageParams* image_params);
  private:
  const ::bosdyn::api::spot_cam::Logpoint_ImageParams& _internal_image_params() const;
  ::bosdyn::api::spot_cam::Logpoint_ImageParams* _internal_mutable_image_params();
  public:
  void unsafe_arena_set_allocated_image_params(
      ::bosdyn::api::spot_cam::Logpoint_ImageParams* image_params);
  ::bosdyn::api::spot_cam::Logpoint_ImageParams* unsafe_arena_release_image_params();

  // .bosdyn.api.spot_cam.Logpoint.RecordType type = 2;
  void clear_type();
  ::bosdyn::api::spot_cam::Logpoint_RecordType type() const;
  void set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value);
  private:
  ::bosdyn::api::spot_cam::Logpoint_RecordType _internal_type() const;
  void _internal_set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value);
  public:

  // .bosdyn.api.spot_cam.Logpoint.LogStatus status = 3;
  void clear_status();
  ::bosdyn::api::spot_cam::Logpoint_LogStatus status() const;
  void set_status(::bosdyn::api::spot_cam::Logpoint_LogStatus value);
  private:
  ::bosdyn::api::spot_cam::Logpoint_LogStatus _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot_cam::Logpoint_LogStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.Logpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint_Calibration > calibration_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  ::bosdyn::api::spot_cam::Logpoint_ImageParams* image_params_;
  int type_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(nullptr);
  }

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::spot_cam::Logpoint& point() const;
  ::bosdyn::api::spot_cam::Logpoint* release_point();
  ::bosdyn::api::spot_cam::Logpoint* mutable_point();
  void set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_point() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::spot_cam::Logpoint* point);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.DeleteResponse) */ {
 public:
  inline DeleteResponse() : DeleteResponse(nullptr) {}
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const final {
    return CreateMaybeMessage<DeleteResponse>(nullptr);
  }

  DeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.DeleteResponse";
  }
  protected:
  explicit DeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.DeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class GetStatusRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.GetStatusRequest) */ {
 public:
  inline GetStatusRequest() : GetStatusRequest(nullptr) {}
  virtual ~GetStatusRequest();

  GetStatusRequest(const GetStatusRequest& from);
  GetStatusRequest(GetStatusRequest&& from) noexcept
    : GetStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetStatusRequest& operator=(const GetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusRequest& operator=(GetStatusRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetStatusRequest*>(
               &_GetStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetStatusRequest& a, GetStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStatusRequest* New() const final {
    return CreateMaybeMessage<GetStatusRequest>(nullptr);
  }

  GetStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStatusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetStatusRequest& from);
  void MergeFrom(const GetStatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.GetStatusRequest";
  }
  protected:
  explicit GetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::spot_cam::Logpoint& point() const;
  ::bosdyn::api::spot_cam::Logpoint* release_point();
  ::bosdyn::api::spot_cam::Logpoint* mutable_point();
  void set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_point() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::spot_cam::Logpoint* point);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.GetStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class GetStatusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.GetStatusResponse) */ {
 public:
  inline GetStatusResponse() : GetStatusResponse(nullptr) {}
  virtual ~GetStatusResponse();

  GetStatusResponse(const GetStatusResponse& from);
  GetStatusResponse(GetStatusResponse&& from) noexcept
    : GetStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetStatusResponse& operator=(const GetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusResponse& operator=(GetStatusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetStatusResponse*>(
               &_GetStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetStatusResponse& a, GetStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStatusResponse* New() const final {
    return CreateMaybeMessage<GetStatusResponse>(nullptr);
  }

  GetStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetStatusResponse& from);
  void MergeFrom(const GetStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.GetStatusResponse";
  }
  protected:
  explicit GetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::spot_cam::Logpoint& point() const;
  ::bosdyn::api::spot_cam::Logpoint* release_point();
  ::bosdyn::api::spot_cam::Logpoint* mutable_point();
  void set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_point() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::spot_cam::Logpoint* point);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.GetStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class RetrieveRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.RetrieveRequest) */ {
 public:
  inline RetrieveRequest() : RetrieveRequest(nullptr) {}
  virtual ~RetrieveRequest();

  RetrieveRequest(const RetrieveRequest& from);
  RetrieveRequest(RetrieveRequest&& from) noexcept
    : RetrieveRequest() {
    *this = ::std::move(from);
  }

  inline RetrieveRequest& operator=(const RetrieveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetrieveRequest& operator=(RetrieveRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RetrieveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetrieveRequest* internal_default_instance() {
    return reinterpret_cast<const RetrieveRequest*>(
               &_RetrieveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RetrieveRequest& a, RetrieveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RetrieveRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetrieveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RetrieveRequest* New() const final {
    return CreateMaybeMessage<RetrieveRequest>(nullptr);
  }

  RetrieveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RetrieveRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RetrieveRequest& from);
  void MergeFrom(const RetrieveRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetrieveRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.RetrieveRequest";
  }
  protected:
  explicit RetrieveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::spot_cam::Logpoint& point() const;
  ::bosdyn::api::spot_cam::Logpoint* release_point();
  ::bosdyn::api::spot_cam::Logpoint* mutable_point();
  void set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_point() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::spot_cam::Logpoint* point);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.RetrieveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class RetrieveResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.RetrieveResponse) */ {
 public:
  inline RetrieveResponse() : RetrieveResponse(nullptr) {}
  virtual ~RetrieveResponse();

  RetrieveResponse(const RetrieveResponse& from);
  RetrieveResponse(RetrieveResponse&& from) noexcept
    : RetrieveResponse() {
    *this = ::std::move(from);
  }

  inline RetrieveResponse& operator=(const RetrieveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetrieveResponse& operator=(RetrieveResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RetrieveResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetrieveResponse* internal_default_instance() {
    return reinterpret_cast<const RetrieveResponse*>(
               &_RetrieveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RetrieveResponse& a, RetrieveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RetrieveResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetrieveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RetrieveResponse* New() const final {
    return CreateMaybeMessage<RetrieveResponse>(nullptr);
  }

  RetrieveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RetrieveResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RetrieveResponse& from);
  void MergeFrom(const RetrieveResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetrieveResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.RetrieveResponse";
  }
  protected:
  explicit RetrieveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLogpointFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint logpoint = 2;
  bool has_logpoint() const;
  private:
  bool _internal_has_logpoint() const;
  public:
  void clear_logpoint();
  const ::bosdyn::api::spot_cam::Logpoint& logpoint() const;
  ::bosdyn::api::spot_cam::Logpoint* release_logpoint();
  ::bosdyn::api::spot_cam::Logpoint* mutable_logpoint();
  void set_allocated_logpoint(::bosdyn::api::spot_cam::Logpoint* logpoint);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_logpoint() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_logpoint();
  public:
  void unsafe_arena_set_allocated_logpoint(
      ::bosdyn::api::spot_cam::Logpoint* logpoint);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_logpoint();

  // .bosdyn.api.DataChunk data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::bosdyn::api::DataChunk& data() const;
  ::bosdyn::api::DataChunk* release_data();
  ::bosdyn::api::DataChunk* mutable_data();
  void set_allocated_data(::bosdyn::api::DataChunk* data);
  private:
  const ::bosdyn::api::DataChunk& _internal_data() const;
  ::bosdyn::api::DataChunk* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::bosdyn::api::DataChunk* data);
  ::bosdyn::api::DataChunk* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.RetrieveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* logpoint_;
  ::bosdyn::api::DataChunk* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class RetrieveRawDataRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.RetrieveRawDataRequest) */ {
 public:
  inline RetrieveRawDataRequest() : RetrieveRawDataRequest(nullptr) {}
  virtual ~RetrieveRawDataRequest();

  RetrieveRawDataRequest(const RetrieveRawDataRequest& from);
  RetrieveRawDataRequest(RetrieveRawDataRequest&& from) noexcept
    : RetrieveRawDataRequest() {
    *this = ::std::move(from);
  }

  inline RetrieveRawDataRequest& operator=(const RetrieveRawDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetrieveRawDataRequest& operator=(RetrieveRawDataRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RetrieveRawDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetrieveRawDataRequest* internal_default_instance() {
    return reinterpret_cast<const RetrieveRawDataRequest*>(
               &_RetrieveRawDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RetrieveRawDataRequest& a, RetrieveRawDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RetrieveRawDataRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetrieveRawDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RetrieveRawDataRequest* New() const final {
    return CreateMaybeMessage<RetrieveRawDataRequest>(nullptr);
  }

  RetrieveRawDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RetrieveRawDataRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RetrieveRawDataRequest& from);
  void MergeFrom(const RetrieveRawDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetrieveRawDataRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.RetrieveRawDataRequest";
  }
  protected:
  explicit RetrieveRawDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::spot_cam::Logpoint& point() const;
  ::bosdyn::api::spot_cam::Logpoint* release_point();
  ::bosdyn::api::spot_cam::Logpoint* mutable_point();
  void set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_point() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::spot_cam::Logpoint* point);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.RetrieveRawDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class RetrieveRawDataResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.RetrieveRawDataResponse) */ {
 public:
  inline RetrieveRawDataResponse() : RetrieveRawDataResponse(nullptr) {}
  virtual ~RetrieveRawDataResponse();

  RetrieveRawDataResponse(const RetrieveRawDataResponse& from);
  RetrieveRawDataResponse(RetrieveRawDataResponse&& from) noexcept
    : RetrieveRawDataResponse() {
    *this = ::std::move(from);
  }

  inline RetrieveRawDataResponse& operator=(const RetrieveRawDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RetrieveRawDataResponse& operator=(RetrieveRawDataResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RetrieveRawDataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RetrieveRawDataResponse* internal_default_instance() {
    return reinterpret_cast<const RetrieveRawDataResponse*>(
               &_RetrieveRawDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RetrieveRawDataResponse& a, RetrieveRawDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RetrieveRawDataResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RetrieveRawDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RetrieveRawDataResponse* New() const final {
    return CreateMaybeMessage<RetrieveRawDataResponse>(nullptr);
  }

  RetrieveRawDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RetrieveRawDataResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RetrieveRawDataResponse& from);
  void MergeFrom(const RetrieveRawDataResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RetrieveRawDataResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.RetrieveRawDataResponse";
  }
  protected:
  explicit RetrieveRawDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLogpointFieldNumber = 2,
    kDataFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint logpoint = 2;
  bool has_logpoint() const;
  private:
  bool _internal_has_logpoint() const;
  public:
  void clear_logpoint();
  const ::bosdyn::api::spot_cam::Logpoint& logpoint() const;
  ::bosdyn::api::spot_cam::Logpoint* release_logpoint();
  ::bosdyn::api::spot_cam::Logpoint* mutable_logpoint();
  void set_allocated_logpoint(::bosdyn::api::spot_cam::Logpoint* logpoint);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_logpoint() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_logpoint();
  public:
  void unsafe_arena_set_allocated_logpoint(
      ::bosdyn::api::spot_cam::Logpoint* logpoint);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_logpoint();

  // .bosdyn.api.DataChunk data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::bosdyn::api::DataChunk& data() const;
  ::bosdyn::api::DataChunk* release_data();
  ::bosdyn::api::DataChunk* mutable_data();
  void set_allocated_data(::bosdyn::api::DataChunk* data);
  private:
  const ::bosdyn::api::DataChunk& _internal_data() const;
  ::bosdyn::api::DataChunk* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::bosdyn::api::DataChunk* data);
  ::bosdyn::api::DataChunk* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.RetrieveRawDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* logpoint_;
  ::bosdyn::api::DataChunk* data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class StoreRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.StoreRequest) */ {
 public:
  inline StoreRequest() : StoreRequest(nullptr) {}
  virtual ~StoreRequest();

  StoreRequest(const StoreRequest& from);
  StoreRequest(StoreRequest&& from) noexcept
    : StoreRequest() {
    *this = ::std::move(from);
  }

  inline StoreRequest& operator=(const StoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreRequest& operator=(StoreRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StoreRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreRequest* internal_default_instance() {
    return reinterpret_cast<const StoreRequest*>(
               &_StoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StoreRequest& a, StoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreRequest* New() const final {
    return CreateMaybeMessage<StoreRequest>(nullptr);
  }

  StoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StoreRequest& from);
  void MergeFrom(const StoreRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.StoreRequest";
  }
  protected:
  explicit StoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kCameraFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string tag = 4;
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Camera camera = 2;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::bosdyn::api::spot_cam::Camera& camera() const;
  ::bosdyn::api::spot_cam::Camera* release_camera();
  ::bosdyn::api::spot_cam::Camera* mutable_camera();
  void set_allocated_camera(::bosdyn::api::spot_cam::Camera* camera);
  private:
  const ::bosdyn::api::spot_cam::Camera& _internal_camera() const;
  ::bosdyn::api::spot_cam::Camera* _internal_mutable_camera();
  public:
  void unsafe_arena_set_allocated_camera(
      ::bosdyn::api::spot_cam::Camera* camera);
  ::bosdyn::api::spot_cam::Camera* unsafe_arena_release_camera();

  // .bosdyn.api.spot_cam.Logpoint.RecordType type = 3;
  void clear_type();
  ::bosdyn::api::spot_cam::Logpoint_RecordType type() const;
  void set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value);
  private:
  ::bosdyn::api::spot_cam::Logpoint_RecordType _internal_type() const;
  void _internal_set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.StoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::spot_cam::Camera* camera_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class StoreResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.StoreResponse) */ {
 public:
  inline StoreResponse() : StoreResponse(nullptr) {}
  virtual ~StoreResponse();

  StoreResponse(const StoreResponse& from);
  StoreResponse(StoreResponse&& from) noexcept
    : StoreResponse() {
    *this = ::std::move(from);
  }

  inline StoreResponse& operator=(const StoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreResponse& operator=(StoreResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StoreResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreResponse* internal_default_instance() {
    return reinterpret_cast<const StoreResponse*>(
               &_StoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StoreResponse& a, StoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreResponse* New() const final {
    return CreateMaybeMessage<StoreResponse>(nullptr);
  }

  StoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StoreResponse& from);
  void MergeFrom(const StoreResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.StoreResponse";
  }
  protected:
  explicit StoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::spot_cam::Logpoint& point() const;
  ::bosdyn::api::spot_cam::Logpoint* release_point();
  ::bosdyn::api::spot_cam::Logpoint* mutable_point();
  void set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_point() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::spot_cam::Logpoint* point);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.StoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class TagRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.TagRequest) */ {
 public:
  inline TagRequest() : TagRequest(nullptr) {}
  virtual ~TagRequest();

  TagRequest(const TagRequest& from);
  TagRequest(TagRequest&& from) noexcept
    : TagRequest() {
    *this = ::std::move(from);
  }

  inline TagRequest& operator=(const TagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagRequest& operator=(TagRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TagRequest* internal_default_instance() {
    return reinterpret_cast<const TagRequest*>(
               &_TagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TagRequest& a, TagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TagRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagRequest* New() const final {
    return CreateMaybeMessage<TagRequest>(nullptr);
  }

  TagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TagRequest& from);
  void MergeFrom(const TagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.TagRequest";
  }
  protected:
  explicit TagRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPointFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot_cam.Logpoint point = 2;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::bosdyn::api::spot_cam::Logpoint& point() const;
  ::bosdyn::api::spot_cam::Logpoint* release_point();
  ::bosdyn::api::spot_cam::Logpoint* mutable_point();
  void set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point);
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_point() const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::bosdyn::api::spot_cam::Logpoint* point);
  ::bosdyn::api::spot_cam::Logpoint* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.TagRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::spot_cam::Logpoint* point_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class TagResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.TagResponse) */ {
 public:
  inline TagResponse() : TagResponse(nullptr) {}
  virtual ~TagResponse();

  TagResponse(const TagResponse& from);
  TagResponse(TagResponse&& from) noexcept
    : TagResponse() {
    *this = ::std::move(from);
  }

  inline TagResponse& operator=(const TagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TagResponse& operator=(TagResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TagResponse* internal_default_instance() {
    return reinterpret_cast<const TagResponse*>(
               &_TagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TagResponse& a, TagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TagResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TagResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TagResponse* New() const final {
    return CreateMaybeMessage<TagResponse>(nullptr);
  }

  TagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TagResponse& from);
  void MergeFrom(const TagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.TagResponse";
  }
  protected:
  explicit TagResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.TagResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class ListCamerasRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.ListCamerasRequest) */ {
 public:
  inline ListCamerasRequest() : ListCamerasRequest(nullptr) {}
  virtual ~ListCamerasRequest();

  ListCamerasRequest(const ListCamerasRequest& from);
  ListCamerasRequest(ListCamerasRequest&& from) noexcept
    : ListCamerasRequest() {
    *this = ::std::move(from);
  }

  inline ListCamerasRequest& operator=(const ListCamerasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCamerasRequest& operator=(ListCamerasRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListCamerasRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListCamerasRequest* internal_default_instance() {
    return reinterpret_cast<const ListCamerasRequest*>(
               &_ListCamerasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListCamerasRequest& a, ListCamerasRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListCamerasRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCamerasRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListCamerasRequest* New() const final {
    return CreateMaybeMessage<ListCamerasRequest>(nullptr);
  }

  ListCamerasRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListCamerasRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListCamerasRequest& from);
  void MergeFrom(const ListCamerasRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCamerasRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.ListCamerasRequest";
  }
  protected:
  explicit ListCamerasRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.ListCamerasRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class ListCamerasResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.ListCamerasResponse) */ {
 public:
  inline ListCamerasResponse() : ListCamerasResponse(nullptr) {}
  virtual ~ListCamerasResponse();

  ListCamerasResponse(const ListCamerasResponse& from);
  ListCamerasResponse(ListCamerasResponse&& from) noexcept
    : ListCamerasResponse() {
    *this = ::std::move(from);
  }

  inline ListCamerasResponse& operator=(const ListCamerasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCamerasResponse& operator=(ListCamerasResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListCamerasResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListCamerasResponse* internal_default_instance() {
    return reinterpret_cast<const ListCamerasResponse*>(
               &_ListCamerasResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ListCamerasResponse& a, ListCamerasResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListCamerasResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCamerasResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListCamerasResponse* New() const final {
    return CreateMaybeMessage<ListCamerasResponse>(nullptr);
  }

  ListCamerasResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListCamerasResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListCamerasResponse& from);
  void MergeFrom(const ListCamerasResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCamerasResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.ListCamerasResponse";
  }
  protected:
  explicit ListCamerasResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCamerasFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.spot_cam.Camera cameras = 2;
  int cameras_size() const;
  private:
  int _internal_cameras_size() const;
  public:
  void clear_cameras();
  ::bosdyn::api::spot_cam::Camera* mutable_cameras(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Camera >*
      mutable_cameras();
  private:
  const ::bosdyn::api::spot_cam::Camera& _internal_cameras(int index) const;
  ::bosdyn::api::spot_cam::Camera* _internal_add_cameras();
  public:
  const ::bosdyn::api::spot_cam::Camera& cameras(int index) const;
  ::bosdyn::api::spot_cam::Camera* add_cameras();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Camera >&
      cameras() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.ListCamerasResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Camera > cameras_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class ListLogpointsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.ListLogpointsRequest) */ {
 public:
  inline ListLogpointsRequest() : ListLogpointsRequest(nullptr) {}
  virtual ~ListLogpointsRequest();

  ListLogpointsRequest(const ListLogpointsRequest& from);
  ListLogpointsRequest(ListLogpointsRequest&& from) noexcept
    : ListLogpointsRequest() {
    *this = ::std::move(from);
  }

  inline ListLogpointsRequest& operator=(const ListLogpointsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLogpointsRequest& operator=(ListLogpointsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListLogpointsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListLogpointsRequest* internal_default_instance() {
    return reinterpret_cast<const ListLogpointsRequest*>(
               &_ListLogpointsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListLogpointsRequest& a, ListLogpointsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLogpointsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLogpointsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListLogpointsRequest* New() const final {
    return CreateMaybeMessage<ListLogpointsRequest>(nullptr);
  }

  ListLogpointsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListLogpointsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListLogpointsRequest& from);
  void MergeFrom(const ListLogpointsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLogpointsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.ListLogpointsRequest";
  }
  protected:
  explicit ListLogpointsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.ListLogpointsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class ListLogpointsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.ListLogpointsResponse) */ {
 public:
  inline ListLogpointsResponse() : ListLogpointsResponse(nullptr) {}
  virtual ~ListLogpointsResponse();

  ListLogpointsResponse(const ListLogpointsResponse& from);
  ListLogpointsResponse(ListLogpointsResponse&& from) noexcept
    : ListLogpointsResponse() {
    *this = ::std::move(from);
  }

  inline ListLogpointsResponse& operator=(const ListLogpointsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListLogpointsResponse& operator=(ListLogpointsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListLogpointsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListLogpointsResponse* internal_default_instance() {
    return reinterpret_cast<const ListLogpointsResponse*>(
               &_ListLogpointsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListLogpointsResponse& a, ListLogpointsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListLogpointsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListLogpointsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListLogpointsResponse* New() const final {
    return CreateMaybeMessage<ListLogpointsResponse>(nullptr);
  }

  ListLogpointsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListLogpointsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListLogpointsResponse& from);
  void MergeFrom(const ListLogpointsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListLogpointsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.ListLogpointsResponse";
  }
  protected:
  explicit ListLogpointsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogpointsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.spot_cam.Logpoint logpoints = 2;
  int logpoints_size() const;
  private:
  int _internal_logpoints_size() const;
  public:
  void clear_logpoints();
  ::bosdyn::api::spot_cam::Logpoint* mutable_logpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint >*
      mutable_logpoints();
  private:
  const ::bosdyn::api::spot_cam::Logpoint& _internal_logpoints(int index) const;
  ::bosdyn::api::spot_cam::Logpoint* _internal_add_logpoints();
  public:
  const ::bosdyn::api::spot_cam::Logpoint& logpoints(int index) const;
  ::bosdyn::api::spot_cam::Logpoint* add_logpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint >&
      logpoints() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.ListLogpointsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint > logpoints_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class SetPassphraseRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.SetPassphraseRequest) */ {
 public:
  inline SetPassphraseRequest() : SetPassphraseRequest(nullptr) {}
  virtual ~SetPassphraseRequest();

  SetPassphraseRequest(const SetPassphraseRequest& from);
  SetPassphraseRequest(SetPassphraseRequest&& from) noexcept
    : SetPassphraseRequest() {
    *this = ::std::move(from);
  }

  inline SetPassphraseRequest& operator=(const SetPassphraseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPassphraseRequest& operator=(SetPassphraseRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetPassphraseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetPassphraseRequest* internal_default_instance() {
    return reinterpret_cast<const SetPassphraseRequest*>(
               &_SetPassphraseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SetPassphraseRequest& a, SetPassphraseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPassphraseRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPassphraseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetPassphraseRequest* New() const final {
    return CreateMaybeMessage<SetPassphraseRequest>(nullptr);
  }

  SetPassphraseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetPassphraseRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetPassphraseRequest& from);
  void MergeFrom(const SetPassphraseRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPassphraseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.SetPassphraseRequest";
  }
  protected:
  explicit SetPassphraseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPassphraseFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string passphrase = 2;
  void clear_passphrase();
  const std::string& passphrase() const;
  void set_passphrase(const std::string& value);
  void set_passphrase(std::string&& value);
  void set_passphrase(const char* value);
  void set_passphrase(const char* value, size_t size);
  std::string* mutable_passphrase();
  std::string* release_passphrase();
  void set_allocated_passphrase(std::string* passphrase);
  private:
  const std::string& _internal_passphrase() const;
  void _internal_set_passphrase(const std::string& value);
  std::string* _internal_mutable_passphrase();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.SetPassphraseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passphrase_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class SetPassphraseResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.SetPassphraseResponse) */ {
 public:
  inline SetPassphraseResponse() : SetPassphraseResponse(nullptr) {}
  virtual ~SetPassphraseResponse();

  SetPassphraseResponse(const SetPassphraseResponse& from);
  SetPassphraseResponse(SetPassphraseResponse&& from) noexcept
    : SetPassphraseResponse() {
    *this = ::std::move(from);
  }

  inline SetPassphraseResponse& operator=(const SetPassphraseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPassphraseResponse& operator=(SetPassphraseResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetPassphraseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetPassphraseResponse* internal_default_instance() {
    return reinterpret_cast<const SetPassphraseResponse*>(
               &_SetPassphraseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SetPassphraseResponse& a, SetPassphraseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPassphraseResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPassphraseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetPassphraseResponse* New() const final {
    return CreateMaybeMessage<SetPassphraseResponse>(nullptr);
  }

  SetPassphraseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetPassphraseResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetPassphraseResponse& from);
  void MergeFrom(const SetPassphraseResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPassphraseResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.SetPassphraseResponse";
  }
  protected:
  explicit SetPassphraseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.SetPassphraseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class DebugRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.DebugRequest) */ {
 public:
  inline DebugRequest() : DebugRequest(nullptr) {}
  virtual ~DebugRequest();

  DebugRequest(const DebugRequest& from);
  DebugRequest(DebugRequest&& from) noexcept
    : DebugRequest() {
    *this = ::std::move(from);
  }

  inline DebugRequest& operator=(const DebugRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugRequest& operator=(DebugRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugRequest* internal_default_instance() {
    return reinterpret_cast<const DebugRequest*>(
               &_DebugRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DebugRequest& a, DebugRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugRequest* New() const final {
    return CreateMaybeMessage<DebugRequest>(nullptr);
  }

  DebugRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugRequest& from);
  void MergeFrom(const DebugRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.DebugRequest";
  }
  protected:
  explicit DebugRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEnableTemperatureFieldNumber = 2,
    kEnableHumidityFieldNumber = 3,
    kEnableBITFieldNumber = 4,
    kEnableShockFieldNumber = 5,
    kEnableSystemStatFieldNumber = 6,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // bool enable_temperature = 2;
  void clear_enable_temperature();
  bool enable_temperature() const;
  void set_enable_temperature(bool value);
  private:
  bool _internal_enable_temperature() const;
  void _internal_set_enable_temperature(bool value);
  public:

  // bool enable_humidity = 3;
  void clear_enable_humidity();
  bool enable_humidity() const;
  void set_enable_humidity(bool value);
  private:
  bool _internal_enable_humidity() const;
  void _internal_set_enable_humidity(bool value);
  public:

  // bool enable_BIT = 4;
  void clear_enable_bit();
  bool enable_bit() const;
  void set_enable_bit(bool value);
  private:
  bool _internal_enable_bit() const;
  void _internal_set_enable_bit(bool value);
  public:

  // bool enable_shock = 5;
  void clear_enable_shock();
  bool enable_shock() const;
  void set_enable_shock(bool value);
  private:
  bool _internal_enable_shock() const;
  void _internal_set_enable_shock(bool value);
  public:

  // bool enable_system_stat = 6;
  void clear_enable_system_stat();
  bool enable_system_stat() const;
  void set_enable_system_stat(bool value);
  private:
  bool _internal_enable_system_stat() const;
  void _internal_set_enable_system_stat(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.DebugRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  bool enable_temperature_;
  bool enable_humidity_;
  bool enable_bit_;
  bool enable_shock_;
  bool enable_system_stat_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// -------------------------------------------------------------------

class DebugResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot_cam.DebugResponse) */ {
 public:
  inline DebugResponse() : DebugResponse(nullptr) {}
  virtual ~DebugResponse();

  DebugResponse(const DebugResponse& from);
  DebugResponse(DebugResponse&& from) noexcept
    : DebugResponse() {
    *this = ::std::move(from);
  }

  inline DebugResponse& operator=(const DebugResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugResponse& operator=(DebugResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DebugResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DebugResponse* internal_default_instance() {
    return reinterpret_cast<const DebugResponse*>(
               &_DebugResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DebugResponse& a, DebugResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DebugResponse* New() const final {
    return CreateMaybeMessage<DebugResponse>(nullptr);
  }

  DebugResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DebugResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DebugResponse& from);
  void MergeFrom(const DebugResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot_cam.DebugResponse";
  }
  protected:
  explicit DebugResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot_cam.DebugResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Logpoint_ImageParams

// int32 width = 1;
inline void Logpoint_ImageParams::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_ImageParams::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_ImageParams::width() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.ImageParams.width)
  return _internal_width();
}
inline void Logpoint_ImageParams::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void Logpoint_ImageParams::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.ImageParams.width)
}

// int32 height = 2;
inline void Logpoint_ImageParams::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_ImageParams::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_ImageParams::height() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.ImageParams.height)
  return _internal_height();
}
inline void Logpoint_ImageParams::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void Logpoint_ImageParams::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.ImageParams.height)
}

// .bosdyn.api.Image.PixelFormat format = 3;
inline void Logpoint_ImageParams::clear_format() {
  format_ = 0;
}
inline ::bosdyn::api::Image_PixelFormat Logpoint_ImageParams::_internal_format() const {
  return static_cast< ::bosdyn::api::Image_PixelFormat >(format_);
}
inline ::bosdyn::api::Image_PixelFormat Logpoint_ImageParams::format() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.ImageParams.format)
  return _internal_format();
}
inline void Logpoint_ImageParams::_internal_set_format(::bosdyn::api::Image_PixelFormat value) {
  
  format_ = value;
}
inline void Logpoint_ImageParams::set_format(::bosdyn::api::Image_PixelFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.ImageParams.format)
}

// -------------------------------------------------------------------

// Logpoint_Calibration

// int32 xoffset = 1;
inline void Logpoint_Calibration::clear_xoffset() {
  xoffset_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_Calibration::_internal_xoffset() const {
  return xoffset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_Calibration::xoffset() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.Calibration.xoffset)
  return _internal_xoffset();
}
inline void Logpoint_Calibration::_internal_set_xoffset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  xoffset_ = value;
}
inline void Logpoint_Calibration::set_xoffset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_xoffset(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.Calibration.xoffset)
}

// int32 yoffset = 2;
inline void Logpoint_Calibration::clear_yoffset() {
  yoffset_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_Calibration::_internal_yoffset() const {
  return yoffset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_Calibration::yoffset() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.Calibration.yoffset)
  return _internal_yoffset();
}
inline void Logpoint_Calibration::_internal_set_yoffset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  yoffset_ = value;
}
inline void Logpoint_Calibration::set_yoffset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_yoffset(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.Calibration.yoffset)
}

// int32 width = 3;
inline void Logpoint_Calibration::clear_width() {
  width_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_Calibration::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_Calibration::width() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.Calibration.width)
  return _internal_width();
}
inline void Logpoint_Calibration::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  width_ = value;
}
inline void Logpoint_Calibration::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.Calibration.width)
}

// int32 height = 4;
inline void Logpoint_Calibration::clear_height() {
  height_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_Calibration::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Logpoint_Calibration::height() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.Calibration.height)
  return _internal_height();
}
inline void Logpoint_Calibration::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  height_ = value;
}
inline void Logpoint_Calibration::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.Calibration.height)
}

// string base_frame_name = 7;
inline void Logpoint_Calibration::clear_base_frame_name() {
  base_frame_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Logpoint_Calibration::base_frame_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.Calibration.base_frame_name)
  return _internal_base_frame_name();
}
inline void Logpoint_Calibration::set_base_frame_name(const std::string& value) {
  _internal_set_base_frame_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.Calibration.base_frame_name)
}
inline std::string* Logpoint_Calibration::mutable_base_frame_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.Logpoint.Calibration.base_frame_name)
  return _internal_mutable_base_frame_name();
}
inline const std::string& Logpoint_Calibration::_internal_base_frame_name() const {
  return base_frame_name_.Get();
}
inline void Logpoint_Calibration::_internal_set_base_frame_name(const std::string& value) {
  
  base_frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Logpoint_Calibration::set_base_frame_name(std::string&& value) {
  
  base_frame_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.spot_cam.Logpoint.Calibration.base_frame_name)
}
inline void Logpoint_Calibration::set_base_frame_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  base_frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot_cam.Logpoint.Calibration.base_frame_name)
}
inline void Logpoint_Calibration::set_base_frame_name(const char* value,
    size_t size) {
  
  base_frame_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot_cam.Logpoint.Calibration.base_frame_name)
}
inline std::string* Logpoint_Calibration::_internal_mutable_base_frame_name() {
  
  return base_frame_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Logpoint_Calibration::release_base_frame_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.Logpoint.Calibration.base_frame_name)
  return base_frame_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Logpoint_Calibration::set_allocated_base_frame_name(std::string* base_frame_name) {
  if (base_frame_name != nullptr) {
    
  } else {
    
  }
  base_frame_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), base_frame_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.Logpoint.Calibration.base_frame_name)
}

// .bosdyn.api.SE3Pose base_tfrom_sensor = 5;
inline bool Logpoint_Calibration::_internal_has_base_tfrom_sensor() const {
  return this != internal_default_instance() && base_tfrom_sensor_ != nullptr;
}
inline bool Logpoint_Calibration::has_base_tfrom_sensor() const {
  return _internal_has_base_tfrom_sensor();
}
inline const ::bosdyn::api::SE3Pose& Logpoint_Calibration::_internal_base_tfrom_sensor() const {
  const ::bosdyn::api::SE3Pose* p = base_tfrom_sensor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Pose*>(
      &::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Logpoint_Calibration::base_tfrom_sensor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.Calibration.base_tfrom_sensor)
  return _internal_base_tfrom_sensor();
}
inline void Logpoint_Calibration::unsafe_arena_set_allocated_base_tfrom_sensor(
    ::bosdyn::api::SE3Pose* base_tfrom_sensor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_tfrom_sensor_);
  }
  base_tfrom_sensor_ = base_tfrom_sensor;
  if (base_tfrom_sensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.Logpoint.Calibration.base_tfrom_sensor)
}
inline ::bosdyn::api::SE3Pose* Logpoint_Calibration::release_base_tfrom_sensor() {
  
  ::bosdyn::api::SE3Pose* temp = base_tfrom_sensor_;
  base_tfrom_sensor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Pose* Logpoint_Calibration::unsafe_arena_release_base_tfrom_sensor() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.Logpoint.Calibration.base_tfrom_sensor)
  
  ::bosdyn::api::SE3Pose* temp = base_tfrom_sensor_;
  base_tfrom_sensor_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Logpoint_Calibration::_internal_mutable_base_tfrom_sensor() {
  
  if (base_tfrom_sensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArena());
    base_tfrom_sensor_ = p;
  }
  return base_tfrom_sensor_;
}
inline ::bosdyn::api::SE3Pose* Logpoint_Calibration::mutable_base_tfrom_sensor() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.Logpoint.Calibration.base_tfrom_sensor)
  return _internal_mutable_base_tfrom_sensor();
}
inline void Logpoint_Calibration::set_allocated_base_tfrom_sensor(::bosdyn::api::SE3Pose* base_tfrom_sensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_tfrom_sensor_);
  }
  if (base_tfrom_sensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_tfrom_sensor)->GetArena();
    if (message_arena != submessage_arena) {
      base_tfrom_sensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_tfrom_sensor, submessage_arena);
    }
    
  } else {
    
  }
  base_tfrom_sensor_ = base_tfrom_sensor;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.Logpoint.Calibration.base_tfrom_sensor)
}

// .bosdyn.api.spot_cam.Camera.PinholeIntrinsics intrinsics = 6;
inline bool Logpoint_Calibration::_internal_has_intrinsics() const {
  return this != internal_default_instance() && intrinsics_ != nullptr;
}
inline bool Logpoint_Calibration::has_intrinsics() const {
  return _internal_has_intrinsics();
}
inline const ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics& Logpoint_Calibration::_internal_intrinsics() const {
  const ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* p = intrinsics_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics*>(
      &::bosdyn::api::spot_cam::_Camera_PinholeIntrinsics_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics& Logpoint_Calibration::intrinsics() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.Calibration.intrinsics)
  return _internal_intrinsics();
}
inline void Logpoint_Calibration::unsafe_arena_set_allocated_intrinsics(
    ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* intrinsics) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(intrinsics_);
  }
  intrinsics_ = intrinsics;
  if (intrinsics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.Logpoint.Calibration.intrinsics)
}
inline ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* Logpoint_Calibration::release_intrinsics() {
  
  ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* temp = intrinsics_;
  intrinsics_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* Logpoint_Calibration::unsafe_arena_release_intrinsics() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.Logpoint.Calibration.intrinsics)
  
  ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* temp = intrinsics_;
  intrinsics_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* Logpoint_Calibration::_internal_mutable_intrinsics() {
  
  if (intrinsics_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Camera_PinholeIntrinsics>(GetArena());
    intrinsics_ = p;
  }
  return intrinsics_;
}
inline ::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* Logpoint_Calibration::mutable_intrinsics() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.Logpoint.Calibration.intrinsics)
  return _internal_mutable_intrinsics();
}
inline void Logpoint_Calibration::set_allocated_intrinsics(::bosdyn::api::spot_cam::Camera_PinholeIntrinsics* intrinsics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(intrinsics_);
  }
  if (intrinsics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(intrinsics)->GetArena();
    if (message_arena != submessage_arena) {
      intrinsics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intrinsics, submessage_arena);
    }
    
  } else {
    
  }
  intrinsics_ = intrinsics;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.Logpoint.Calibration.intrinsics)
}

// -------------------------------------------------------------------

// Logpoint

// string name = 1;
inline void Logpoint::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Logpoint::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.name)
  return _internal_name();
}
inline void Logpoint::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.name)
}
inline std::string* Logpoint::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.Logpoint.name)
  return _internal_mutable_name();
}
inline const std::string& Logpoint::_internal_name() const {
  return name_.Get();
}
inline void Logpoint::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Logpoint::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.spot_cam.Logpoint.name)
}
inline void Logpoint::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot_cam.Logpoint.name)
}
inline void Logpoint::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot_cam.Logpoint.name)
}
inline std::string* Logpoint::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Logpoint::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.Logpoint.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Logpoint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.Logpoint.name)
}

// .bosdyn.api.spot_cam.Logpoint.RecordType type = 2;
inline void Logpoint::clear_type() {
  type_ = 0;
}
inline ::bosdyn::api::spot_cam::Logpoint_RecordType Logpoint::_internal_type() const {
  return static_cast< ::bosdyn::api::spot_cam::Logpoint_RecordType >(type_);
}
inline ::bosdyn::api::spot_cam::Logpoint_RecordType Logpoint::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.type)
  return _internal_type();
}
inline void Logpoint::_internal_set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value) {
  
  type_ = value;
}
inline void Logpoint::set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.type)
}

// .bosdyn.api.spot_cam.Logpoint.LogStatus status = 3;
inline void Logpoint::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::spot_cam::Logpoint_LogStatus Logpoint::_internal_status() const {
  return static_cast< ::bosdyn::api::spot_cam::Logpoint_LogStatus >(status_);
}
inline ::bosdyn::api::spot_cam::Logpoint_LogStatus Logpoint::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.status)
  return _internal_status();
}
inline void Logpoint::_internal_set_status(::bosdyn::api::spot_cam::Logpoint_LogStatus value) {
  
  status_ = value;
}
inline void Logpoint::set_status(::bosdyn::api::spot_cam::Logpoint_LogStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.status)
}

// string tag = 4;
inline void Logpoint::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Logpoint::tag() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.tag)
  return _internal_tag();
}
inline void Logpoint::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.Logpoint.tag)
}
inline std::string* Logpoint::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.Logpoint.tag)
  return _internal_mutable_tag();
}
inline const std::string& Logpoint::_internal_tag() const {
  return tag_.Get();
}
inline void Logpoint::_internal_set_tag(const std::string& value) {
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Logpoint::set_tag(std::string&& value) {
  
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.spot_cam.Logpoint.tag)
}
inline void Logpoint::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot_cam.Logpoint.tag)
}
inline void Logpoint::set_tag(const char* value,
    size_t size) {
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot_cam.Logpoint.tag)
}
inline std::string* Logpoint::_internal_mutable_tag() {
  
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Logpoint::release_tag() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.Logpoint.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Logpoint::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.Logpoint.tag)
}

// .google.protobuf.Timestamp timestamp = 5;
inline bool Logpoint::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Logpoint::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Logpoint::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Logpoint::timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.timestamp)
  return _internal_timestamp();
}
inline void Logpoint::unsafe_arena_set_allocated_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.Logpoint.timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Logpoint::release_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Logpoint::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.Logpoint.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Logpoint::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Logpoint::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.Logpoint.timestamp)
  return _internal_mutable_timestamp();
}
inline void Logpoint::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.Logpoint.timestamp)
}

// .bosdyn.api.spot_cam.Logpoint.ImageParams image_params = 6;
inline bool Logpoint::_internal_has_image_params() const {
  return this != internal_default_instance() && image_params_ != nullptr;
}
inline bool Logpoint::has_image_params() const {
  return _internal_has_image_params();
}
inline void Logpoint::clear_image_params() {
  if (GetArena() == nullptr && image_params_ != nullptr) {
    delete image_params_;
  }
  image_params_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint_ImageParams& Logpoint::_internal_image_params() const {
  const ::bosdyn::api::spot_cam::Logpoint_ImageParams* p = image_params_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint_ImageParams*>(
      &::bosdyn::api::spot_cam::_Logpoint_ImageParams_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint_ImageParams& Logpoint::image_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.image_params)
  return _internal_image_params();
}
inline void Logpoint::unsafe_arena_set_allocated_image_params(
    ::bosdyn::api::spot_cam::Logpoint_ImageParams* image_params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_params_);
  }
  image_params_ = image_params;
  if (image_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.Logpoint.image_params)
}
inline ::bosdyn::api::spot_cam::Logpoint_ImageParams* Logpoint::release_image_params() {
  
  ::bosdyn::api::spot_cam::Logpoint_ImageParams* temp = image_params_;
  image_params_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint_ImageParams* Logpoint::unsafe_arena_release_image_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.Logpoint.image_params)
  
  ::bosdyn::api::spot_cam::Logpoint_ImageParams* temp = image_params_;
  image_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint_ImageParams* Logpoint::_internal_mutable_image_params() {
  
  if (image_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint_ImageParams>(GetArena());
    image_params_ = p;
  }
  return image_params_;
}
inline ::bosdyn::api::spot_cam::Logpoint_ImageParams* Logpoint::mutable_image_params() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.Logpoint.image_params)
  return _internal_mutable_image_params();
}
inline void Logpoint::set_allocated_image_params(::bosdyn::api::spot_cam::Logpoint_ImageParams* image_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete image_params_;
  }
  if (image_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(image_params);
    if (message_arena != submessage_arena) {
      image_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_params, submessage_arena);
    }
    
  } else {
    
  }
  image_params_ = image_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.Logpoint.image_params)
}

// repeated .bosdyn.api.spot_cam.Logpoint.Calibration calibration = 7;
inline int Logpoint::_internal_calibration_size() const {
  return calibration_.size();
}
inline int Logpoint::calibration_size() const {
  return _internal_calibration_size();
}
inline void Logpoint::clear_calibration() {
  calibration_.Clear();
}
inline ::bosdyn::api::spot_cam::Logpoint_Calibration* Logpoint::mutable_calibration(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.Logpoint.calibration)
  return calibration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint_Calibration >*
Logpoint::mutable_calibration() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot_cam.Logpoint.calibration)
  return &calibration_;
}
inline const ::bosdyn::api::spot_cam::Logpoint_Calibration& Logpoint::_internal_calibration(int index) const {
  return calibration_.Get(index);
}
inline const ::bosdyn::api::spot_cam::Logpoint_Calibration& Logpoint::calibration(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.Logpoint.calibration)
  return _internal_calibration(index);
}
inline ::bosdyn::api::spot_cam::Logpoint_Calibration* Logpoint::_internal_add_calibration() {
  return calibration_.Add();
}
inline ::bosdyn::api::spot_cam::Logpoint_Calibration* Logpoint::add_calibration() {
  // @@protoc_insertion_point(field_add:bosdyn.api.spot_cam.Logpoint.calibration)
  return _internal_add_calibration();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint_Calibration >&
Logpoint::calibration() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot_cam.Logpoint.calibration)
  return calibration_;
}

// -------------------------------------------------------------------

// DeleteRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DeleteRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DeleteRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DeleteRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DeleteRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DeleteRequest.header)
  return _internal_header();
}
inline void DeleteRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.DeleteRequest.header)
}
inline ::bosdyn::api::RequestHeader* DeleteRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeleteRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.DeleteRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeleteRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* DeleteRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.DeleteRequest.header)
  return _internal_mutable_header();
}
inline void DeleteRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.DeleteRequest.header)
}

// .bosdyn.api.spot_cam.Logpoint point = 2;
inline bool DeleteRequest::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool DeleteRequest::has_point() const {
  return _internal_has_point();
}
inline void DeleteRequest::clear_point() {
  if (GetArena() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& DeleteRequest::_internal_point() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& DeleteRequest::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DeleteRequest.point)
  return _internal_point();
}
inline void DeleteRequest::unsafe_arena_set_allocated_point(
    ::bosdyn::api::spot_cam::Logpoint* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.DeleteRequest.point)
}
inline ::bosdyn::api::spot_cam::Logpoint* DeleteRequest::release_point() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* DeleteRequest::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.DeleteRequest.point)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* DeleteRequest::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::bosdyn::api::spot_cam::Logpoint* DeleteRequest::mutable_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.DeleteRequest.point)
  return _internal_mutable_point();
}
inline void DeleteRequest::set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.DeleteRequest.point)
}

// -------------------------------------------------------------------

// DeleteResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DeleteResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DeleteResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DeleteResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DeleteResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DeleteResponse.header)
  return _internal_header();
}
inline void DeleteResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.DeleteResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DeleteResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeleteResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.DeleteResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeleteResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* DeleteResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.DeleteResponse.header)
  return _internal_mutable_header();
}
inline void DeleteResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.DeleteResponse.header)
}

// -------------------------------------------------------------------

// GetStatusRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetStatusRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetStatusRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetStatusRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetStatusRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetStatusRequest.header)
  return _internal_header();
}
inline void GetStatusRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetStatusRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetStatusRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetStatusRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetStatusRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetStatusRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* GetStatusRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetStatusRequest.header)
  return _internal_mutable_header();
}
inline void GetStatusRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetStatusRequest.header)
}

// .bosdyn.api.spot_cam.Logpoint point = 2;
inline bool GetStatusRequest::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool GetStatusRequest::has_point() const {
  return _internal_has_point();
}
inline void GetStatusRequest::clear_point() {
  if (GetArena() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& GetStatusRequest::_internal_point() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& GetStatusRequest::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetStatusRequest.point)
  return _internal_point();
}
inline void GetStatusRequest::unsafe_arena_set_allocated_point(
    ::bosdyn::api::spot_cam::Logpoint* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetStatusRequest.point)
}
inline ::bosdyn::api::spot_cam::Logpoint* GetStatusRequest::release_point() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* GetStatusRequest::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetStatusRequest.point)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* GetStatusRequest::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::bosdyn::api::spot_cam::Logpoint* GetStatusRequest::mutable_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetStatusRequest.point)
  return _internal_mutable_point();
}
inline void GetStatusRequest::set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetStatusRequest.point)
}

// -------------------------------------------------------------------

// GetStatusResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetStatusResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetStatusResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetStatusResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetStatusResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetStatusResponse.header)
  return _internal_header();
}
inline void GetStatusResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetStatusResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetStatusResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetStatusResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetStatusResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetStatusResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* GetStatusResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetStatusResponse.header)
  return _internal_mutable_header();
}
inline void GetStatusResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetStatusResponse.header)
}

// .bosdyn.api.spot_cam.Logpoint point = 2;
inline bool GetStatusResponse::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool GetStatusResponse::has_point() const {
  return _internal_has_point();
}
inline void GetStatusResponse::clear_point() {
  if (GetArena() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& GetStatusResponse::_internal_point() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& GetStatusResponse::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.GetStatusResponse.point)
  return _internal_point();
}
inline void GetStatusResponse::unsafe_arena_set_allocated_point(
    ::bosdyn::api::spot_cam::Logpoint* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.GetStatusResponse.point)
}
inline ::bosdyn::api::spot_cam::Logpoint* GetStatusResponse::release_point() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* GetStatusResponse::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.GetStatusResponse.point)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* GetStatusResponse::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::bosdyn::api::spot_cam::Logpoint* GetStatusResponse::mutable_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.GetStatusResponse.point)
  return _internal_mutable_point();
}
inline void GetStatusResponse::set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.GetStatusResponse.point)
}

// -------------------------------------------------------------------

// RetrieveRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RetrieveRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RetrieveRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RetrieveRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RetrieveRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveRequest.header)
  return _internal_header();
}
inline void RetrieveRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveRequest.header)
}
inline ::bosdyn::api::RequestHeader* RetrieveRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RetrieveRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RetrieveRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RetrieveRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveRequest.header)
  return _internal_mutable_header();
}
inline void RetrieveRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveRequest.header)
}

// .bosdyn.api.spot_cam.Logpoint point = 2;
inline bool RetrieveRequest::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool RetrieveRequest::has_point() const {
  return _internal_has_point();
}
inline void RetrieveRequest::clear_point() {
  if (GetArena() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& RetrieveRequest::_internal_point() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& RetrieveRequest::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveRequest.point)
  return _internal_point();
}
inline void RetrieveRequest::unsafe_arena_set_allocated_point(
    ::bosdyn::api::spot_cam::Logpoint* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveRequest.point)
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRequest::release_point() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRequest::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveRequest.point)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRequest::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRequest::mutable_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveRequest.point)
  return _internal_mutable_point();
}
inline void RetrieveRequest::set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveRequest.point)
}

// -------------------------------------------------------------------

// RetrieveResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RetrieveResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RetrieveResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RetrieveResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RetrieveResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveResponse.header)
  return _internal_header();
}
inline void RetrieveResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RetrieveResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RetrieveResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RetrieveResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RetrieveResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveResponse.header)
  return _internal_mutable_header();
}
inline void RetrieveResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveResponse.header)
}

// .bosdyn.api.spot_cam.Logpoint logpoint = 2;
inline bool RetrieveResponse::_internal_has_logpoint() const {
  return this != internal_default_instance() && logpoint_ != nullptr;
}
inline bool RetrieveResponse::has_logpoint() const {
  return _internal_has_logpoint();
}
inline void RetrieveResponse::clear_logpoint() {
  if (GetArena() == nullptr && logpoint_ != nullptr) {
    delete logpoint_;
  }
  logpoint_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& RetrieveResponse::_internal_logpoint() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = logpoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& RetrieveResponse::logpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveResponse.logpoint)
  return _internal_logpoint();
}
inline void RetrieveResponse::unsafe_arena_set_allocated_logpoint(
    ::bosdyn::api::spot_cam::Logpoint* logpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logpoint_);
  }
  logpoint_ = logpoint;
  if (logpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveResponse.logpoint)
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveResponse::release_logpoint() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = logpoint_;
  logpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveResponse::unsafe_arena_release_logpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveResponse.logpoint)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = logpoint_;
  logpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveResponse::_internal_mutable_logpoint() {
  
  if (logpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    logpoint_ = p;
  }
  return logpoint_;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveResponse::mutable_logpoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveResponse.logpoint)
  return _internal_mutable_logpoint();
}
inline void RetrieveResponse::set_allocated_logpoint(::bosdyn::api::spot_cam::Logpoint* logpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete logpoint_;
  }
  if (logpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(logpoint);
    if (message_arena != submessage_arena) {
      logpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logpoint, submessage_arena);
    }
    
  } else {
    
  }
  logpoint_ = logpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveResponse.logpoint)
}

// .bosdyn.api.DataChunk data = 3;
inline bool RetrieveResponse::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool RetrieveResponse::has_data() const {
  return _internal_has_data();
}
inline const ::bosdyn::api::DataChunk& RetrieveResponse::_internal_data() const {
  const ::bosdyn::api::DataChunk* p = data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::DataChunk*>(
      &::bosdyn::api::_DataChunk_default_instance_);
}
inline const ::bosdyn::api::DataChunk& RetrieveResponse::data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveResponse.data)
  return _internal_data();
}
inline void RetrieveResponse::unsafe_arena_set_allocated_data(
    ::bosdyn::api::DataChunk* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveResponse.data)
}
inline ::bosdyn::api::DataChunk* RetrieveResponse::release_data() {
  
  ::bosdyn::api::DataChunk* temp = data_;
  data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::DataChunk* RetrieveResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveResponse.data)
  
  ::bosdyn::api::DataChunk* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataChunk* RetrieveResponse::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataChunk>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::bosdyn::api::DataChunk* RetrieveResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveResponse.data)
  return _internal_mutable_data();
}
inline void RetrieveResponse::set_allocated_data(::bosdyn::api::DataChunk* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data)->GetArena();
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveResponse.data)
}

// -------------------------------------------------------------------

// RetrieveRawDataRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RetrieveRawDataRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RetrieveRawDataRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RetrieveRawDataRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RetrieveRawDataRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveRawDataRequest.header)
  return _internal_header();
}
inline void RetrieveRawDataRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataRequest.header)
}
inline ::bosdyn::api::RequestHeader* RetrieveRawDataRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RetrieveRawDataRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveRawDataRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RetrieveRawDataRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RetrieveRawDataRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveRawDataRequest.header)
  return _internal_mutable_header();
}
inline void RetrieveRawDataRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataRequest.header)
}

// .bosdyn.api.spot_cam.Logpoint point = 2;
inline bool RetrieveRawDataRequest::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool RetrieveRawDataRequest::has_point() const {
  return _internal_has_point();
}
inline void RetrieveRawDataRequest::clear_point() {
  if (GetArena() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& RetrieveRawDataRequest::_internal_point() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& RetrieveRawDataRequest::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveRawDataRequest.point)
  return _internal_point();
}
inline void RetrieveRawDataRequest::unsafe_arena_set_allocated_point(
    ::bosdyn::api::spot_cam::Logpoint* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataRequest.point)
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRawDataRequest::release_point() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRawDataRequest::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveRawDataRequest.point)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRawDataRequest::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRawDataRequest::mutable_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveRawDataRequest.point)
  return _internal_mutable_point();
}
inline void RetrieveRawDataRequest::set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataRequest.point)
}

// -------------------------------------------------------------------

// RetrieveRawDataResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RetrieveRawDataResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RetrieveRawDataResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RetrieveRawDataResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RetrieveRawDataResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveRawDataResponse.header)
  return _internal_header();
}
inline void RetrieveRawDataResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RetrieveRawDataResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RetrieveRawDataResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveRawDataResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RetrieveRawDataResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RetrieveRawDataResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveRawDataResponse.header)
  return _internal_mutable_header();
}
inline void RetrieveRawDataResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataResponse.header)
}

// .bosdyn.api.spot_cam.Logpoint logpoint = 2;
inline bool RetrieveRawDataResponse::_internal_has_logpoint() const {
  return this != internal_default_instance() && logpoint_ != nullptr;
}
inline bool RetrieveRawDataResponse::has_logpoint() const {
  return _internal_has_logpoint();
}
inline void RetrieveRawDataResponse::clear_logpoint() {
  if (GetArena() == nullptr && logpoint_ != nullptr) {
    delete logpoint_;
  }
  logpoint_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& RetrieveRawDataResponse::_internal_logpoint() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = logpoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& RetrieveRawDataResponse::logpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveRawDataResponse.logpoint)
  return _internal_logpoint();
}
inline void RetrieveRawDataResponse::unsafe_arena_set_allocated_logpoint(
    ::bosdyn::api::spot_cam::Logpoint* logpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logpoint_);
  }
  logpoint_ = logpoint;
  if (logpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataResponse.logpoint)
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRawDataResponse::release_logpoint() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = logpoint_;
  logpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRawDataResponse::unsafe_arena_release_logpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveRawDataResponse.logpoint)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = logpoint_;
  logpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRawDataResponse::_internal_mutable_logpoint() {
  
  if (logpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    logpoint_ = p;
  }
  return logpoint_;
}
inline ::bosdyn::api::spot_cam::Logpoint* RetrieveRawDataResponse::mutable_logpoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveRawDataResponse.logpoint)
  return _internal_mutable_logpoint();
}
inline void RetrieveRawDataResponse::set_allocated_logpoint(::bosdyn::api::spot_cam::Logpoint* logpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete logpoint_;
  }
  if (logpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(logpoint);
    if (message_arena != submessage_arena) {
      logpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logpoint, submessage_arena);
    }
    
  } else {
    
  }
  logpoint_ = logpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataResponse.logpoint)
}

// .bosdyn.api.DataChunk data = 3;
inline bool RetrieveRawDataResponse::_internal_has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline bool RetrieveRawDataResponse::has_data() const {
  return _internal_has_data();
}
inline const ::bosdyn::api::DataChunk& RetrieveRawDataResponse::_internal_data() const {
  const ::bosdyn::api::DataChunk* p = data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::DataChunk*>(
      &::bosdyn::api::_DataChunk_default_instance_);
}
inline const ::bosdyn::api::DataChunk& RetrieveRawDataResponse::data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.RetrieveRawDataResponse.data)
  return _internal_data();
}
inline void RetrieveRawDataResponse::unsafe_arena_set_allocated_data(
    ::bosdyn::api::DataChunk* data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataResponse.data)
}
inline ::bosdyn::api::DataChunk* RetrieveRawDataResponse::release_data() {
  
  ::bosdyn::api::DataChunk* temp = data_;
  data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::DataChunk* RetrieveRawDataResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.RetrieveRawDataResponse.data)
  
  ::bosdyn::api::DataChunk* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DataChunk* RetrieveRawDataResponse::_internal_mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DataChunk>(GetArena());
    data_ = p;
  }
  return data_;
}
inline ::bosdyn::api::DataChunk* RetrieveRawDataResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.RetrieveRawDataResponse.data)
  return _internal_mutable_data();
}
inline void RetrieveRawDataResponse::set_allocated_data(::bosdyn::api::DataChunk* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data)->GetArena();
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.RetrieveRawDataResponse.data)
}

// -------------------------------------------------------------------

// StoreRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool StoreRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool StoreRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& StoreRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& StoreRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.StoreRequest.header)
  return _internal_header();
}
inline void StoreRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.StoreRequest.header)
}
inline ::bosdyn::api::RequestHeader* StoreRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.StoreRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* StoreRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* StoreRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.StoreRequest.header)
  return _internal_mutable_header();
}
inline void StoreRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.StoreRequest.header)
}

// .bosdyn.api.spot_cam.Camera camera = 2;
inline bool StoreRequest::_internal_has_camera() const {
  return this != internal_default_instance() && camera_ != nullptr;
}
inline bool StoreRequest::has_camera() const {
  return _internal_has_camera();
}
inline const ::bosdyn::api::spot_cam::Camera& StoreRequest::_internal_camera() const {
  const ::bosdyn::api::spot_cam::Camera* p = camera_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Camera*>(
      &::bosdyn::api::spot_cam::_Camera_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Camera& StoreRequest::camera() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.StoreRequest.camera)
  return _internal_camera();
}
inline void StoreRequest::unsafe_arena_set_allocated_camera(
    ::bosdyn::api::spot_cam::Camera* camera) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_);
  }
  camera_ = camera;
  if (camera) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.StoreRequest.camera)
}
inline ::bosdyn::api::spot_cam::Camera* StoreRequest::release_camera() {
  
  ::bosdyn::api::spot_cam::Camera* temp = camera_;
  camera_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Camera* StoreRequest::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.StoreRequest.camera)
  
  ::bosdyn::api::spot_cam::Camera* temp = camera_;
  camera_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Camera* StoreRequest::_internal_mutable_camera() {
  
  if (camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Camera>(GetArena());
    camera_ = p;
  }
  return camera_;
}
inline ::bosdyn::api::spot_cam::Camera* StoreRequest::mutable_camera() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.StoreRequest.camera)
  return _internal_mutable_camera();
}
inline void StoreRequest::set_allocated_camera(::bosdyn::api::spot_cam::Camera* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_);
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera)->GetArena();
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    
  } else {
    
  }
  camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.StoreRequest.camera)
}

// .bosdyn.api.spot_cam.Logpoint.RecordType type = 3;
inline void StoreRequest::clear_type() {
  type_ = 0;
}
inline ::bosdyn::api::spot_cam::Logpoint_RecordType StoreRequest::_internal_type() const {
  return static_cast< ::bosdyn::api::spot_cam::Logpoint_RecordType >(type_);
}
inline ::bosdyn::api::spot_cam::Logpoint_RecordType StoreRequest::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.StoreRequest.type)
  return _internal_type();
}
inline void StoreRequest::_internal_set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value) {
  
  type_ = value;
}
inline void StoreRequest::set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.StoreRequest.type)
}

// string tag = 4;
inline void StoreRequest::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& StoreRequest::tag() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.StoreRequest.tag)
  return _internal_tag();
}
inline void StoreRequest::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.StoreRequest.tag)
}
inline std::string* StoreRequest::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.StoreRequest.tag)
  return _internal_mutable_tag();
}
inline const std::string& StoreRequest::_internal_tag() const {
  return tag_.Get();
}
inline void StoreRequest::_internal_set_tag(const std::string& value) {
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StoreRequest::set_tag(std::string&& value) {
  
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.spot_cam.StoreRequest.tag)
}
inline void StoreRequest::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot_cam.StoreRequest.tag)
}
inline void StoreRequest::set_tag(const char* value,
    size_t size) {
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot_cam.StoreRequest.tag)
}
inline std::string* StoreRequest::_internal_mutable_tag() {
  
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StoreRequest::release_tag() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.StoreRequest.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StoreRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.StoreRequest.tag)
}

// -------------------------------------------------------------------

// StoreResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool StoreResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool StoreResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& StoreResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& StoreResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.StoreResponse.header)
  return _internal_header();
}
inline void StoreResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.StoreResponse.header)
}
inline ::bosdyn::api::ResponseHeader* StoreResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.StoreResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* StoreResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* StoreResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.StoreResponse.header)
  return _internal_mutable_header();
}
inline void StoreResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.StoreResponse.header)
}

// .bosdyn.api.spot_cam.Logpoint point = 2;
inline bool StoreResponse::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool StoreResponse::has_point() const {
  return _internal_has_point();
}
inline void StoreResponse::clear_point() {
  if (GetArena() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& StoreResponse::_internal_point() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& StoreResponse::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.StoreResponse.point)
  return _internal_point();
}
inline void StoreResponse::unsafe_arena_set_allocated_point(
    ::bosdyn::api::spot_cam::Logpoint* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.StoreResponse.point)
}
inline ::bosdyn::api::spot_cam::Logpoint* StoreResponse::release_point() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* StoreResponse::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.StoreResponse.point)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* StoreResponse::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::bosdyn::api::spot_cam::Logpoint* StoreResponse::mutable_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.StoreResponse.point)
  return _internal_mutable_point();
}
inline void StoreResponse::set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.StoreResponse.point)
}

// -------------------------------------------------------------------

// TagRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool TagRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool TagRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& TagRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& TagRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.TagRequest.header)
  return _internal_header();
}
inline void TagRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.TagRequest.header)
}
inline ::bosdyn::api::RequestHeader* TagRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* TagRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.TagRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* TagRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* TagRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.TagRequest.header)
  return _internal_mutable_header();
}
inline void TagRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.TagRequest.header)
}

// .bosdyn.api.spot_cam.Logpoint point = 2;
inline bool TagRequest::_internal_has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline bool TagRequest::has_point() const {
  return _internal_has_point();
}
inline void TagRequest::clear_point() {
  if (GetArena() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
}
inline const ::bosdyn::api::spot_cam::Logpoint& TagRequest::_internal_point() const {
  const ::bosdyn::api::spot_cam::Logpoint* p = point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Logpoint*>(
      &::bosdyn::api::spot_cam::_Logpoint_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Logpoint& TagRequest::point() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.TagRequest.point)
  return _internal_point();
}
inline void TagRequest::unsafe_arena_set_allocated_point(
    ::bosdyn::api::spot_cam::Logpoint* point) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  point_ = point;
  if (point) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.TagRequest.point)
}
inline ::bosdyn::api::spot_cam::Logpoint* TagRequest::release_point() {
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* TagRequest::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.TagRequest.point)
  
  ::bosdyn::api::spot_cam::Logpoint* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Logpoint* TagRequest::_internal_mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Logpoint>(GetArena());
    point_ = p;
  }
  return point_;
}
inline ::bosdyn::api::spot_cam::Logpoint* TagRequest::mutable_point() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.TagRequest.point)
  return _internal_mutable_point();
}
inline void TagRequest::set_allocated_point(::bosdyn::api::spot_cam::Logpoint* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.TagRequest.point)
}

// -------------------------------------------------------------------

// TagResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool TagResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool TagResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& TagResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& TagResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.TagResponse.header)
  return _internal_header();
}
inline void TagResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.TagResponse.header)
}
inline ::bosdyn::api::ResponseHeader* TagResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TagResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.TagResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* TagResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* TagResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.TagResponse.header)
  return _internal_mutable_header();
}
inline void TagResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.TagResponse.header)
}

// -------------------------------------------------------------------

// ListCamerasRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListCamerasRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListCamerasRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListCamerasRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListCamerasRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListCamerasRequest.header)
  return _internal_header();
}
inline void ListCamerasRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.ListCamerasRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListCamerasRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListCamerasRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.ListCamerasRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListCamerasRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* ListCamerasRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListCamerasRequest.header)
  return _internal_mutable_header();
}
inline void ListCamerasRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.ListCamerasRequest.header)
}

// -------------------------------------------------------------------

// ListCamerasResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListCamerasResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListCamerasResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListCamerasResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListCamerasResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListCamerasResponse.header)
  return _internal_header();
}
inline void ListCamerasResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.ListCamerasResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListCamerasResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListCamerasResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.ListCamerasResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListCamerasResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* ListCamerasResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListCamerasResponse.header)
  return _internal_mutable_header();
}
inline void ListCamerasResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.ListCamerasResponse.header)
}

// repeated .bosdyn.api.spot_cam.Camera cameras = 2;
inline int ListCamerasResponse::_internal_cameras_size() const {
  return cameras_.size();
}
inline int ListCamerasResponse::cameras_size() const {
  return _internal_cameras_size();
}
inline ::bosdyn::api::spot_cam::Camera* ListCamerasResponse::mutable_cameras(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListCamerasResponse.cameras)
  return cameras_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Camera >*
ListCamerasResponse::mutable_cameras() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot_cam.ListCamerasResponse.cameras)
  return &cameras_;
}
inline const ::bosdyn::api::spot_cam::Camera& ListCamerasResponse::_internal_cameras(int index) const {
  return cameras_.Get(index);
}
inline const ::bosdyn::api::spot_cam::Camera& ListCamerasResponse::cameras(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListCamerasResponse.cameras)
  return _internal_cameras(index);
}
inline ::bosdyn::api::spot_cam::Camera* ListCamerasResponse::_internal_add_cameras() {
  return cameras_.Add();
}
inline ::bosdyn::api::spot_cam::Camera* ListCamerasResponse::add_cameras() {
  // @@protoc_insertion_point(field_add:bosdyn.api.spot_cam.ListCamerasResponse.cameras)
  return _internal_add_cameras();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Camera >&
ListCamerasResponse::cameras() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot_cam.ListCamerasResponse.cameras)
  return cameras_;
}

// -------------------------------------------------------------------

// ListLogpointsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListLogpointsRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListLogpointsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListLogpointsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListLogpointsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListLogpointsRequest.header)
  return _internal_header();
}
inline void ListLogpointsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.ListLogpointsRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListLogpointsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListLogpointsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.ListLogpointsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListLogpointsRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* ListLogpointsRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListLogpointsRequest.header)
  return _internal_mutable_header();
}
inline void ListLogpointsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.ListLogpointsRequest.header)
}

// -------------------------------------------------------------------

// ListLogpointsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListLogpointsResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListLogpointsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListLogpointsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListLogpointsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListLogpointsResponse.header)
  return _internal_header();
}
inline void ListLogpointsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.ListLogpointsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListLogpointsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListLogpointsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.ListLogpointsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListLogpointsResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* ListLogpointsResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListLogpointsResponse.header)
  return _internal_mutable_header();
}
inline void ListLogpointsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.ListLogpointsResponse.header)
}

// repeated .bosdyn.api.spot_cam.Logpoint logpoints = 2;
inline int ListLogpointsResponse::_internal_logpoints_size() const {
  return logpoints_.size();
}
inline int ListLogpointsResponse::logpoints_size() const {
  return _internal_logpoints_size();
}
inline void ListLogpointsResponse::clear_logpoints() {
  logpoints_.Clear();
}
inline ::bosdyn::api::spot_cam::Logpoint* ListLogpointsResponse::mutable_logpoints(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.ListLogpointsResponse.logpoints)
  return logpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint >*
ListLogpointsResponse::mutable_logpoints() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.spot_cam.ListLogpointsResponse.logpoints)
  return &logpoints_;
}
inline const ::bosdyn::api::spot_cam::Logpoint& ListLogpointsResponse::_internal_logpoints(int index) const {
  return logpoints_.Get(index);
}
inline const ::bosdyn::api::spot_cam::Logpoint& ListLogpointsResponse::logpoints(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.ListLogpointsResponse.logpoints)
  return _internal_logpoints(index);
}
inline ::bosdyn::api::spot_cam::Logpoint* ListLogpointsResponse::_internal_add_logpoints() {
  return logpoints_.Add();
}
inline ::bosdyn::api::spot_cam::Logpoint* ListLogpointsResponse::add_logpoints() {
  // @@protoc_insertion_point(field_add:bosdyn.api.spot_cam.ListLogpointsResponse.logpoints)
  return _internal_add_logpoints();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::spot_cam::Logpoint >&
ListLogpointsResponse::logpoints() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.spot_cam.ListLogpointsResponse.logpoints)
  return logpoints_;
}

// -------------------------------------------------------------------

// SetPassphraseRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SetPassphraseRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SetPassphraseRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SetPassphraseRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SetPassphraseRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPassphraseRequest.header)
  return _internal_header();
}
inline void SetPassphraseRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPassphraseRequest.header)
}
inline ::bosdyn::api::RequestHeader* SetPassphraseRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetPassphraseRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPassphraseRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetPassphraseRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* SetPassphraseRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPassphraseRequest.header)
  return _internal_mutable_header();
}
inline void SetPassphraseRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPassphraseRequest.header)
}

// string passphrase = 2;
inline void SetPassphraseRequest::clear_passphrase() {
  passphrase_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetPassphraseRequest::passphrase() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPassphraseRequest.passphrase)
  return _internal_passphrase();
}
inline void SetPassphraseRequest::set_passphrase(const std::string& value) {
  _internal_set_passphrase(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.SetPassphraseRequest.passphrase)
}
inline std::string* SetPassphraseRequest::mutable_passphrase() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPassphraseRequest.passphrase)
  return _internal_mutable_passphrase();
}
inline const std::string& SetPassphraseRequest::_internal_passphrase() const {
  return passphrase_.Get();
}
inline void SetPassphraseRequest::_internal_set_passphrase(const std::string& value) {
  
  passphrase_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetPassphraseRequest::set_passphrase(std::string&& value) {
  
  passphrase_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.spot_cam.SetPassphraseRequest.passphrase)
}
inline void SetPassphraseRequest::set_passphrase(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  passphrase_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.spot_cam.SetPassphraseRequest.passphrase)
}
inline void SetPassphraseRequest::set_passphrase(const char* value,
    size_t size) {
  
  passphrase_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.spot_cam.SetPassphraseRequest.passphrase)
}
inline std::string* SetPassphraseRequest::_internal_mutable_passphrase() {
  
  return passphrase_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetPassphraseRequest::release_passphrase() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPassphraseRequest.passphrase)
  return passphrase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetPassphraseRequest::set_allocated_passphrase(std::string* passphrase) {
  if (passphrase != nullptr) {
    
  } else {
    
  }
  passphrase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passphrase,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPassphraseRequest.passphrase)
}

// -------------------------------------------------------------------

// SetPassphraseResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SetPassphraseResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SetPassphraseResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SetPassphraseResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SetPassphraseResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.SetPassphraseResponse.header)
  return _internal_header();
}
inline void SetPassphraseResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.SetPassphraseResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SetPassphraseResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetPassphraseResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.SetPassphraseResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetPassphraseResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* SetPassphraseResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.SetPassphraseResponse.header)
  return _internal_mutable_header();
}
inline void SetPassphraseResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.SetPassphraseResponse.header)
}

// -------------------------------------------------------------------

// DebugRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DebugRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DebugRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DebugRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DebugRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DebugRequest.header)
  return _internal_header();
}
inline void DebugRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.DebugRequest.header)
}
inline ::bosdyn::api::RequestHeader* DebugRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* DebugRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.DebugRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DebugRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* DebugRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.DebugRequest.header)
  return _internal_mutable_header();
}
inline void DebugRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.DebugRequest.header)
}

// bool enable_temperature = 2;
inline void DebugRequest::clear_enable_temperature() {
  enable_temperature_ = false;
}
inline bool DebugRequest::_internal_enable_temperature() const {
  return enable_temperature_;
}
inline bool DebugRequest::enable_temperature() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DebugRequest.enable_temperature)
  return _internal_enable_temperature();
}
inline void DebugRequest::_internal_set_enable_temperature(bool value) {
  
  enable_temperature_ = value;
}
inline void DebugRequest::set_enable_temperature(bool value) {
  _internal_set_enable_temperature(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.DebugRequest.enable_temperature)
}

// bool enable_humidity = 3;
inline void DebugRequest::clear_enable_humidity() {
  enable_humidity_ = false;
}
inline bool DebugRequest::_internal_enable_humidity() const {
  return enable_humidity_;
}
inline bool DebugRequest::enable_humidity() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DebugRequest.enable_humidity)
  return _internal_enable_humidity();
}
inline void DebugRequest::_internal_set_enable_humidity(bool value) {
  
  enable_humidity_ = value;
}
inline void DebugRequest::set_enable_humidity(bool value) {
  _internal_set_enable_humidity(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.DebugRequest.enable_humidity)
}

// bool enable_BIT = 4;
inline void DebugRequest::clear_enable_bit() {
  enable_bit_ = false;
}
inline bool DebugRequest::_internal_enable_bit() const {
  return enable_bit_;
}
inline bool DebugRequest::enable_bit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DebugRequest.enable_BIT)
  return _internal_enable_bit();
}
inline void DebugRequest::_internal_set_enable_bit(bool value) {
  
  enable_bit_ = value;
}
inline void DebugRequest::set_enable_bit(bool value) {
  _internal_set_enable_bit(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.DebugRequest.enable_BIT)
}

// bool enable_shock = 5;
inline void DebugRequest::clear_enable_shock() {
  enable_shock_ = false;
}
inline bool DebugRequest::_internal_enable_shock() const {
  return enable_shock_;
}
inline bool DebugRequest::enable_shock() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DebugRequest.enable_shock)
  return _internal_enable_shock();
}
inline void DebugRequest::_internal_set_enable_shock(bool value) {
  
  enable_shock_ = value;
}
inline void DebugRequest::set_enable_shock(bool value) {
  _internal_set_enable_shock(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.DebugRequest.enable_shock)
}

// bool enable_system_stat = 6;
inline void DebugRequest::clear_enable_system_stat() {
  enable_system_stat_ = false;
}
inline bool DebugRequest::_internal_enable_system_stat() const {
  return enable_system_stat_;
}
inline bool DebugRequest::enable_system_stat() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DebugRequest.enable_system_stat)
  return _internal_enable_system_stat();
}
inline void DebugRequest::_internal_set_enable_system_stat(bool value) {
  
  enable_system_stat_ = value;
}
inline void DebugRequest::set_enable_system_stat(bool value) {
  _internal_set_enable_system_stat(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot_cam.DebugRequest.enable_system_stat)
}

// -------------------------------------------------------------------

// DebugResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DebugResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DebugResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DebugResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DebugResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot_cam.DebugResponse.header)
  return _internal_header();
}
inline void DebugResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot_cam.DebugResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DebugResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DebugResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot_cam.DebugResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DebugResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* DebugResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot_cam.DebugResponse.header)
  return _internal_mutable_header();
}
inline void DebugResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot_cam.DebugResponse.header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spot_cam
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::spot_cam::Logpoint_RecordType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot_cam::Logpoint_RecordType>() {
  return ::bosdyn::api::spot_cam::Logpoint_RecordType_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot_cam::Logpoint_LogStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot_cam::Logpoint_LogStatus>() {
  return ::bosdyn::api::spot_cam::Logpoint_LogStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_5fcam_2flogging_2eproto
