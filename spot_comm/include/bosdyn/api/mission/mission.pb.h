// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/mission/mission.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fmission_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fmission_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include "bosdyn/api/mission/nodes.pb.h"
#include "bosdyn/api/mission/util.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fmission_2fmission_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto;
namespace bosdyn {
namespace api {
namespace mission {
class AnswerQuestionRequest;
class AnswerQuestionRequestDefaultTypeInternal;
extern AnswerQuestionRequestDefaultTypeInternal _AnswerQuestionRequest_default_instance_;
class AnswerQuestionResponse;
class AnswerQuestionResponseDefaultTypeInternal;
extern AnswerQuestionResponseDefaultTypeInternal _AnswerQuestionResponse_default_instance_;
class FailedNode;
class FailedNodeDefaultTypeInternal;
extern FailedNodeDefaultTypeInternal _FailedNode_default_instance_;
class GetInfoRequest;
class GetInfoRequestDefaultTypeInternal;
extern GetInfoRequestDefaultTypeInternal _GetInfoRequest_default_instance_;
class GetInfoResponse;
class GetInfoResponseDefaultTypeInternal;
extern GetInfoResponseDefaultTypeInternal _GetInfoResponse_default_instance_;
class GetMissionRequest;
class GetMissionRequestDefaultTypeInternal;
extern GetMissionRequestDefaultTypeInternal _GetMissionRequest_default_instance_;
class GetMissionResponse;
class GetMissionResponseDefaultTypeInternal;
extern GetMissionResponseDefaultTypeInternal _GetMissionResponse_default_instance_;
class GetStateRequest;
class GetStateRequestDefaultTypeInternal;
extern GetStateRequestDefaultTypeInternal _GetStateRequest_default_instance_;
class GetStateResponse;
class GetStateResponseDefaultTypeInternal;
extern GetStateResponseDefaultTypeInternal _GetStateResponse_default_instance_;
class LoadMissionRequest;
class LoadMissionRequestDefaultTypeInternal;
extern LoadMissionRequestDefaultTypeInternal _LoadMissionRequest_default_instance_;
class LoadMissionResponse;
class LoadMissionResponseDefaultTypeInternal;
extern LoadMissionResponseDefaultTypeInternal _LoadMissionResponse_default_instance_;
class MissionInfo;
class MissionInfoDefaultTypeInternal;
extern MissionInfoDefaultTypeInternal _MissionInfo_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class PauseMissionRequest;
class PauseMissionRequestDefaultTypeInternal;
extern PauseMissionRequestDefaultTypeInternal _PauseMissionRequest_default_instance_;
class PauseMissionResponse;
class PauseMissionResponseDefaultTypeInternal;
extern PauseMissionResponseDefaultTypeInternal _PauseMissionResponse_default_instance_;
class PlayMissionRequest;
class PlayMissionRequestDefaultTypeInternal;
extern PlayMissionRequestDefaultTypeInternal _PlayMissionRequest_default_instance_;
class PlayMissionResponse;
class PlayMissionResponseDefaultTypeInternal;
extern PlayMissionResponseDefaultTypeInternal _PlayMissionResponse_default_instance_;
class PlaySettings;
class PlaySettingsDefaultTypeInternal;
extern PlaySettingsDefaultTypeInternal _PlaySettings_default_instance_;
class Question;
class QuestionDefaultTypeInternal;
extern QuestionDefaultTypeInternal _Question_default_instance_;
class RestartMissionRequest;
class RestartMissionRequestDefaultTypeInternal;
extern RestartMissionRequestDefaultTypeInternal _RestartMissionRequest_default_instance_;
class RestartMissionResponse;
class RestartMissionResponseDefaultTypeInternal;
extern RestartMissionResponseDefaultTypeInternal _RestartMissionResponse_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class State_AnsweredQuestion;
class State_AnsweredQuestionDefaultTypeInternal;
extern State_AnsweredQuestionDefaultTypeInternal _State_AnsweredQuestion_default_instance_;
class State_NodeStatesAtTick;
class State_NodeStatesAtTickDefaultTypeInternal;
extern State_NodeStatesAtTickDefaultTypeInternal _State_NodeStatesAtTick_default_instance_;
class State_NodeStatesAtTick_NodeState;
class State_NodeStatesAtTick_NodeStateDefaultTypeInternal;
extern State_NodeStatesAtTick_NodeStateDefaultTypeInternal _State_NodeStatesAtTick_NodeState_default_instance_;
}  // namespace mission
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::mission::AnswerQuestionRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::AnswerQuestionRequest>(Arena*);
template<> ::bosdyn::api::mission::AnswerQuestionResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::AnswerQuestionResponse>(Arena*);
template<> ::bosdyn::api::mission::FailedNode* Arena::CreateMaybeMessage<::bosdyn::api::mission::FailedNode>(Arena*);
template<> ::bosdyn::api::mission::GetInfoRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::GetInfoRequest>(Arena*);
template<> ::bosdyn::api::mission::GetInfoResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::GetInfoResponse>(Arena*);
template<> ::bosdyn::api::mission::GetMissionRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::GetMissionRequest>(Arena*);
template<> ::bosdyn::api::mission::GetMissionResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::GetMissionResponse>(Arena*);
template<> ::bosdyn::api::mission::GetStateRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::GetStateRequest>(Arena*);
template<> ::bosdyn::api::mission::GetStateResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::GetStateResponse>(Arena*);
template<> ::bosdyn::api::mission::LoadMissionRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::LoadMissionRequest>(Arena*);
template<> ::bosdyn::api::mission::LoadMissionResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::LoadMissionResponse>(Arena*);
template<> ::bosdyn::api::mission::MissionInfo* Arena::CreateMaybeMessage<::bosdyn::api::mission::MissionInfo>(Arena*);
template<> ::bosdyn::api::mission::NodeInfo* Arena::CreateMaybeMessage<::bosdyn::api::mission::NodeInfo>(Arena*);
template<> ::bosdyn::api::mission::PauseMissionRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::PauseMissionRequest>(Arena*);
template<> ::bosdyn::api::mission::PauseMissionResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::PauseMissionResponse>(Arena*);
template<> ::bosdyn::api::mission::PlayMissionRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::PlayMissionRequest>(Arena*);
template<> ::bosdyn::api::mission::PlayMissionResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::PlayMissionResponse>(Arena*);
template<> ::bosdyn::api::mission::PlaySettings* Arena::CreateMaybeMessage<::bosdyn::api::mission::PlaySettings>(Arena*);
template<> ::bosdyn::api::mission::Question* Arena::CreateMaybeMessage<::bosdyn::api::mission::Question>(Arena*);
template<> ::bosdyn::api::mission::RestartMissionRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::RestartMissionRequest>(Arena*);
template<> ::bosdyn::api::mission::RestartMissionResponse* Arena::CreateMaybeMessage<::bosdyn::api::mission::RestartMissionResponse>(Arena*);
template<> ::bosdyn::api::mission::State* Arena::CreateMaybeMessage<::bosdyn::api::mission::State>(Arena*);
template<> ::bosdyn::api::mission::State_AnsweredQuestion* Arena::CreateMaybeMessage<::bosdyn::api::mission::State_AnsweredQuestion>(Arena*);
template<> ::bosdyn::api::mission::State_NodeStatesAtTick* Arena::CreateMaybeMessage<::bosdyn::api::mission::State_NodeStatesAtTick>(Arena*);
template<> ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState* Arena::CreateMaybeMessage<::bosdyn::api::mission::State_NodeStatesAtTick_NodeState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace mission {

enum State_Status : int {
  State_Status_STATUS_UNKNOWN = 0,
  State_Status_STATUS_FAILURE = 1,
  State_Status_STATUS_RUNNING = 2,
  State_Status_STATUS_SUCCESS = 3,
  State_Status_STATUS_PAUSED = 4,
  State_Status_STATUS_ERROR = 5,
  State_Status_STATUS_NONE = 6,
  State_Status_State_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  State_Status_State_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool State_Status_IsValid(int value);
constexpr State_Status State_Status_Status_MIN = State_Status_STATUS_UNKNOWN;
constexpr State_Status State_Status_Status_MAX = State_Status_STATUS_NONE;
constexpr int State_Status_Status_ARRAYSIZE = State_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* State_Status_descriptor();
template<typename T>
inline const std::string& State_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, State_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function State_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    State_Status_descriptor(), enum_t_value);
}
inline bool State_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, State_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<State_Status>(
    State_Status_descriptor(), name, value);
}
enum AnswerQuestionResponse_Status : int {
  AnswerQuestionResponse_Status_STATUS_UNKNOWN = 0,
  AnswerQuestionResponse_Status_STATUS_OK = 1,
  AnswerQuestionResponse_Status_STATUS_INVALID_QUESTION_ID = 2,
  AnswerQuestionResponse_Status_STATUS_INVALID_CODE = 3,
  AnswerQuestionResponse_Status_STATUS_ALREADY_ANSWERED = 4,
  AnswerQuestionResponse_Status_AnswerQuestionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AnswerQuestionResponse_Status_AnswerQuestionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AnswerQuestionResponse_Status_IsValid(int value);
constexpr AnswerQuestionResponse_Status AnswerQuestionResponse_Status_Status_MIN = AnswerQuestionResponse_Status_STATUS_UNKNOWN;
constexpr AnswerQuestionResponse_Status AnswerQuestionResponse_Status_Status_MAX = AnswerQuestionResponse_Status_STATUS_ALREADY_ANSWERED;
constexpr int AnswerQuestionResponse_Status_Status_ARRAYSIZE = AnswerQuestionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AnswerQuestionResponse_Status_descriptor();
template<typename T>
inline const std::string& AnswerQuestionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AnswerQuestionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AnswerQuestionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AnswerQuestionResponse_Status_descriptor(), enum_t_value);
}
inline bool AnswerQuestionResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnswerQuestionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AnswerQuestionResponse_Status>(
    AnswerQuestionResponse_Status_descriptor(), name, value);
}
enum PlayMissionResponse_Status : int {
  PlayMissionResponse_Status_STATUS_UNKNOWN = 0,
  PlayMissionResponse_Status_STATUS_OK = 1,
  PlayMissionResponse_Status_STATUS_NO_MISSION = 2,
  PlayMissionResponse_Status_PlayMissionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlayMissionResponse_Status_PlayMissionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlayMissionResponse_Status_IsValid(int value);
constexpr PlayMissionResponse_Status PlayMissionResponse_Status_Status_MIN = PlayMissionResponse_Status_STATUS_UNKNOWN;
constexpr PlayMissionResponse_Status PlayMissionResponse_Status_Status_MAX = PlayMissionResponse_Status_STATUS_NO_MISSION;
constexpr int PlayMissionResponse_Status_Status_ARRAYSIZE = PlayMissionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayMissionResponse_Status_descriptor();
template<typename T>
inline const std::string& PlayMissionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayMissionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayMissionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayMissionResponse_Status_descriptor(), enum_t_value);
}
inline bool PlayMissionResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayMissionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayMissionResponse_Status>(
    PlayMissionResponse_Status_descriptor(), name, value);
}
enum RestartMissionResponse_Status : int {
  RestartMissionResponse_Status_STATUS_UNKNOWN = 0,
  RestartMissionResponse_Status_STATUS_OK = 1,
  RestartMissionResponse_Status_STATUS_NO_MISSION = 2,
  RestartMissionResponse_Status_STATUS_VALIDATE_ERROR = 3,
  RestartMissionResponse_Status_RestartMissionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RestartMissionResponse_Status_RestartMissionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RestartMissionResponse_Status_IsValid(int value);
constexpr RestartMissionResponse_Status RestartMissionResponse_Status_Status_MIN = RestartMissionResponse_Status_STATUS_UNKNOWN;
constexpr RestartMissionResponse_Status RestartMissionResponse_Status_Status_MAX = RestartMissionResponse_Status_STATUS_VALIDATE_ERROR;
constexpr int RestartMissionResponse_Status_Status_ARRAYSIZE = RestartMissionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RestartMissionResponse_Status_descriptor();
template<typename T>
inline const std::string& RestartMissionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RestartMissionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RestartMissionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RestartMissionResponse_Status_descriptor(), enum_t_value);
}
inline bool RestartMissionResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RestartMissionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RestartMissionResponse_Status>(
    RestartMissionResponse_Status_descriptor(), name, value);
}
enum LoadMissionResponse_Status : int {
  LoadMissionResponse_Status_STATUS_UNKNOWN = 0,
  LoadMissionResponse_Status_STATUS_OK = 1,
  LoadMissionResponse_Status_STATUS_COMPILE_ERROR = 2,
  LoadMissionResponse_Status_STATUS_VALIDATE_ERROR = 3,
  LoadMissionResponse_Status_LoadMissionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LoadMissionResponse_Status_LoadMissionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LoadMissionResponse_Status_IsValid(int value);
constexpr LoadMissionResponse_Status LoadMissionResponse_Status_Status_MIN = LoadMissionResponse_Status_STATUS_UNKNOWN;
constexpr LoadMissionResponse_Status LoadMissionResponse_Status_Status_MAX = LoadMissionResponse_Status_STATUS_VALIDATE_ERROR;
constexpr int LoadMissionResponse_Status_Status_ARRAYSIZE = LoadMissionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoadMissionResponse_Status_descriptor();
template<typename T>
inline const std::string& LoadMissionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoadMissionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoadMissionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoadMissionResponse_Status_descriptor(), enum_t_value);
}
inline bool LoadMissionResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoadMissionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoadMissionResponse_Status>(
    LoadMissionResponse_Status_descriptor(), name, value);
}
enum PauseMissionResponse_Status : int {
  PauseMissionResponse_Status_STATUS_UNKNOWN = 0,
  PauseMissionResponse_Status_STATUS_OK = 1,
  PauseMissionResponse_Status_STATUS_NO_MISSION_PLAYING = 2,
  PauseMissionResponse_Status_PauseMissionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PauseMissionResponse_Status_PauseMissionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PauseMissionResponse_Status_IsValid(int value);
constexpr PauseMissionResponse_Status PauseMissionResponse_Status_Status_MIN = PauseMissionResponse_Status_STATUS_UNKNOWN;
constexpr PauseMissionResponse_Status PauseMissionResponse_Status_Status_MAX = PauseMissionResponse_Status_STATUS_NO_MISSION_PLAYING;
constexpr int PauseMissionResponse_Status_Status_ARRAYSIZE = PauseMissionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PauseMissionResponse_Status_descriptor();
template<typename T>
inline const std::string& PauseMissionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PauseMissionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PauseMissionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PauseMissionResponse_Status_descriptor(), enum_t_value);
}
inline bool PauseMissionResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PauseMissionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PauseMissionResponse_Status>(
    PauseMissionResponse_Status_descriptor(), name, value);
}
// ===================================================================

class GetStateRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.GetStateRequest) */ {
 public:
  inline GetStateRequest() : GetStateRequest(nullptr) {}
  virtual ~GetStateRequest();

  GetStateRequest(const GetStateRequest& from);
  GetStateRequest(GetStateRequest&& from) noexcept
    : GetStateRequest() {
    *this = ::std::move(from);
  }

  inline GetStateRequest& operator=(const GetStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStateRequest& operator=(GetStateRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetStateRequest& default_instance();

  enum LowerBoundCase {
    kHistoryLowerTickBound = 3,
    kHistoryPastTicks = 4,
    LOWER_BOUND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetStateRequest*>(
               &_GetStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetStateRequest& a, GetStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStateRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStateRequest* New() const final {
    return CreateMaybeMessage<GetStateRequest>(nullptr);
  }

  GetStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetStateRequest& from);
  void MergeFrom(const GetStateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.GetStateRequest";
  }
  protected:
  explicit GetStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kHistoryUpperTickBoundFieldNumber = 2,
    kHistoryLowerTickBoundFieldNumber = 3,
    kHistoryPastTicksFieldNumber = 4,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .google.protobuf.Int64Value history_upper_tick_bound = 2;
  bool has_history_upper_tick_bound() const;
  private:
  bool _internal_has_history_upper_tick_bound() const;
  public:
  void clear_history_upper_tick_bound();
  const PROTOBUF_NAMESPACE_ID::Int64Value& history_upper_tick_bound() const;
  PROTOBUF_NAMESPACE_ID::Int64Value* release_history_upper_tick_bound();
  PROTOBUF_NAMESPACE_ID::Int64Value* mutable_history_upper_tick_bound();
  void set_allocated_history_upper_tick_bound(PROTOBUF_NAMESPACE_ID::Int64Value* history_upper_tick_bound);
  private:
  const PROTOBUF_NAMESPACE_ID::Int64Value& _internal_history_upper_tick_bound() const;
  PROTOBUF_NAMESPACE_ID::Int64Value* _internal_mutable_history_upper_tick_bound();
  public:
  void unsafe_arena_set_allocated_history_upper_tick_bound(
      PROTOBUF_NAMESPACE_ID::Int64Value* history_upper_tick_bound);
  PROTOBUF_NAMESPACE_ID::Int64Value* unsafe_arena_release_history_upper_tick_bound();

  // int64 history_lower_tick_bound = 3;
  private:
  bool _internal_has_history_lower_tick_bound() const;
  public:
  void clear_history_lower_tick_bound();
  ::PROTOBUF_NAMESPACE_ID::int64 history_lower_tick_bound() const;
  void set_history_lower_tick_bound(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_history_lower_tick_bound() const;
  void _internal_set_history_lower_tick_bound(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 history_past_ticks = 4;
  private:
  bool _internal_has_history_past_ticks() const;
  public:
  void clear_history_past_ticks();
  ::PROTOBUF_NAMESPACE_ID::int64 history_past_ticks() const;
  void set_history_past_ticks(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_history_past_ticks() const;
  void _internal_set_history_past_ticks(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  void clear_lower_bound();
  LowerBoundCase lower_bound_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.GetStateRequest)
 private:
  class _Internal;
  void set_has_history_lower_tick_bound();
  void set_has_history_past_ticks();

  inline bool has_lower_bound() const;
  inline void clear_has_lower_bound();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  PROTOBUF_NAMESPACE_ID::Int64Value* history_upper_tick_bound_;
  union LowerBoundUnion {
    LowerBoundUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int64 history_lower_tick_bound_;
    ::PROTOBUF_NAMESPACE_ID::int64 history_past_ticks_;
  } lower_bound_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class GetStateResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.GetStateResponse) */ {
 public:
  inline GetStateResponse() : GetStateResponse(nullptr) {}
  virtual ~GetStateResponse();

  GetStateResponse(const GetStateResponse& from);
  GetStateResponse(GetStateResponse&& from) noexcept
    : GetStateResponse() {
    *this = ::std::move(from);
  }

  inline GetStateResponse& operator=(const GetStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStateResponse& operator=(GetStateResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetStateResponse*>(
               &_GetStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetStateResponse& a, GetStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStateResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStateResponse* New() const final {
    return CreateMaybeMessage<GetStateResponse>(nullptr);
  }

  GetStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetStateResponse& from);
  void MergeFrom(const GetStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.GetStateResponse";
  }
  protected:
  explicit GetStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.State state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::bosdyn::api::mission::State& state() const;
  ::bosdyn::api::mission::State* release_state();
  ::bosdyn::api::mission::State* mutable_state();
  void set_allocated_state(::bosdyn::api::mission::State* state);
  private:
  const ::bosdyn::api::mission::State& _internal_state() const;
  ::bosdyn::api::mission::State* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::bosdyn::api::mission::State* state);
  ::bosdyn::api::mission::State* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.GetStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::mission::State* state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class State_AnsweredQuestion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.State.AnsweredQuestion) */ {
 public:
  inline State_AnsweredQuestion() : State_AnsweredQuestion(nullptr) {}
  virtual ~State_AnsweredQuestion();

  State_AnsweredQuestion(const State_AnsweredQuestion& from);
  State_AnsweredQuestion(State_AnsweredQuestion&& from) noexcept
    : State_AnsweredQuestion() {
    *this = ::std::move(from);
  }

  inline State_AnsweredQuestion& operator=(const State_AnsweredQuestion& from) {
    CopyFrom(from);
    return *this;
  }
  inline State_AnsweredQuestion& operator=(State_AnsweredQuestion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const State_AnsweredQuestion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_AnsweredQuestion* internal_default_instance() {
    return reinterpret_cast<const State_AnsweredQuestion*>(
               &_State_AnsweredQuestion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(State_AnsweredQuestion& a, State_AnsweredQuestion& b) {
    a.Swap(&b);
  }
  inline void Swap(State_AnsweredQuestion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State_AnsweredQuestion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline State_AnsweredQuestion* New() const final {
    return CreateMaybeMessage<State_AnsweredQuestion>(nullptr);
  }

  State_AnsweredQuestion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<State_AnsweredQuestion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const State_AnsweredQuestion& from);
  void MergeFrom(const State_AnsweredQuestion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_AnsweredQuestion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.State.AnsweredQuestion";
  }
  protected:
  explicit State_AnsweredQuestion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestionFieldNumber = 1,
    kAcceptedAnswerCodeFieldNumber = 2,
  };
  // .bosdyn.api.mission.Question question = 1;
  bool has_question() const;
  private:
  bool _internal_has_question() const;
  public:
  void clear_question();
  const ::bosdyn::api::mission::Question& question() const;
  ::bosdyn::api::mission::Question* release_question();
  ::bosdyn::api::mission::Question* mutable_question();
  void set_allocated_question(::bosdyn::api::mission::Question* question);
  private:
  const ::bosdyn::api::mission::Question& _internal_question() const;
  ::bosdyn::api::mission::Question* _internal_mutable_question();
  public:
  void unsafe_arena_set_allocated_question(
      ::bosdyn::api::mission::Question* question);
  ::bosdyn::api::mission::Question* unsafe_arena_release_question();

  // int64 accepted_answer_code = 2;
  void clear_accepted_answer_code();
  ::PROTOBUF_NAMESPACE_ID::int64 accepted_answer_code() const;
  void set_accepted_answer_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_accepted_answer_code() const;
  void _internal_set_accepted_answer_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.State.AnsweredQuestion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::mission::Question* question_;
  ::PROTOBUF_NAMESPACE_ID::int64 accepted_answer_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class State_NodeStatesAtTick_NodeState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.State.NodeStatesAtTick.NodeState) */ {
 public:
  inline State_NodeStatesAtTick_NodeState() : State_NodeStatesAtTick_NodeState(nullptr) {}
  virtual ~State_NodeStatesAtTick_NodeState();

  State_NodeStatesAtTick_NodeState(const State_NodeStatesAtTick_NodeState& from);
  State_NodeStatesAtTick_NodeState(State_NodeStatesAtTick_NodeState&& from) noexcept
    : State_NodeStatesAtTick_NodeState() {
    *this = ::std::move(from);
  }

  inline State_NodeStatesAtTick_NodeState& operator=(const State_NodeStatesAtTick_NodeState& from) {
    CopyFrom(from);
    return *this;
  }
  inline State_NodeStatesAtTick_NodeState& operator=(State_NodeStatesAtTick_NodeState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const State_NodeStatesAtTick_NodeState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_NodeStatesAtTick_NodeState* internal_default_instance() {
    return reinterpret_cast<const State_NodeStatesAtTick_NodeState*>(
               &_State_NodeStatesAtTick_NodeState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(State_NodeStatesAtTick_NodeState& a, State_NodeStatesAtTick_NodeState& b) {
    a.Swap(&b);
  }
  inline void Swap(State_NodeStatesAtTick_NodeState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State_NodeStatesAtTick_NodeState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline State_NodeStatesAtTick_NodeState* New() const final {
    return CreateMaybeMessage<State_NodeStatesAtTick_NodeState>(nullptr);
  }

  State_NodeStatesAtTick_NodeState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<State_NodeStatesAtTick_NodeState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const State_NodeStatesAtTick_NodeState& from);
  void MergeFrom(const State_NodeStatesAtTick_NodeState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_NodeStatesAtTick_NodeState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.State.NodeStatesAtTick.NodeState";
  }
  protected:
  explicit State_NodeStatesAtTick_NodeState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kIdFieldNumber = 3,
    kResultFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // int64 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .bosdyn.api.mission.Result result = 1;
  void clear_result();
  ::bosdyn::api::mission::Result result() const;
  void set_result(::bosdyn::api::mission::Result value);
  private:
  ::bosdyn::api::mission::Result _internal_result() const;
  void _internal_set_result(::bosdyn::api::mission::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.State.NodeStatesAtTick.NodeState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class State_NodeStatesAtTick PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.State.NodeStatesAtTick) */ {
 public:
  inline State_NodeStatesAtTick() : State_NodeStatesAtTick(nullptr) {}
  virtual ~State_NodeStatesAtTick();

  State_NodeStatesAtTick(const State_NodeStatesAtTick& from);
  State_NodeStatesAtTick(State_NodeStatesAtTick&& from) noexcept
    : State_NodeStatesAtTick() {
    *this = ::std::move(from);
  }

  inline State_NodeStatesAtTick& operator=(const State_NodeStatesAtTick& from) {
    CopyFrom(from);
    return *this;
  }
  inline State_NodeStatesAtTick& operator=(State_NodeStatesAtTick&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const State_NodeStatesAtTick& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_NodeStatesAtTick* internal_default_instance() {
    return reinterpret_cast<const State_NodeStatesAtTick*>(
               &_State_NodeStatesAtTick_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(State_NodeStatesAtTick& a, State_NodeStatesAtTick& b) {
    a.Swap(&b);
  }
  inline void Swap(State_NodeStatesAtTick* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State_NodeStatesAtTick* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline State_NodeStatesAtTick* New() const final {
    return CreateMaybeMessage<State_NodeStatesAtTick>(nullptr);
  }

  State_NodeStatesAtTick* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<State_NodeStatesAtTick>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const State_NodeStatesAtTick& from);
  void MergeFrom(const State_NodeStatesAtTick& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_NodeStatesAtTick* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.State.NodeStatesAtTick";
  }
  protected:
  explicit State_NodeStatesAtTick(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef State_NodeStatesAtTick_NodeState NodeState;

  // accessors -------------------------------------------------------

  enum : int {
    kNodeStatesFieldNumber = 3,
    kTickStartTimestampFieldNumber = 2,
    kTickCounterFieldNumber = 1,
  };
  // repeated .bosdyn.api.mission.State.NodeStatesAtTick.NodeState node_states = 3;
  int node_states_size() const;
  private:
  int _internal_node_states_size() const;
  public:
  void clear_node_states();
  ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState* mutable_node_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState >*
      mutable_node_states();
  private:
  const ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState& _internal_node_states(int index) const;
  ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState* _internal_add_node_states();
  public:
  const ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState& node_states(int index) const;
  ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState* add_node_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState >&
      node_states() const;

  // .google.protobuf.Timestamp tick_start_timestamp = 2;
  bool has_tick_start_timestamp() const;
  private:
  bool _internal_has_tick_start_timestamp() const;
  public:
  void clear_tick_start_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& tick_start_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_tick_start_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_tick_start_timestamp();
  void set_allocated_tick_start_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* tick_start_timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_tick_start_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_tick_start_timestamp();
  public:
  void unsafe_arena_set_allocated_tick_start_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* tick_start_timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_tick_start_timestamp();

  // int64 tick_counter = 1;
  void clear_tick_counter();
  ::PROTOBUF_NAMESPACE_ID::int64 tick_counter() const;
  void set_tick_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tick_counter() const;
  void _internal_set_tick_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.State.NodeStatesAtTick)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState > node_states_;
  PROTOBUF_NAMESPACE_ID::Timestamp* tick_start_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 tick_counter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class State PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.State) */ {
 public:
  inline State() : State(nullptr) {}
  virtual ~State();

  State(const State& from);
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const State& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline State* New() const final {
    return CreateMaybeMessage<State>(nullptr);
  }

  State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<State>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.State";
  }
  protected:
  explicit State(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef State_AnsweredQuestion AnsweredQuestion;
  typedef State_NodeStatesAtTick NodeStatesAtTick;

  typedef State_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    State_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_FAILURE =
    State_Status_STATUS_FAILURE;
  static constexpr Status STATUS_RUNNING =
    State_Status_STATUS_RUNNING;
  static constexpr Status STATUS_SUCCESS =
    State_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_PAUSED =
    State_Status_STATUS_PAUSED;
  static constexpr Status STATUS_ERROR =
    State_Status_STATUS_ERROR;
  static constexpr Status STATUS_NONE =
    State_Status_STATUS_NONE;
  static inline bool Status_IsValid(int value) {
    return State_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    State_Status_Status_MIN;
  static constexpr Status Status_MAX =
    State_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    State_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return State_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return State_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return State_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kQuestionsFieldNumber = 1,
    kAnsweredQuestionsFieldNumber = 2,
    kHistoryFieldNumber = 3,
    kErrorFieldNumber = 5,
    kTickCounterFieldNumber = 6,
    kMissionIdFieldNumber = 7,
    kStatusFieldNumber = 4,
  };
  // repeated .bosdyn.api.mission.Question questions = 1;
  int questions_size() const;
  private:
  int _internal_questions_size() const;
  public:
  void clear_questions();
  ::bosdyn::api::mission::Question* mutable_questions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Question >*
      mutable_questions();
  private:
  const ::bosdyn::api::mission::Question& _internal_questions(int index) const;
  ::bosdyn::api::mission::Question* _internal_add_questions();
  public:
  const ::bosdyn::api::mission::Question& questions(int index) const;
  ::bosdyn::api::mission::Question* add_questions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Question >&
      questions() const;

  // repeated .bosdyn.api.mission.State.AnsweredQuestion answered_questions = 2;
  int answered_questions_size() const;
  private:
  int _internal_answered_questions_size() const;
  public:
  void clear_answered_questions();
  ::bosdyn::api::mission::State_AnsweredQuestion* mutable_answered_questions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_AnsweredQuestion >*
      mutable_answered_questions();
  private:
  const ::bosdyn::api::mission::State_AnsweredQuestion& _internal_answered_questions(int index) const;
  ::bosdyn::api::mission::State_AnsweredQuestion* _internal_add_answered_questions();
  public:
  const ::bosdyn::api::mission::State_AnsweredQuestion& answered_questions(int index) const;
  ::bosdyn::api::mission::State_AnsweredQuestion* add_answered_questions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_AnsweredQuestion >&
      answered_questions() const;

  // repeated .bosdyn.api.mission.State.NodeStatesAtTick history = 3;
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::bosdyn::api::mission::State_NodeStatesAtTick* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick >*
      mutable_history();
  private:
  const ::bosdyn::api::mission::State_NodeStatesAtTick& _internal_history(int index) const;
  ::bosdyn::api::mission::State_NodeStatesAtTick* _internal_add_history();
  public:
  const ::bosdyn::api::mission::State_NodeStatesAtTick& history(int index) const;
  ::bosdyn::api::mission::State_NodeStatesAtTick* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick >&
      history() const;

  // string error = 5;
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // int64 tick_counter = 6;
  void clear_tick_counter();
  ::PROTOBUF_NAMESPACE_ID::int64 tick_counter() const;
  void set_tick_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tick_counter() const;
  void _internal_set_tick_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 mission_id = 7;
  void clear_mission_id();
  ::PROTOBUF_NAMESPACE_ID::int64 mission_id() const;
  void set_mission_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_mission_id() const;
  void _internal_set_mission_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .bosdyn.api.mission.State.Status status = 4;
  void clear_status();
  ::bosdyn::api::mission::State_Status status() const;
  void set_status(::bosdyn::api::mission::State_Status value);
  private:
  ::bosdyn::api::mission::State_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::State_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.State)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Question > questions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_AnsweredQuestion > answered_questions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick > history_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::PROTOBUF_NAMESPACE_ID::int64 tick_counter_;
  ::PROTOBUF_NAMESPACE_ID::int64 mission_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class Question PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Question) */ {
 public:
  inline Question() : Question(nullptr) {}
  virtual ~Question();

  Question(const Question& from);
  Question(Question&& from) noexcept
    : Question() {
    *this = ::std::move(from);
  }

  inline Question& operator=(const Question& from) {
    CopyFrom(from);
    return *this;
  }
  inline Question& operator=(Question&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Question& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Question* internal_default_instance() {
    return reinterpret_cast<const Question*>(
               &_Question_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Question& a, Question& b) {
    a.Swap(&b);
  }
  inline void Swap(Question* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Question* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Question* New() const final {
    return CreateMaybeMessage<Question>(nullptr);
  }

  Question* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Question>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Question& from);
  void MergeFrom(const Question& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Question* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Question";
  }
  protected:
  explicit Question(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 4,
    kSourceFieldNumber = 2,
    kTextFieldNumber = 3,
    kIdFieldNumber = 1,
    kForAutonomousProcessingFieldNumber = 5,
  };
  // repeated .bosdyn.api.mission.Prompt.Option options = 4;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  ::bosdyn::api::mission::Prompt_Option* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >*
      mutable_options();
  private:
  const ::bosdyn::api::mission::Prompt_Option& _internal_options(int index) const;
  ::bosdyn::api::mission::Prompt_Option* _internal_add_options();
  public:
  const ::bosdyn::api::mission::Prompt_Option& options(int index) const;
  ::bosdyn::api::mission::Prompt_Option* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >&
      options() const;

  // string source = 2;
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string text = 3;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool for_autonomous_processing = 5;
  void clear_for_autonomous_processing();
  bool for_autonomous_processing() const;
  void set_for_autonomous_processing(bool value);
  private:
  bool _internal_for_autonomous_processing() const;
  void _internal_set_for_autonomous_processing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Question)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option > options_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  bool for_autonomous_processing_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class AnswerQuestionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.AnswerQuestionRequest) */ {
 public:
  inline AnswerQuestionRequest() : AnswerQuestionRequest(nullptr) {}
  virtual ~AnswerQuestionRequest();

  AnswerQuestionRequest(const AnswerQuestionRequest& from);
  AnswerQuestionRequest(AnswerQuestionRequest&& from) noexcept
    : AnswerQuestionRequest() {
    *this = ::std::move(from);
  }

  inline AnswerQuestionRequest& operator=(const AnswerQuestionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerQuestionRequest& operator=(AnswerQuestionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnswerQuestionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnswerQuestionRequest* internal_default_instance() {
    return reinterpret_cast<const AnswerQuestionRequest*>(
               &_AnswerQuestionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AnswerQuestionRequest& a, AnswerQuestionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerQuestionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerQuestionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnswerQuestionRequest* New() const final {
    return CreateMaybeMessage<AnswerQuestionRequest>(nullptr);
  }

  AnswerQuestionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnswerQuestionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnswerQuestionRequest& from);
  void MergeFrom(const AnswerQuestionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerQuestionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.AnswerQuestionRequest";
  }
  protected:
  explicit AnswerQuestionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kQuestionIdFieldNumber = 2,
    kCodeFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // int64 question_id = 2;
  void clear_question_id();
  ::PROTOBUF_NAMESPACE_ID::int64 question_id() const;
  void set_question_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_question_id() const;
  void _internal_set_question_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 code = 3;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int64 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.AnswerQuestionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int64 question_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class AnswerQuestionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.AnswerQuestionResponse) */ {
 public:
  inline AnswerQuestionResponse() : AnswerQuestionResponse(nullptr) {}
  virtual ~AnswerQuestionResponse();

  AnswerQuestionResponse(const AnswerQuestionResponse& from);
  AnswerQuestionResponse(AnswerQuestionResponse&& from) noexcept
    : AnswerQuestionResponse() {
    *this = ::std::move(from);
  }

  inline AnswerQuestionResponse& operator=(const AnswerQuestionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnswerQuestionResponse& operator=(AnswerQuestionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnswerQuestionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnswerQuestionResponse* internal_default_instance() {
    return reinterpret_cast<const AnswerQuestionResponse*>(
               &_AnswerQuestionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AnswerQuestionResponse& a, AnswerQuestionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AnswerQuestionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnswerQuestionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnswerQuestionResponse* New() const final {
    return CreateMaybeMessage<AnswerQuestionResponse>(nullptr);
  }

  AnswerQuestionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnswerQuestionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnswerQuestionResponse& from);
  void MergeFrom(const AnswerQuestionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnswerQuestionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.AnswerQuestionResponse";
  }
  protected:
  explicit AnswerQuestionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AnswerQuestionResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    AnswerQuestionResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    AnswerQuestionResponse_Status_STATUS_OK;
  static constexpr Status STATUS_INVALID_QUESTION_ID =
    AnswerQuestionResponse_Status_STATUS_INVALID_QUESTION_ID;
  static constexpr Status STATUS_INVALID_CODE =
    AnswerQuestionResponse_Status_STATUS_INVALID_CODE;
  static constexpr Status STATUS_ALREADY_ANSWERED =
    AnswerQuestionResponse_Status_STATUS_ALREADY_ANSWERED;
  static inline bool Status_IsValid(int value) {
    return AnswerQuestionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    AnswerQuestionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    AnswerQuestionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    AnswerQuestionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return AnswerQuestionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return AnswerQuestionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return AnswerQuestionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.AnswerQuestionResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::mission::AnswerQuestionResponse_Status status() const;
  void set_status(::bosdyn::api::mission::AnswerQuestionResponse_Status value);
  private:
  ::bosdyn::api::mission::AnswerQuestionResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::AnswerQuestionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.AnswerQuestionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class MissionInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.MissionInfo) */ {
 public:
  inline MissionInfo() : MissionInfo(nullptr) {}
  virtual ~MissionInfo();

  MissionInfo(const MissionInfo& from);
  MissionInfo(MissionInfo&& from) noexcept
    : MissionInfo() {
    *this = ::std::move(from);
  }

  inline MissionInfo& operator=(const MissionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MissionInfo& operator=(MissionInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MissionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MissionInfo* internal_default_instance() {
    return reinterpret_cast<const MissionInfo*>(
               &_MissionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MissionInfo& a, MissionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MissionInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MissionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MissionInfo* New() const final {
    return CreateMaybeMessage<MissionInfo>(nullptr);
  }

  MissionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MissionInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MissionInfo& from);
  void MergeFrom(const MissionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MissionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.MissionInfo";
  }
  protected:
  explicit MissionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRootFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // .bosdyn.api.mission.NodeInfo root = 2;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::bosdyn::api::mission::NodeInfo& root() const;
  ::bosdyn::api::mission::NodeInfo* release_root();
  ::bosdyn::api::mission::NodeInfo* mutable_root();
  void set_allocated_root(::bosdyn::api::mission::NodeInfo* root);
  private:
  const ::bosdyn::api::mission::NodeInfo& _internal_root() const;
  ::bosdyn::api::mission::NodeInfo* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::bosdyn::api::mission::NodeInfo* root);
  ::bosdyn::api::mission::NodeInfo* unsafe_arena_release_root();

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.MissionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::mission::NodeInfo* root_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(nullptr);
  }

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 4,
    kNameFieldNumber = 2,
    kUserDataFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .bosdyn.api.mission.NodeInfo children = 4;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::bosdyn::api::mission::NodeInfo* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::NodeInfo >*
      mutable_children();
  private:
  const ::bosdyn::api::mission::NodeInfo& _internal_children(int index) const;
  ::bosdyn::api::mission::NodeInfo* _internal_add_children();
  public:
  const ::bosdyn::api::mission::NodeInfo& children(int index) const;
  ::bosdyn::api::mission::NodeInfo* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::NodeInfo >&
      children() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .bosdyn.api.mission.UserData user_data = 3;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::bosdyn::api::mission::UserData& user_data() const;
  ::bosdyn::api::mission::UserData* release_user_data();
  ::bosdyn::api::mission::UserData* mutable_user_data();
  void set_allocated_user_data(::bosdyn::api::mission::UserData* user_data);
  private:
  const ::bosdyn::api::mission::UserData& _internal_user_data() const;
  ::bosdyn::api::mission::UserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::bosdyn::api::mission::UserData* user_data);
  ::bosdyn::api::mission::UserData* unsafe_arena_release_user_data();

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::NodeInfo > children_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::bosdyn::api::mission::UserData* user_data_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class FailedNode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.FailedNode) */ {
 public:
  inline FailedNode() : FailedNode(nullptr) {}
  virtual ~FailedNode();

  FailedNode(const FailedNode& from);
  FailedNode(FailedNode&& from) noexcept
    : FailedNode() {
    *this = ::std::move(from);
  }

  inline FailedNode& operator=(const FailedNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailedNode& operator=(FailedNode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FailedNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FailedNode* internal_default_instance() {
    return reinterpret_cast<const FailedNode*>(
               &_FailedNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FailedNode& a, FailedNode& b) {
    a.Swap(&b);
  }
  inline void Swap(FailedNode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailedNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FailedNode* New() const final {
    return CreateMaybeMessage<FailedNode>(nullptr);
  }

  FailedNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FailedNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FailedNode& from);
  void MergeFrom(const FailedNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailedNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.FailedNode";
  }
  protected:
  explicit FailedNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string error = 2;
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.FailedNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class PlayMissionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.PlayMissionRequest) */ {
 public:
  inline PlayMissionRequest() : PlayMissionRequest(nullptr) {}
  virtual ~PlayMissionRequest();

  PlayMissionRequest(const PlayMissionRequest& from);
  PlayMissionRequest(PlayMissionRequest&& from) noexcept
    : PlayMissionRequest() {
    *this = ::std::move(from);
  }

  inline PlayMissionRequest& operator=(const PlayMissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayMissionRequest& operator=(PlayMissionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayMissionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayMissionRequest* internal_default_instance() {
    return reinterpret_cast<const PlayMissionRequest*>(
               &_PlayMissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PlayMissionRequest& a, PlayMissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayMissionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayMissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayMissionRequest* New() const final {
    return CreateMaybeMessage<PlayMissionRequest>(nullptr);
  }

  PlayMissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayMissionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayMissionRequest& from);
  void MergeFrom(const PlayMissionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayMissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.PlayMissionRequest";
  }
  protected:
  explicit PlayMissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kPauseTimeFieldNumber = 3,
    kSettingsFieldNumber = 5,
  };
  // repeated .bosdyn.api.Lease leases = 4;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .google.protobuf.Timestamp pause_time = 3;
  bool has_pause_time() const;
  private:
  bool _internal_has_pause_time() const;
  public:
  void clear_pause_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& pause_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_pause_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_pause_time();
  void set_allocated_pause_time(PROTOBUF_NAMESPACE_ID::Timestamp* pause_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_pause_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_pause_time();
  public:
  void unsafe_arena_set_allocated_pause_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* pause_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_pause_time();

  // .bosdyn.api.mission.PlaySettings settings = 5;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::bosdyn::api::mission::PlaySettings& settings() const;
  ::bosdyn::api::mission::PlaySettings* release_settings();
  ::bosdyn::api::mission::PlaySettings* mutable_settings();
  void set_allocated_settings(::bosdyn::api::mission::PlaySettings* settings);
  private:
  const ::bosdyn::api::mission::PlaySettings& _internal_settings() const;
  ::bosdyn::api::mission::PlaySettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::bosdyn::api::mission::PlaySettings* settings);
  ::bosdyn::api::mission::PlaySettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.PlayMissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
  ::bosdyn::api::RequestHeader* header_;
  PROTOBUF_NAMESPACE_ID::Timestamp* pause_time_;
  ::bosdyn::api::mission::PlaySettings* settings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class PlaySettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.PlaySettings) */ {
 public:
  inline PlaySettings() : PlaySettings(nullptr) {}
  virtual ~PlaySettings();

  PlaySettings(const PlaySettings& from);
  PlaySettings(PlaySettings&& from) noexcept
    : PlaySettings() {
    *this = ::std::move(from);
  }

  inline PlaySettings& operator=(const PlaySettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlaySettings& operator=(PlaySettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlaySettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlaySettings* internal_default_instance() {
    return reinterpret_cast<const PlaySettings*>(
               &_PlaySettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PlaySettings& a, PlaySettings& b) {
    a.Swap(&b);
  }
  inline void Swap(PlaySettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlaySettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlaySettings* New() const final {
    return CreateMaybeMessage<PlaySettings>(nullptr);
  }

  PlaySettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlaySettings>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlaySettings& from);
  void MergeFrom(const PlaySettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlaySettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.PlaySettings";
  }
  protected:
  explicit PlaySettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVelocityLimitFieldNumber = 1,
  };
  // .bosdyn.api.SE2VelocityLimit velocity_limit = 1;
  bool has_velocity_limit() const;
  private:
  bool _internal_has_velocity_limit() const;
  public:
  void clear_velocity_limit();
  const ::bosdyn::api::SE2VelocityLimit& velocity_limit() const;
  ::bosdyn::api::SE2VelocityLimit* release_velocity_limit();
  ::bosdyn::api::SE2VelocityLimit* mutable_velocity_limit();
  void set_allocated_velocity_limit(::bosdyn::api::SE2VelocityLimit* velocity_limit);
  private:
  const ::bosdyn::api::SE2VelocityLimit& _internal_velocity_limit() const;
  ::bosdyn::api::SE2VelocityLimit* _internal_mutable_velocity_limit();
  public:
  void unsafe_arena_set_allocated_velocity_limit(
      ::bosdyn::api::SE2VelocityLimit* velocity_limit);
  ::bosdyn::api::SE2VelocityLimit* unsafe_arena_release_velocity_limit();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.PlaySettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::SE2VelocityLimit* velocity_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class PlayMissionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.PlayMissionResponse) */ {
 public:
  inline PlayMissionResponse() : PlayMissionResponse(nullptr) {}
  virtual ~PlayMissionResponse();

  PlayMissionResponse(const PlayMissionResponse& from);
  PlayMissionResponse(PlayMissionResponse&& from) noexcept
    : PlayMissionResponse() {
    *this = ::std::move(from);
  }

  inline PlayMissionResponse& operator=(const PlayMissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayMissionResponse& operator=(PlayMissionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayMissionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayMissionResponse* internal_default_instance() {
    return reinterpret_cast<const PlayMissionResponse*>(
               &_PlayMissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PlayMissionResponse& a, PlayMissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayMissionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayMissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayMissionResponse* New() const final {
    return CreateMaybeMessage<PlayMissionResponse>(nullptr);
  }

  PlayMissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayMissionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayMissionResponse& from);
  void MergeFrom(const PlayMissionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayMissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.PlayMissionResponse";
  }
  protected:
  explicit PlayMissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PlayMissionResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    PlayMissionResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    PlayMissionResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NO_MISSION =
    PlayMissionResponse_Status_STATUS_NO_MISSION;
  static inline bool Status_IsValid(int value) {
    return PlayMissionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    PlayMissionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    PlayMissionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    PlayMissionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return PlayMissionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return PlayMissionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return PlayMissionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 3;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.PlayMissionResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::mission::PlayMissionResponse_Status status() const;
  void set_status(::bosdyn::api::mission::PlayMissionResponse_Status value);
  private:
  ::bosdyn::api::mission::PlayMissionResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::PlayMissionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.PlayMissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
  ::bosdyn::api::ResponseHeader* header_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class RestartMissionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.RestartMissionRequest) */ {
 public:
  inline RestartMissionRequest() : RestartMissionRequest(nullptr) {}
  virtual ~RestartMissionRequest();

  RestartMissionRequest(const RestartMissionRequest& from);
  RestartMissionRequest(RestartMissionRequest&& from) noexcept
    : RestartMissionRequest() {
    *this = ::std::move(from);
  }

  inline RestartMissionRequest& operator=(const RestartMissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestartMissionRequest& operator=(RestartMissionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RestartMissionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestartMissionRequest* internal_default_instance() {
    return reinterpret_cast<const RestartMissionRequest*>(
               &_RestartMissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RestartMissionRequest& a, RestartMissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RestartMissionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestartMissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RestartMissionRequest* New() const final {
    return CreateMaybeMessage<RestartMissionRequest>(nullptr);
  }

  RestartMissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RestartMissionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RestartMissionRequest& from);
  void MergeFrom(const RestartMissionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestartMissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.RestartMissionRequest";
  }
  protected:
  explicit RestartMissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kPauseTimeFieldNumber = 2,
    kSettingsFieldNumber = 4,
  };
  // repeated .bosdyn.api.Lease leases = 3;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .google.protobuf.Timestamp pause_time = 2;
  bool has_pause_time() const;
  private:
  bool _internal_has_pause_time() const;
  public:
  void clear_pause_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& pause_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_pause_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_pause_time();
  void set_allocated_pause_time(PROTOBUF_NAMESPACE_ID::Timestamp* pause_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_pause_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_pause_time();
  public:
  void unsafe_arena_set_allocated_pause_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* pause_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_pause_time();

  // .bosdyn.api.mission.PlaySettings settings = 4;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::bosdyn::api::mission::PlaySettings& settings() const;
  ::bosdyn::api::mission::PlaySettings* release_settings();
  ::bosdyn::api::mission::PlaySettings* mutable_settings();
  void set_allocated_settings(::bosdyn::api::mission::PlaySettings* settings);
  private:
  const ::bosdyn::api::mission::PlaySettings& _internal_settings() const;
  ::bosdyn::api::mission::PlaySettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::bosdyn::api::mission::PlaySettings* settings);
  ::bosdyn::api::mission::PlaySettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.RestartMissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
  ::bosdyn::api::RequestHeader* header_;
  PROTOBUF_NAMESPACE_ID::Timestamp* pause_time_;
  ::bosdyn::api::mission::PlaySettings* settings_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class RestartMissionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.RestartMissionResponse) */ {
 public:
  inline RestartMissionResponse() : RestartMissionResponse(nullptr) {}
  virtual ~RestartMissionResponse();

  RestartMissionResponse(const RestartMissionResponse& from);
  RestartMissionResponse(RestartMissionResponse&& from) noexcept
    : RestartMissionResponse() {
    *this = ::std::move(from);
  }

  inline RestartMissionResponse& operator=(const RestartMissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestartMissionResponse& operator=(RestartMissionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RestartMissionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestartMissionResponse* internal_default_instance() {
    return reinterpret_cast<const RestartMissionResponse*>(
               &_RestartMissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RestartMissionResponse& a, RestartMissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RestartMissionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestartMissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RestartMissionResponse* New() const final {
    return CreateMaybeMessage<RestartMissionResponse>(nullptr);
  }

  RestartMissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RestartMissionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RestartMissionResponse& from);
  void MergeFrom(const RestartMissionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestartMissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.RestartMissionResponse";
  }
  protected:
  explicit RestartMissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RestartMissionResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    RestartMissionResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    RestartMissionResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NO_MISSION =
    RestartMissionResponse_Status_STATUS_NO_MISSION;
  static constexpr Status STATUS_VALIDATE_ERROR =
    RestartMissionResponse_Status_STATUS_VALIDATE_ERROR;
  static inline bool Status_IsValid(int value) {
    return RestartMissionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    RestartMissionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    RestartMissionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    RestartMissionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return RestartMissionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return RestartMissionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return RestartMissionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 3,
    kFailedNodesFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 3;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // repeated .bosdyn.api.mission.FailedNode failed_nodes = 4;
  int failed_nodes_size() const;
  private:
  int _internal_failed_nodes_size() const;
  public:
  void clear_failed_nodes();
  ::bosdyn::api::mission::FailedNode* mutable_failed_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >*
      mutable_failed_nodes();
  private:
  const ::bosdyn::api::mission::FailedNode& _internal_failed_nodes(int index) const;
  ::bosdyn::api::mission::FailedNode* _internal_add_failed_nodes();
  public:
  const ::bosdyn::api::mission::FailedNode& failed_nodes(int index) const;
  ::bosdyn::api::mission::FailedNode* add_failed_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >&
      failed_nodes() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.RestartMissionResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::mission::RestartMissionResponse_Status status() const;
  void set_status(::bosdyn::api::mission::RestartMissionResponse_Status value);
  private:
  ::bosdyn::api::mission::RestartMissionResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::RestartMissionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.RestartMissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode > failed_nodes_;
  ::bosdyn::api::ResponseHeader* header_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class LoadMissionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.LoadMissionRequest) */ {
 public:
  inline LoadMissionRequest() : LoadMissionRequest(nullptr) {}
  virtual ~LoadMissionRequest();

  LoadMissionRequest(const LoadMissionRequest& from);
  LoadMissionRequest(LoadMissionRequest&& from) noexcept
    : LoadMissionRequest() {
    *this = ::std::move(from);
  }

  inline LoadMissionRequest& operator=(const LoadMissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadMissionRequest& operator=(LoadMissionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadMissionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadMissionRequest* internal_default_instance() {
    return reinterpret_cast<const LoadMissionRequest*>(
               &_LoadMissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LoadMissionRequest& a, LoadMissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadMissionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadMissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadMissionRequest* New() const final {
    return CreateMaybeMessage<LoadMissionRequest>(nullptr);
  }

  LoadMissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadMissionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadMissionRequest& from);
  void MergeFrom(const LoadMissionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadMissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.LoadMissionRequest";
  }
  protected:
  explicit LoadMissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeasesFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kRootFieldNumber = 2,
  };
  // repeated .bosdyn.api.Lease leases = 3;
  int leases_size() const;
  private:
  int _internal_leases_size() const;
  public:
  void clear_leases();
  ::bosdyn::api::Lease* mutable_leases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
      mutable_leases();
  private:
  const ::bosdyn::api::Lease& _internal_leases(int index) const;
  ::bosdyn::api::Lease* _internal_add_leases();
  public:
  const ::bosdyn::api::Lease& leases(int index) const;
  ::bosdyn::api::Lease* add_leases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
      leases() const;

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.Node root = 2;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::bosdyn::api::mission::Node& root() const;
  ::bosdyn::api::mission::Node* release_root();
  ::bosdyn::api::mission::Node* mutable_root();
  void set_allocated_root(::bosdyn::api::mission::Node* root);
  private:
  const ::bosdyn::api::mission::Node& _internal_root() const;
  ::bosdyn::api::mission::Node* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::bosdyn::api::mission::Node* root);
  ::bosdyn::api::mission::Node* unsafe_arena_release_root();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.LoadMissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease > leases_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::mission::Node* root_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class LoadMissionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.LoadMissionResponse) */ {
 public:
  inline LoadMissionResponse() : LoadMissionResponse(nullptr) {}
  virtual ~LoadMissionResponse();

  LoadMissionResponse(const LoadMissionResponse& from);
  LoadMissionResponse(LoadMissionResponse&& from) noexcept
    : LoadMissionResponse() {
    *this = ::std::move(from);
  }

  inline LoadMissionResponse& operator=(const LoadMissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadMissionResponse& operator=(LoadMissionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadMissionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadMissionResponse* internal_default_instance() {
    return reinterpret_cast<const LoadMissionResponse*>(
               &_LoadMissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LoadMissionResponse& a, LoadMissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadMissionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadMissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadMissionResponse* New() const final {
    return CreateMaybeMessage<LoadMissionResponse>(nullptr);
  }

  LoadMissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadMissionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadMissionResponse& from);
  void MergeFrom(const LoadMissionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadMissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.LoadMissionResponse";
  }
  protected:
  explicit LoadMissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LoadMissionResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    LoadMissionResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    LoadMissionResponse_Status_STATUS_OK;
  static constexpr Status STATUS_COMPILE_ERROR =
    LoadMissionResponse_Status_STATUS_COMPILE_ERROR;
  static constexpr Status STATUS_VALIDATE_ERROR =
    LoadMissionResponse_Status_STATUS_VALIDATE_ERROR;
  static inline bool Status_IsValid(int value) {
    return LoadMissionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    LoadMissionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    LoadMissionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    LoadMissionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return LoadMissionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return LoadMissionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return LoadMissionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseUseResultsFieldNumber = 3,
    kFailedNodesFieldNumber = 5,
    kHeaderFieldNumber = 1,
    kMissionInfoFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // repeated .bosdyn.api.LeaseUseResult lease_use_results = 3;
  int lease_use_results_size() const;
  private:
  int _internal_lease_use_results_size() const;
  public:
  void clear_lease_use_results();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
      mutable_lease_use_results();
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* _internal_add_lease_use_results();
  public:
  const ::bosdyn::api::LeaseUseResult& lease_use_results(int index) const;
  ::bosdyn::api::LeaseUseResult* add_lease_use_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
      lease_use_results() const;

  // repeated .bosdyn.api.mission.FailedNode failed_nodes = 5;
  int failed_nodes_size() const;
  private:
  int _internal_failed_nodes_size() const;
  public:
  void clear_failed_nodes();
  ::bosdyn::api::mission::FailedNode* mutable_failed_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >*
      mutable_failed_nodes();
  private:
  const ::bosdyn::api::mission::FailedNode& _internal_failed_nodes(int index) const;
  ::bosdyn::api::mission::FailedNode* _internal_add_failed_nodes();
  public:
  const ::bosdyn::api::mission::FailedNode& failed_nodes(int index) const;
  ::bosdyn::api::mission::FailedNode* add_failed_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >&
      failed_nodes() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.MissionInfo mission_info = 4;
  bool has_mission_info() const;
  private:
  bool _internal_has_mission_info() const;
  public:
  void clear_mission_info();
  const ::bosdyn::api::mission::MissionInfo& mission_info() const;
  ::bosdyn::api::mission::MissionInfo* release_mission_info();
  ::bosdyn::api::mission::MissionInfo* mutable_mission_info();
  void set_allocated_mission_info(::bosdyn::api::mission::MissionInfo* mission_info);
  private:
  const ::bosdyn::api::mission::MissionInfo& _internal_mission_info() const;
  ::bosdyn::api::mission::MissionInfo* _internal_mutable_mission_info();
  public:
  void unsafe_arena_set_allocated_mission_info(
      ::bosdyn::api::mission::MissionInfo* mission_info);
  ::bosdyn::api::mission::MissionInfo* unsafe_arena_release_mission_info();

  // .bosdyn.api.mission.LoadMissionResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::mission::LoadMissionResponse_Status status() const;
  void set_status(::bosdyn::api::mission::LoadMissionResponse_Status value);
  private:
  ::bosdyn::api::mission::LoadMissionResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::LoadMissionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.LoadMissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult > lease_use_results_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode > failed_nodes_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::mission::MissionInfo* mission_info_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class GetInfoRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.GetInfoRequest) */ {
 public:
  inline GetInfoRequest() : GetInfoRequest(nullptr) {}
  virtual ~GetInfoRequest();

  GetInfoRequest(const GetInfoRequest& from);
  GetInfoRequest(GetInfoRequest&& from) noexcept
    : GetInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetInfoRequest& operator=(const GetInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoRequest& operator=(GetInfoRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetInfoRequest*>(
               &_GetInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetInfoRequest& a, GetInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetInfoRequest* New() const final {
    return CreateMaybeMessage<GetInfoRequest>(nullptr);
  }

  GetInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetInfoRequest& from);
  void MergeFrom(const GetInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.GetInfoRequest";
  }
  protected:
  explicit GetInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.GetInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class GetInfoResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.GetInfoResponse) */ {
 public:
  inline GetInfoResponse() : GetInfoResponse(nullptr) {}
  virtual ~GetInfoResponse();

  GetInfoResponse(const GetInfoResponse& from);
  GetInfoResponse(GetInfoResponse&& from) noexcept
    : GetInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetInfoResponse& operator=(const GetInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInfoResponse& operator=(GetInfoResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetInfoResponse*>(
               &_GetInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetInfoResponse& a, GetInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInfoResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetInfoResponse* New() const final {
    return CreateMaybeMessage<GetInfoResponse>(nullptr);
  }

  GetInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetInfoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetInfoResponse& from);
  void MergeFrom(const GetInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.GetInfoResponse";
  }
  protected:
  explicit GetInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kMissionInfoFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.MissionInfo mission_info = 2;
  bool has_mission_info() const;
  private:
  bool _internal_has_mission_info() const;
  public:
  void clear_mission_info();
  const ::bosdyn::api::mission::MissionInfo& mission_info() const;
  ::bosdyn::api::mission::MissionInfo* release_mission_info();
  ::bosdyn::api::mission::MissionInfo* mutable_mission_info();
  void set_allocated_mission_info(::bosdyn::api::mission::MissionInfo* mission_info);
  private:
  const ::bosdyn::api::mission::MissionInfo& _internal_mission_info() const;
  ::bosdyn::api::mission::MissionInfo* _internal_mutable_mission_info();
  public:
  void unsafe_arena_set_allocated_mission_info(
      ::bosdyn::api::mission::MissionInfo* mission_info);
  ::bosdyn::api::mission::MissionInfo* unsafe_arena_release_mission_info();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.GetInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::mission::MissionInfo* mission_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class PauseMissionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.PauseMissionRequest) */ {
 public:
  inline PauseMissionRequest() : PauseMissionRequest(nullptr) {}
  virtual ~PauseMissionRequest();

  PauseMissionRequest(const PauseMissionRequest& from);
  PauseMissionRequest(PauseMissionRequest&& from) noexcept
    : PauseMissionRequest() {
    *this = ::std::move(from);
  }

  inline PauseMissionRequest& operator=(const PauseMissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseMissionRequest& operator=(PauseMissionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PauseMissionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PauseMissionRequest* internal_default_instance() {
    return reinterpret_cast<const PauseMissionRequest*>(
               &_PauseMissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PauseMissionRequest& a, PauseMissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseMissionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseMissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PauseMissionRequest* New() const final {
    return CreateMaybeMessage<PauseMissionRequest>(nullptr);
  }

  PauseMissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PauseMissionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PauseMissionRequest& from);
  void MergeFrom(const PauseMissionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseMissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.PauseMissionRequest";
  }
  protected:
  explicit PauseMissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.PauseMissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class PauseMissionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.PauseMissionResponse) */ {
 public:
  inline PauseMissionResponse() : PauseMissionResponse(nullptr) {}
  virtual ~PauseMissionResponse();

  PauseMissionResponse(const PauseMissionResponse& from);
  PauseMissionResponse(PauseMissionResponse&& from) noexcept
    : PauseMissionResponse() {
    *this = ::std::move(from);
  }

  inline PauseMissionResponse& operator=(const PauseMissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseMissionResponse& operator=(PauseMissionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PauseMissionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PauseMissionResponse* internal_default_instance() {
    return reinterpret_cast<const PauseMissionResponse*>(
               &_PauseMissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PauseMissionResponse& a, PauseMissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseMissionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseMissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PauseMissionResponse* New() const final {
    return CreateMaybeMessage<PauseMissionResponse>(nullptr);
  }

  PauseMissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PauseMissionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PauseMissionResponse& from);
  void MergeFrom(const PauseMissionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseMissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.PauseMissionResponse";
  }
  protected:
  explicit PauseMissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PauseMissionResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    PauseMissionResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    PauseMissionResponse_Status_STATUS_OK;
  static constexpr Status STATUS_NO_MISSION_PLAYING =
    PauseMissionResponse_Status_STATUS_NO_MISSION_PLAYING;
  static inline bool Status_IsValid(int value) {
    return PauseMissionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    PauseMissionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    PauseMissionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    PauseMissionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return PauseMissionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return PauseMissionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return PauseMissionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 3;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // .bosdyn.api.mission.PauseMissionResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::mission::PauseMissionResponse_Status status() const;
  void set_status(::bosdyn::api::mission::PauseMissionResponse_Status value);
  private:
  ::bosdyn::api::mission::PauseMissionResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::mission::PauseMissionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.PauseMissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class GetMissionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.GetMissionRequest) */ {
 public:
  inline GetMissionRequest() : GetMissionRequest(nullptr) {}
  virtual ~GetMissionRequest();

  GetMissionRequest(const GetMissionRequest& from);
  GetMissionRequest(GetMissionRequest&& from) noexcept
    : GetMissionRequest() {
    *this = ::std::move(from);
  }

  inline GetMissionRequest& operator=(const GetMissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMissionRequest& operator=(GetMissionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetMissionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMissionRequest* internal_default_instance() {
    return reinterpret_cast<const GetMissionRequest*>(
               &_GetMissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetMissionRequest& a, GetMissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMissionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMissionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetMissionRequest* New() const final {
    return CreateMaybeMessage<GetMissionRequest>(nullptr);
  }

  GetMissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetMissionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetMissionRequest& from);
  void MergeFrom(const GetMissionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.GetMissionRequest";
  }
  protected:
  explicit GetMissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.GetMissionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// -------------------------------------------------------------------

class GetMissionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.GetMissionResponse) */ {
 public:
  inline GetMissionResponse() : GetMissionResponse(nullptr) {}
  virtual ~GetMissionResponse();

  GetMissionResponse(const GetMissionResponse& from);
  GetMissionResponse(GetMissionResponse&& from) noexcept
    : GetMissionResponse() {
    *this = ::std::move(from);
  }

  inline GetMissionResponse& operator=(const GetMissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMissionResponse& operator=(GetMissionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetMissionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMissionResponse* internal_default_instance() {
    return reinterpret_cast<const GetMissionResponse*>(
               &_GetMissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetMissionResponse& a, GetMissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMissionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMissionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetMissionResponse* New() const final {
    return CreateMaybeMessage<GetMissionResponse>(nullptr);
  }

  GetMissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetMissionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetMissionResponse& from);
  void MergeFrom(const GetMissionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.GetMissionResponse";
  }
  protected:
  explicit GetMissionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fmission_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRootFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.mission.Node root = 2;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::bosdyn::api::mission::Node& root() const;
  ::bosdyn::api::mission::Node* release_root();
  ::bosdyn::api::mission::Node* mutable_root();
  void set_allocated_root(::bosdyn::api::mission::Node* root);
  private:
  const ::bosdyn::api::mission::Node& _internal_root() const;
  ::bosdyn::api::mission::Node* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::bosdyn::api::mission::Node* root);
  ::bosdyn::api::mission::Node* unsafe_arena_release_root();

  // int64 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.GetMissionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::mission::Node* root_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fmission_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetStateRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetStateRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetStateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetStateRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetStateRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetStateRequest.header)
  return _internal_header();
}
inline void GetStateRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetStateRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetStateRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetStateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetStateRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetStateRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* GetStateRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetStateRequest.header)
  return _internal_mutable_header();
}
inline void GetStateRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetStateRequest.header)
}

// .google.protobuf.Int64Value history_upper_tick_bound = 2;
inline bool GetStateRequest::_internal_has_history_upper_tick_bound() const {
  return this != internal_default_instance() && history_upper_tick_bound_ != nullptr;
}
inline bool GetStateRequest::has_history_upper_tick_bound() const {
  return _internal_has_history_upper_tick_bound();
}
inline const PROTOBUF_NAMESPACE_ID::Int64Value& GetStateRequest::_internal_history_upper_tick_bound() const {
  const PROTOBUF_NAMESPACE_ID::Int64Value* p = history_upper_tick_bound_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Int64Value*>(
      &PROTOBUF_NAMESPACE_ID::_Int64Value_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Int64Value& GetStateRequest::history_upper_tick_bound() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetStateRequest.history_upper_tick_bound)
  return _internal_history_upper_tick_bound();
}
inline void GetStateRequest::unsafe_arena_set_allocated_history_upper_tick_bound(
    PROTOBUF_NAMESPACE_ID::Int64Value* history_upper_tick_bound) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(history_upper_tick_bound_);
  }
  history_upper_tick_bound_ = history_upper_tick_bound;
  if (history_upper_tick_bound) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetStateRequest.history_upper_tick_bound)
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetStateRequest::release_history_upper_tick_bound() {
  
  PROTOBUF_NAMESPACE_ID::Int64Value* temp = history_upper_tick_bound_;
  history_upper_tick_bound_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetStateRequest::unsafe_arena_release_history_upper_tick_bound() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetStateRequest.history_upper_tick_bound)
  
  PROTOBUF_NAMESPACE_ID::Int64Value* temp = history_upper_tick_bound_;
  history_upper_tick_bound_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetStateRequest::_internal_mutable_history_upper_tick_bound() {
  
  if (history_upper_tick_bound_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Int64Value>(GetArena());
    history_upper_tick_bound_ = p;
  }
  return history_upper_tick_bound_;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetStateRequest::mutable_history_upper_tick_bound() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetStateRequest.history_upper_tick_bound)
  return _internal_mutable_history_upper_tick_bound();
}
inline void GetStateRequest::set_allocated_history_upper_tick_bound(PROTOBUF_NAMESPACE_ID::Int64Value* history_upper_tick_bound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(history_upper_tick_bound_);
  }
  if (history_upper_tick_bound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(history_upper_tick_bound)->GetArena();
    if (message_arena != submessage_arena) {
      history_upper_tick_bound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, history_upper_tick_bound, submessage_arena);
    }
    
  } else {
    
  }
  history_upper_tick_bound_ = history_upper_tick_bound;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetStateRequest.history_upper_tick_bound)
}

// int64 history_lower_tick_bound = 3;
inline bool GetStateRequest::_internal_has_history_lower_tick_bound() const {
  return lower_bound_case() == kHistoryLowerTickBound;
}
inline void GetStateRequest::set_has_history_lower_tick_bound() {
  _oneof_case_[0] = kHistoryLowerTickBound;
}
inline void GetStateRequest::clear_history_lower_tick_bound() {
  if (_internal_has_history_lower_tick_bound()) {
    lower_bound_.history_lower_tick_bound_ = PROTOBUF_LONGLONG(0);
    clear_has_lower_bound();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetStateRequest::_internal_history_lower_tick_bound() const {
  if (_internal_has_history_lower_tick_bound()) {
    return lower_bound_.history_lower_tick_bound_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void GetStateRequest::_internal_set_history_lower_tick_bound(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_history_lower_tick_bound()) {
    clear_lower_bound();
    set_has_history_lower_tick_bound();
  }
  lower_bound_.history_lower_tick_bound_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetStateRequest::history_lower_tick_bound() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetStateRequest.history_lower_tick_bound)
  return _internal_history_lower_tick_bound();
}
inline void GetStateRequest::set_history_lower_tick_bound(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_history_lower_tick_bound(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.GetStateRequest.history_lower_tick_bound)
}

// int64 history_past_ticks = 4;
inline bool GetStateRequest::_internal_has_history_past_ticks() const {
  return lower_bound_case() == kHistoryPastTicks;
}
inline void GetStateRequest::set_has_history_past_ticks() {
  _oneof_case_[0] = kHistoryPastTicks;
}
inline void GetStateRequest::clear_history_past_ticks() {
  if (_internal_has_history_past_ticks()) {
    lower_bound_.history_past_ticks_ = PROTOBUF_LONGLONG(0);
    clear_has_lower_bound();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetStateRequest::_internal_history_past_ticks() const {
  if (_internal_has_history_past_ticks()) {
    return lower_bound_.history_past_ticks_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void GetStateRequest::_internal_set_history_past_ticks(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_history_past_ticks()) {
    clear_lower_bound();
    set_has_history_past_ticks();
  }
  lower_bound_.history_past_ticks_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetStateRequest::history_past_ticks() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetStateRequest.history_past_ticks)
  return _internal_history_past_ticks();
}
inline void GetStateRequest::set_history_past_ticks(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_history_past_ticks(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.GetStateRequest.history_past_ticks)
}

inline bool GetStateRequest::has_lower_bound() const {
  return lower_bound_case() != LOWER_BOUND_NOT_SET;
}
inline void GetStateRequest::clear_has_lower_bound() {
  _oneof_case_[0] = LOWER_BOUND_NOT_SET;
}
inline GetStateRequest::LowerBoundCase GetStateRequest::lower_bound_case() const {
  return GetStateRequest::LowerBoundCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetStateResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetStateResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetStateResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetStateResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetStateResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetStateResponse.header)
  return _internal_header();
}
inline void GetStateResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetStateResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetStateResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetStateResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetStateResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetStateResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* GetStateResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetStateResponse.header)
  return _internal_mutable_header();
}
inline void GetStateResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetStateResponse.header)
}

// .bosdyn.api.mission.State state = 2;
inline bool GetStateResponse::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool GetStateResponse::has_state() const {
  return _internal_has_state();
}
inline void GetStateResponse::clear_state() {
  if (GetArena() == nullptr && state_ != nullptr) {
    delete state_;
  }
  state_ = nullptr;
}
inline const ::bosdyn::api::mission::State& GetStateResponse::_internal_state() const {
  const ::bosdyn::api::mission::State* p = state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::State*>(
      &::bosdyn::api::mission::_State_default_instance_);
}
inline const ::bosdyn::api::mission::State& GetStateResponse::state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetStateResponse.state)
  return _internal_state();
}
inline void GetStateResponse::unsafe_arena_set_allocated_state(
    ::bosdyn::api::mission::State* state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetStateResponse.state)
}
inline ::bosdyn::api::mission::State* GetStateResponse::release_state() {
  
  ::bosdyn::api::mission::State* temp = state_;
  state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::State* GetStateResponse::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetStateResponse.state)
  
  ::bosdyn::api::mission::State* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::State* GetStateResponse::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::State>(GetArena());
    state_ = p;
  }
  return state_;
}
inline ::bosdyn::api::mission::State* GetStateResponse::mutable_state() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetStateResponse.state)
  return _internal_mutable_state();
}
inline void GetStateResponse::set_allocated_state(::bosdyn::api::mission::State* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetStateResponse.state)
}

// -------------------------------------------------------------------

// State_AnsweredQuestion

// .bosdyn.api.mission.Question question = 1;
inline bool State_AnsweredQuestion::_internal_has_question() const {
  return this != internal_default_instance() && question_ != nullptr;
}
inline bool State_AnsweredQuestion::has_question() const {
  return _internal_has_question();
}
inline void State_AnsweredQuestion::clear_question() {
  if (GetArena() == nullptr && question_ != nullptr) {
    delete question_;
  }
  question_ = nullptr;
}
inline const ::bosdyn::api::mission::Question& State_AnsweredQuestion::_internal_question() const {
  const ::bosdyn::api::mission::Question* p = question_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Question*>(
      &::bosdyn::api::mission::_Question_default_instance_);
}
inline const ::bosdyn::api::mission::Question& State_AnsweredQuestion::question() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.AnsweredQuestion.question)
  return _internal_question();
}
inline void State_AnsweredQuestion::unsafe_arena_set_allocated_question(
    ::bosdyn::api::mission::Question* question) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(question_);
  }
  question_ = question;
  if (question) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.State.AnsweredQuestion.question)
}
inline ::bosdyn::api::mission::Question* State_AnsweredQuestion::release_question() {
  
  ::bosdyn::api::mission::Question* temp = question_;
  question_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Question* State_AnsweredQuestion::unsafe_arena_release_question() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.State.AnsweredQuestion.question)
  
  ::bosdyn::api::mission::Question* temp = question_;
  question_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Question* State_AnsweredQuestion::_internal_mutable_question() {
  
  if (question_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Question>(GetArena());
    question_ = p;
  }
  return question_;
}
inline ::bosdyn::api::mission::Question* State_AnsweredQuestion::mutable_question() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.State.AnsweredQuestion.question)
  return _internal_mutable_question();
}
inline void State_AnsweredQuestion::set_allocated_question(::bosdyn::api::mission::Question* question) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete question_;
  }
  if (question) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(question);
    if (message_arena != submessage_arena) {
      question = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, question, submessage_arena);
    }
    
  } else {
    
  }
  question_ = question;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.State.AnsweredQuestion.question)
}

// int64 accepted_answer_code = 2;
inline void State_AnsweredQuestion::clear_accepted_answer_code() {
  accepted_answer_code_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State_AnsweredQuestion::_internal_accepted_answer_code() const {
  return accepted_answer_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State_AnsweredQuestion::accepted_answer_code() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.AnsweredQuestion.accepted_answer_code)
  return _internal_accepted_answer_code();
}
inline void State_AnsweredQuestion::_internal_set_accepted_answer_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  accepted_answer_code_ = value;
}
inline void State_AnsweredQuestion::set_accepted_answer_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_accepted_answer_code(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.AnsweredQuestion.accepted_answer_code)
}

// -------------------------------------------------------------------

// State_NodeStatesAtTick_NodeState

// .bosdyn.api.mission.Result result = 1;
inline void State_NodeStatesAtTick_NodeState::clear_result() {
  result_ = 0;
}
inline ::bosdyn::api::mission::Result State_NodeStatesAtTick_NodeState::_internal_result() const {
  return static_cast< ::bosdyn::api::mission::Result >(result_);
}
inline ::bosdyn::api::mission::Result State_NodeStatesAtTick_NodeState::result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.result)
  return _internal_result();
}
inline void State_NodeStatesAtTick_NodeState::_internal_set_result(::bosdyn::api::mission::Result value) {
  
  result_ = value;
}
inline void State_NodeStatesAtTick_NodeState::set_result(::bosdyn::api::mission::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.result)
}

// string error = 2;
inline void State_NodeStatesAtTick_NodeState::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& State_NodeStatesAtTick_NodeState::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.error)
  return _internal_error();
}
inline void State_NodeStatesAtTick_NodeState::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.error)
}
inline std::string* State_NodeStatesAtTick_NodeState::mutable_error() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.error)
  return _internal_mutable_error();
}
inline const std::string& State_NodeStatesAtTick_NodeState::_internal_error() const {
  return error_.Get();
}
inline void State_NodeStatesAtTick_NodeState::_internal_set_error(const std::string& value) {
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void State_NodeStatesAtTick_NodeState::set_error(std::string&& value) {
  
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.error)
}
inline void State_NodeStatesAtTick_NodeState::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.error)
}
inline void State_NodeStatesAtTick_NodeState::set_error(const char* value,
    size_t size) {
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.error)
}
inline std::string* State_NodeStatesAtTick_NodeState::_internal_mutable_error() {
  
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* State_NodeStatesAtTick_NodeState::release_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void State_NodeStatesAtTick_NodeState::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.error)
}

// int64 id = 3;
inline void State_NodeStatesAtTick_NodeState::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State_NodeStatesAtTick_NodeState::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State_NodeStatesAtTick_NodeState::id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.id)
  return _internal_id();
}
inline void State_NodeStatesAtTick_NodeState::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void State_NodeStatesAtTick_NodeState::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.NodeStatesAtTick.NodeState.id)
}

// -------------------------------------------------------------------

// State_NodeStatesAtTick

// int64 tick_counter = 1;
inline void State_NodeStatesAtTick::clear_tick_counter() {
  tick_counter_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State_NodeStatesAtTick::_internal_tick_counter() const {
  return tick_counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State_NodeStatesAtTick::tick_counter() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.NodeStatesAtTick.tick_counter)
  return _internal_tick_counter();
}
inline void State_NodeStatesAtTick::_internal_set_tick_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tick_counter_ = value;
}
inline void State_NodeStatesAtTick::set_tick_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tick_counter(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.NodeStatesAtTick.tick_counter)
}

// .google.protobuf.Timestamp tick_start_timestamp = 2;
inline bool State_NodeStatesAtTick::_internal_has_tick_start_timestamp() const {
  return this != internal_default_instance() && tick_start_timestamp_ != nullptr;
}
inline bool State_NodeStatesAtTick::has_tick_start_timestamp() const {
  return _internal_has_tick_start_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& State_NodeStatesAtTick::_internal_tick_start_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = tick_start_timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& State_NodeStatesAtTick::tick_start_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.NodeStatesAtTick.tick_start_timestamp)
  return _internal_tick_start_timestamp();
}
inline void State_NodeStatesAtTick::unsafe_arena_set_allocated_tick_start_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* tick_start_timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tick_start_timestamp_);
  }
  tick_start_timestamp_ = tick_start_timestamp;
  if (tick_start_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.State.NodeStatesAtTick.tick_start_timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* State_NodeStatesAtTick::release_tick_start_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = tick_start_timestamp_;
  tick_start_timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* State_NodeStatesAtTick::unsafe_arena_release_tick_start_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.State.NodeStatesAtTick.tick_start_timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = tick_start_timestamp_;
  tick_start_timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* State_NodeStatesAtTick::_internal_mutable_tick_start_timestamp() {
  
  if (tick_start_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    tick_start_timestamp_ = p;
  }
  return tick_start_timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* State_NodeStatesAtTick::mutable_tick_start_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.State.NodeStatesAtTick.tick_start_timestamp)
  return _internal_mutable_tick_start_timestamp();
}
inline void State_NodeStatesAtTick::set_allocated_tick_start_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* tick_start_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tick_start_timestamp_);
  }
  if (tick_start_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tick_start_timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      tick_start_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tick_start_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  tick_start_timestamp_ = tick_start_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.State.NodeStatesAtTick.tick_start_timestamp)
}

// repeated .bosdyn.api.mission.State.NodeStatesAtTick.NodeState node_states = 3;
inline int State_NodeStatesAtTick::_internal_node_states_size() const {
  return node_states_.size();
}
inline int State_NodeStatesAtTick::node_states_size() const {
  return _internal_node_states_size();
}
inline void State_NodeStatesAtTick::clear_node_states() {
  node_states_.Clear();
}
inline ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState* State_NodeStatesAtTick::mutable_node_states(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.State.NodeStatesAtTick.node_states)
  return node_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState >*
State_NodeStatesAtTick::mutable_node_states() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.State.NodeStatesAtTick.node_states)
  return &node_states_;
}
inline const ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState& State_NodeStatesAtTick::_internal_node_states(int index) const {
  return node_states_.Get(index);
}
inline const ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState& State_NodeStatesAtTick::node_states(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.NodeStatesAtTick.node_states)
  return _internal_node_states(index);
}
inline ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState* State_NodeStatesAtTick::_internal_add_node_states() {
  return node_states_.Add();
}
inline ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState* State_NodeStatesAtTick::add_node_states() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.State.NodeStatesAtTick.node_states)
  return _internal_add_node_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick_NodeState >&
State_NodeStatesAtTick::node_states() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.State.NodeStatesAtTick.node_states)
  return node_states_;
}

// -------------------------------------------------------------------

// State

// repeated .bosdyn.api.mission.Question questions = 1;
inline int State::_internal_questions_size() const {
  return questions_.size();
}
inline int State::questions_size() const {
  return _internal_questions_size();
}
inline void State::clear_questions() {
  questions_.Clear();
}
inline ::bosdyn::api::mission::Question* State::mutable_questions(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.State.questions)
  return questions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Question >*
State::mutable_questions() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.State.questions)
  return &questions_;
}
inline const ::bosdyn::api::mission::Question& State::_internal_questions(int index) const {
  return questions_.Get(index);
}
inline const ::bosdyn::api::mission::Question& State::questions(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.questions)
  return _internal_questions(index);
}
inline ::bosdyn::api::mission::Question* State::_internal_add_questions() {
  return questions_.Add();
}
inline ::bosdyn::api::mission::Question* State::add_questions() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.State.questions)
  return _internal_add_questions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Question >&
State::questions() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.State.questions)
  return questions_;
}

// repeated .bosdyn.api.mission.State.AnsweredQuestion answered_questions = 2;
inline int State::_internal_answered_questions_size() const {
  return answered_questions_.size();
}
inline int State::answered_questions_size() const {
  return _internal_answered_questions_size();
}
inline void State::clear_answered_questions() {
  answered_questions_.Clear();
}
inline ::bosdyn::api::mission::State_AnsweredQuestion* State::mutable_answered_questions(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.State.answered_questions)
  return answered_questions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_AnsweredQuestion >*
State::mutable_answered_questions() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.State.answered_questions)
  return &answered_questions_;
}
inline const ::bosdyn::api::mission::State_AnsweredQuestion& State::_internal_answered_questions(int index) const {
  return answered_questions_.Get(index);
}
inline const ::bosdyn::api::mission::State_AnsweredQuestion& State::answered_questions(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.answered_questions)
  return _internal_answered_questions(index);
}
inline ::bosdyn::api::mission::State_AnsweredQuestion* State::_internal_add_answered_questions() {
  return answered_questions_.Add();
}
inline ::bosdyn::api::mission::State_AnsweredQuestion* State::add_answered_questions() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.State.answered_questions)
  return _internal_add_answered_questions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_AnsweredQuestion >&
State::answered_questions() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.State.answered_questions)
  return answered_questions_;
}

// repeated .bosdyn.api.mission.State.NodeStatesAtTick history = 3;
inline int State::_internal_history_size() const {
  return history_.size();
}
inline int State::history_size() const {
  return _internal_history_size();
}
inline void State::clear_history() {
  history_.Clear();
}
inline ::bosdyn::api::mission::State_NodeStatesAtTick* State::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.State.history)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick >*
State::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.State.history)
  return &history_;
}
inline const ::bosdyn::api::mission::State_NodeStatesAtTick& State::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::bosdyn::api::mission::State_NodeStatesAtTick& State::history(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.history)
  return _internal_history(index);
}
inline ::bosdyn::api::mission::State_NodeStatesAtTick* State::_internal_add_history() {
  return history_.Add();
}
inline ::bosdyn::api::mission::State_NodeStatesAtTick* State::add_history() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.State.history)
  return _internal_add_history();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::State_NodeStatesAtTick >&
State::history() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.State.history)
  return history_;
}

// .bosdyn.api.mission.State.Status status = 4;
inline void State::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::mission::State_Status State::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::State_Status >(status_);
}
inline ::bosdyn::api::mission::State_Status State::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.status)
  return _internal_status();
}
inline void State::_internal_set_status(::bosdyn::api::mission::State_Status value) {
  
  status_ = value;
}
inline void State::set_status(::bosdyn::api::mission::State_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.status)
}

// string error = 5;
inline void State::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& State::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.error)
  return _internal_error();
}
inline void State::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.error)
}
inline std::string* State::mutable_error() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.State.error)
  return _internal_mutable_error();
}
inline const std::string& State::_internal_error() const {
  return error_.Get();
}
inline void State::_internal_set_error(const std::string& value) {
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void State::set_error(std::string&& value) {
  
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.State.error)
}
inline void State::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.State.error)
}
inline void State::set_error(const char* value,
    size_t size) {
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.State.error)
}
inline std::string* State::_internal_mutable_error() {
  
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* State::release_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.State.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void State::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.State.error)
}

// int64 tick_counter = 6;
inline void State::clear_tick_counter() {
  tick_counter_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::_internal_tick_counter() const {
  return tick_counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::tick_counter() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.tick_counter)
  return _internal_tick_counter();
}
inline void State::_internal_set_tick_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tick_counter_ = value;
}
inline void State::set_tick_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tick_counter(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.tick_counter)
}

// int64 mission_id = 7;
inline void State::clear_mission_id() {
  mission_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::_internal_mission_id() const {
  return mission_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::mission_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.State.mission_id)
  return _internal_mission_id();
}
inline void State::_internal_set_mission_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  mission_id_ = value;
}
inline void State::set_mission_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_mission_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.State.mission_id)
}

// -------------------------------------------------------------------

// Question

// int64 id = 1;
inline void Question::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Question::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Question::id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Question.id)
  return _internal_id();
}
inline void Question::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void Question::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Question.id)
}

// string source = 2;
inline void Question::clear_source() {
  source_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Question::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Question.source)
  return _internal_source();
}
inline void Question::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Question.source)
}
inline std::string* Question::mutable_source() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Question.source)
  return _internal_mutable_source();
}
inline const std::string& Question::_internal_source() const {
  return source_.Get();
}
inline void Question::_internal_set_source(const std::string& value) {
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Question::set_source(std::string&& value) {
  
  source_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.Question.source)
}
inline void Question::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.Question.source)
}
inline void Question::set_source(const char* value,
    size_t size) {
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.Question.source)
}
inline std::string* Question::_internal_mutable_source() {
  
  return source_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Question::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Question.source)
  return source_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Question::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Question.source)
}

// string text = 3;
inline void Question::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Question::text() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Question.text)
  return _internal_text();
}
inline void Question::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Question.text)
}
inline std::string* Question::mutable_text() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Question.text)
  return _internal_mutable_text();
}
inline const std::string& Question::_internal_text() const {
  return text_.Get();
}
inline void Question::_internal_set_text(const std::string& value) {
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Question::set_text(std::string&& value) {
  
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.Question.text)
}
inline void Question::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.Question.text)
}
inline void Question::set_text(const char* value,
    size_t size) {
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.Question.text)
}
inline std::string* Question::_internal_mutable_text() {
  
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Question::release_text() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Question.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Question::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Question.text)
}

// repeated .bosdyn.api.mission.Prompt.Option options = 4;
inline int Question::_internal_options_size() const {
  return options_.size();
}
inline int Question::options_size() const {
  return _internal_options_size();
}
inline ::bosdyn::api::mission::Prompt_Option* Question::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Question.options)
  return options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >*
Question::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Question.options)
  return &options_;
}
inline const ::bosdyn::api::mission::Prompt_Option& Question::_internal_options(int index) const {
  return options_.Get(index);
}
inline const ::bosdyn::api::mission::Prompt_Option& Question::options(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Question.options)
  return _internal_options(index);
}
inline ::bosdyn::api::mission::Prompt_Option* Question::_internal_add_options() {
  return options_.Add();
}
inline ::bosdyn::api::mission::Prompt_Option* Question::add_options() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Question.options)
  return _internal_add_options();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >&
Question::options() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Question.options)
  return options_;
}

// bool for_autonomous_processing = 5;
inline void Question::clear_for_autonomous_processing() {
  for_autonomous_processing_ = false;
}
inline bool Question::_internal_for_autonomous_processing() const {
  return for_autonomous_processing_;
}
inline bool Question::for_autonomous_processing() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Question.for_autonomous_processing)
  return _internal_for_autonomous_processing();
}
inline void Question::_internal_set_for_autonomous_processing(bool value) {
  
  for_autonomous_processing_ = value;
}
inline void Question::set_for_autonomous_processing(bool value) {
  _internal_set_for_autonomous_processing(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Question.for_autonomous_processing)
}

// -------------------------------------------------------------------

// AnswerQuestionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool AnswerQuestionRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool AnswerQuestionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& AnswerQuestionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& AnswerQuestionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.AnswerQuestionRequest.header)
  return _internal_header();
}
inline void AnswerQuestionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.AnswerQuestionRequest.header)
}
inline ::bosdyn::api::RequestHeader* AnswerQuestionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* AnswerQuestionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.AnswerQuestionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* AnswerQuestionRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* AnswerQuestionRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.AnswerQuestionRequest.header)
  return _internal_mutable_header();
}
inline void AnswerQuestionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.AnswerQuestionRequest.header)
}

// int64 question_id = 2;
inline void AnswerQuestionRequest::clear_question_id() {
  question_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AnswerQuestionRequest::_internal_question_id() const {
  return question_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AnswerQuestionRequest::question_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.AnswerQuestionRequest.question_id)
  return _internal_question_id();
}
inline void AnswerQuestionRequest::_internal_set_question_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  question_id_ = value;
}
inline void AnswerQuestionRequest::set_question_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_question_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.AnswerQuestionRequest.question_id)
}

// int64 code = 3;
inline void AnswerQuestionRequest::clear_code() {
  code_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AnswerQuestionRequest::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AnswerQuestionRequest::code() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.AnswerQuestionRequest.code)
  return _internal_code();
}
inline void AnswerQuestionRequest::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  code_ = value;
}
inline void AnswerQuestionRequest::set_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.AnswerQuestionRequest.code)
}

// -------------------------------------------------------------------

// AnswerQuestionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool AnswerQuestionResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool AnswerQuestionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& AnswerQuestionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& AnswerQuestionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.AnswerQuestionResponse.header)
  return _internal_header();
}
inline void AnswerQuestionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.AnswerQuestionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* AnswerQuestionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AnswerQuestionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.AnswerQuestionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* AnswerQuestionResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* AnswerQuestionResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.AnswerQuestionResponse.header)
  return _internal_mutable_header();
}
inline void AnswerQuestionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.AnswerQuestionResponse.header)
}

// .bosdyn.api.mission.AnswerQuestionResponse.Status status = 2;
inline void AnswerQuestionResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::mission::AnswerQuestionResponse_Status AnswerQuestionResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::AnswerQuestionResponse_Status >(status_);
}
inline ::bosdyn::api::mission::AnswerQuestionResponse_Status AnswerQuestionResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.AnswerQuestionResponse.status)
  return _internal_status();
}
inline void AnswerQuestionResponse::_internal_set_status(::bosdyn::api::mission::AnswerQuestionResponse_Status value) {
  
  status_ = value;
}
inline void AnswerQuestionResponse::set_status(::bosdyn::api::mission::AnswerQuestionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.AnswerQuestionResponse.status)
}

// -------------------------------------------------------------------

// MissionInfo

// int64 id = 1;
inline void MissionInfo::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MissionInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MissionInfo::id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.MissionInfo.id)
  return _internal_id();
}
inline void MissionInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void MissionInfo::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.MissionInfo.id)
}

// .bosdyn.api.mission.NodeInfo root = 2;
inline bool MissionInfo::_internal_has_root() const {
  return this != internal_default_instance() && root_ != nullptr;
}
inline bool MissionInfo::has_root() const {
  return _internal_has_root();
}
inline void MissionInfo::clear_root() {
  if (GetArena() == nullptr && root_ != nullptr) {
    delete root_;
  }
  root_ = nullptr;
}
inline const ::bosdyn::api::mission::NodeInfo& MissionInfo::_internal_root() const {
  const ::bosdyn::api::mission::NodeInfo* p = root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::NodeInfo*>(
      &::bosdyn::api::mission::_NodeInfo_default_instance_);
}
inline const ::bosdyn::api::mission::NodeInfo& MissionInfo::root() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.MissionInfo.root)
  return _internal_root();
}
inline void MissionInfo::unsafe_arena_set_allocated_root(
    ::bosdyn::api::mission::NodeInfo* root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.MissionInfo.root)
}
inline ::bosdyn::api::mission::NodeInfo* MissionInfo::release_root() {
  
  ::bosdyn::api::mission::NodeInfo* temp = root_;
  root_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::NodeInfo* MissionInfo::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.MissionInfo.root)
  
  ::bosdyn::api::mission::NodeInfo* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::NodeInfo* MissionInfo::_internal_mutable_root() {
  
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::NodeInfo>(GetArena());
    root_ = p;
  }
  return root_;
}
inline ::bosdyn::api::mission::NodeInfo* MissionInfo::mutable_root() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.MissionInfo.root)
  return _internal_mutable_root();
}
inline void MissionInfo::set_allocated_root(::bosdyn::api::mission::NodeInfo* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete root_;
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(root);
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.MissionInfo.root)
}

// -------------------------------------------------------------------

// NodeInfo

// int64 id = 1;
inline void NodeInfo::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NodeInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NodeInfo::id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.NodeInfo.id)
  return _internal_id();
}
inline void NodeInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void NodeInfo::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.NodeInfo.id)
}

// string name = 2;
inline void NodeInfo::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeInfo::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.NodeInfo.name)
  return _internal_name();
}
inline void NodeInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.NodeInfo.name)
}
inline std::string* NodeInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.NodeInfo.name)
  return _internal_mutable_name();
}
inline const std::string& NodeInfo::_internal_name() const {
  return name_.Get();
}
inline void NodeInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeInfo::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.NodeInfo.name)
}
inline void NodeInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.NodeInfo.name)
}
inline void NodeInfo::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.NodeInfo.name)
}
inline std::string* NodeInfo::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeInfo::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.NodeInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.NodeInfo.name)
}

// .bosdyn.api.mission.UserData user_data = 3;
inline bool NodeInfo::_internal_has_user_data() const {
  return this != internal_default_instance() && user_data_ != nullptr;
}
inline bool NodeInfo::has_user_data() const {
  return _internal_has_user_data();
}
inline const ::bosdyn::api::mission::UserData& NodeInfo::_internal_user_data() const {
  const ::bosdyn::api::mission::UserData* p = user_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::UserData*>(
      &::bosdyn::api::mission::_UserData_default_instance_);
}
inline const ::bosdyn::api::mission::UserData& NodeInfo::user_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.NodeInfo.user_data)
  return _internal_user_data();
}
inline void NodeInfo::unsafe_arena_set_allocated_user_data(
    ::bosdyn::api::mission::UserData* user_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_data_);
  }
  user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.NodeInfo.user_data)
}
inline ::bosdyn::api::mission::UserData* NodeInfo::release_user_data() {
  
  ::bosdyn::api::mission::UserData* temp = user_data_;
  user_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::UserData* NodeInfo::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.NodeInfo.user_data)
  
  ::bosdyn::api::mission::UserData* temp = user_data_;
  user_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::UserData* NodeInfo::_internal_mutable_user_data() {
  
  if (user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::UserData>(GetArena());
    user_data_ = p;
  }
  return user_data_;
}
inline ::bosdyn::api::mission::UserData* NodeInfo::mutable_user_data() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.NodeInfo.user_data)
  return _internal_mutable_user_data();
}
inline void NodeInfo::set_allocated_user_data(::bosdyn::api::mission::UserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_data_);
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_data)->GetArena();
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.NodeInfo.user_data)
}

// repeated .bosdyn.api.mission.NodeInfo children = 4;
inline int NodeInfo::_internal_children_size() const {
  return children_.size();
}
inline int NodeInfo::children_size() const {
  return _internal_children_size();
}
inline void NodeInfo::clear_children() {
  children_.Clear();
}
inline ::bosdyn::api::mission::NodeInfo* NodeInfo::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.NodeInfo.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::NodeInfo >*
NodeInfo::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.NodeInfo.children)
  return &children_;
}
inline const ::bosdyn::api::mission::NodeInfo& NodeInfo::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::bosdyn::api::mission::NodeInfo& NodeInfo::children(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.NodeInfo.children)
  return _internal_children(index);
}
inline ::bosdyn::api::mission::NodeInfo* NodeInfo::_internal_add_children() {
  return children_.Add();
}
inline ::bosdyn::api::mission::NodeInfo* NodeInfo::add_children() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.NodeInfo.children)
  return _internal_add_children();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::NodeInfo >&
NodeInfo::children() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.NodeInfo.children)
  return children_;
}

// -------------------------------------------------------------------

// FailedNode

// string name = 1;
inline void FailedNode::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FailedNode::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.FailedNode.name)
  return _internal_name();
}
inline void FailedNode::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.FailedNode.name)
}
inline std::string* FailedNode::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.FailedNode.name)
  return _internal_mutable_name();
}
inline const std::string& FailedNode::_internal_name() const {
  return name_.Get();
}
inline void FailedNode::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FailedNode::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.FailedNode.name)
}
inline void FailedNode::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.FailedNode.name)
}
inline void FailedNode::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.FailedNode.name)
}
inline std::string* FailedNode::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FailedNode::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.FailedNode.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FailedNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.FailedNode.name)
}

// string error = 2;
inline void FailedNode::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FailedNode::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.FailedNode.error)
  return _internal_error();
}
inline void FailedNode::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.FailedNode.error)
}
inline std::string* FailedNode::mutable_error() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.FailedNode.error)
  return _internal_mutable_error();
}
inline const std::string& FailedNode::_internal_error() const {
  return error_.Get();
}
inline void FailedNode::_internal_set_error(const std::string& value) {
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FailedNode::set_error(std::string&& value) {
  
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.FailedNode.error)
}
inline void FailedNode::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.FailedNode.error)
}
inline void FailedNode::set_error(const char* value,
    size_t size) {
  
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.FailedNode.error)
}
inline std::string* FailedNode::_internal_mutable_error() {
  
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FailedNode::release_error() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.FailedNode.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FailedNode::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.FailedNode.error)
}

// -------------------------------------------------------------------

// PlayMissionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool PlayMissionRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool PlayMissionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& PlayMissionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& PlayMissionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PlayMissionRequest.header)
  return _internal_header();
}
inline void PlayMissionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PlayMissionRequest.header)
}
inline ::bosdyn::api::RequestHeader* PlayMissionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* PlayMissionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PlayMissionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* PlayMissionRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* PlayMissionRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PlayMissionRequest.header)
  return _internal_mutable_header();
}
inline void PlayMissionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PlayMissionRequest.header)
}

// .google.protobuf.Timestamp pause_time = 3;
inline bool PlayMissionRequest::_internal_has_pause_time() const {
  return this != internal_default_instance() && pause_time_ != nullptr;
}
inline bool PlayMissionRequest::has_pause_time() const {
  return _internal_has_pause_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PlayMissionRequest::_internal_pause_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = pause_time_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& PlayMissionRequest::pause_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PlayMissionRequest.pause_time)
  return _internal_pause_time();
}
inline void PlayMissionRequest::unsafe_arena_set_allocated_pause_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* pause_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pause_time_);
  }
  pause_time_ = pause_time;
  if (pause_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PlayMissionRequest.pause_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PlayMissionRequest::release_pause_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = pause_time_;
  pause_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PlayMissionRequest::unsafe_arena_release_pause_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PlayMissionRequest.pause_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = pause_time_;
  pause_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PlayMissionRequest::_internal_mutable_pause_time() {
  
  if (pause_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    pause_time_ = p;
  }
  return pause_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* PlayMissionRequest::mutable_pause_time() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PlayMissionRequest.pause_time)
  return _internal_mutable_pause_time();
}
inline void PlayMissionRequest::set_allocated_pause_time(PROTOBUF_NAMESPACE_ID::Timestamp* pause_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pause_time_);
  }
  if (pause_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pause_time)->GetArena();
    if (message_arena != submessage_arena) {
      pause_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pause_time, submessage_arena);
    }
    
  } else {
    
  }
  pause_time_ = pause_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PlayMissionRequest.pause_time)
}

// repeated .bosdyn.api.Lease leases = 4;
inline int PlayMissionRequest::_internal_leases_size() const {
  return leases_.size();
}
inline int PlayMissionRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* PlayMissionRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PlayMissionRequest.leases)
  return leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
PlayMissionRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.PlayMissionRequest.leases)
  return &leases_;
}
inline const ::bosdyn::api::Lease& PlayMissionRequest::_internal_leases(int index) const {
  return leases_.Get(index);
}
inline const ::bosdyn::api::Lease& PlayMissionRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PlayMissionRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* PlayMissionRequest::_internal_add_leases() {
  return leases_.Add();
}
inline ::bosdyn::api::Lease* PlayMissionRequest::add_leases() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.PlayMissionRequest.leases)
  return _internal_add_leases();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
PlayMissionRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.PlayMissionRequest.leases)
  return leases_;
}

// .bosdyn.api.mission.PlaySettings settings = 5;
inline bool PlayMissionRequest::_internal_has_settings() const {
  return this != internal_default_instance() && settings_ != nullptr;
}
inline bool PlayMissionRequest::has_settings() const {
  return _internal_has_settings();
}
inline void PlayMissionRequest::clear_settings() {
  if (GetArena() == nullptr && settings_ != nullptr) {
    delete settings_;
  }
  settings_ = nullptr;
}
inline const ::bosdyn::api::mission::PlaySettings& PlayMissionRequest::_internal_settings() const {
  const ::bosdyn::api::mission::PlaySettings* p = settings_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::PlaySettings*>(
      &::bosdyn::api::mission::_PlaySettings_default_instance_);
}
inline const ::bosdyn::api::mission::PlaySettings& PlayMissionRequest::settings() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PlayMissionRequest.settings)
  return _internal_settings();
}
inline void PlayMissionRequest::unsafe_arena_set_allocated_settings(
    ::bosdyn::api::mission::PlaySettings* settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings_);
  }
  settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PlayMissionRequest.settings)
}
inline ::bosdyn::api::mission::PlaySettings* PlayMissionRequest::release_settings() {
  
  ::bosdyn::api::mission::PlaySettings* temp = settings_;
  settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::PlaySettings* PlayMissionRequest::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PlayMissionRequest.settings)
  
  ::bosdyn::api::mission::PlaySettings* temp = settings_;
  settings_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::PlaySettings* PlayMissionRequest::_internal_mutable_settings() {
  
  if (settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::PlaySettings>(GetArena());
    settings_ = p;
  }
  return settings_;
}
inline ::bosdyn::api::mission::PlaySettings* PlayMissionRequest::mutable_settings() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PlayMissionRequest.settings)
  return _internal_mutable_settings();
}
inline void PlayMissionRequest::set_allocated_settings(::bosdyn::api::mission::PlaySettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PlayMissionRequest.settings)
}

// -------------------------------------------------------------------

// PlaySettings

// .bosdyn.api.SE2VelocityLimit velocity_limit = 1;
inline bool PlaySettings::_internal_has_velocity_limit() const {
  return this != internal_default_instance() && velocity_limit_ != nullptr;
}
inline bool PlaySettings::has_velocity_limit() const {
  return _internal_has_velocity_limit();
}
inline const ::bosdyn::api::SE2VelocityLimit& PlaySettings::_internal_velocity_limit() const {
  const ::bosdyn::api::SE2VelocityLimit* p = velocity_limit_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE2VelocityLimit*>(
      &::bosdyn::api::_SE2VelocityLimit_default_instance_);
}
inline const ::bosdyn::api::SE2VelocityLimit& PlaySettings::velocity_limit() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PlaySettings.velocity_limit)
  return _internal_velocity_limit();
}
inline void PlaySettings::unsafe_arena_set_allocated_velocity_limit(
    ::bosdyn::api::SE2VelocityLimit* velocity_limit) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_limit_);
  }
  velocity_limit_ = velocity_limit;
  if (velocity_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PlaySettings.velocity_limit)
}
inline ::bosdyn::api::SE2VelocityLimit* PlaySettings::release_velocity_limit() {
  
  ::bosdyn::api::SE2VelocityLimit* temp = velocity_limit_;
  velocity_limit_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE2VelocityLimit* PlaySettings::unsafe_arena_release_velocity_limit() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PlaySettings.velocity_limit)
  
  ::bosdyn::api::SE2VelocityLimit* temp = velocity_limit_;
  velocity_limit_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE2VelocityLimit* PlaySettings::_internal_mutable_velocity_limit() {
  
  if (velocity_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE2VelocityLimit>(GetArena());
    velocity_limit_ = p;
  }
  return velocity_limit_;
}
inline ::bosdyn::api::SE2VelocityLimit* PlaySettings::mutable_velocity_limit() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PlaySettings.velocity_limit)
  return _internal_mutable_velocity_limit();
}
inline void PlaySettings::set_allocated_velocity_limit(::bosdyn::api::SE2VelocityLimit* velocity_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_limit_);
  }
  if (velocity_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity_limit)->GetArena();
    if (message_arena != submessage_arena) {
      velocity_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_limit, submessage_arena);
    }
    
  } else {
    
  }
  velocity_limit_ = velocity_limit;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PlaySettings.velocity_limit)
}

// -------------------------------------------------------------------

// PlayMissionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool PlayMissionResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool PlayMissionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& PlayMissionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& PlayMissionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PlayMissionResponse.header)
  return _internal_header();
}
inline void PlayMissionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PlayMissionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* PlayMissionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* PlayMissionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PlayMissionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* PlayMissionResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* PlayMissionResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PlayMissionResponse.header)
  return _internal_mutable_header();
}
inline void PlayMissionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PlayMissionResponse.header)
}

// .bosdyn.api.mission.PlayMissionResponse.Status status = 2;
inline void PlayMissionResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::mission::PlayMissionResponse_Status PlayMissionResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::PlayMissionResponse_Status >(status_);
}
inline ::bosdyn::api::mission::PlayMissionResponse_Status PlayMissionResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PlayMissionResponse.status)
  return _internal_status();
}
inline void PlayMissionResponse::_internal_set_status(::bosdyn::api::mission::PlayMissionResponse_Status value) {
  
  status_ = value;
}
inline void PlayMissionResponse::set_status(::bosdyn::api::mission::PlayMissionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.PlayMissionResponse.status)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 3;
inline int PlayMissionResponse::_internal_lease_use_results_size() const {
  return lease_use_results_.size();
}
inline int PlayMissionResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* PlayMissionResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PlayMissionResponse.lease_use_results)
  return lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
PlayMissionResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.PlayMissionResponse.lease_use_results)
  return &lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& PlayMissionResponse::_internal_lease_use_results(int index) const {
  return lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& PlayMissionResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PlayMissionResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* PlayMissionResponse::_internal_add_lease_use_results() {
  return lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* PlayMissionResponse::add_lease_use_results() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.PlayMissionResponse.lease_use_results)
  return _internal_add_lease_use_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
PlayMissionResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.PlayMissionResponse.lease_use_results)
  return lease_use_results_;
}

// -------------------------------------------------------------------

// RestartMissionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RestartMissionRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RestartMissionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RestartMissionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RestartMissionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartMissionRequest.header)
  return _internal_header();
}
inline void RestartMissionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.RestartMissionRequest.header)
}
inline ::bosdyn::api::RequestHeader* RestartMissionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RestartMissionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RestartMissionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RestartMissionRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RestartMissionRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RestartMissionRequest.header)
  return _internal_mutable_header();
}
inline void RestartMissionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RestartMissionRequest.header)
}

// .google.protobuf.Timestamp pause_time = 2;
inline bool RestartMissionRequest::_internal_has_pause_time() const {
  return this != internal_default_instance() && pause_time_ != nullptr;
}
inline bool RestartMissionRequest::has_pause_time() const {
  return _internal_has_pause_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& RestartMissionRequest::_internal_pause_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = pause_time_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& RestartMissionRequest::pause_time() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartMissionRequest.pause_time)
  return _internal_pause_time();
}
inline void RestartMissionRequest::unsafe_arena_set_allocated_pause_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* pause_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pause_time_);
  }
  pause_time_ = pause_time;
  if (pause_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.RestartMissionRequest.pause_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RestartMissionRequest::release_pause_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = pause_time_;
  pause_time_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RestartMissionRequest::unsafe_arena_release_pause_time() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RestartMissionRequest.pause_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = pause_time_;
  pause_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RestartMissionRequest::_internal_mutable_pause_time() {
  
  if (pause_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    pause_time_ = p;
  }
  return pause_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* RestartMissionRequest::mutable_pause_time() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RestartMissionRequest.pause_time)
  return _internal_mutable_pause_time();
}
inline void RestartMissionRequest::set_allocated_pause_time(PROTOBUF_NAMESPACE_ID::Timestamp* pause_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pause_time_);
  }
  if (pause_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pause_time)->GetArena();
    if (message_arena != submessage_arena) {
      pause_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pause_time, submessage_arena);
    }
    
  } else {
    
  }
  pause_time_ = pause_time;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RestartMissionRequest.pause_time)
}

// repeated .bosdyn.api.Lease leases = 3;
inline int RestartMissionRequest::_internal_leases_size() const {
  return leases_.size();
}
inline int RestartMissionRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* RestartMissionRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RestartMissionRequest.leases)
  return leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
RestartMissionRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.RestartMissionRequest.leases)
  return &leases_;
}
inline const ::bosdyn::api::Lease& RestartMissionRequest::_internal_leases(int index) const {
  return leases_.Get(index);
}
inline const ::bosdyn::api::Lease& RestartMissionRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartMissionRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* RestartMissionRequest::_internal_add_leases() {
  return leases_.Add();
}
inline ::bosdyn::api::Lease* RestartMissionRequest::add_leases() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RestartMissionRequest.leases)
  return _internal_add_leases();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
RestartMissionRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.RestartMissionRequest.leases)
  return leases_;
}

// .bosdyn.api.mission.PlaySettings settings = 4;
inline bool RestartMissionRequest::_internal_has_settings() const {
  return this != internal_default_instance() && settings_ != nullptr;
}
inline bool RestartMissionRequest::has_settings() const {
  return _internal_has_settings();
}
inline void RestartMissionRequest::clear_settings() {
  if (GetArena() == nullptr && settings_ != nullptr) {
    delete settings_;
  }
  settings_ = nullptr;
}
inline const ::bosdyn::api::mission::PlaySettings& RestartMissionRequest::_internal_settings() const {
  const ::bosdyn::api::mission::PlaySettings* p = settings_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::PlaySettings*>(
      &::bosdyn::api::mission::_PlaySettings_default_instance_);
}
inline const ::bosdyn::api::mission::PlaySettings& RestartMissionRequest::settings() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartMissionRequest.settings)
  return _internal_settings();
}
inline void RestartMissionRequest::unsafe_arena_set_allocated_settings(
    ::bosdyn::api::mission::PlaySettings* settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings_);
  }
  settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.RestartMissionRequest.settings)
}
inline ::bosdyn::api::mission::PlaySettings* RestartMissionRequest::release_settings() {
  
  ::bosdyn::api::mission::PlaySettings* temp = settings_;
  settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::PlaySettings* RestartMissionRequest::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RestartMissionRequest.settings)
  
  ::bosdyn::api::mission::PlaySettings* temp = settings_;
  settings_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::PlaySettings* RestartMissionRequest::_internal_mutable_settings() {
  
  if (settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::PlaySettings>(GetArena());
    settings_ = p;
  }
  return settings_;
}
inline ::bosdyn::api::mission::PlaySettings* RestartMissionRequest::mutable_settings() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RestartMissionRequest.settings)
  return _internal_mutable_settings();
}
inline void RestartMissionRequest::set_allocated_settings(::bosdyn::api::mission::PlaySettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RestartMissionRequest.settings)
}

// -------------------------------------------------------------------

// RestartMissionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RestartMissionResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RestartMissionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RestartMissionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RestartMissionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartMissionResponse.header)
  return _internal_header();
}
inline void RestartMissionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.RestartMissionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RestartMissionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RestartMissionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RestartMissionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RestartMissionResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RestartMissionResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RestartMissionResponse.header)
  return _internal_mutable_header();
}
inline void RestartMissionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RestartMissionResponse.header)
}

// .bosdyn.api.mission.RestartMissionResponse.Status status = 2;
inline void RestartMissionResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::mission::RestartMissionResponse_Status RestartMissionResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::RestartMissionResponse_Status >(status_);
}
inline ::bosdyn::api::mission::RestartMissionResponse_Status RestartMissionResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartMissionResponse.status)
  return _internal_status();
}
inline void RestartMissionResponse::_internal_set_status(::bosdyn::api::mission::RestartMissionResponse_Status value) {
  
  status_ = value;
}
inline void RestartMissionResponse::set_status(::bosdyn::api::mission::RestartMissionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RestartMissionResponse.status)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 3;
inline int RestartMissionResponse::_internal_lease_use_results_size() const {
  return lease_use_results_.size();
}
inline int RestartMissionResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* RestartMissionResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RestartMissionResponse.lease_use_results)
  return lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
RestartMissionResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.RestartMissionResponse.lease_use_results)
  return &lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& RestartMissionResponse::_internal_lease_use_results(int index) const {
  return lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& RestartMissionResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartMissionResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* RestartMissionResponse::_internal_add_lease_use_results() {
  return lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* RestartMissionResponse::add_lease_use_results() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RestartMissionResponse.lease_use_results)
  return _internal_add_lease_use_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
RestartMissionResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.RestartMissionResponse.lease_use_results)
  return lease_use_results_;
}

// repeated .bosdyn.api.mission.FailedNode failed_nodes = 4;
inline int RestartMissionResponse::_internal_failed_nodes_size() const {
  return failed_nodes_.size();
}
inline int RestartMissionResponse::failed_nodes_size() const {
  return _internal_failed_nodes_size();
}
inline void RestartMissionResponse::clear_failed_nodes() {
  failed_nodes_.Clear();
}
inline ::bosdyn::api::mission::FailedNode* RestartMissionResponse::mutable_failed_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RestartMissionResponse.failed_nodes)
  return failed_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >*
RestartMissionResponse::mutable_failed_nodes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.RestartMissionResponse.failed_nodes)
  return &failed_nodes_;
}
inline const ::bosdyn::api::mission::FailedNode& RestartMissionResponse::_internal_failed_nodes(int index) const {
  return failed_nodes_.Get(index);
}
inline const ::bosdyn::api::mission::FailedNode& RestartMissionResponse::failed_nodes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RestartMissionResponse.failed_nodes)
  return _internal_failed_nodes(index);
}
inline ::bosdyn::api::mission::FailedNode* RestartMissionResponse::_internal_add_failed_nodes() {
  return failed_nodes_.Add();
}
inline ::bosdyn::api::mission::FailedNode* RestartMissionResponse::add_failed_nodes() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RestartMissionResponse.failed_nodes)
  return _internal_add_failed_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >&
RestartMissionResponse::failed_nodes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.RestartMissionResponse.failed_nodes)
  return failed_nodes_;
}

// -------------------------------------------------------------------

// LoadMissionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool LoadMissionRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool LoadMissionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& LoadMissionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& LoadMissionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.LoadMissionRequest.header)
  return _internal_header();
}
inline void LoadMissionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.LoadMissionRequest.header)
}
inline ::bosdyn::api::RequestHeader* LoadMissionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* LoadMissionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.LoadMissionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* LoadMissionRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* LoadMissionRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.LoadMissionRequest.header)
  return _internal_mutable_header();
}
inline void LoadMissionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.LoadMissionRequest.header)
}

// .bosdyn.api.mission.Node root = 2;
inline bool LoadMissionRequest::_internal_has_root() const {
  return this != internal_default_instance() && root_ != nullptr;
}
inline bool LoadMissionRequest::has_root() const {
  return _internal_has_root();
}
inline const ::bosdyn::api::mission::Node& LoadMissionRequest::_internal_root() const {
  const ::bosdyn::api::mission::Node* p = root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& LoadMissionRequest::root() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.LoadMissionRequest.root)
  return _internal_root();
}
inline void LoadMissionRequest::unsafe_arena_set_allocated_root(
    ::bosdyn::api::mission::Node* root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.LoadMissionRequest.root)
}
inline ::bosdyn::api::mission::Node* LoadMissionRequest::release_root() {
  
  ::bosdyn::api::mission::Node* temp = root_;
  root_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* LoadMissionRequest::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.LoadMissionRequest.root)
  
  ::bosdyn::api::mission::Node* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* LoadMissionRequest::_internal_mutable_root() {
  
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    root_ = p;
  }
  return root_;
}
inline ::bosdyn::api::mission::Node* LoadMissionRequest::mutable_root() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.LoadMissionRequest.root)
  return _internal_mutable_root();
}
inline void LoadMissionRequest::set_allocated_root(::bosdyn::api::mission::Node* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root)->GetArena();
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.LoadMissionRequest.root)
}

// repeated .bosdyn.api.Lease leases = 3;
inline int LoadMissionRequest::_internal_leases_size() const {
  return leases_.size();
}
inline int LoadMissionRequest::leases_size() const {
  return _internal_leases_size();
}
inline ::bosdyn::api::Lease* LoadMissionRequest::mutable_leases(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.LoadMissionRequest.leases)
  return leases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >*
LoadMissionRequest::mutable_leases() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.LoadMissionRequest.leases)
  return &leases_;
}
inline const ::bosdyn::api::Lease& LoadMissionRequest::_internal_leases(int index) const {
  return leases_.Get(index);
}
inline const ::bosdyn::api::Lease& LoadMissionRequest::leases(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.LoadMissionRequest.leases)
  return _internal_leases(index);
}
inline ::bosdyn::api::Lease* LoadMissionRequest::_internal_add_leases() {
  return leases_.Add();
}
inline ::bosdyn::api::Lease* LoadMissionRequest::add_leases() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.LoadMissionRequest.leases)
  return _internal_add_leases();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Lease >&
LoadMissionRequest::leases() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.LoadMissionRequest.leases)
  return leases_;
}

// -------------------------------------------------------------------

// LoadMissionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool LoadMissionResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool LoadMissionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& LoadMissionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& LoadMissionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.LoadMissionResponse.header)
  return _internal_header();
}
inline void LoadMissionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.LoadMissionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* LoadMissionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* LoadMissionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.LoadMissionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* LoadMissionResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* LoadMissionResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.LoadMissionResponse.header)
  return _internal_mutable_header();
}
inline void LoadMissionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.LoadMissionResponse.header)
}

// .bosdyn.api.mission.LoadMissionResponse.Status status = 2;
inline void LoadMissionResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::mission::LoadMissionResponse_Status LoadMissionResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::LoadMissionResponse_Status >(status_);
}
inline ::bosdyn::api::mission::LoadMissionResponse_Status LoadMissionResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.LoadMissionResponse.status)
  return _internal_status();
}
inline void LoadMissionResponse::_internal_set_status(::bosdyn::api::mission::LoadMissionResponse_Status value) {
  
  status_ = value;
}
inline void LoadMissionResponse::set_status(::bosdyn::api::mission::LoadMissionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.LoadMissionResponse.status)
}

// repeated .bosdyn.api.LeaseUseResult lease_use_results = 3;
inline int LoadMissionResponse::_internal_lease_use_results_size() const {
  return lease_use_results_.size();
}
inline int LoadMissionResponse::lease_use_results_size() const {
  return _internal_lease_use_results_size();
}
inline ::bosdyn::api::LeaseUseResult* LoadMissionResponse::mutable_lease_use_results(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.LoadMissionResponse.lease_use_results)
  return lease_use_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >*
LoadMissionResponse::mutable_lease_use_results() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.LoadMissionResponse.lease_use_results)
  return &lease_use_results_;
}
inline const ::bosdyn::api::LeaseUseResult& LoadMissionResponse::_internal_lease_use_results(int index) const {
  return lease_use_results_.Get(index);
}
inline const ::bosdyn::api::LeaseUseResult& LoadMissionResponse::lease_use_results(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.LoadMissionResponse.lease_use_results)
  return _internal_lease_use_results(index);
}
inline ::bosdyn::api::LeaseUseResult* LoadMissionResponse::_internal_add_lease_use_results() {
  return lease_use_results_.Add();
}
inline ::bosdyn::api::LeaseUseResult* LoadMissionResponse::add_lease_use_results() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.LoadMissionResponse.lease_use_results)
  return _internal_add_lease_use_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::LeaseUseResult >&
LoadMissionResponse::lease_use_results() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.LoadMissionResponse.lease_use_results)
  return lease_use_results_;
}

// .bosdyn.api.mission.MissionInfo mission_info = 4;
inline bool LoadMissionResponse::_internal_has_mission_info() const {
  return this != internal_default_instance() && mission_info_ != nullptr;
}
inline bool LoadMissionResponse::has_mission_info() const {
  return _internal_has_mission_info();
}
inline void LoadMissionResponse::clear_mission_info() {
  if (GetArena() == nullptr && mission_info_ != nullptr) {
    delete mission_info_;
  }
  mission_info_ = nullptr;
}
inline const ::bosdyn::api::mission::MissionInfo& LoadMissionResponse::_internal_mission_info() const {
  const ::bosdyn::api::mission::MissionInfo* p = mission_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::MissionInfo*>(
      &::bosdyn::api::mission::_MissionInfo_default_instance_);
}
inline const ::bosdyn::api::mission::MissionInfo& LoadMissionResponse::mission_info() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.LoadMissionResponse.mission_info)
  return _internal_mission_info();
}
inline void LoadMissionResponse::unsafe_arena_set_allocated_mission_info(
    ::bosdyn::api::mission::MissionInfo* mission_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mission_info_);
  }
  mission_info_ = mission_info;
  if (mission_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.LoadMissionResponse.mission_info)
}
inline ::bosdyn::api::mission::MissionInfo* LoadMissionResponse::release_mission_info() {
  
  ::bosdyn::api::mission::MissionInfo* temp = mission_info_;
  mission_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::MissionInfo* LoadMissionResponse::unsafe_arena_release_mission_info() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.LoadMissionResponse.mission_info)
  
  ::bosdyn::api::mission::MissionInfo* temp = mission_info_;
  mission_info_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::MissionInfo* LoadMissionResponse::_internal_mutable_mission_info() {
  
  if (mission_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::MissionInfo>(GetArena());
    mission_info_ = p;
  }
  return mission_info_;
}
inline ::bosdyn::api::mission::MissionInfo* LoadMissionResponse::mutable_mission_info() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.LoadMissionResponse.mission_info)
  return _internal_mutable_mission_info();
}
inline void LoadMissionResponse::set_allocated_mission_info(::bosdyn::api::mission::MissionInfo* mission_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mission_info_;
  }
  if (mission_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mission_info);
    if (message_arena != submessage_arena) {
      mission_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mission_info, submessage_arena);
    }
    
  } else {
    
  }
  mission_info_ = mission_info;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.LoadMissionResponse.mission_info)
}

// repeated .bosdyn.api.mission.FailedNode failed_nodes = 5;
inline int LoadMissionResponse::_internal_failed_nodes_size() const {
  return failed_nodes_.size();
}
inline int LoadMissionResponse::failed_nodes_size() const {
  return _internal_failed_nodes_size();
}
inline void LoadMissionResponse::clear_failed_nodes() {
  failed_nodes_.Clear();
}
inline ::bosdyn::api::mission::FailedNode* LoadMissionResponse::mutable_failed_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.LoadMissionResponse.failed_nodes)
  return failed_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >*
LoadMissionResponse::mutable_failed_nodes() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.LoadMissionResponse.failed_nodes)
  return &failed_nodes_;
}
inline const ::bosdyn::api::mission::FailedNode& LoadMissionResponse::_internal_failed_nodes(int index) const {
  return failed_nodes_.Get(index);
}
inline const ::bosdyn::api::mission::FailedNode& LoadMissionResponse::failed_nodes(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.LoadMissionResponse.failed_nodes)
  return _internal_failed_nodes(index);
}
inline ::bosdyn::api::mission::FailedNode* LoadMissionResponse::_internal_add_failed_nodes() {
  return failed_nodes_.Add();
}
inline ::bosdyn::api::mission::FailedNode* LoadMissionResponse::add_failed_nodes() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.LoadMissionResponse.failed_nodes)
  return _internal_add_failed_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::FailedNode >&
LoadMissionResponse::failed_nodes() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.LoadMissionResponse.failed_nodes)
  return failed_nodes_;
}

// -------------------------------------------------------------------

// GetInfoRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetInfoRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetInfoRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetInfoRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetInfoRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetInfoRequest.header)
  return _internal_header();
}
inline void GetInfoRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetInfoRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetInfoRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetInfoRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetInfoRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetInfoRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* GetInfoRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetInfoRequest.header)
  return _internal_mutable_header();
}
inline void GetInfoRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetInfoRequest.header)
}

// -------------------------------------------------------------------

// GetInfoResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetInfoResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetInfoResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetInfoResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetInfoResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetInfoResponse.header)
  return _internal_header();
}
inline void GetInfoResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetInfoResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetInfoResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetInfoResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetInfoResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetInfoResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* GetInfoResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetInfoResponse.header)
  return _internal_mutable_header();
}
inline void GetInfoResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetInfoResponse.header)
}

// .bosdyn.api.mission.MissionInfo mission_info = 2;
inline bool GetInfoResponse::_internal_has_mission_info() const {
  return this != internal_default_instance() && mission_info_ != nullptr;
}
inline bool GetInfoResponse::has_mission_info() const {
  return _internal_has_mission_info();
}
inline void GetInfoResponse::clear_mission_info() {
  if (GetArena() == nullptr && mission_info_ != nullptr) {
    delete mission_info_;
  }
  mission_info_ = nullptr;
}
inline const ::bosdyn::api::mission::MissionInfo& GetInfoResponse::_internal_mission_info() const {
  const ::bosdyn::api::mission::MissionInfo* p = mission_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::MissionInfo*>(
      &::bosdyn::api::mission::_MissionInfo_default_instance_);
}
inline const ::bosdyn::api::mission::MissionInfo& GetInfoResponse::mission_info() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetInfoResponse.mission_info)
  return _internal_mission_info();
}
inline void GetInfoResponse::unsafe_arena_set_allocated_mission_info(
    ::bosdyn::api::mission::MissionInfo* mission_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mission_info_);
  }
  mission_info_ = mission_info;
  if (mission_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetInfoResponse.mission_info)
}
inline ::bosdyn::api::mission::MissionInfo* GetInfoResponse::release_mission_info() {
  
  ::bosdyn::api::mission::MissionInfo* temp = mission_info_;
  mission_info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::MissionInfo* GetInfoResponse::unsafe_arena_release_mission_info() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetInfoResponse.mission_info)
  
  ::bosdyn::api::mission::MissionInfo* temp = mission_info_;
  mission_info_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::MissionInfo* GetInfoResponse::_internal_mutable_mission_info() {
  
  if (mission_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::MissionInfo>(GetArena());
    mission_info_ = p;
  }
  return mission_info_;
}
inline ::bosdyn::api::mission::MissionInfo* GetInfoResponse::mutable_mission_info() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetInfoResponse.mission_info)
  return _internal_mutable_mission_info();
}
inline void GetInfoResponse::set_allocated_mission_info(::bosdyn::api::mission::MissionInfo* mission_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mission_info_;
  }
  if (mission_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mission_info);
    if (message_arena != submessage_arena) {
      mission_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mission_info, submessage_arena);
    }
    
  } else {
    
  }
  mission_info_ = mission_info;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetInfoResponse.mission_info)
}

// -------------------------------------------------------------------

// PauseMissionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool PauseMissionRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool PauseMissionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& PauseMissionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& PauseMissionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PauseMissionRequest.header)
  return _internal_header();
}
inline void PauseMissionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PauseMissionRequest.header)
}
inline ::bosdyn::api::RequestHeader* PauseMissionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* PauseMissionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PauseMissionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* PauseMissionRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* PauseMissionRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PauseMissionRequest.header)
  return _internal_mutable_header();
}
inline void PauseMissionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PauseMissionRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool PauseMissionRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool PauseMissionRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& PauseMissionRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& PauseMissionRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PauseMissionRequest.lease)
  return _internal_lease();
}
inline void PauseMissionRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PauseMissionRequest.lease)
}
inline ::bosdyn::api::Lease* PauseMissionRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* PauseMissionRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PauseMissionRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* PauseMissionRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* PauseMissionRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PauseMissionRequest.lease)
  return _internal_mutable_lease();
}
inline void PauseMissionRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PauseMissionRequest.lease)
}

// -------------------------------------------------------------------

// PauseMissionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool PauseMissionResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool PauseMissionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& PauseMissionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& PauseMissionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PauseMissionResponse.header)
  return _internal_header();
}
inline void PauseMissionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PauseMissionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* PauseMissionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* PauseMissionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PauseMissionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* PauseMissionResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* PauseMissionResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PauseMissionResponse.header)
  return _internal_mutable_header();
}
inline void PauseMissionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PauseMissionResponse.header)
}

// .bosdyn.api.mission.PauseMissionResponse.Status status = 2;
inline void PauseMissionResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::mission::PauseMissionResponse_Status PauseMissionResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::mission::PauseMissionResponse_Status >(status_);
}
inline ::bosdyn::api::mission::PauseMissionResponse_Status PauseMissionResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PauseMissionResponse.status)
  return _internal_status();
}
inline void PauseMissionResponse::_internal_set_status(::bosdyn::api::mission::PauseMissionResponse_Status value) {
  
  status_ = value;
}
inline void PauseMissionResponse::set_status(::bosdyn::api::mission::PauseMissionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.PauseMissionResponse.status)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 3;
inline bool PauseMissionResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool PauseMissionResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& PauseMissionResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& PauseMissionResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.PauseMissionResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void PauseMissionResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.PauseMissionResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* PauseMissionResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* PauseMissionResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.PauseMissionResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* PauseMissionResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* PauseMissionResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.PauseMissionResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void PauseMissionResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.PauseMissionResponse.lease_use_result)
}

// -------------------------------------------------------------------

// GetMissionRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetMissionRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetMissionRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetMissionRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetMissionRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetMissionRequest.header)
  return _internal_header();
}
inline void GetMissionRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetMissionRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetMissionRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetMissionRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetMissionRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetMissionRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* GetMissionRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetMissionRequest.header)
  return _internal_mutable_header();
}
inline void GetMissionRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetMissionRequest.header)
}

// -------------------------------------------------------------------

// GetMissionResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetMissionResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetMissionResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetMissionResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetMissionResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetMissionResponse.header)
  return _internal_header();
}
inline void GetMissionResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetMissionResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetMissionResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetMissionResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetMissionResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetMissionResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* GetMissionResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetMissionResponse.header)
  return _internal_mutable_header();
}
inline void GetMissionResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetMissionResponse.header)
}

// .bosdyn.api.mission.Node root = 2;
inline bool GetMissionResponse::_internal_has_root() const {
  return this != internal_default_instance() && root_ != nullptr;
}
inline bool GetMissionResponse::has_root() const {
  return _internal_has_root();
}
inline const ::bosdyn::api::mission::Node& GetMissionResponse::_internal_root() const {
  const ::bosdyn::api::mission::Node* p = root_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& GetMissionResponse::root() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetMissionResponse.root)
  return _internal_root();
}
inline void GetMissionResponse::unsafe_arena_set_allocated_root(
    ::bosdyn::api::mission::Node* root) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.GetMissionResponse.root)
}
inline ::bosdyn::api::mission::Node* GetMissionResponse::release_root() {
  
  ::bosdyn::api::mission::Node* temp = root_;
  root_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* GetMissionResponse::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.GetMissionResponse.root)
  
  ::bosdyn::api::mission::Node* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* GetMissionResponse::_internal_mutable_root() {
  
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    root_ = p;
  }
  return root_;
}
inline ::bosdyn::api::mission::Node* GetMissionResponse::mutable_root() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.GetMissionResponse.root)
  return _internal_mutable_root();
}
inline void GetMissionResponse::set_allocated_root(::bosdyn::api::mission::Node* root) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(root_);
  }
  if (root) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(root)->GetArena();
    if (message_arena != submessage_arena) {
      root = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    
  } else {
    
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.GetMissionResponse.root)
}

// int64 id = 3;
inline void GetMissionResponse::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetMissionResponse::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetMissionResponse::id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.GetMissionResponse.id)
  return _internal_id();
}
inline void GetMissionResponse::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void GetMissionResponse::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.GetMissionResponse.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mission
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::mission::State_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::State_Status>() {
  return ::bosdyn::api::mission::State_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::AnswerQuestionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::AnswerQuestionResponse_Status>() {
  return ::bosdyn::api::mission::AnswerQuestionResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::PlayMissionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::PlayMissionResponse_Status>() {
  return ::bosdyn::api::mission::PlayMissionResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::RestartMissionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::RestartMissionResponse_Status>() {
  return ::bosdyn::api::mission::RestartMissionResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::LoadMissionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::LoadMissionResponse_Status>() {
  return ::bosdyn::api::mission::LoadMissionResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::mission::PauseMissionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::PauseMissionResponse_Status>() {
  return ::bosdyn::api::mission::PauseMissionResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fmission_2eproto
