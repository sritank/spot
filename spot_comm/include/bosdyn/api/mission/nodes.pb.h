// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/mission/nodes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fnodes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fnodes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/duration.pb.h>
#include "bosdyn/api/spot_cam/camera.pb.h"
#include "bosdyn/api/spot_cam/logging.pb.h"
#include "bosdyn/api/robot_command.pb.h"
#include "bosdyn/api/power.pb.h"
#include "bosdyn/api/graph_nav/graph_nav.pb.h"
#include "bosdyn/api/mission/util.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fmission_2fnodes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[23]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto;
namespace bosdyn {
namespace api {
namespace mission {
class BosdynGraphNavLocalize;
class BosdynGraphNavLocalizeDefaultTypeInternal;
extern BosdynGraphNavLocalizeDefaultTypeInternal _BosdynGraphNavLocalize_default_instance_;
class BosdynGraphNavState;
class BosdynGraphNavStateDefaultTypeInternal;
extern BosdynGraphNavStateDefaultTypeInternal _BosdynGraphNavState_default_instance_;
class BosdynNavigateTo;
class BosdynNavigateToDefaultTypeInternal;
extern BosdynNavigateToDefaultTypeInternal _BosdynNavigateTo_default_instance_;
class BosdynPowerRequest;
class BosdynPowerRequestDefaultTypeInternal;
extern BosdynPowerRequestDefaultTypeInternal _BosdynPowerRequest_default_instance_;
class BosdynRobotCommand;
class BosdynRobotCommandDefaultTypeInternal;
extern BosdynRobotCommandDefaultTypeInternal _BosdynRobotCommand_default_instance_;
class BosdynRobotState;
class BosdynRobotStateDefaultTypeInternal;
extern BosdynRobotStateDefaultTypeInternal _BosdynRobotState_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class Condition_Operand;
class Condition_OperandDefaultTypeInternal;
extern Condition_OperandDefaultTypeInternal _Condition_Operand_default_instance_;
class ConstantResult;
class ConstantResultDefaultTypeInternal;
extern ConstantResultDefaultTypeInternal _ConstantResult_default_instance_;
class DefineBlackboard;
class DefineBlackboardDefaultTypeInternal;
extern DefineBlackboardDefaultTypeInternal _DefineBlackboard_default_instance_;
class ForDuration;
class ForDurationDefaultTypeInternal;
extern ForDurationDefaultTypeInternal _ForDuration_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Prompt;
class PromptDefaultTypeInternal;
extern PromptDefaultTypeInternal _Prompt_default_instance_;
class Prompt_Option;
class Prompt_OptionDefaultTypeInternal;
extern Prompt_OptionDefaultTypeInternal _Prompt_Option_default_instance_;
class RemoteGrpc;
class RemoteGrpcDefaultTypeInternal;
extern RemoteGrpcDefaultTypeInternal _RemoteGrpc_default_instance_;
class Repeat;
class RepeatDefaultTypeInternal;
extern RepeatDefaultTypeInternal _Repeat_default_instance_;
class Retry;
class RetryDefaultTypeInternal;
extern RetryDefaultTypeInternal _Retry_default_instance_;
class Selector;
class SelectorDefaultTypeInternal;
extern SelectorDefaultTypeInternal _Selector_default_instance_;
class Sequence;
class SequenceDefaultTypeInternal;
extern SequenceDefaultTypeInternal _Sequence_default_instance_;
class SetBlackboard;
class SetBlackboardDefaultTypeInternal;
extern SetBlackboardDefaultTypeInternal _SetBlackboard_default_instance_;
class SimpleParallel;
class SimpleParallelDefaultTypeInternal;
extern SimpleParallelDefaultTypeInternal _SimpleParallel_default_instance_;
class Sleep;
class SleepDefaultTypeInternal;
extern SleepDefaultTypeInternal _Sleep_default_instance_;
class SpotCamStoreMedia;
class SpotCamStoreMediaDefaultTypeInternal;
extern SpotCamStoreMediaDefaultTypeInternal _SpotCamStoreMedia_default_instance_;
}  // namespace mission
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::mission::BosdynGraphNavLocalize* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynGraphNavLocalize>(Arena*);
template<> ::bosdyn::api::mission::BosdynGraphNavState* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynGraphNavState>(Arena*);
template<> ::bosdyn::api::mission::BosdynNavigateTo* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynNavigateTo>(Arena*);
template<> ::bosdyn::api::mission::BosdynPowerRequest* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynPowerRequest>(Arena*);
template<> ::bosdyn::api::mission::BosdynRobotCommand* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynRobotCommand>(Arena*);
template<> ::bosdyn::api::mission::BosdynRobotState* Arena::CreateMaybeMessage<::bosdyn::api::mission::BosdynRobotState>(Arena*);
template<> ::bosdyn::api::mission::Condition* Arena::CreateMaybeMessage<::bosdyn::api::mission::Condition>(Arena*);
template<> ::bosdyn::api::mission::Condition_Operand* Arena::CreateMaybeMessage<::bosdyn::api::mission::Condition_Operand>(Arena*);
template<> ::bosdyn::api::mission::ConstantResult* Arena::CreateMaybeMessage<::bosdyn::api::mission::ConstantResult>(Arena*);
template<> ::bosdyn::api::mission::DefineBlackboard* Arena::CreateMaybeMessage<::bosdyn::api::mission::DefineBlackboard>(Arena*);
template<> ::bosdyn::api::mission::ForDuration* Arena::CreateMaybeMessage<::bosdyn::api::mission::ForDuration>(Arena*);
template<> ::bosdyn::api::mission::Node* Arena::CreateMaybeMessage<::bosdyn::api::mission::Node>(Arena*);
template<> ::bosdyn::api::mission::Prompt* Arena::CreateMaybeMessage<::bosdyn::api::mission::Prompt>(Arena*);
template<> ::bosdyn::api::mission::Prompt_Option* Arena::CreateMaybeMessage<::bosdyn::api::mission::Prompt_Option>(Arena*);
template<> ::bosdyn::api::mission::RemoteGrpc* Arena::CreateMaybeMessage<::bosdyn::api::mission::RemoteGrpc>(Arena*);
template<> ::bosdyn::api::mission::Repeat* Arena::CreateMaybeMessage<::bosdyn::api::mission::Repeat>(Arena*);
template<> ::bosdyn::api::mission::Retry* Arena::CreateMaybeMessage<::bosdyn::api::mission::Retry>(Arena*);
template<> ::bosdyn::api::mission::Selector* Arena::CreateMaybeMessage<::bosdyn::api::mission::Selector>(Arena*);
template<> ::bosdyn::api::mission::Sequence* Arena::CreateMaybeMessage<::bosdyn::api::mission::Sequence>(Arena*);
template<> ::bosdyn::api::mission::SetBlackboard* Arena::CreateMaybeMessage<::bosdyn::api::mission::SetBlackboard>(Arena*);
template<> ::bosdyn::api::mission::SimpleParallel* Arena::CreateMaybeMessage<::bosdyn::api::mission::SimpleParallel>(Arena*);
template<> ::bosdyn::api::mission::Sleep* Arena::CreateMaybeMessage<::bosdyn::api::mission::Sleep>(Arena*);
template<> ::bosdyn::api::mission::SpotCamStoreMedia* Arena::CreateMaybeMessage<::bosdyn::api::mission::SpotCamStoreMedia>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace mission {

enum Condition_Compare : int {
  Condition_Compare_COMPARE_UNKNOWN = 0,
  Condition_Compare_COMPARE_EQ = 1,
  Condition_Compare_COMPARE_NE = 2,
  Condition_Compare_COMPARE_LT = 3,
  Condition_Compare_COMPARE_GT = 4,
  Condition_Compare_COMPARE_LE = 5,
  Condition_Compare_COMPARE_GE = 6,
  Condition_Compare_Condition_Compare_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Condition_Compare_Condition_Compare_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Condition_Compare_IsValid(int value);
constexpr Condition_Compare Condition_Compare_Compare_MIN = Condition_Compare_COMPARE_UNKNOWN;
constexpr Condition_Compare Condition_Compare_Compare_MAX = Condition_Compare_COMPARE_GE;
constexpr int Condition_Compare_Compare_ARRAYSIZE = Condition_Compare_Compare_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Condition_Compare_descriptor();
template<typename T>
inline const std::string& Condition_Compare_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Condition_Compare>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Condition_Compare_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Condition_Compare_descriptor(), enum_t_value);
}
inline bool Condition_Compare_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Condition_Compare* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Condition_Compare>(
    Condition_Compare_descriptor(), name, value);
}
// ===================================================================

class Node PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  virtual ~Node();

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Node& default_instance();

  enum TypeCase {
    kImpl = 4,
    kNodeReference = 5,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(nullptr);
  }

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParameterValuesFieldNumber = 6,
    kOverridesFieldNumber = 7,
    kParametersFieldNumber = 8,
    kNameFieldNumber = 1,
    kReferenceIdFieldNumber = 3,
    kUserDataFieldNumber = 2,
    kImplFieldNumber = 4,
    kNodeReferenceFieldNumber = 5,
  };
  // repeated .bosdyn.api.mission.KeyValue parameter_values = 6;
  int parameter_values_size() const;
  private:
  int _internal_parameter_values_size() const;
  public:
  void clear_parameter_values();
  ::bosdyn::api::mission::KeyValue* mutable_parameter_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_parameter_values();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_parameter_values(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_parameter_values();
  public:
  const ::bosdyn::api::mission::KeyValue& parameter_values(int index) const;
  ::bosdyn::api::mission::KeyValue* add_parameter_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      parameter_values() const;

  // repeated .bosdyn.api.mission.KeyValue overrides = 7;
  int overrides_size() const;
  private:
  int _internal_overrides_size() const;
  public:
  void clear_overrides();
  ::bosdyn::api::mission::KeyValue* mutable_overrides(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_overrides();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_overrides(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_overrides();
  public:
  const ::bosdyn::api::mission::KeyValue& overrides(int index) const;
  ::bosdyn::api::mission::KeyValue* add_overrides();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      overrides() const;

  // repeated .bosdyn.api.mission.VariableDeclaration parameters = 8;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::bosdyn::api::mission::VariableDeclaration* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
      mutable_parameters();
  private:
  const ::bosdyn::api::mission::VariableDeclaration& _internal_parameters(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* _internal_add_parameters();
  public:
  const ::bosdyn::api::mission::VariableDeclaration& parameters(int index) const;
  ::bosdyn::api::mission::VariableDeclaration* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
      parameters() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string reference_id = 3;
  void clear_reference_id();
  const std::string& reference_id() const;
  void set_reference_id(const std::string& value);
  void set_reference_id(std::string&& value);
  void set_reference_id(const char* value);
  void set_reference_id(const char* value, size_t size);
  std::string* mutable_reference_id();
  std::string* release_reference_id();
  void set_allocated_reference_id(std::string* reference_id);
  private:
  const std::string& _internal_reference_id() const;
  void _internal_set_reference_id(const std::string& value);
  std::string* _internal_mutable_reference_id();
  public:

  // .bosdyn.api.mission.UserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::bosdyn::api::mission::UserData& user_data() const;
  ::bosdyn::api::mission::UserData* release_user_data();
  ::bosdyn::api::mission::UserData* mutable_user_data();
  void set_allocated_user_data(::bosdyn::api::mission::UserData* user_data);
  private:
  const ::bosdyn::api::mission::UserData& _internal_user_data() const;
  ::bosdyn::api::mission::UserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::bosdyn::api::mission::UserData* user_data);
  ::bosdyn::api::mission::UserData* unsafe_arena_release_user_data();

  // .google.protobuf.Any impl = 4;
  bool has_impl() const;
  private:
  bool _internal_has_impl() const;
  public:
  void clear_impl();
  const PROTOBUF_NAMESPACE_ID::Any& impl() const;
  PROTOBUF_NAMESPACE_ID::Any* release_impl();
  PROTOBUF_NAMESPACE_ID::Any* mutable_impl();
  void set_allocated_impl(PROTOBUF_NAMESPACE_ID::Any* impl);
  private:
  const PROTOBUF_NAMESPACE_ID::Any& _internal_impl() const;
  PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_impl();
  public:
  void unsafe_arena_set_allocated_impl(
      PROTOBUF_NAMESPACE_ID::Any* impl);
  PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_impl();

  // string node_reference = 5;
  private:
  bool _internal_has_node_reference() const;
  public:
  void clear_node_reference();
  const std::string& node_reference() const;
  void set_node_reference(const std::string& value);
  void set_node_reference(std::string&& value);
  void set_node_reference(const char* value);
  void set_node_reference(const char* value, size_t size);
  std::string* mutable_node_reference();
  std::string* release_node_reference();
  void set_allocated_node_reference(std::string* node_reference);
  private:
  const std::string& _internal_node_reference() const;
  void _internal_set_node_reference(const std::string& value);
  std::string* _internal_mutable_node_reference();
  public:

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Node)
 private:
  class _Internal;
  void set_has_impl();
  void set_has_node_reference();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > parameter_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > overrides_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_id_;
  ::bosdyn::api::mission::UserData* user_data_;
  union TypeUnion {
    TypeUnion() {}
    PROTOBUF_NAMESPACE_ID::Any* impl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_reference_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Sequence PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Sequence) */ {
 public:
  inline Sequence() : Sequence(nullptr) {}
  virtual ~Sequence();

  Sequence(const Sequence& from);
  Sequence(Sequence&& from) noexcept
    : Sequence() {
    *this = ::std::move(from);
  }

  inline Sequence& operator=(const Sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sequence& operator=(Sequence&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Sequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sequence* internal_default_instance() {
    return reinterpret_cast<const Sequence*>(
               &_Sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Sequence& a, Sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(Sequence* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sequence* New() const final {
    return CreateMaybeMessage<Sequence>(nullptr);
  }

  Sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Sequence& from);
  void MergeFrom(const Sequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Sequence";
  }
  protected:
  explicit Sequence(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kAlwaysRestartFieldNumber = 1,
  };
  // repeated .bosdyn.api.mission.Node children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::bosdyn::api::mission::Node* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >*
      mutable_children();
  private:
  const ::bosdyn::api::mission::Node& _internal_children(int index) const;
  ::bosdyn::api::mission::Node* _internal_add_children();
  public:
  const ::bosdyn::api::mission::Node& children(int index) const;
  ::bosdyn::api::mission::Node* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >&
      children() const;

  // bool always_restart = 1;
  void clear_always_restart();
  bool always_restart() const;
  void set_always_restart(bool value);
  private:
  bool _internal_always_restart() const;
  void _internal_set_always_restart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Sequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node > children_;
  bool always_restart_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Selector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Selector) */ {
 public:
  inline Selector() : Selector(nullptr) {}
  virtual ~Selector();

  Selector(const Selector& from);
  Selector(Selector&& from) noexcept
    : Selector() {
    *this = ::std::move(from);
  }

  inline Selector& operator=(const Selector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Selector& operator=(Selector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Selector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Selector* internal_default_instance() {
    return reinterpret_cast<const Selector*>(
               &_Selector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Selector& a, Selector& b) {
    a.Swap(&b);
  }
  inline void Swap(Selector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Selector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Selector* New() const final {
    return CreateMaybeMessage<Selector>(nullptr);
  }

  Selector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Selector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Selector& from);
  void MergeFrom(const Selector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Selector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Selector";
  }
  protected:
  explicit Selector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kAlwaysRestartFieldNumber = 1,
  };
  // repeated .bosdyn.api.mission.Node children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::bosdyn::api::mission::Node* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >*
      mutable_children();
  private:
  const ::bosdyn::api::mission::Node& _internal_children(int index) const;
  ::bosdyn::api::mission::Node* _internal_add_children();
  public:
  const ::bosdyn::api::mission::Node& children(int index) const;
  ::bosdyn::api::mission::Node* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >&
      children() const;

  // bool always_restart = 1;
  void clear_always_restart();
  bool always_restart() const;
  void set_always_restart(bool value);
  private:
  bool _internal_always_restart() const;
  void _internal_set_always_restart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Selector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node > children_;
  bool always_restart_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Repeat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Repeat) */ {
 public:
  inline Repeat() : Repeat(nullptr) {}
  virtual ~Repeat();

  Repeat(const Repeat& from);
  Repeat(Repeat&& from) noexcept
    : Repeat() {
    *this = ::std::move(from);
  }

  inline Repeat& operator=(const Repeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Repeat& operator=(Repeat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Repeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Repeat* internal_default_instance() {
    return reinterpret_cast<const Repeat*>(
               &_Repeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Repeat& a, Repeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Repeat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Repeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Repeat* New() const final {
    return CreateMaybeMessage<Repeat>(nullptr);
  }

  Repeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Repeat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Repeat& from);
  void MergeFrom(const Repeat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Repeat";
  }
  protected:
  explicit Repeat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 4,
    kMaxStartsFieldNumber = 1,
  };
  // .bosdyn.api.mission.Node child = 4;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // int32 max_starts = 1;
  void clear_max_starts();
  ::PROTOBUF_NAMESPACE_ID::int32 max_starts() const;
  void set_max_starts(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_starts() const;
  void _internal_set_max_starts(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Repeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::mission::Node* child_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_starts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Retry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Retry) */ {
 public:
  inline Retry() : Retry(nullptr) {}
  virtual ~Retry();

  Retry(const Retry& from);
  Retry(Retry&& from) noexcept
    : Retry() {
    *this = ::std::move(from);
  }

  inline Retry& operator=(const Retry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Retry& operator=(Retry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Retry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Retry* internal_default_instance() {
    return reinterpret_cast<const Retry*>(
               &_Retry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Retry& a, Retry& b) {
    a.Swap(&b);
  }
  inline void Swap(Retry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Retry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Retry* New() const final {
    return CreateMaybeMessage<Retry>(nullptr);
  }

  Retry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Retry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Retry& from);
  void MergeFrom(const Retry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Retry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Retry";
  }
  protected:
  explicit Retry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 2,
    kMaxAttemptsFieldNumber = 1,
  };
  // .bosdyn.api.mission.Node child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // int32 max_attempts = 1;
  void clear_max_attempts();
  ::PROTOBUF_NAMESPACE_ID::int32 max_attempts() const;
  void set_max_attempts(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_attempts() const;
  void _internal_set_max_attempts(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Retry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::mission::Node* child_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_attempts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class ForDuration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.ForDuration) */ {
 public:
  inline ForDuration() : ForDuration(nullptr) {}
  virtual ~ForDuration();

  ForDuration(const ForDuration& from);
  ForDuration(ForDuration&& from) noexcept
    : ForDuration() {
    *this = ::std::move(from);
  }

  inline ForDuration& operator=(const ForDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForDuration& operator=(ForDuration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ForDuration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ForDuration* internal_default_instance() {
    return reinterpret_cast<const ForDuration*>(
               &_ForDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ForDuration& a, ForDuration& b) {
    a.Swap(&b);
  }
  inline void Swap(ForDuration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForDuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ForDuration* New() const final {
    return CreateMaybeMessage<ForDuration>(nullptr);
  }

  ForDuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ForDuration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ForDuration& from);
  void MergeFrom(const ForDuration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForDuration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.ForDuration";
  }
  protected:
  explicit ForDuration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // .google.protobuf.Duration duration = 1;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const PROTOBUF_NAMESPACE_ID::Duration& duration() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_duration();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_duration();
  void set_allocated_duration(PROTOBUF_NAMESPACE_ID::Duration* duration);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_duration() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      PROTOBUF_NAMESPACE_ID::Duration* duration);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_duration();

  // .bosdyn.api.mission.Node child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.ForDuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Duration* duration_;
  ::bosdyn::api::mission::Node* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SimpleParallel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SimpleParallel) */ {
 public:
  inline SimpleParallel() : SimpleParallel(nullptr) {}
  virtual ~SimpleParallel();

  SimpleParallel(const SimpleParallel& from);
  SimpleParallel(SimpleParallel&& from) noexcept
    : SimpleParallel() {
    *this = ::std::move(from);
  }

  inline SimpleParallel& operator=(const SimpleParallel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleParallel& operator=(SimpleParallel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimpleParallel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimpleParallel* internal_default_instance() {
    return reinterpret_cast<const SimpleParallel*>(
               &_SimpleParallel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SimpleParallel& a, SimpleParallel& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleParallel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleParallel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimpleParallel* New() const final {
    return CreateMaybeMessage<SimpleParallel>(nullptr);
  }

  SimpleParallel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimpleParallel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimpleParallel& from);
  void MergeFrom(const SimpleParallel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimpleParallel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SimpleParallel";
  }
  protected:
  explicit SimpleParallel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimaryFieldNumber = 1,
    kSecondaryFieldNumber = 2,
  };
  // .bosdyn.api.mission.Node primary = 1;
  bool has_primary() const;
  private:
  bool _internal_has_primary() const;
  public:
  void clear_primary();
  const ::bosdyn::api::mission::Node& primary() const;
  ::bosdyn::api::mission::Node* release_primary();
  ::bosdyn::api::mission::Node* mutable_primary();
  void set_allocated_primary(::bosdyn::api::mission::Node* primary);
  private:
  const ::bosdyn::api::mission::Node& _internal_primary() const;
  ::bosdyn::api::mission::Node* _internal_mutable_primary();
  public:
  void unsafe_arena_set_allocated_primary(
      ::bosdyn::api::mission::Node* primary);
  ::bosdyn::api::mission::Node* unsafe_arena_release_primary();

  // .bosdyn.api.mission.Node secondary = 2;
  bool has_secondary() const;
  private:
  bool _internal_has_secondary() const;
  public:
  void clear_secondary();
  const ::bosdyn::api::mission::Node& secondary() const;
  ::bosdyn::api::mission::Node* release_secondary();
  ::bosdyn::api::mission::Node* mutable_secondary();
  void set_allocated_secondary(::bosdyn::api::mission::Node* secondary);
  private:
  const ::bosdyn::api::mission::Node& _internal_secondary() const;
  ::bosdyn::api::mission::Node* _internal_mutable_secondary();
  public:
  void unsafe_arena_set_allocated_secondary(
      ::bosdyn::api::mission::Node* secondary);
  ::bosdyn::api::mission::Node* unsafe_arena_release_secondary();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SimpleParallel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::mission::Node* primary_;
  ::bosdyn::api::mission::Node* secondary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Condition_Operand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Condition.Operand) */ {
 public:
  inline Condition_Operand() : Condition_Operand(nullptr) {}
  virtual ~Condition_Operand();

  Condition_Operand(const Condition_Operand& from);
  Condition_Operand(Condition_Operand&& from) noexcept
    : Condition_Operand() {
    *this = ::std::move(from);
  }

  inline Condition_Operand& operator=(const Condition_Operand& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition_Operand& operator=(Condition_Operand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Condition_Operand& default_instance();

  enum TypeCase {
    kVar = 1,
    kConst = 2,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition_Operand* internal_default_instance() {
    return reinterpret_cast<const Condition_Operand*>(
               &_Condition_Operand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Condition_Operand& a, Condition_Operand& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition_Operand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition_Operand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Condition_Operand* New() const final {
    return CreateMaybeMessage<Condition_Operand>(nullptr);
  }

  Condition_Operand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition_Operand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Condition_Operand& from);
  void MergeFrom(const Condition_Operand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition_Operand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Condition.Operand";
  }
  protected:
  explicit Condition_Operand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVarFieldNumber = 1,
    kConstFieldNumber = 2,
  };
  // .bosdyn.api.mission.VariableDeclaration var = 1;
  bool has_var() const;
  private:
  bool _internal_has_var() const;
  public:
  void clear_var();
  const ::bosdyn::api::mission::VariableDeclaration& var() const;
  ::bosdyn::api::mission::VariableDeclaration* release_var();
  ::bosdyn::api::mission::VariableDeclaration* mutable_var();
  void set_allocated_var(::bosdyn::api::mission::VariableDeclaration* var);
  private:
  const ::bosdyn::api::mission::VariableDeclaration& _internal_var() const;
  ::bosdyn::api::mission::VariableDeclaration* _internal_mutable_var();
  public:
  void unsafe_arena_set_allocated_var(
      ::bosdyn::api::mission::VariableDeclaration* var);
  ::bosdyn::api::mission::VariableDeclaration* unsafe_arena_release_var();

  // .bosdyn.api.mission.ConstantValue const = 2;
  bool has_const_() const;
  private:
  bool _internal_has_const_() const;
  public:
  void clear_const_();
  const ::bosdyn::api::mission::ConstantValue& const_() const;
  ::bosdyn::api::mission::ConstantValue* release_const_();
  ::bosdyn::api::mission::ConstantValue* mutable_const_();
  void set_allocated_const_(::bosdyn::api::mission::ConstantValue* const_);
  private:
  const ::bosdyn::api::mission::ConstantValue& _internal_const_() const;
  ::bosdyn::api::mission::ConstantValue* _internal_mutable_const_();
  public:
  void unsafe_arena_set_allocated_const_(
      ::bosdyn::api::mission::ConstantValue* const_);
  ::bosdyn::api::mission::ConstantValue* unsafe_arena_release_const_();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Condition.Operand)
 private:
  class _Internal;
  void set_has_var();
  void set_has_const_();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    TypeUnion() {}
    ::bosdyn::api::mission::VariableDeclaration* var_;
    ::bosdyn::api::mission::ConstantValue* const__;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Condition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  virtual ~Condition();

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(nullptr);
  }

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Condition_Operand Operand;

  typedef Condition_Compare Compare;
  static constexpr Compare COMPARE_UNKNOWN =
    Condition_Compare_COMPARE_UNKNOWN;
  static constexpr Compare COMPARE_EQ =
    Condition_Compare_COMPARE_EQ;
  static constexpr Compare COMPARE_NE =
    Condition_Compare_COMPARE_NE;
  static constexpr Compare COMPARE_LT =
    Condition_Compare_COMPARE_LT;
  static constexpr Compare COMPARE_GT =
    Condition_Compare_COMPARE_GT;
  static constexpr Compare COMPARE_LE =
    Condition_Compare_COMPARE_LE;
  static constexpr Compare COMPARE_GE =
    Condition_Compare_COMPARE_GE;
  static inline bool Compare_IsValid(int value) {
    return Condition_Compare_IsValid(value);
  }
  static constexpr Compare Compare_MIN =
    Condition_Compare_Compare_MIN;
  static constexpr Compare Compare_MAX =
    Condition_Compare_Compare_MAX;
  static constexpr int Compare_ARRAYSIZE =
    Condition_Compare_Compare_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Compare_descriptor() {
    return Condition_Compare_descriptor();
  }
  template<typename T>
  static inline const std::string& Compare_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Compare>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Compare_Name.");
    return Condition_Compare_Name(enum_t_value);
  }
  static inline bool Compare_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Compare* value) {
    return Condition_Compare_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLhsFieldNumber = 1,
    kRhsFieldNumber = 2,
    kOperationFieldNumber = 5,
  };
  // .bosdyn.api.mission.Condition.Operand lhs = 1;
  bool has_lhs() const;
  private:
  bool _internal_has_lhs() const;
  public:
  void clear_lhs();
  const ::bosdyn::api::mission::Condition_Operand& lhs() const;
  ::bosdyn::api::mission::Condition_Operand* release_lhs();
  ::bosdyn::api::mission::Condition_Operand* mutable_lhs();
  void set_allocated_lhs(::bosdyn::api::mission::Condition_Operand* lhs);
  private:
  const ::bosdyn::api::mission::Condition_Operand& _internal_lhs() const;
  ::bosdyn::api::mission::Condition_Operand* _internal_mutable_lhs();
  public:
  void unsafe_arena_set_allocated_lhs(
      ::bosdyn::api::mission::Condition_Operand* lhs);
  ::bosdyn::api::mission::Condition_Operand* unsafe_arena_release_lhs();

  // .bosdyn.api.mission.Condition.Operand rhs = 2;
  bool has_rhs() const;
  private:
  bool _internal_has_rhs() const;
  public:
  void clear_rhs();
  const ::bosdyn::api::mission::Condition_Operand& rhs() const;
  ::bosdyn::api::mission::Condition_Operand* release_rhs();
  ::bosdyn::api::mission::Condition_Operand* mutable_rhs();
  void set_allocated_rhs(::bosdyn::api::mission::Condition_Operand* rhs);
  private:
  const ::bosdyn::api::mission::Condition_Operand& _internal_rhs() const;
  ::bosdyn::api::mission::Condition_Operand* _internal_mutable_rhs();
  public:
  void unsafe_arena_set_allocated_rhs(
      ::bosdyn::api::mission::Condition_Operand* rhs);
  ::bosdyn::api::mission::Condition_Operand* unsafe_arena_release_rhs();

  // .bosdyn.api.mission.Condition.Compare operation = 5;
  void clear_operation();
  ::bosdyn::api::mission::Condition_Compare operation() const;
  void set_operation(::bosdyn::api::mission::Condition_Compare value);
  private:
  ::bosdyn::api::mission::Condition_Compare _internal_operation() const;
  void _internal_set_operation(::bosdyn::api::mission::Condition_Compare value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Condition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::mission::Condition_Operand* lhs_;
  ::bosdyn::api::mission::Condition_Operand* rhs_;
  int operation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynRobotState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynRobotState) */ {
 public:
  inline BosdynRobotState() : BosdynRobotState(nullptr) {}
  virtual ~BosdynRobotState();

  BosdynRobotState(const BosdynRobotState& from);
  BosdynRobotState(BosdynRobotState&& from) noexcept
    : BosdynRobotState() {
    *this = ::std::move(from);
  }

  inline BosdynRobotState& operator=(const BosdynRobotState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynRobotState& operator=(BosdynRobotState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BosdynRobotState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BosdynRobotState* internal_default_instance() {
    return reinterpret_cast<const BosdynRobotState*>(
               &_BosdynRobotState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BosdynRobotState& a, BosdynRobotState& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynRobotState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynRobotState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BosdynRobotState* New() const final {
    return CreateMaybeMessage<BosdynRobotState>(nullptr);
  }

  BosdynRobotState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BosdynRobotState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BosdynRobotState& from);
  void MergeFrom(const BosdynRobotState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynRobotState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynRobotState";
  }
  protected:
  explicit BosdynRobotState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kStateNameFieldNumber = 4,
    kChildFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string state_name = 4;
  void clear_state_name();
  const std::string& state_name() const;
  void set_state_name(const std::string& value);
  void set_state_name(std::string&& value);
  void set_state_name(const char* value);
  void set_state_name(const char* value, size_t size);
  std::string* mutable_state_name();
  std::string* release_state_name();
  void set_allocated_state_name(std::string* state_name);
  private:
  const std::string& _internal_state_name() const;
  void _internal_set_state_name(const std::string& value);
  std::string* _internal_mutable_state_name();
  public:

  // .bosdyn.api.mission.Node child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynRobotState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_name_;
  ::bosdyn::api::mission::Node* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynRobotCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynRobotCommand) */ {
 public:
  inline BosdynRobotCommand() : BosdynRobotCommand(nullptr) {}
  virtual ~BosdynRobotCommand();

  BosdynRobotCommand(const BosdynRobotCommand& from);
  BosdynRobotCommand(BosdynRobotCommand&& from) noexcept
    : BosdynRobotCommand() {
    *this = ::std::move(from);
  }

  inline BosdynRobotCommand& operator=(const BosdynRobotCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynRobotCommand& operator=(BosdynRobotCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BosdynRobotCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BosdynRobotCommand* internal_default_instance() {
    return reinterpret_cast<const BosdynRobotCommand*>(
               &_BosdynRobotCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BosdynRobotCommand& a, BosdynRobotCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynRobotCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynRobotCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BosdynRobotCommand* New() const final {
    return CreateMaybeMessage<BosdynRobotCommand>(nullptr);
  }

  BosdynRobotCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BosdynRobotCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BosdynRobotCommand& from);
  void MergeFrom(const BosdynRobotCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynRobotCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynRobotCommand";
  }
  protected:
  explicit BosdynRobotCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .bosdyn.api.RobotCommand command = 3;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::bosdyn::api::RobotCommand& command() const;
  ::bosdyn::api::RobotCommand* release_command();
  ::bosdyn::api::RobotCommand* mutable_command();
  void set_allocated_command(::bosdyn::api::RobotCommand* command);
  private:
  const ::bosdyn::api::RobotCommand& _internal_command() const;
  ::bosdyn::api::RobotCommand* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::bosdyn::api::RobotCommand* command);
  ::bosdyn::api::RobotCommand* unsafe_arena_release_command();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynRobotCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::bosdyn::api::RobotCommand* command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynPowerRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynPowerRequest) */ {
 public:
  inline BosdynPowerRequest() : BosdynPowerRequest(nullptr) {}
  virtual ~BosdynPowerRequest();

  BosdynPowerRequest(const BosdynPowerRequest& from);
  BosdynPowerRequest(BosdynPowerRequest&& from) noexcept
    : BosdynPowerRequest() {
    *this = ::std::move(from);
  }

  inline BosdynPowerRequest& operator=(const BosdynPowerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynPowerRequest& operator=(BosdynPowerRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BosdynPowerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BosdynPowerRequest* internal_default_instance() {
    return reinterpret_cast<const BosdynPowerRequest*>(
               &_BosdynPowerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BosdynPowerRequest& a, BosdynPowerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynPowerRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynPowerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BosdynPowerRequest* New() const final {
    return CreateMaybeMessage<BosdynPowerRequest>(nullptr);
  }

  BosdynPowerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BosdynPowerRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BosdynPowerRequest& from);
  void MergeFrom(const BosdynPowerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynPowerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynPowerRequest";
  }
  protected:
  explicit BosdynPowerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kRequestFieldNumber = 4,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // .bosdyn.api.PowerCommandRequest.Request request = 4;
  void clear_request();
  ::bosdyn::api::PowerCommandRequest_Request request() const;
  void set_request(::bosdyn::api::PowerCommandRequest_Request value);
  private:
  ::bosdyn::api::PowerCommandRequest_Request _internal_request() const;
  void _internal_set_request(::bosdyn::api::PowerCommandRequest_Request value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynPowerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  int request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynNavigateTo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynNavigateTo) */ {
 public:
  inline BosdynNavigateTo() : BosdynNavigateTo(nullptr) {}
  virtual ~BosdynNavigateTo();

  BosdynNavigateTo(const BosdynNavigateTo& from);
  BosdynNavigateTo(BosdynNavigateTo&& from) noexcept
    : BosdynNavigateTo() {
    *this = ::std::move(from);
  }

  inline BosdynNavigateTo& operator=(const BosdynNavigateTo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynNavigateTo& operator=(BosdynNavigateTo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BosdynNavigateTo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BosdynNavigateTo* internal_default_instance() {
    return reinterpret_cast<const BosdynNavigateTo*>(
               &_BosdynNavigateTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(BosdynNavigateTo& a, BosdynNavigateTo& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynNavigateTo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynNavigateTo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BosdynNavigateTo* New() const final {
    return CreateMaybeMessage<BosdynNavigateTo>(nullptr);
  }

  BosdynNavigateTo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BosdynNavigateTo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BosdynNavigateTo& from);
  void MergeFrom(const BosdynNavigateTo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynNavigateTo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynNavigateTo";
  }
  protected:
  explicit BosdynNavigateTo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kDestinationWaypointIdFieldNumber = 3,
    kRouteGenParamsFieldNumber = 4,
    kTravelParamsFieldNumber = 5,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string destination_waypoint_id = 3;
  void clear_destination_waypoint_id();
  const std::string& destination_waypoint_id() const;
  void set_destination_waypoint_id(const std::string& value);
  void set_destination_waypoint_id(std::string&& value);
  void set_destination_waypoint_id(const char* value);
  void set_destination_waypoint_id(const char* value, size_t size);
  std::string* mutable_destination_waypoint_id();
  std::string* release_destination_waypoint_id();
  void set_allocated_destination_waypoint_id(std::string* destination_waypoint_id);
  private:
  const std::string& _internal_destination_waypoint_id() const;
  void _internal_set_destination_waypoint_id(const std::string& value);
  std::string* _internal_mutable_destination_waypoint_id();
  public:

  // .bosdyn.api.graph_nav.RouteGenParams route_gen_params = 4;
  bool has_route_gen_params() const;
  private:
  bool _internal_has_route_gen_params() const;
  public:
  void clear_route_gen_params();
  const ::bosdyn::api::graph_nav::RouteGenParams& route_gen_params() const;
  ::bosdyn::api::graph_nav::RouteGenParams* release_route_gen_params();
  ::bosdyn::api::graph_nav::RouteGenParams* mutable_route_gen_params();
  void set_allocated_route_gen_params(::bosdyn::api::graph_nav::RouteGenParams* route_gen_params);
  private:
  const ::bosdyn::api::graph_nav::RouteGenParams& _internal_route_gen_params() const;
  ::bosdyn::api::graph_nav::RouteGenParams* _internal_mutable_route_gen_params();
  public:
  void unsafe_arena_set_allocated_route_gen_params(
      ::bosdyn::api::graph_nav::RouteGenParams* route_gen_params);
  ::bosdyn::api::graph_nav::RouteGenParams* unsafe_arena_release_route_gen_params();

  // .bosdyn.api.graph_nav.TravelParams travel_params = 5;
  bool has_travel_params() const;
  private:
  bool _internal_has_travel_params() const;
  public:
  void clear_travel_params();
  const ::bosdyn::api::graph_nav::TravelParams& travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* release_travel_params();
  ::bosdyn::api::graph_nav::TravelParams* mutable_travel_params();
  void set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params);
  private:
  const ::bosdyn::api::graph_nav::TravelParams& _internal_travel_params() const;
  ::bosdyn::api::graph_nav::TravelParams* _internal_mutable_travel_params();
  public:
  void unsafe_arena_set_allocated_travel_params(
      ::bosdyn::api::graph_nav::TravelParams* travel_params);
  ::bosdyn::api::graph_nav::TravelParams* unsafe_arena_release_travel_params();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynNavigateTo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_waypoint_id_;
  ::bosdyn::api::graph_nav::RouteGenParams* route_gen_params_;
  ::bosdyn::api::graph_nav::TravelParams* travel_params_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynGraphNavState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynGraphNavState) */ {
 public:
  inline BosdynGraphNavState() : BosdynGraphNavState(nullptr) {}
  virtual ~BosdynGraphNavState();

  BosdynGraphNavState(const BosdynGraphNavState& from);
  BosdynGraphNavState(BosdynGraphNavState&& from) noexcept
    : BosdynGraphNavState() {
    *this = ::std::move(from);
  }

  inline BosdynGraphNavState& operator=(const BosdynGraphNavState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynGraphNavState& operator=(BosdynGraphNavState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BosdynGraphNavState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BosdynGraphNavState* internal_default_instance() {
    return reinterpret_cast<const BosdynGraphNavState*>(
               &_BosdynGraphNavState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BosdynGraphNavState& a, BosdynGraphNavState& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynGraphNavState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynGraphNavState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BosdynGraphNavState* New() const final {
    return CreateMaybeMessage<BosdynGraphNavState>(nullptr);
  }

  BosdynGraphNavState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BosdynGraphNavState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BosdynGraphNavState& from);
  void MergeFrom(const BosdynGraphNavState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynGraphNavState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynGraphNavState";
  }
  protected:
  explicit BosdynGraphNavState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kStateNameFieldNumber = 4,
    kChildFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string state_name = 4;
  void clear_state_name();
  const std::string& state_name() const;
  void set_state_name(const std::string& value);
  void set_state_name(std::string&& value);
  void set_state_name(const char* value);
  void set_state_name(const char* value, size_t size);
  std::string* mutable_state_name();
  std::string* release_state_name();
  void set_allocated_state_name(std::string* state_name);
  private:
  const std::string& _internal_state_name() const;
  void _internal_set_state_name(const std::string& value);
  std::string* _internal_mutable_state_name();
  public:

  // .bosdyn.api.mission.Node child = 3;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynGraphNavState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_name_;
  ::bosdyn::api::mission::Node* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class BosdynGraphNavLocalize PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.BosdynGraphNavLocalize) */ {
 public:
  inline BosdynGraphNavLocalize() : BosdynGraphNavLocalize(nullptr) {}
  virtual ~BosdynGraphNavLocalize();

  BosdynGraphNavLocalize(const BosdynGraphNavLocalize& from);
  BosdynGraphNavLocalize(BosdynGraphNavLocalize&& from) noexcept
    : BosdynGraphNavLocalize() {
    *this = ::std::move(from);
  }

  inline BosdynGraphNavLocalize& operator=(const BosdynGraphNavLocalize& from) {
    CopyFrom(from);
    return *this;
  }
  inline BosdynGraphNavLocalize& operator=(BosdynGraphNavLocalize&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BosdynGraphNavLocalize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BosdynGraphNavLocalize* internal_default_instance() {
    return reinterpret_cast<const BosdynGraphNavLocalize*>(
               &_BosdynGraphNavLocalize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BosdynGraphNavLocalize& a, BosdynGraphNavLocalize& b) {
    a.Swap(&b);
  }
  inline void Swap(BosdynGraphNavLocalize* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BosdynGraphNavLocalize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BosdynGraphNavLocalize* New() const final {
    return CreateMaybeMessage<BosdynGraphNavLocalize>(nullptr);
  }

  BosdynGraphNavLocalize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BosdynGraphNavLocalize>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BosdynGraphNavLocalize& from);
  void MergeFrom(const BosdynGraphNavLocalize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BosdynGraphNavLocalize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.BosdynGraphNavLocalize";
  }
  protected:
  explicit BosdynGraphNavLocalize(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.BosdynGraphNavLocalize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class RemoteGrpc PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.RemoteGrpc) */ {
 public:
  inline RemoteGrpc() : RemoteGrpc(nullptr) {}
  virtual ~RemoteGrpc();

  RemoteGrpc(const RemoteGrpc& from);
  RemoteGrpc(RemoteGrpc&& from) noexcept
    : RemoteGrpc() {
    *this = ::std::move(from);
  }

  inline RemoteGrpc& operator=(const RemoteGrpc& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteGrpc& operator=(RemoteGrpc&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoteGrpc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoteGrpc* internal_default_instance() {
    return reinterpret_cast<const RemoteGrpc*>(
               &_RemoteGrpc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RemoteGrpc& a, RemoteGrpc& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteGrpc* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteGrpc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteGrpc* New() const final {
    return CreateMaybeMessage<RemoteGrpc>(nullptr);
  }

  RemoteGrpc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteGrpc>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoteGrpc& from);
  void MergeFrom(const RemoteGrpc& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteGrpc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.RemoteGrpc";
  }
  protected:
  explicit RemoteGrpc(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaseResourcesFieldNumber = 5,
    kInputsFieldNumber = 6,
    kHostFieldNumber = 1,
    kServiceNameFieldNumber = 3,
    kTimeoutFieldNumber = 4,
  };
  // repeated string lease_resources = 5;
  int lease_resources_size() const;
  private:
  int _internal_lease_resources_size() const;
  public:
  void clear_lease_resources();
  const std::string& lease_resources(int index) const;
  std::string* mutable_lease_resources(int index);
  void set_lease_resources(int index, const std::string& value);
  void set_lease_resources(int index, std::string&& value);
  void set_lease_resources(int index, const char* value);
  void set_lease_resources(int index, const char* value, size_t size);
  std::string* add_lease_resources();
  void add_lease_resources(const std::string& value);
  void add_lease_resources(std::string&& value);
  void add_lease_resources(const char* value);
  void add_lease_resources(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& lease_resources() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_lease_resources();
  private:
  const std::string& _internal_lease_resources(int index) const;
  std::string* _internal_add_lease_resources();
  public:

  // repeated .bosdyn.api.mission.KeyValue inputs = 6;
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::bosdyn::api::mission::KeyValue* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_inputs();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_inputs(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_inputs();
  public:
  const ::bosdyn::api::mission::KeyValue& inputs(int index) const;
  ::bosdyn::api::mission::KeyValue* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      inputs() const;

  // string host = 1;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string service_name = 3;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // float timeout = 4;
  void clear_timeout();
  float timeout() const;
  void set_timeout(float value);
  private:
  float _internal_timeout() const;
  void _internal_set_timeout(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.RemoteGrpc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> lease_resources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > inputs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  float timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Sleep PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Sleep) */ {
 public:
  inline Sleep() : Sleep(nullptr) {}
  virtual ~Sleep();

  Sleep(const Sleep& from);
  Sleep(Sleep&& from) noexcept
    : Sleep() {
    *this = ::std::move(from);
  }

  inline Sleep& operator=(const Sleep& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sleep& operator=(Sleep&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Sleep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sleep* internal_default_instance() {
    return reinterpret_cast<const Sleep*>(
               &_Sleep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Sleep& a, Sleep& b) {
    a.Swap(&b);
  }
  inline void Swap(Sleep* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sleep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sleep* New() const final {
    return CreateMaybeMessage<Sleep>(nullptr);
  }

  Sleep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sleep>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Sleep& from);
  void MergeFrom(const Sleep& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sleep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Sleep";
  }
  protected:
  explicit Sleep(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kRestartAfterStopFieldNumber = 2,
  };
  // float seconds = 1;
  void clear_seconds();
  float seconds() const;
  void set_seconds(float value);
  private:
  float _internal_seconds() const;
  void _internal_set_seconds(float value);
  public:

  // bool restart_after_stop = 2;
  void clear_restart_after_stop();
  bool restart_after_stop() const;
  void set_restart_after_stop(bool value);
  private:
  bool _internal_restart_after_stop() const;
  void _internal_set_restart_after_stop(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Sleep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float seconds_;
  bool restart_after_stop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Prompt_Option PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Prompt.Option) */ {
 public:
  inline Prompt_Option() : Prompt_Option(nullptr) {}
  virtual ~Prompt_Option();

  Prompt_Option(const Prompt_Option& from);
  Prompt_Option(Prompt_Option&& from) noexcept
    : Prompt_Option() {
    *this = ::std::move(from);
  }

  inline Prompt_Option& operator=(const Prompt_Option& from) {
    CopyFrom(from);
    return *this;
  }
  inline Prompt_Option& operator=(Prompt_Option&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Prompt_Option& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Prompt_Option* internal_default_instance() {
    return reinterpret_cast<const Prompt_Option*>(
               &_Prompt_Option_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Prompt_Option& a, Prompt_Option& b) {
    a.Swap(&b);
  }
  inline void Swap(Prompt_Option* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Prompt_Option* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Prompt_Option* New() const final {
    return CreateMaybeMessage<Prompt_Option>(nullptr);
  }

  Prompt_Option* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Prompt_Option>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Prompt_Option& from);
  void MergeFrom(const Prompt_Option& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Prompt_Option* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Prompt.Option";
  }
  protected:
  explicit Prompt_Option(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kAnswerCodeFieldNumber = 2,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // int64 answer_code = 2;
  void clear_answer_code();
  ::PROTOBUF_NAMESPACE_ID::int64 answer_code() const;
  void set_answer_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_answer_code() const;
  void _internal_set_answer_code(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Prompt.Option)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::int64 answer_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class Prompt PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.Prompt) */ {
 public:
  inline Prompt() : Prompt(nullptr) {}
  virtual ~Prompt();

  Prompt(const Prompt& from);
  Prompt(Prompt&& from) noexcept
    : Prompt() {
    *this = ::std::move(from);
  }

  inline Prompt& operator=(const Prompt& from) {
    CopyFrom(from);
    return *this;
  }
  inline Prompt& operator=(Prompt&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Prompt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Prompt* internal_default_instance() {
    return reinterpret_cast<const Prompt*>(
               &_Prompt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Prompt& a, Prompt& b) {
    a.Swap(&b);
  }
  inline void Swap(Prompt* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Prompt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Prompt* New() const final {
    return CreateMaybeMessage<Prompt>(nullptr);
  }

  Prompt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Prompt>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Prompt& from);
  void MergeFrom(const Prompt& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Prompt* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.Prompt";
  }
  protected:
  explicit Prompt(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Prompt_Option Option;

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 4,
    kTextFieldNumber = 2,
    kSourceFieldNumber = 3,
    kChildFieldNumber = 5,
    kAlwaysRepromptFieldNumber = 1,
    kForAutonomousProcessingFieldNumber = 6,
  };
  // repeated .bosdyn.api.mission.Prompt.Option options = 4;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  ::bosdyn::api::mission::Prompt_Option* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >*
      mutable_options();
  private:
  const ::bosdyn::api::mission::Prompt_Option& _internal_options(int index) const;
  ::bosdyn::api::mission::Prompt_Option* _internal_add_options();
  public:
  const ::bosdyn::api::mission::Prompt_Option& options(int index) const;
  ::bosdyn::api::mission::Prompt_Option* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >&
      options() const;

  // string text = 2;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string source = 3;
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // .bosdyn.api.mission.Node child = 5;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // bool always_reprompt = 1;
  void clear_always_reprompt();
  bool always_reprompt() const;
  void set_always_reprompt(bool value);
  private:
  bool _internal_always_reprompt() const;
  void _internal_set_always_reprompt(bool value);
  public:

  // bool for_autonomous_processing = 6;
  void clear_for_autonomous_processing();
  bool for_autonomous_processing() const;
  void set_for_autonomous_processing(bool value);
  private:
  bool _internal_for_autonomous_processing() const;
  void _internal_set_for_autonomous_processing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.Prompt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option > options_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::bosdyn::api::mission::Node* child_;
  bool always_reprompt_;
  bool for_autonomous_processing_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SpotCamStoreMedia PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SpotCamStoreMedia) */ {
 public:
  inline SpotCamStoreMedia() : SpotCamStoreMedia(nullptr) {}
  virtual ~SpotCamStoreMedia();

  SpotCamStoreMedia(const SpotCamStoreMedia& from);
  SpotCamStoreMedia(SpotCamStoreMedia&& from) noexcept
    : SpotCamStoreMedia() {
    *this = ::std::move(from);
  }

  inline SpotCamStoreMedia& operator=(const SpotCamStoreMedia& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCamStoreMedia& operator=(SpotCamStoreMedia&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpotCamStoreMedia& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpotCamStoreMedia* internal_default_instance() {
    return reinterpret_cast<const SpotCamStoreMedia*>(
               &_SpotCamStoreMedia_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SpotCamStoreMedia& a, SpotCamStoreMedia& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCamStoreMedia* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCamStoreMedia* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpotCamStoreMedia* New() const final {
    return CreateMaybeMessage<SpotCamStoreMedia>(nullptr);
  }

  SpotCamStoreMedia* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpotCamStoreMedia>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpotCamStoreMedia& from);
  void MergeFrom(const SpotCamStoreMedia& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCamStoreMedia* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SpotCamStoreMedia";
  }
  protected:
  explicit SpotCamStoreMedia(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kHostFieldNumber = 2,
    kTagFieldNumber = 5,
    kCameraFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // string host = 2;
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string tag = 5;
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // .bosdyn.api.spot_cam.Camera camera = 3;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::bosdyn::api::spot_cam::Camera& camera() const;
  ::bosdyn::api::spot_cam::Camera* release_camera();
  ::bosdyn::api::spot_cam::Camera* mutable_camera();
  void set_allocated_camera(::bosdyn::api::spot_cam::Camera* camera);
  private:
  const ::bosdyn::api::spot_cam::Camera& _internal_camera() const;
  ::bosdyn::api::spot_cam::Camera* _internal_mutable_camera();
  public:
  void unsafe_arena_set_allocated_camera(
      ::bosdyn::api::spot_cam::Camera* camera);
  ::bosdyn::api::spot_cam::Camera* unsafe_arena_release_camera();

  // .bosdyn.api.spot_cam.Logpoint.RecordType type = 4;
  void clear_type();
  ::bosdyn::api::spot_cam::Logpoint_RecordType type() const;
  void set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value);
  private:
  ::bosdyn::api::spot_cam::Logpoint_RecordType _internal_type() const;
  void _internal_set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SpotCamStoreMedia)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::bosdyn::api::spot_cam::Camera* camera_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class DefineBlackboard PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.DefineBlackboard) */ {
 public:
  inline DefineBlackboard() : DefineBlackboard(nullptr) {}
  virtual ~DefineBlackboard();

  DefineBlackboard(const DefineBlackboard& from);
  DefineBlackboard(DefineBlackboard&& from) noexcept
    : DefineBlackboard() {
    *this = ::std::move(from);
  }

  inline DefineBlackboard& operator=(const DefineBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefineBlackboard& operator=(DefineBlackboard&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DefineBlackboard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DefineBlackboard* internal_default_instance() {
    return reinterpret_cast<const DefineBlackboard*>(
               &_DefineBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DefineBlackboard& a, DefineBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(DefineBlackboard* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefineBlackboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DefineBlackboard* New() const final {
    return CreateMaybeMessage<DefineBlackboard>(nullptr);
  }

  DefineBlackboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DefineBlackboard>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DefineBlackboard& from);
  void MergeFrom(const DefineBlackboard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefineBlackboard* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.DefineBlackboard";
  }
  protected:
  explicit DefineBlackboard(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlackboardVariablesFieldNumber = 1,
    kChildFieldNumber = 2,
  };
  // repeated .bosdyn.api.mission.KeyValue blackboard_variables = 1;
  int blackboard_variables_size() const;
  private:
  int _internal_blackboard_variables_size() const;
  public:
  void clear_blackboard_variables();
  ::bosdyn::api::mission::KeyValue* mutable_blackboard_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_blackboard_variables();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_blackboard_variables(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_blackboard_variables();
  public:
  const ::bosdyn::api::mission::KeyValue& blackboard_variables(int index) const;
  ::bosdyn::api::mission::KeyValue* add_blackboard_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      blackboard_variables() const;

  // .bosdyn.api.mission.Node child = 2;
  bool has_child() const;
  private:
  bool _internal_has_child() const;
  public:
  void clear_child();
  const ::bosdyn::api::mission::Node& child() const;
  ::bosdyn::api::mission::Node* release_child();
  ::bosdyn::api::mission::Node* mutable_child();
  void set_allocated_child(::bosdyn::api::mission::Node* child);
  private:
  const ::bosdyn::api::mission::Node& _internal_child() const;
  ::bosdyn::api::mission::Node* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::bosdyn::api::mission::Node* child);
  ::bosdyn::api::mission::Node* unsafe_arena_release_child();

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.DefineBlackboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > blackboard_variables_;
  ::bosdyn::api::mission::Node* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class SetBlackboard PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.SetBlackboard) */ {
 public:
  inline SetBlackboard() : SetBlackboard(nullptr) {}
  virtual ~SetBlackboard();

  SetBlackboard(const SetBlackboard& from);
  SetBlackboard(SetBlackboard&& from) noexcept
    : SetBlackboard() {
    *this = ::std::move(from);
  }

  inline SetBlackboard& operator=(const SetBlackboard& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetBlackboard& operator=(SetBlackboard&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetBlackboard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetBlackboard* internal_default_instance() {
    return reinterpret_cast<const SetBlackboard*>(
               &_SetBlackboard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SetBlackboard& a, SetBlackboard& b) {
    a.Swap(&b);
  }
  inline void Swap(SetBlackboard* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetBlackboard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetBlackboard* New() const final {
    return CreateMaybeMessage<SetBlackboard>(nullptr);
  }

  SetBlackboard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetBlackboard>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetBlackboard& from);
  void MergeFrom(const SetBlackboard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetBlackboard* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.SetBlackboard";
  }
  protected:
  explicit SetBlackboard(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlackboardVariablesFieldNumber = 1,
  };
  // repeated .bosdyn.api.mission.KeyValue blackboard_variables = 1;
  int blackboard_variables_size() const;
  private:
  int _internal_blackboard_variables_size() const;
  public:
  void clear_blackboard_variables();
  ::bosdyn::api::mission::KeyValue* mutable_blackboard_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
      mutable_blackboard_variables();
  private:
  const ::bosdyn::api::mission::KeyValue& _internal_blackboard_variables(int index) const;
  ::bosdyn::api::mission::KeyValue* _internal_add_blackboard_variables();
  public:
  const ::bosdyn::api::mission::KeyValue& blackboard_variables(int index) const;
  ::bosdyn::api::mission::KeyValue* add_blackboard_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
      blackboard_variables() const;

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.SetBlackboard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue > blackboard_variables_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// -------------------------------------------------------------------

class ConstantResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.mission.ConstantResult) */ {
 public:
  inline ConstantResult() : ConstantResult(nullptr) {}
  virtual ~ConstantResult();

  ConstantResult(const ConstantResult& from);
  ConstantResult(ConstantResult&& from) noexcept
    : ConstantResult() {
    *this = ::std::move(from);
  }

  inline ConstantResult& operator=(const ConstantResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantResult& operator=(ConstantResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConstantResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConstantResult* internal_default_instance() {
    return reinterpret_cast<const ConstantResult*>(
               &_ConstantResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ConstantResult& a, ConstantResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstantResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConstantResult* New() const final {
    return CreateMaybeMessage<ConstantResult>(nullptr);
  }

  ConstantResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConstantResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConstantResult& from);
  void MergeFrom(const ConstantResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstantResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.mission.ConstantResult";
  }
  protected:
  explicit ConstantResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fmission_2fnodes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .bosdyn.api.mission.Result result = 1;
  void clear_result();
  ::bosdyn::api::mission::Result result() const;
  void set_result(::bosdyn::api::mission::Result value);
  private:
  ::bosdyn::api::mission::Result _internal_result() const;
  void _internal_set_result(::bosdyn::api::mission::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.mission.ConstantResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fmission_2fnodes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Node

// string name = 1;
inline void Node::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.name)
  return _internal_name();
}
inline void Node::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Node.name)
}
inline std::string* Node::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.name)
  return _internal_mutable_name();
}
inline const std::string& Node::_internal_name() const {
  return name_.Get();
}
inline void Node::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Node::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.Node.name)
}
inline void Node::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.Node.name)
}
inline void Node::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.Node.name)
}
inline std::string* Node::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Node::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Node.name)
}

// .bosdyn.api.mission.UserData user_data = 2;
inline bool Node::_internal_has_user_data() const {
  return this != internal_default_instance() && user_data_ != nullptr;
}
inline bool Node::has_user_data() const {
  return _internal_has_user_data();
}
inline const ::bosdyn::api::mission::UserData& Node::_internal_user_data() const {
  const ::bosdyn::api::mission::UserData* p = user_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::UserData*>(
      &::bosdyn::api::mission::_UserData_default_instance_);
}
inline const ::bosdyn::api::mission::UserData& Node::user_data() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.user_data)
  return _internal_user_data();
}
inline void Node::unsafe_arena_set_allocated_user_data(
    ::bosdyn::api::mission::UserData* user_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_data_);
  }
  user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Node.user_data)
}
inline ::bosdyn::api::mission::UserData* Node::release_user_data() {
  
  ::bosdyn::api::mission::UserData* temp = user_data_;
  user_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::UserData* Node::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.user_data)
  
  ::bosdyn::api::mission::UserData* temp = user_data_;
  user_data_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::UserData* Node::_internal_mutable_user_data() {
  
  if (user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::UserData>(GetArena());
    user_data_ = p;
  }
  return user_data_;
}
inline ::bosdyn::api::mission::UserData* Node::mutable_user_data() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.user_data)
  return _internal_mutable_user_data();
}
inline void Node::set_allocated_user_data(::bosdyn::api::mission::UserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_data_);
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_data)->GetArena();
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Node.user_data)
}

// string reference_id = 3;
inline void Node::clear_reference_id() {
  reference_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Node::reference_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.reference_id)
  return _internal_reference_id();
}
inline void Node::set_reference_id(const std::string& value) {
  _internal_set_reference_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Node.reference_id)
}
inline std::string* Node::mutable_reference_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.reference_id)
  return _internal_mutable_reference_id();
}
inline const std::string& Node::_internal_reference_id() const {
  return reference_id_.Get();
}
inline void Node::_internal_set_reference_id(const std::string& value) {
  
  reference_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Node::set_reference_id(std::string&& value) {
  
  reference_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.Node.reference_id)
}
inline void Node::set_reference_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reference_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.Node.reference_id)
}
inline void Node::set_reference_id(const char* value,
    size_t size) {
  
  reference_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.Node.reference_id)
}
inline std::string* Node::_internal_mutable_reference_id() {
  
  return reference_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Node::release_reference_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.reference_id)
  return reference_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Node::set_allocated_reference_id(std::string* reference_id) {
  if (reference_id != nullptr) {
    
  } else {
    
  }
  reference_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reference_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Node.reference_id)
}

// .google.protobuf.Any impl = 4;
inline bool Node::_internal_has_impl() const {
  return type_case() == kImpl;
}
inline bool Node::has_impl() const {
  return _internal_has_impl();
}
inline void Node::set_has_impl() {
  _oneof_case_[0] = kImpl;
}
inline PROTOBUF_NAMESPACE_ID::Any* Node::release_impl() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.impl)
  if (_internal_has_impl()) {
    clear_has_type();
      PROTOBUF_NAMESPACE_ID::Any* temp = type_.impl_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.impl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const PROTOBUF_NAMESPACE_ID::Any& Node::_internal_impl() const {
  return _internal_has_impl()
      ? *type_.impl_
      : *reinterpret_cast< PROTOBUF_NAMESPACE_ID::Any*>(&PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Any& Node::impl() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.impl)
  return _internal_impl();
}
inline PROTOBUF_NAMESPACE_ID::Any* Node::unsafe_arena_release_impl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.mission.Node.impl)
  if (_internal_has_impl()) {
    clear_has_type();
    PROTOBUF_NAMESPACE_ID::Any* temp = type_.impl_;
    type_.impl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Node::unsafe_arena_set_allocated_impl(PROTOBUF_NAMESPACE_ID::Any* impl) {
  clear_type();
  if (impl) {
    set_has_impl();
    type_.impl_ = impl;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Node.impl)
}
inline PROTOBUF_NAMESPACE_ID::Any* Node::_internal_mutable_impl() {
  if (!_internal_has_impl()) {
    clear_type();
    set_has_impl();
    type_.impl_ = CreateMaybeMessage< PROTOBUF_NAMESPACE_ID::Any >(GetArena());
  }
  return type_.impl_;
}
inline PROTOBUF_NAMESPACE_ID::Any* Node::mutable_impl() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.impl)
  return _internal_mutable_impl();
}

// string node_reference = 5;
inline bool Node::_internal_has_node_reference() const {
  return type_case() == kNodeReference;
}
inline void Node::set_has_node_reference() {
  _oneof_case_[0] = kNodeReference;
}
inline void Node::clear_node_reference() {
  if (_internal_has_node_reference()) {
    type_.node_reference_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_type();
  }
}
inline const std::string& Node::node_reference() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.node_reference)
  return _internal_node_reference();
}
inline void Node::set_node_reference(const std::string& value) {
  _internal_set_node_reference(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Node.node_reference)
}
inline std::string* Node::mutable_node_reference() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.node_reference)
  return _internal_mutable_node_reference();
}
inline const std::string& Node::_internal_node_reference() const {
  if (_internal_has_node_reference()) {
    return type_.node_reference_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Node::_internal_set_node_reference(const std::string& value) {
  if (!_internal_has_node_reference()) {
    clear_type();
    set_has_node_reference();
    type_.node_reference_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.node_reference_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Node::set_node_reference(std::string&& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Node.node_reference)
  if (!_internal_has_node_reference()) {
    clear_type();
    set_has_node_reference();
    type_.node_reference_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.node_reference_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.Node.node_reference)
}
inline void Node::set_node_reference(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_node_reference()) {
    clear_type();
    set_has_node_reference();
    type_.node_reference_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.node_reference_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.Node.node_reference)
}
inline void Node::set_node_reference(const char* value,
                             size_t size) {
  if (!_internal_has_node_reference()) {
    clear_type();
    set_has_node_reference();
    type_.node_reference_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.node_reference_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.Node.node_reference)
}
inline std::string* Node::_internal_mutable_node_reference() {
  if (!_internal_has_node_reference()) {
    clear_type();
    set_has_node_reference();
    type_.node_reference_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return type_.node_reference_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Node::release_node_reference() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Node.node_reference)
  if (_internal_has_node_reference()) {
    clear_has_type();
    return type_.node_reference_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void Node::set_allocated_node_reference(std::string* node_reference) {
  if (has_type()) {
    clear_type();
  }
  if (node_reference != nullptr) {
    set_has_node_reference();
    type_.node_reference_.UnsafeSetDefault(node_reference);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(node_reference);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Node.node_reference)
}

// repeated .bosdyn.api.mission.KeyValue parameter_values = 6;
inline int Node::_internal_parameter_values_size() const {
  return parameter_values_.size();
}
inline int Node::parameter_values_size() const {
  return _internal_parameter_values_size();
}
inline ::bosdyn::api::mission::KeyValue* Node::mutable_parameter_values(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.parameter_values)
  return parameter_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
Node::mutable_parameter_values() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Node.parameter_values)
  return &parameter_values_;
}
inline const ::bosdyn::api::mission::KeyValue& Node::_internal_parameter_values(int index) const {
  return parameter_values_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& Node::parameter_values(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.parameter_values)
  return _internal_parameter_values(index);
}
inline ::bosdyn::api::mission::KeyValue* Node::_internal_add_parameter_values() {
  return parameter_values_.Add();
}
inline ::bosdyn::api::mission::KeyValue* Node::add_parameter_values() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Node.parameter_values)
  return _internal_add_parameter_values();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
Node::parameter_values() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Node.parameter_values)
  return parameter_values_;
}

// repeated .bosdyn.api.mission.KeyValue overrides = 7;
inline int Node::_internal_overrides_size() const {
  return overrides_.size();
}
inline int Node::overrides_size() const {
  return _internal_overrides_size();
}
inline ::bosdyn::api::mission::KeyValue* Node::mutable_overrides(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.overrides)
  return overrides_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
Node::mutable_overrides() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Node.overrides)
  return &overrides_;
}
inline const ::bosdyn::api::mission::KeyValue& Node::_internal_overrides(int index) const {
  return overrides_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& Node::overrides(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.overrides)
  return _internal_overrides(index);
}
inline ::bosdyn::api::mission::KeyValue* Node::_internal_add_overrides() {
  return overrides_.Add();
}
inline ::bosdyn::api::mission::KeyValue* Node::add_overrides() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Node.overrides)
  return _internal_add_overrides();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
Node::overrides() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Node.overrides)
  return overrides_;
}

// repeated .bosdyn.api.mission.VariableDeclaration parameters = 8;
inline int Node::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Node::parameters_size() const {
  return _internal_parameters_size();
}
inline ::bosdyn::api::mission::VariableDeclaration* Node::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Node.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >*
Node::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Node.parameters)
  return &parameters_;
}
inline const ::bosdyn::api::mission::VariableDeclaration& Node::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::bosdyn::api::mission::VariableDeclaration& Node::parameters(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Node.parameters)
  return _internal_parameters(index);
}
inline ::bosdyn::api::mission::VariableDeclaration* Node::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::bosdyn::api::mission::VariableDeclaration* Node::add_parameters() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Node.parameters)
  return _internal_add_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::VariableDeclaration >&
Node::parameters() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Node.parameters)
  return parameters_;
}

inline bool Node::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Node::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Node::TypeCase Node::type_case() const {
  return Node::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Sequence

// bool always_restart = 1;
inline void Sequence::clear_always_restart() {
  always_restart_ = false;
}
inline bool Sequence::_internal_always_restart() const {
  return always_restart_;
}
inline bool Sequence::always_restart() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Sequence.always_restart)
  return _internal_always_restart();
}
inline void Sequence::_internal_set_always_restart(bool value) {
  
  always_restart_ = value;
}
inline void Sequence::set_always_restart(bool value) {
  _internal_set_always_restart(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Sequence.always_restart)
}

// repeated .bosdyn.api.mission.Node children = 2;
inline int Sequence::_internal_children_size() const {
  return children_.size();
}
inline int Sequence::children_size() const {
  return _internal_children_size();
}
inline void Sequence::clear_children() {
  children_.Clear();
}
inline ::bosdyn::api::mission::Node* Sequence::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Sequence.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >*
Sequence::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Sequence.children)
  return &children_;
}
inline const ::bosdyn::api::mission::Node& Sequence::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::bosdyn::api::mission::Node& Sequence::children(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Sequence.children)
  return _internal_children(index);
}
inline ::bosdyn::api::mission::Node* Sequence::_internal_add_children() {
  return children_.Add();
}
inline ::bosdyn::api::mission::Node* Sequence::add_children() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Sequence.children)
  return _internal_add_children();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >&
Sequence::children() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Sequence.children)
  return children_;
}

// -------------------------------------------------------------------

// Selector

// bool always_restart = 1;
inline void Selector::clear_always_restart() {
  always_restart_ = false;
}
inline bool Selector::_internal_always_restart() const {
  return always_restart_;
}
inline bool Selector::always_restart() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Selector.always_restart)
  return _internal_always_restart();
}
inline void Selector::_internal_set_always_restart(bool value) {
  
  always_restart_ = value;
}
inline void Selector::set_always_restart(bool value) {
  _internal_set_always_restart(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Selector.always_restart)
}

// repeated .bosdyn.api.mission.Node children = 2;
inline int Selector::_internal_children_size() const {
  return children_.size();
}
inline int Selector::children_size() const {
  return _internal_children_size();
}
inline void Selector::clear_children() {
  children_.Clear();
}
inline ::bosdyn::api::mission::Node* Selector::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Selector.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >*
Selector::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Selector.children)
  return &children_;
}
inline const ::bosdyn::api::mission::Node& Selector::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::bosdyn::api::mission::Node& Selector::children(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Selector.children)
  return _internal_children(index);
}
inline ::bosdyn::api::mission::Node* Selector::_internal_add_children() {
  return children_.Add();
}
inline ::bosdyn::api::mission::Node* Selector::add_children() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Selector.children)
  return _internal_add_children();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Node >&
Selector::children() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Selector.children)
  return children_;
}

// -------------------------------------------------------------------

// Repeat

// int32 max_starts = 1;
inline void Repeat::clear_max_starts() {
  max_starts_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Repeat::_internal_max_starts() const {
  return max_starts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Repeat::max_starts() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Repeat.max_starts)
  return _internal_max_starts();
}
inline void Repeat::_internal_set_max_starts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_starts_ = value;
}
inline void Repeat::set_max_starts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_starts(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Repeat.max_starts)
}

// .bosdyn.api.mission.Node child = 4;
inline bool Repeat::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Repeat::has_child() const {
  return _internal_has_child();
}
inline void Repeat::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& Repeat::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = child_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Repeat::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Repeat.child)
  return _internal_child();
}
inline void Repeat::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Repeat.child)
}
inline ::bosdyn::api::mission::Node* Repeat::release_child() {
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* Repeat::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Repeat.child)
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* Repeat::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::bosdyn::api::mission::Node* Repeat::mutable_child() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Repeat.child)
  return _internal_mutable_child();
}
inline void Repeat::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Repeat.child)
}

// -------------------------------------------------------------------

// Retry

// int32 max_attempts = 1;
inline void Retry::clear_max_attempts() {
  max_attempts_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Retry::_internal_max_attempts() const {
  return max_attempts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Retry::max_attempts() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Retry.max_attempts)
  return _internal_max_attempts();
}
inline void Retry::_internal_set_max_attempts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_attempts_ = value;
}
inline void Retry::set_max_attempts(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_attempts(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Retry.max_attempts)
}

// .bosdyn.api.mission.Node child = 2;
inline bool Retry::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Retry::has_child() const {
  return _internal_has_child();
}
inline void Retry::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& Retry::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = child_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Retry::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Retry.child)
  return _internal_child();
}
inline void Retry::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Retry.child)
}
inline ::bosdyn::api::mission::Node* Retry::release_child() {
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* Retry::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Retry.child)
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* Retry::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::bosdyn::api::mission::Node* Retry::mutable_child() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Retry.child)
  return _internal_mutable_child();
}
inline void Retry::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Retry.child)
}

// -------------------------------------------------------------------

// ForDuration

// .google.protobuf.Duration duration = 1;
inline bool ForDuration::_internal_has_duration() const {
  return this != internal_default_instance() && duration_ != nullptr;
}
inline bool ForDuration::has_duration() const {
  return _internal_has_duration();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& ForDuration::_internal_duration() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = duration_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration*>(
      &PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& ForDuration::duration() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ForDuration.duration)
  return _internal_duration();
}
inline void ForDuration::unsafe_arena_set_allocated_duration(
    PROTOBUF_NAMESPACE_ID::Duration* duration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  duration_ = duration;
  if (duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.ForDuration.duration)
}
inline PROTOBUF_NAMESPACE_ID::Duration* ForDuration::release_duration() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* ForDuration::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ForDuration.duration)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = duration_;
  duration_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* ForDuration::_internal_mutable_duration() {
  
  if (duration_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    duration_ = p;
  }
  return duration_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* ForDuration::mutable_duration() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ForDuration.duration)
  return _internal_mutable_duration();
}
inline void ForDuration::set_allocated_duration(PROTOBUF_NAMESPACE_ID::Duration* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration_);
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(duration)->GetArena();
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    
  } else {
    
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ForDuration.duration)
}

// .bosdyn.api.mission.Node child = 2;
inline bool ForDuration::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool ForDuration::has_child() const {
  return _internal_has_child();
}
inline void ForDuration::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& ForDuration::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = child_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& ForDuration::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ForDuration.child)
  return _internal_child();
}
inline void ForDuration::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.ForDuration.child)
}
inline ::bosdyn::api::mission::Node* ForDuration::release_child() {
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* ForDuration::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.ForDuration.child)
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* ForDuration::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::bosdyn::api::mission::Node* ForDuration::mutable_child() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.ForDuration.child)
  return _internal_mutable_child();
}
inline void ForDuration::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.ForDuration.child)
}

// -------------------------------------------------------------------

// SimpleParallel

// .bosdyn.api.mission.Node primary = 1;
inline bool SimpleParallel::_internal_has_primary() const {
  return this != internal_default_instance() && primary_ != nullptr;
}
inline bool SimpleParallel::has_primary() const {
  return _internal_has_primary();
}
inline void SimpleParallel::clear_primary() {
  if (GetArena() == nullptr && primary_ != nullptr) {
    delete primary_;
  }
  primary_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& SimpleParallel::_internal_primary() const {
  const ::bosdyn::api::mission::Node* p = primary_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& SimpleParallel::primary() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SimpleParallel.primary)
  return _internal_primary();
}
inline void SimpleParallel::unsafe_arena_set_allocated_primary(
    ::bosdyn::api::mission::Node* primary) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(primary_);
  }
  primary_ = primary;
  if (primary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SimpleParallel.primary)
}
inline ::bosdyn::api::mission::Node* SimpleParallel::release_primary() {
  
  ::bosdyn::api::mission::Node* temp = primary_;
  primary_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::unsafe_arena_release_primary() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SimpleParallel.primary)
  
  ::bosdyn::api::mission::Node* temp = primary_;
  primary_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::_internal_mutable_primary() {
  
  if (primary_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    primary_ = p;
  }
  return primary_;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::mutable_primary() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SimpleParallel.primary)
  return _internal_mutable_primary();
}
inline void SimpleParallel::set_allocated_primary(::bosdyn::api::mission::Node* primary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete primary_;
  }
  if (primary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(primary);
    if (message_arena != submessage_arena) {
      primary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primary, submessage_arena);
    }
    
  } else {
    
  }
  primary_ = primary;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SimpleParallel.primary)
}

// .bosdyn.api.mission.Node secondary = 2;
inline bool SimpleParallel::_internal_has_secondary() const {
  return this != internal_default_instance() && secondary_ != nullptr;
}
inline bool SimpleParallel::has_secondary() const {
  return _internal_has_secondary();
}
inline void SimpleParallel::clear_secondary() {
  if (GetArena() == nullptr && secondary_ != nullptr) {
    delete secondary_;
  }
  secondary_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& SimpleParallel::_internal_secondary() const {
  const ::bosdyn::api::mission::Node* p = secondary_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& SimpleParallel::secondary() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SimpleParallel.secondary)
  return _internal_secondary();
}
inline void SimpleParallel::unsafe_arena_set_allocated_secondary(
    ::bosdyn::api::mission::Node* secondary) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(secondary_);
  }
  secondary_ = secondary;
  if (secondary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SimpleParallel.secondary)
}
inline ::bosdyn::api::mission::Node* SimpleParallel::release_secondary() {
  
  ::bosdyn::api::mission::Node* temp = secondary_;
  secondary_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::unsafe_arena_release_secondary() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SimpleParallel.secondary)
  
  ::bosdyn::api::mission::Node* temp = secondary_;
  secondary_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::_internal_mutable_secondary() {
  
  if (secondary_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    secondary_ = p;
  }
  return secondary_;
}
inline ::bosdyn::api::mission::Node* SimpleParallel::mutable_secondary() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SimpleParallel.secondary)
  return _internal_mutable_secondary();
}
inline void SimpleParallel::set_allocated_secondary(::bosdyn::api::mission::Node* secondary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete secondary_;
  }
  if (secondary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(secondary);
    if (message_arena != submessage_arena) {
      secondary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, secondary, submessage_arena);
    }
    
  } else {
    
  }
  secondary_ = secondary;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SimpleParallel.secondary)
}

// -------------------------------------------------------------------

// Condition_Operand

// .bosdyn.api.mission.VariableDeclaration var = 1;
inline bool Condition_Operand::_internal_has_var() const {
  return type_case() == kVar;
}
inline bool Condition_Operand::has_var() const {
  return _internal_has_var();
}
inline void Condition_Operand::set_has_var() {
  _oneof_case_[0] = kVar;
}
inline ::bosdyn::api::mission::VariableDeclaration* Condition_Operand::release_var() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Condition.Operand.var)
  if (_internal_has_var()) {
    clear_has_type();
      ::bosdyn::api::mission::VariableDeclaration* temp = type_.var_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::mission::VariableDeclaration& Condition_Operand::_internal_var() const {
  return _internal_has_var()
      ? *type_.var_
      : *reinterpret_cast< ::bosdyn::api::mission::VariableDeclaration*>(&::bosdyn::api::mission::_VariableDeclaration_default_instance_);
}
inline const ::bosdyn::api::mission::VariableDeclaration& Condition_Operand::var() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.Operand.var)
  return _internal_var();
}
inline ::bosdyn::api::mission::VariableDeclaration* Condition_Operand::unsafe_arena_release_var() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.mission.Condition.Operand.var)
  if (_internal_has_var()) {
    clear_has_type();
    ::bosdyn::api::mission::VariableDeclaration* temp = type_.var_;
    type_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition_Operand::unsafe_arena_set_allocated_var(::bosdyn::api::mission::VariableDeclaration* var) {
  clear_type();
  if (var) {
    set_has_var();
    type_.var_ = var;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Condition.Operand.var)
}
inline ::bosdyn::api::mission::VariableDeclaration* Condition_Operand::_internal_mutable_var() {
  if (!_internal_has_var()) {
    clear_type();
    set_has_var();
    type_.var_ = CreateMaybeMessage< ::bosdyn::api::mission::VariableDeclaration >(GetArena());
  }
  return type_.var_;
}
inline ::bosdyn::api::mission::VariableDeclaration* Condition_Operand::mutable_var() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Condition.Operand.var)
  return _internal_mutable_var();
}

// .bosdyn.api.mission.ConstantValue const = 2;
inline bool Condition_Operand::_internal_has_const_() const {
  return type_case() == kConst;
}
inline bool Condition_Operand::has_const_() const {
  return _internal_has_const_();
}
inline void Condition_Operand::set_has_const_() {
  _oneof_case_[0] = kConst;
}
inline ::bosdyn::api::mission::ConstantValue* Condition_Operand::release_const_() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Condition.Operand.const)
  if (_internal_has_const_()) {
    clear_has_type();
      ::bosdyn::api::mission::ConstantValue* temp = type_.const__;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.const__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bosdyn::api::mission::ConstantValue& Condition_Operand::_internal_const_() const {
  return _internal_has_const_()
      ? *type_.const__
      : *reinterpret_cast< ::bosdyn::api::mission::ConstantValue*>(&::bosdyn::api::mission::_ConstantValue_default_instance_);
}
inline const ::bosdyn::api::mission::ConstantValue& Condition_Operand::const_() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.Operand.const)
  return _internal_const_();
}
inline ::bosdyn::api::mission::ConstantValue* Condition_Operand::unsafe_arena_release_const_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bosdyn.api.mission.Condition.Operand.const)
  if (_internal_has_const_()) {
    clear_has_type();
    ::bosdyn::api::mission::ConstantValue* temp = type_.const__;
    type_.const__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition_Operand::unsafe_arena_set_allocated_const_(::bosdyn::api::mission::ConstantValue* const_) {
  clear_type();
  if (const_) {
    set_has_const_();
    type_.const__ = const_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Condition.Operand.const)
}
inline ::bosdyn::api::mission::ConstantValue* Condition_Operand::_internal_mutable_const_() {
  if (!_internal_has_const_()) {
    clear_type();
    set_has_const_();
    type_.const__ = CreateMaybeMessage< ::bosdyn::api::mission::ConstantValue >(GetArena());
  }
  return type_.const__;
}
inline ::bosdyn::api::mission::ConstantValue* Condition_Operand::mutable_const_() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Condition.Operand.const)
  return _internal_mutable_const_();
}

inline bool Condition_Operand::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Condition_Operand::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Condition_Operand::TypeCase Condition_Operand::type_case() const {
  return Condition_Operand::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Condition

// .bosdyn.api.mission.Condition.Operand lhs = 1;
inline bool Condition::_internal_has_lhs() const {
  return this != internal_default_instance() && lhs_ != nullptr;
}
inline bool Condition::has_lhs() const {
  return _internal_has_lhs();
}
inline void Condition::clear_lhs() {
  if (GetArena() == nullptr && lhs_ != nullptr) {
    delete lhs_;
  }
  lhs_ = nullptr;
}
inline const ::bosdyn::api::mission::Condition_Operand& Condition::_internal_lhs() const {
  const ::bosdyn::api::mission::Condition_Operand* p = lhs_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Condition_Operand*>(
      &::bosdyn::api::mission::_Condition_Operand_default_instance_);
}
inline const ::bosdyn::api::mission::Condition_Operand& Condition::lhs() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.lhs)
  return _internal_lhs();
}
inline void Condition::unsafe_arena_set_allocated_lhs(
    ::bosdyn::api::mission::Condition_Operand* lhs) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lhs_);
  }
  lhs_ = lhs;
  if (lhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Condition.lhs)
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::release_lhs() {
  
  ::bosdyn::api::mission::Condition_Operand* temp = lhs_;
  lhs_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::unsafe_arena_release_lhs() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Condition.lhs)
  
  ::bosdyn::api::mission::Condition_Operand* temp = lhs_;
  lhs_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::_internal_mutable_lhs() {
  
  if (lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Condition_Operand>(GetArena());
    lhs_ = p;
  }
  return lhs_;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::mutable_lhs() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Condition.lhs)
  return _internal_mutable_lhs();
}
inline void Condition::set_allocated_lhs(::bosdyn::api::mission::Condition_Operand* lhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lhs_;
  }
  if (lhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lhs);
    if (message_arena != submessage_arena) {
      lhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lhs, submessage_arena);
    }
    
  } else {
    
  }
  lhs_ = lhs;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Condition.lhs)
}

// .bosdyn.api.mission.Condition.Operand rhs = 2;
inline bool Condition::_internal_has_rhs() const {
  return this != internal_default_instance() && rhs_ != nullptr;
}
inline bool Condition::has_rhs() const {
  return _internal_has_rhs();
}
inline void Condition::clear_rhs() {
  if (GetArena() == nullptr && rhs_ != nullptr) {
    delete rhs_;
  }
  rhs_ = nullptr;
}
inline const ::bosdyn::api::mission::Condition_Operand& Condition::_internal_rhs() const {
  const ::bosdyn::api::mission::Condition_Operand* p = rhs_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Condition_Operand*>(
      &::bosdyn::api::mission::_Condition_Operand_default_instance_);
}
inline const ::bosdyn::api::mission::Condition_Operand& Condition::rhs() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.rhs)
  return _internal_rhs();
}
inline void Condition::unsafe_arena_set_allocated_rhs(
    ::bosdyn::api::mission::Condition_Operand* rhs) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rhs_);
  }
  rhs_ = rhs;
  if (rhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Condition.rhs)
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::release_rhs() {
  
  ::bosdyn::api::mission::Condition_Operand* temp = rhs_;
  rhs_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::unsafe_arena_release_rhs() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Condition.rhs)
  
  ::bosdyn::api::mission::Condition_Operand* temp = rhs_;
  rhs_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::_internal_mutable_rhs() {
  
  if (rhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Condition_Operand>(GetArena());
    rhs_ = p;
  }
  return rhs_;
}
inline ::bosdyn::api::mission::Condition_Operand* Condition::mutable_rhs() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Condition.rhs)
  return _internal_mutable_rhs();
}
inline void Condition::set_allocated_rhs(::bosdyn::api::mission::Condition_Operand* rhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rhs_;
  }
  if (rhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rhs);
    if (message_arena != submessage_arena) {
      rhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rhs, submessage_arena);
    }
    
  } else {
    
  }
  rhs_ = rhs;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Condition.rhs)
}

// .bosdyn.api.mission.Condition.Compare operation = 5;
inline void Condition::clear_operation() {
  operation_ = 0;
}
inline ::bosdyn::api::mission::Condition_Compare Condition::_internal_operation() const {
  return static_cast< ::bosdyn::api::mission::Condition_Compare >(operation_);
}
inline ::bosdyn::api::mission::Condition_Compare Condition::operation() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Condition.operation)
  return _internal_operation();
}
inline void Condition::_internal_set_operation(::bosdyn::api::mission::Condition_Compare value) {
  
  operation_ = value;
}
inline void Condition::set_operation(::bosdyn::api::mission::Condition_Compare value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Condition.operation)
}

// -------------------------------------------------------------------

// BosdynRobotState

// string service_name = 1;
inline void BosdynRobotState::clear_service_name() {
  service_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynRobotState::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotState.service_name)
  return _internal_service_name();
}
inline void BosdynRobotState::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotState.service_name)
}
inline std::string* BosdynRobotState::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotState.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& BosdynRobotState::_internal_service_name() const {
  return service_name_.Get();
}
inline void BosdynRobotState::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynRobotState::set_service_name(std::string&& value) {
  
  service_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynRobotState.service_name)
}
inline void BosdynRobotState::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynRobotState.service_name)
}
inline void BosdynRobotState::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynRobotState.service_name)
}
inline std::string* BosdynRobotState::_internal_mutable_service_name() {
  
  return service_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynRobotState::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotState.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynRobotState::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotState.service_name)
}

// string host = 2;
inline void BosdynRobotState::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynRobotState::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotState.host)
  return _internal_host();
}
inline void BosdynRobotState::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotState.host)
}
inline std::string* BosdynRobotState::mutable_host() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotState.host)
  return _internal_mutable_host();
}
inline const std::string& BosdynRobotState::_internal_host() const {
  return host_.Get();
}
inline void BosdynRobotState::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynRobotState::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynRobotState.host)
}
inline void BosdynRobotState::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynRobotState.host)
}
inline void BosdynRobotState::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynRobotState.host)
}
inline std::string* BosdynRobotState::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynRobotState::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotState.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynRobotState::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotState.host)
}

// .bosdyn.api.mission.Node child = 3;
inline bool BosdynRobotState::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool BosdynRobotState::has_child() const {
  return _internal_has_child();
}
inline void BosdynRobotState::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& BosdynRobotState::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = child_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& BosdynRobotState::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotState.child)
  return _internal_child();
}
inline void BosdynRobotState::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynRobotState.child)
}
inline ::bosdyn::api::mission::Node* BosdynRobotState::release_child() {
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynRobotState::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotState.child)
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynRobotState::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::bosdyn::api::mission::Node* BosdynRobotState::mutable_child() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotState.child)
  return _internal_mutable_child();
}
inline void BosdynRobotState::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotState.child)
}

// string state_name = 4;
inline void BosdynRobotState::clear_state_name() {
  state_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynRobotState::state_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotState.state_name)
  return _internal_state_name();
}
inline void BosdynRobotState::set_state_name(const std::string& value) {
  _internal_set_state_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotState.state_name)
}
inline std::string* BosdynRobotState::mutable_state_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotState.state_name)
  return _internal_mutable_state_name();
}
inline const std::string& BosdynRobotState::_internal_state_name() const {
  return state_name_.Get();
}
inline void BosdynRobotState::_internal_set_state_name(const std::string& value) {
  
  state_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynRobotState::set_state_name(std::string&& value) {
  
  state_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynRobotState.state_name)
}
inline void BosdynRobotState::set_state_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynRobotState.state_name)
}
inline void BosdynRobotState::set_state_name(const char* value,
    size_t size) {
  
  state_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynRobotState.state_name)
}
inline std::string* BosdynRobotState::_internal_mutable_state_name() {
  
  return state_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynRobotState::release_state_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotState.state_name)
  return state_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynRobotState::set_allocated_state_name(std::string* state_name) {
  if (state_name != nullptr) {
    
  } else {
    
  }
  state_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotState.state_name)
}

// -------------------------------------------------------------------

// BosdynRobotCommand

// string service_name = 1;
inline void BosdynRobotCommand::clear_service_name() {
  service_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynRobotCommand::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotCommand.service_name)
  return _internal_service_name();
}
inline void BosdynRobotCommand::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotCommand.service_name)
}
inline std::string* BosdynRobotCommand::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotCommand.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& BosdynRobotCommand::_internal_service_name() const {
  return service_name_.Get();
}
inline void BosdynRobotCommand::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynRobotCommand::set_service_name(std::string&& value) {
  
  service_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynRobotCommand.service_name)
}
inline void BosdynRobotCommand::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynRobotCommand.service_name)
}
inline void BosdynRobotCommand::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynRobotCommand.service_name)
}
inline std::string* BosdynRobotCommand::_internal_mutable_service_name() {
  
  return service_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynRobotCommand::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotCommand.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynRobotCommand::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotCommand.service_name)
}

// string host = 2;
inline void BosdynRobotCommand::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynRobotCommand::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotCommand.host)
  return _internal_host();
}
inline void BosdynRobotCommand::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynRobotCommand.host)
}
inline std::string* BosdynRobotCommand::mutable_host() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotCommand.host)
  return _internal_mutable_host();
}
inline const std::string& BosdynRobotCommand::_internal_host() const {
  return host_.Get();
}
inline void BosdynRobotCommand::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynRobotCommand::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynRobotCommand.host)
}
inline void BosdynRobotCommand::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynRobotCommand.host)
}
inline void BosdynRobotCommand::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynRobotCommand.host)
}
inline std::string* BosdynRobotCommand::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynRobotCommand::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotCommand.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynRobotCommand::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotCommand.host)
}

// .bosdyn.api.RobotCommand command = 3;
inline bool BosdynRobotCommand::_internal_has_command() const {
  return this != internal_default_instance() && command_ != nullptr;
}
inline bool BosdynRobotCommand::has_command() const {
  return _internal_has_command();
}
inline const ::bosdyn::api::RobotCommand& BosdynRobotCommand::_internal_command() const {
  const ::bosdyn::api::RobotCommand* p = command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RobotCommand*>(
      &::bosdyn::api::_RobotCommand_default_instance_);
}
inline const ::bosdyn::api::RobotCommand& BosdynRobotCommand::command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynRobotCommand.command)
  return _internal_command();
}
inline void BosdynRobotCommand::unsafe_arena_set_allocated_command(
    ::bosdyn::api::RobotCommand* command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynRobotCommand.command)
}
inline ::bosdyn::api::RobotCommand* BosdynRobotCommand::release_command() {
  
  ::bosdyn::api::RobotCommand* temp = command_;
  command_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RobotCommand* BosdynRobotCommand::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynRobotCommand.command)
  
  ::bosdyn::api::RobotCommand* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RobotCommand* BosdynRobotCommand::_internal_mutable_command() {
  
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RobotCommand>(GetArena());
    command_ = p;
  }
  return command_;
}
inline ::bosdyn::api::RobotCommand* BosdynRobotCommand::mutable_command() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynRobotCommand.command)
  return _internal_mutable_command();
}
inline void BosdynRobotCommand::set_allocated_command(::bosdyn::api::RobotCommand* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command)->GetArena();
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynRobotCommand.command)
}

// -------------------------------------------------------------------

// BosdynPowerRequest

// string service_name = 1;
inline void BosdynPowerRequest::clear_service_name() {
  service_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynPowerRequest::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynPowerRequest.service_name)
  return _internal_service_name();
}
inline void BosdynPowerRequest::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynPowerRequest.service_name)
}
inline std::string* BosdynPowerRequest::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynPowerRequest.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& BosdynPowerRequest::_internal_service_name() const {
  return service_name_.Get();
}
inline void BosdynPowerRequest::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynPowerRequest::set_service_name(std::string&& value) {
  
  service_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynPowerRequest.service_name)
}
inline void BosdynPowerRequest::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynPowerRequest.service_name)
}
inline void BosdynPowerRequest::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynPowerRequest.service_name)
}
inline std::string* BosdynPowerRequest::_internal_mutable_service_name() {
  
  return service_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynPowerRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynPowerRequest.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynPowerRequest::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynPowerRequest.service_name)
}

// string host = 2;
inline void BosdynPowerRequest::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynPowerRequest::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynPowerRequest.host)
  return _internal_host();
}
inline void BosdynPowerRequest::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynPowerRequest.host)
}
inline std::string* BosdynPowerRequest::mutable_host() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynPowerRequest.host)
  return _internal_mutable_host();
}
inline const std::string& BosdynPowerRequest::_internal_host() const {
  return host_.Get();
}
inline void BosdynPowerRequest::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynPowerRequest::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynPowerRequest.host)
}
inline void BosdynPowerRequest::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynPowerRequest.host)
}
inline void BosdynPowerRequest::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynPowerRequest.host)
}
inline std::string* BosdynPowerRequest::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynPowerRequest::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynPowerRequest.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynPowerRequest::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynPowerRequest.host)
}

// .bosdyn.api.PowerCommandRequest.Request request = 4;
inline void BosdynPowerRequest::clear_request() {
  request_ = 0;
}
inline ::bosdyn::api::PowerCommandRequest_Request BosdynPowerRequest::_internal_request() const {
  return static_cast< ::bosdyn::api::PowerCommandRequest_Request >(request_);
}
inline ::bosdyn::api::PowerCommandRequest_Request BosdynPowerRequest::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynPowerRequest.request)
  return _internal_request();
}
inline void BosdynPowerRequest::_internal_set_request(::bosdyn::api::PowerCommandRequest_Request value) {
  
  request_ = value;
}
inline void BosdynPowerRequest::set_request(::bosdyn::api::PowerCommandRequest_Request value) {
  _internal_set_request(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynPowerRequest.request)
}

// -------------------------------------------------------------------

// BosdynNavigateTo

// string service_name = 1;
inline void BosdynNavigateTo::clear_service_name() {
  service_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynNavigateTo::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.service_name)
  return _internal_service_name();
}
inline void BosdynNavigateTo::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateTo.service_name)
}
inline std::string* BosdynNavigateTo::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& BosdynNavigateTo::_internal_service_name() const {
  return service_name_.Get();
}
inline void BosdynNavigateTo::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynNavigateTo::set_service_name(std::string&& value) {
  
  service_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynNavigateTo.service_name)
}
inline void BosdynNavigateTo::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynNavigateTo.service_name)
}
inline void BosdynNavigateTo::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynNavigateTo.service_name)
}
inline std::string* BosdynNavigateTo::_internal_mutable_service_name() {
  
  return service_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynNavigateTo::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynNavigateTo::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.service_name)
}

// string host = 2;
inline void BosdynNavigateTo::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynNavigateTo::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.host)
  return _internal_host();
}
inline void BosdynNavigateTo::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateTo.host)
}
inline std::string* BosdynNavigateTo::mutable_host() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.host)
  return _internal_mutable_host();
}
inline const std::string& BosdynNavigateTo::_internal_host() const {
  return host_.Get();
}
inline void BosdynNavigateTo::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynNavigateTo::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynNavigateTo.host)
}
inline void BosdynNavigateTo::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynNavigateTo.host)
}
inline void BosdynNavigateTo::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynNavigateTo.host)
}
inline std::string* BosdynNavigateTo::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynNavigateTo::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynNavigateTo::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.host)
}

// string destination_waypoint_id = 3;
inline void BosdynNavigateTo::clear_destination_waypoint_id() {
  destination_waypoint_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynNavigateTo::destination_waypoint_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
  return _internal_destination_waypoint_id();
}
inline void BosdynNavigateTo::set_destination_waypoint_id(const std::string& value) {
  _internal_set_destination_waypoint_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
}
inline std::string* BosdynNavigateTo::mutable_destination_waypoint_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
  return _internal_mutable_destination_waypoint_id();
}
inline const std::string& BosdynNavigateTo::_internal_destination_waypoint_id() const {
  return destination_waypoint_id_.Get();
}
inline void BosdynNavigateTo::_internal_set_destination_waypoint_id(const std::string& value) {
  
  destination_waypoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynNavigateTo::set_destination_waypoint_id(std::string&& value) {
  
  destination_waypoint_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
}
inline void BosdynNavigateTo::set_destination_waypoint_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  destination_waypoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
}
inline void BosdynNavigateTo::set_destination_waypoint_id(const char* value,
    size_t size) {
  
  destination_waypoint_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
}
inline std::string* BosdynNavigateTo::_internal_mutable_destination_waypoint_id() {
  
  return destination_waypoint_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynNavigateTo::release_destination_waypoint_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
  return destination_waypoint_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynNavigateTo::set_allocated_destination_waypoint_id(std::string* destination_waypoint_id) {
  if (destination_waypoint_id != nullptr) {
    
  } else {
    
  }
  destination_waypoint_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination_waypoint_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.destination_waypoint_id)
}

// .bosdyn.api.graph_nav.RouteGenParams route_gen_params = 4;
inline bool BosdynNavigateTo::_internal_has_route_gen_params() const {
  return this != internal_default_instance() && route_gen_params_ != nullptr;
}
inline bool BosdynNavigateTo::has_route_gen_params() const {
  return _internal_has_route_gen_params();
}
inline const ::bosdyn::api::graph_nav::RouteGenParams& BosdynNavigateTo::_internal_route_gen_params() const {
  const ::bosdyn::api::graph_nav::RouteGenParams* p = route_gen_params_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::RouteGenParams*>(
      &::bosdyn::api::graph_nav::_RouteGenParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::RouteGenParams& BosdynNavigateTo::route_gen_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
  return _internal_route_gen_params();
}
inline void BosdynNavigateTo::unsafe_arena_set_allocated_route_gen_params(
    ::bosdyn::api::graph_nav::RouteGenParams* route_gen_params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route_gen_params_);
  }
  route_gen_params_ = route_gen_params;
  if (route_gen_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
}
inline ::bosdyn::api::graph_nav::RouteGenParams* BosdynNavigateTo::release_route_gen_params() {
  
  ::bosdyn::api::graph_nav::RouteGenParams* temp = route_gen_params_;
  route_gen_params_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* BosdynNavigateTo::unsafe_arena_release_route_gen_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
  
  ::bosdyn::api::graph_nav::RouteGenParams* temp = route_gen_params_;
  route_gen_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* BosdynNavigateTo::_internal_mutable_route_gen_params() {
  
  if (route_gen_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::RouteGenParams>(GetArena());
    route_gen_params_ = p;
  }
  return route_gen_params_;
}
inline ::bosdyn::api::graph_nav::RouteGenParams* BosdynNavigateTo::mutable_route_gen_params() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
  return _internal_mutable_route_gen_params();
}
inline void BosdynNavigateTo::set_allocated_route_gen_params(::bosdyn::api::graph_nav::RouteGenParams* route_gen_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(route_gen_params_);
  }
  if (route_gen_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route_gen_params)->GetArena();
    if (message_arena != submessage_arena) {
      route_gen_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route_gen_params, submessage_arena);
    }
    
  } else {
    
  }
  route_gen_params_ = route_gen_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.route_gen_params)
}

// .bosdyn.api.graph_nav.TravelParams travel_params = 5;
inline bool BosdynNavigateTo::_internal_has_travel_params() const {
  return this != internal_default_instance() && travel_params_ != nullptr;
}
inline bool BosdynNavigateTo::has_travel_params() const {
  return _internal_has_travel_params();
}
inline const ::bosdyn::api::graph_nav::TravelParams& BosdynNavigateTo::_internal_travel_params() const {
  const ::bosdyn::api::graph_nav::TravelParams* p = travel_params_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::graph_nav::TravelParams*>(
      &::bosdyn::api::graph_nav::_TravelParams_default_instance_);
}
inline const ::bosdyn::api::graph_nav::TravelParams& BosdynNavigateTo::travel_params() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynNavigateTo.travel_params)
  return _internal_travel_params();
}
inline void BosdynNavigateTo::unsafe_arena_set_allocated_travel_params(
    ::bosdyn::api::graph_nav::TravelParams* travel_params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(travel_params_);
  }
  travel_params_ = travel_params;
  if (travel_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynNavigateTo.travel_params)
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateTo::release_travel_params() {
  
  ::bosdyn::api::graph_nav::TravelParams* temp = travel_params_;
  travel_params_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateTo::unsafe_arena_release_travel_params() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynNavigateTo.travel_params)
  
  ::bosdyn::api::graph_nav::TravelParams* temp = travel_params_;
  travel_params_ = nullptr;
  return temp;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateTo::_internal_mutable_travel_params() {
  
  if (travel_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::graph_nav::TravelParams>(GetArena());
    travel_params_ = p;
  }
  return travel_params_;
}
inline ::bosdyn::api::graph_nav::TravelParams* BosdynNavigateTo::mutable_travel_params() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynNavigateTo.travel_params)
  return _internal_mutable_travel_params();
}
inline void BosdynNavigateTo::set_allocated_travel_params(::bosdyn::api::graph_nav::TravelParams* travel_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(travel_params_);
  }
  if (travel_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(travel_params)->GetArena();
    if (message_arena != submessage_arena) {
      travel_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, travel_params, submessage_arena);
    }
    
  } else {
    
  }
  travel_params_ = travel_params;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynNavigateTo.travel_params)
}

// -------------------------------------------------------------------

// BosdynGraphNavState

// string service_name = 1;
inline void BosdynGraphNavState::clear_service_name() {
  service_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynGraphNavState::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.service_name)
  return _internal_service_name();
}
inline void BosdynGraphNavState::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavState.service_name)
}
inline std::string* BosdynGraphNavState::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& BosdynGraphNavState::_internal_service_name() const {
  return service_name_.Get();
}
inline void BosdynGraphNavState::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynGraphNavState::set_service_name(std::string&& value) {
  
  service_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynGraphNavState.service_name)
}
inline void BosdynGraphNavState::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynGraphNavState.service_name)
}
inline void BosdynGraphNavState::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynGraphNavState.service_name)
}
inline std::string* BosdynGraphNavState::_internal_mutable_service_name() {
  
  return service_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynGraphNavState::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynGraphNavState::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.service_name)
}

// string host = 2;
inline void BosdynGraphNavState::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynGraphNavState::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.host)
  return _internal_host();
}
inline void BosdynGraphNavState::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavState.host)
}
inline std::string* BosdynGraphNavState::mutable_host() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.host)
  return _internal_mutable_host();
}
inline const std::string& BosdynGraphNavState::_internal_host() const {
  return host_.Get();
}
inline void BosdynGraphNavState::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynGraphNavState::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynGraphNavState.host)
}
inline void BosdynGraphNavState::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynGraphNavState.host)
}
inline void BosdynGraphNavState::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynGraphNavState.host)
}
inline std::string* BosdynGraphNavState::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynGraphNavState::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynGraphNavState::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.host)
}

// .bosdyn.api.mission.Node child = 3;
inline bool BosdynGraphNavState::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool BosdynGraphNavState::has_child() const {
  return _internal_has_child();
}
inline void BosdynGraphNavState::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& BosdynGraphNavState::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = child_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& BosdynGraphNavState::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.child)
  return _internal_child();
}
inline void BosdynGraphNavState::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.BosdynGraphNavState.child)
}
inline ::bosdyn::api::mission::Node* BosdynGraphNavState::release_child() {
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynGraphNavState::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.child)
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* BosdynGraphNavState::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::bosdyn::api::mission::Node* BosdynGraphNavState::mutable_child() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.child)
  return _internal_mutable_child();
}
inline void BosdynGraphNavState::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.child)
}

// string state_name = 4;
inline void BosdynGraphNavState::clear_state_name() {
  state_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynGraphNavState::state_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavState.state_name)
  return _internal_state_name();
}
inline void BosdynGraphNavState::set_state_name(const std::string& value) {
  _internal_set_state_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavState.state_name)
}
inline std::string* BosdynGraphNavState::mutable_state_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavState.state_name)
  return _internal_mutable_state_name();
}
inline const std::string& BosdynGraphNavState::_internal_state_name() const {
  return state_name_.Get();
}
inline void BosdynGraphNavState::_internal_set_state_name(const std::string& value) {
  
  state_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynGraphNavState::set_state_name(std::string&& value) {
  
  state_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynGraphNavState.state_name)
}
inline void BosdynGraphNavState::set_state_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynGraphNavState.state_name)
}
inline void BosdynGraphNavState::set_state_name(const char* value,
    size_t size) {
  
  state_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynGraphNavState.state_name)
}
inline std::string* BosdynGraphNavState::_internal_mutable_state_name() {
  
  return state_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynGraphNavState::release_state_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavState.state_name)
  return state_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynGraphNavState::set_allocated_state_name(std::string* state_name) {
  if (state_name != nullptr) {
    
  } else {
    
  }
  state_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavState.state_name)
}

// -------------------------------------------------------------------

// BosdynGraphNavLocalize

// string service_name = 1;
inline void BosdynGraphNavLocalize::clear_service_name() {
  service_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynGraphNavLocalize::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
  return _internal_service_name();
}
inline void BosdynGraphNavLocalize::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
}
inline std::string* BosdynGraphNavLocalize::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& BosdynGraphNavLocalize::_internal_service_name() const {
  return service_name_.Get();
}
inline void BosdynGraphNavLocalize::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynGraphNavLocalize::set_service_name(std::string&& value) {
  
  service_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
}
inline void BosdynGraphNavLocalize::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
}
inline void BosdynGraphNavLocalize::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
}
inline std::string* BosdynGraphNavLocalize::_internal_mutable_service_name() {
  
  return service_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynGraphNavLocalize::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynGraphNavLocalize::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavLocalize.service_name)
}

// string host = 2;
inline void BosdynGraphNavLocalize::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& BosdynGraphNavLocalize::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.BosdynGraphNavLocalize.host)
  return _internal_host();
}
inline void BosdynGraphNavLocalize::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.BosdynGraphNavLocalize.host)
}
inline std::string* BosdynGraphNavLocalize::mutable_host() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.BosdynGraphNavLocalize.host)
  return _internal_mutable_host();
}
inline const std::string& BosdynGraphNavLocalize::_internal_host() const {
  return host_.Get();
}
inline void BosdynGraphNavLocalize::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BosdynGraphNavLocalize::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.BosdynGraphNavLocalize.host)
}
inline void BosdynGraphNavLocalize::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.BosdynGraphNavLocalize.host)
}
inline void BosdynGraphNavLocalize::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.BosdynGraphNavLocalize.host)
}
inline std::string* BosdynGraphNavLocalize::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BosdynGraphNavLocalize::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.BosdynGraphNavLocalize.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BosdynGraphNavLocalize::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.BosdynGraphNavLocalize.host)
}

// -------------------------------------------------------------------

// RemoteGrpc

// string host = 1;
inline void RemoteGrpc::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteGrpc::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.host)
  return _internal_host();
}
inline void RemoteGrpc::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.host)
}
inline std::string* RemoteGrpc::mutable_host() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RemoteGrpc.host)
  return _internal_mutable_host();
}
inline const std::string& RemoteGrpc::_internal_host() const {
  return host_.Get();
}
inline void RemoteGrpc::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteGrpc::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.RemoteGrpc.host)
}
inline void RemoteGrpc::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.RemoteGrpc.host)
}
inline void RemoteGrpc::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.RemoteGrpc.host)
}
inline std::string* RemoteGrpc::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteGrpc::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RemoteGrpc.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteGrpc::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RemoteGrpc.host)
}

// string service_name = 3;
inline void RemoteGrpc::clear_service_name() {
  service_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RemoteGrpc::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.service_name)
  return _internal_service_name();
}
inline void RemoteGrpc::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.service_name)
}
inline std::string* RemoteGrpc::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RemoteGrpc.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& RemoteGrpc::_internal_service_name() const {
  return service_name_.Get();
}
inline void RemoteGrpc::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RemoteGrpc::set_service_name(std::string&& value) {
  
  service_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.RemoteGrpc.service_name)
}
inline void RemoteGrpc::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.RemoteGrpc.service_name)
}
inline void RemoteGrpc::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.RemoteGrpc.service_name)
}
inline std::string* RemoteGrpc::_internal_mutable_service_name() {
  
  return service_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RemoteGrpc::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.RemoteGrpc.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemoteGrpc::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.RemoteGrpc.service_name)
}

// float timeout = 4;
inline void RemoteGrpc::clear_timeout() {
  timeout_ = 0;
}
inline float RemoteGrpc::_internal_timeout() const {
  return timeout_;
}
inline float RemoteGrpc::timeout() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.timeout)
  return _internal_timeout();
}
inline void RemoteGrpc::_internal_set_timeout(float value) {
  
  timeout_ = value;
}
inline void RemoteGrpc::set_timeout(float value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.timeout)
}

// repeated string lease_resources = 5;
inline int RemoteGrpc::_internal_lease_resources_size() const {
  return lease_resources_.size();
}
inline int RemoteGrpc::lease_resources_size() const {
  return _internal_lease_resources_size();
}
inline void RemoteGrpc::clear_lease_resources() {
  lease_resources_.Clear();
}
inline std::string* RemoteGrpc::add_lease_resources() {
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return _internal_add_lease_resources();
}
inline const std::string& RemoteGrpc::_internal_lease_resources(int index) const {
  return lease_resources_.Get(index);
}
inline const std::string& RemoteGrpc::lease_resources(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return _internal_lease_resources(index);
}
inline std::string* RemoteGrpc::mutable_lease_resources(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return lease_resources_.Mutable(index);
}
inline void RemoteGrpc::set_lease_resources(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.lease_resources)
  lease_resources_.Mutable(index)->assign(value);
}
inline void RemoteGrpc::set_lease_resources(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.RemoteGrpc.lease_resources)
  lease_resources_.Mutable(index)->assign(std::move(value));
}
inline void RemoteGrpc::set_lease_resources(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lease_resources_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::set_lease_resources(int index, const char* value, size_t size) {
  lease_resources_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline std::string* RemoteGrpc::_internal_add_lease_resources() {
  return lease_resources_.Add();
}
inline void RemoteGrpc::add_lease_resources(const std::string& value) {
  lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::add_lease_resources(std::string&& value) {
  lease_resources_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::add_lease_resources(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  lease_resources_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline void RemoteGrpc::add_lease_resources(const char* value, size_t size) {
  lease_resources_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.mission.RemoteGrpc.lease_resources)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RemoteGrpc::lease_resources() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return lease_resources_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RemoteGrpc::mutable_lease_resources() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.RemoteGrpc.lease_resources)
  return &lease_resources_;
}

// repeated .bosdyn.api.mission.KeyValue inputs = 6;
inline int RemoteGrpc::_internal_inputs_size() const {
  return inputs_.size();
}
inline int RemoteGrpc::inputs_size() const {
  return _internal_inputs_size();
}
inline ::bosdyn::api::mission::KeyValue* RemoteGrpc::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.RemoteGrpc.inputs)
  return inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
RemoteGrpc::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.RemoteGrpc.inputs)
  return &inputs_;
}
inline const ::bosdyn::api::mission::KeyValue& RemoteGrpc::_internal_inputs(int index) const {
  return inputs_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& RemoteGrpc::inputs(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.RemoteGrpc.inputs)
  return _internal_inputs(index);
}
inline ::bosdyn::api::mission::KeyValue* RemoteGrpc::_internal_add_inputs() {
  return inputs_.Add();
}
inline ::bosdyn::api::mission::KeyValue* RemoteGrpc::add_inputs() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.RemoteGrpc.inputs)
  return _internal_add_inputs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
RemoteGrpc::inputs() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.RemoteGrpc.inputs)
  return inputs_;
}

// -------------------------------------------------------------------

// Sleep

// float seconds = 1;
inline void Sleep::clear_seconds() {
  seconds_ = 0;
}
inline float Sleep::_internal_seconds() const {
  return seconds_;
}
inline float Sleep::seconds() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Sleep.seconds)
  return _internal_seconds();
}
inline void Sleep::_internal_set_seconds(float value) {
  
  seconds_ = value;
}
inline void Sleep::set_seconds(float value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Sleep.seconds)
}

// bool restart_after_stop = 2;
inline void Sleep::clear_restart_after_stop() {
  restart_after_stop_ = false;
}
inline bool Sleep::_internal_restart_after_stop() const {
  return restart_after_stop_;
}
inline bool Sleep::restart_after_stop() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Sleep.restart_after_stop)
  return _internal_restart_after_stop();
}
inline void Sleep::_internal_set_restart_after_stop(bool value) {
  
  restart_after_stop_ = value;
}
inline void Sleep::set_restart_after_stop(bool value) {
  _internal_set_restart_after_stop(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Sleep.restart_after_stop)
}

// -------------------------------------------------------------------

// Prompt_Option

// string text = 1;
inline void Prompt_Option::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Prompt_Option::text() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.Option.text)
  return _internal_text();
}
inline void Prompt_Option::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.Option.text)
}
inline std::string* Prompt_Option::mutable_text() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.Option.text)
  return _internal_mutable_text();
}
inline const std::string& Prompt_Option::_internal_text() const {
  return text_.Get();
}
inline void Prompt_Option::_internal_set_text(const std::string& value) {
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Prompt_Option::set_text(std::string&& value) {
  
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.Prompt.Option.text)
}
inline void Prompt_Option::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.Prompt.Option.text)
}
inline void Prompt_Option::set_text(const char* value,
    size_t size) {
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.Prompt.Option.text)
}
inline std::string* Prompt_Option::_internal_mutable_text() {
  
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Prompt_Option::release_text() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Prompt.Option.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Prompt_Option::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Prompt.Option.text)
}

// int64 answer_code = 2;
inline void Prompt_Option::clear_answer_code() {
  answer_code_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Prompt_Option::_internal_answer_code() const {
  return answer_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Prompt_Option::answer_code() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.Option.answer_code)
  return _internal_answer_code();
}
inline void Prompt_Option::_internal_set_answer_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  answer_code_ = value;
}
inline void Prompt_Option::set_answer_code(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_answer_code(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.Option.answer_code)
}

// -------------------------------------------------------------------

// Prompt

// bool always_reprompt = 1;
inline void Prompt::clear_always_reprompt() {
  always_reprompt_ = false;
}
inline bool Prompt::_internal_always_reprompt() const {
  return always_reprompt_;
}
inline bool Prompt::always_reprompt() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.always_reprompt)
  return _internal_always_reprompt();
}
inline void Prompt::_internal_set_always_reprompt(bool value) {
  
  always_reprompt_ = value;
}
inline void Prompt::set_always_reprompt(bool value) {
  _internal_set_always_reprompt(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.always_reprompt)
}

// string text = 2;
inline void Prompt::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Prompt::text() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.text)
  return _internal_text();
}
inline void Prompt::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.text)
}
inline std::string* Prompt::mutable_text() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.text)
  return _internal_mutable_text();
}
inline const std::string& Prompt::_internal_text() const {
  return text_.Get();
}
inline void Prompt::_internal_set_text(const std::string& value) {
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Prompt::set_text(std::string&& value) {
  
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.Prompt.text)
}
inline void Prompt::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.Prompt.text)
}
inline void Prompt::set_text(const char* value,
    size_t size) {
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.Prompt.text)
}
inline std::string* Prompt::_internal_mutable_text() {
  
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Prompt::release_text() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Prompt.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Prompt::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Prompt.text)
}

// string source = 3;
inline void Prompt::clear_source() {
  source_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Prompt::source() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.source)
  return _internal_source();
}
inline void Prompt::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.source)
}
inline std::string* Prompt::mutable_source() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.source)
  return _internal_mutable_source();
}
inline const std::string& Prompt::_internal_source() const {
  return source_.Get();
}
inline void Prompt::_internal_set_source(const std::string& value) {
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Prompt::set_source(std::string&& value) {
  
  source_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.Prompt.source)
}
inline void Prompt::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.Prompt.source)
}
inline void Prompt::set_source(const char* value,
    size_t size) {
  
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.Prompt.source)
}
inline std::string* Prompt::_internal_mutable_source() {
  
  return source_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Prompt::release_source() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Prompt.source)
  return source_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Prompt::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Prompt.source)
}

// repeated .bosdyn.api.mission.Prompt.Option options = 4;
inline int Prompt::_internal_options_size() const {
  return options_.size();
}
inline int Prompt::options_size() const {
  return _internal_options_size();
}
inline void Prompt::clear_options() {
  options_.Clear();
}
inline ::bosdyn::api::mission::Prompt_Option* Prompt::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.options)
  return options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >*
Prompt::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.Prompt.options)
  return &options_;
}
inline const ::bosdyn::api::mission::Prompt_Option& Prompt::_internal_options(int index) const {
  return options_.Get(index);
}
inline const ::bosdyn::api::mission::Prompt_Option& Prompt::options(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.options)
  return _internal_options(index);
}
inline ::bosdyn::api::mission::Prompt_Option* Prompt::_internal_add_options() {
  return options_.Add();
}
inline ::bosdyn::api::mission::Prompt_Option* Prompt::add_options() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.Prompt.options)
  return _internal_add_options();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::Prompt_Option >&
Prompt::options() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.Prompt.options)
  return options_;
}

// .bosdyn.api.mission.Node child = 5;
inline bool Prompt::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool Prompt::has_child() const {
  return _internal_has_child();
}
inline void Prompt::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& Prompt::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = child_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& Prompt::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.child)
  return _internal_child();
}
inline void Prompt::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.Prompt.child)
}
inline ::bosdyn::api::mission::Node* Prompt::release_child() {
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* Prompt::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.Prompt.child)
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* Prompt::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::bosdyn::api::mission::Node* Prompt::mutable_child() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.Prompt.child)
  return _internal_mutable_child();
}
inline void Prompt::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.Prompt.child)
}

// bool for_autonomous_processing = 6;
inline void Prompt::clear_for_autonomous_processing() {
  for_autonomous_processing_ = false;
}
inline bool Prompt::_internal_for_autonomous_processing() const {
  return for_autonomous_processing_;
}
inline bool Prompt::for_autonomous_processing() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.Prompt.for_autonomous_processing)
  return _internal_for_autonomous_processing();
}
inline void Prompt::_internal_set_for_autonomous_processing(bool value) {
  
  for_autonomous_processing_ = value;
}
inline void Prompt::set_for_autonomous_processing(bool value) {
  _internal_set_for_autonomous_processing(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.Prompt.for_autonomous_processing)
}

// -------------------------------------------------------------------

// SpotCamStoreMedia

// string service_name = 1;
inline void SpotCamStoreMedia::clear_service_name() {
  service_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SpotCamStoreMedia::service_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.service_name)
  return _internal_service_name();
}
inline void SpotCamStoreMedia::set_service_name(const std::string& value) {
  _internal_set_service_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamStoreMedia.service_name)
}
inline std::string* SpotCamStoreMedia::mutable_service_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamStoreMedia.service_name)
  return _internal_mutable_service_name();
}
inline const std::string& SpotCamStoreMedia::_internal_service_name() const {
  return service_name_.Get();
}
inline void SpotCamStoreMedia::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SpotCamStoreMedia::set_service_name(std::string&& value) {
  
  service_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.SpotCamStoreMedia.service_name)
}
inline void SpotCamStoreMedia::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.SpotCamStoreMedia.service_name)
}
inline void SpotCamStoreMedia::set_service_name(const char* value,
    size_t size) {
  
  service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.SpotCamStoreMedia.service_name)
}
inline std::string* SpotCamStoreMedia::_internal_mutable_service_name() {
  
  return service_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SpotCamStoreMedia::release_service_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamStoreMedia.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpotCamStoreMedia::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.service_name)
}

// string host = 2;
inline void SpotCamStoreMedia::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SpotCamStoreMedia::host() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.host)
  return _internal_host();
}
inline void SpotCamStoreMedia::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamStoreMedia.host)
}
inline std::string* SpotCamStoreMedia::mutable_host() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamStoreMedia.host)
  return _internal_mutable_host();
}
inline const std::string& SpotCamStoreMedia::_internal_host() const {
  return host_.Get();
}
inline void SpotCamStoreMedia::_internal_set_host(const std::string& value) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SpotCamStoreMedia::set_host(std::string&& value) {
  
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.SpotCamStoreMedia.host)
}
inline void SpotCamStoreMedia::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.SpotCamStoreMedia.host)
}
inline void SpotCamStoreMedia::set_host(const char* value,
    size_t size) {
  
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.SpotCamStoreMedia.host)
}
inline std::string* SpotCamStoreMedia::_internal_mutable_host() {
  
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SpotCamStoreMedia::release_host() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamStoreMedia.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpotCamStoreMedia::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.host)
}

// .bosdyn.api.spot_cam.Camera camera = 3;
inline bool SpotCamStoreMedia::_internal_has_camera() const {
  return this != internal_default_instance() && camera_ != nullptr;
}
inline bool SpotCamStoreMedia::has_camera() const {
  return _internal_has_camera();
}
inline const ::bosdyn::api::spot_cam::Camera& SpotCamStoreMedia::_internal_camera() const {
  const ::bosdyn::api::spot_cam::Camera* p = camera_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot_cam::Camera*>(
      &::bosdyn::api::spot_cam::_Camera_default_instance_);
}
inline const ::bosdyn::api::spot_cam::Camera& SpotCamStoreMedia::camera() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.camera)
  return _internal_camera();
}
inline void SpotCamStoreMedia::unsafe_arena_set_allocated_camera(
    ::bosdyn::api::spot_cam::Camera* camera) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_);
  }
  camera_ = camera;
  if (camera) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.camera)
}
inline ::bosdyn::api::spot_cam::Camera* SpotCamStoreMedia::release_camera() {
  
  ::bosdyn::api::spot_cam::Camera* temp = camera_;
  camera_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot_cam::Camera* SpotCamStoreMedia::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamStoreMedia.camera)
  
  ::bosdyn::api::spot_cam::Camera* temp = camera_;
  camera_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot_cam::Camera* SpotCamStoreMedia::_internal_mutable_camera() {
  
  if (camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot_cam::Camera>(GetArena());
    camera_ = p;
  }
  return camera_;
}
inline ::bosdyn::api::spot_cam::Camera* SpotCamStoreMedia::mutable_camera() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamStoreMedia.camera)
  return _internal_mutable_camera();
}
inline void SpotCamStoreMedia::set_allocated_camera(::bosdyn::api::spot_cam::Camera* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_);
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera)->GetArena();
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    
  } else {
    
  }
  camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.camera)
}

// .bosdyn.api.spot_cam.Logpoint.RecordType type = 4;
inline void SpotCamStoreMedia::clear_type() {
  type_ = 0;
}
inline ::bosdyn::api::spot_cam::Logpoint_RecordType SpotCamStoreMedia::_internal_type() const {
  return static_cast< ::bosdyn::api::spot_cam::Logpoint_RecordType >(type_);
}
inline ::bosdyn::api::spot_cam::Logpoint_RecordType SpotCamStoreMedia::type() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.type)
  return _internal_type();
}
inline void SpotCamStoreMedia::_internal_set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value) {
  
  type_ = value;
}
inline void SpotCamStoreMedia::set_type(::bosdyn::api::spot_cam::Logpoint_RecordType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamStoreMedia.type)
}

// string tag = 5;
inline void SpotCamStoreMedia::clear_tag() {
  tag_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SpotCamStoreMedia::tag() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SpotCamStoreMedia.tag)
  return _internal_tag();
}
inline void SpotCamStoreMedia::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.SpotCamStoreMedia.tag)
}
inline std::string* SpotCamStoreMedia::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SpotCamStoreMedia.tag)
  return _internal_mutable_tag();
}
inline const std::string& SpotCamStoreMedia::_internal_tag() const {
  return tag_.Get();
}
inline void SpotCamStoreMedia::_internal_set_tag(const std::string& value) {
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SpotCamStoreMedia::set_tag(std::string&& value) {
  
  tag_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.mission.SpotCamStoreMedia.tag)
}
inline void SpotCamStoreMedia::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.mission.SpotCamStoreMedia.tag)
}
inline void SpotCamStoreMedia::set_tag(const char* value,
    size_t size) {
  
  tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.mission.SpotCamStoreMedia.tag)
}
inline std::string* SpotCamStoreMedia::_internal_mutable_tag() {
  
  return tag_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SpotCamStoreMedia::release_tag() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.SpotCamStoreMedia.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SpotCamStoreMedia::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.SpotCamStoreMedia.tag)
}

// -------------------------------------------------------------------

// DefineBlackboard

// repeated .bosdyn.api.mission.KeyValue blackboard_variables = 1;
inline int DefineBlackboard::_internal_blackboard_variables_size() const {
  return blackboard_variables_.size();
}
inline int DefineBlackboard::blackboard_variables_size() const {
  return _internal_blackboard_variables_size();
}
inline ::bosdyn::api::mission::KeyValue* DefineBlackboard::mutable_blackboard_variables(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return blackboard_variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
DefineBlackboard::mutable_blackboard_variables() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return &blackboard_variables_;
}
inline const ::bosdyn::api::mission::KeyValue& DefineBlackboard::_internal_blackboard_variables(int index) const {
  return blackboard_variables_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& DefineBlackboard::blackboard_variables(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return _internal_blackboard_variables(index);
}
inline ::bosdyn::api::mission::KeyValue* DefineBlackboard::_internal_add_blackboard_variables() {
  return blackboard_variables_.Add();
}
inline ::bosdyn::api::mission::KeyValue* DefineBlackboard::add_blackboard_variables() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return _internal_add_blackboard_variables();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
DefineBlackboard::blackboard_variables() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.DefineBlackboard.blackboard_variables)
  return blackboard_variables_;
}

// .bosdyn.api.mission.Node child = 2;
inline bool DefineBlackboard::_internal_has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline bool DefineBlackboard::has_child() const {
  return _internal_has_child();
}
inline void DefineBlackboard::clear_child() {
  if (GetArena() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::bosdyn::api::mission::Node& DefineBlackboard::_internal_child() const {
  const ::bosdyn::api::mission::Node* p = child_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::mission::Node*>(
      &::bosdyn::api::mission::_Node_default_instance_);
}
inline const ::bosdyn::api::mission::Node& DefineBlackboard::child() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.DefineBlackboard.child)
  return _internal_child();
}
inline void DefineBlackboard::unsafe_arena_set_allocated_child(
    ::bosdyn::api::mission::Node* child) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(child_);
  }
  child_ = child;
  if (child) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.mission.DefineBlackboard.child)
}
inline ::bosdyn::api::mission::Node* DefineBlackboard::release_child() {
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::mission::Node* DefineBlackboard::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:bosdyn.api.mission.DefineBlackboard.child)
  
  ::bosdyn::api::mission::Node* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::bosdyn::api::mission::Node* DefineBlackboard::_internal_mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::mission::Node>(GetArena());
    child_ = p;
  }
  return child_;
}
inline ::bosdyn::api::mission::Node* DefineBlackboard::mutable_child() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.DefineBlackboard.child)
  return _internal_mutable_child();
}
inline void DefineBlackboard::set_allocated_child(::bosdyn::api::mission::Node* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.mission.DefineBlackboard.child)
}

// -------------------------------------------------------------------

// SetBlackboard

// repeated .bosdyn.api.mission.KeyValue blackboard_variables = 1;
inline int SetBlackboard::_internal_blackboard_variables_size() const {
  return blackboard_variables_.size();
}
inline int SetBlackboard::blackboard_variables_size() const {
  return _internal_blackboard_variables_size();
}
inline ::bosdyn::api::mission::KeyValue* SetBlackboard::mutable_blackboard_variables(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return blackboard_variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >*
SetBlackboard::mutable_blackboard_variables() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return &blackboard_variables_;
}
inline const ::bosdyn::api::mission::KeyValue& SetBlackboard::_internal_blackboard_variables(int index) const {
  return blackboard_variables_.Get(index);
}
inline const ::bosdyn::api::mission::KeyValue& SetBlackboard::blackboard_variables(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return _internal_blackboard_variables(index);
}
inline ::bosdyn::api::mission::KeyValue* SetBlackboard::_internal_add_blackboard_variables() {
  return blackboard_variables_.Add();
}
inline ::bosdyn::api::mission::KeyValue* SetBlackboard::add_blackboard_variables() {
  // @@protoc_insertion_point(field_add:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return _internal_add_blackboard_variables();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::mission::KeyValue >&
SetBlackboard::blackboard_variables() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.mission.SetBlackboard.blackboard_variables)
  return blackboard_variables_;
}

// -------------------------------------------------------------------

// ConstantResult

// .bosdyn.api.mission.Result result = 1;
inline void ConstantResult::clear_result() {
  result_ = 0;
}
inline ::bosdyn::api::mission::Result ConstantResult::_internal_result() const {
  return static_cast< ::bosdyn::api::mission::Result >(result_);
}
inline ::bosdyn::api::mission::Result ConstantResult::result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.mission.ConstantResult.result)
  return _internal_result();
}
inline void ConstantResult::_internal_set_result(::bosdyn::api::mission::Result value) {
  
  result_ = value;
}
inline void ConstantResult::set_result(::bosdyn::api::mission::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.mission.ConstantResult.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mission
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::mission::Condition_Compare> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::mission::Condition_Compare>() {
  return ::bosdyn::api::mission::Condition_Compare_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fmission_2fnodes_2eproto
