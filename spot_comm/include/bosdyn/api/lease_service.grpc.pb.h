// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bosdyn/api/lease_service.proto
// Original file comments:
// Copyright (c) 2020 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).
//
#ifndef GRPC_bosdyn_2fapi_2flease_5fservice_2eproto__INCLUDED
#define GRPC_bosdyn_2fapi_2flease_5fservice_2eproto__INCLUDED

#include "bosdyn/api/lease_service.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace bosdyn {
namespace api {

// LeaseService provides Leases of shared resources to clients.
// An example of a shared resource is the set of leg motors on Spot, which
// has the resource name of "body".
// Clients can delegate out the Leases they receive from the LeaseService
// to additional clients or services by generating sub-leases.
// Leases obtained from the LeaseService may be revoked if the Lease holder
// does not check in frequently to the LeaseService, or if another client
// force-acquires a Lease.
class LeaseService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.LeaseService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Acquire a lease to a specific resource if the resource is available.
    virtual ::grpc::Status AcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::bosdyn::api::AcquireLeaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::AcquireLeaseResponse>> AsyncAcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::AcquireLeaseResponse>>(AsyncAcquireLeaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::AcquireLeaseResponse>> PrepareAsyncAcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::AcquireLeaseResponse>>(PrepareAsyncAcquireLeaseRaw(context, request, cq));
    }
    // Take a lease for a specific resource even if another client has a lease.
    virtual ::grpc::Status TakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::bosdyn::api::TakeLeaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::TakeLeaseResponse>> AsyncTakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::TakeLeaseResponse>>(AsyncTakeLeaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::TakeLeaseResponse>> PrepareAsyncTakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::TakeLeaseResponse>>(PrepareAsyncTakeLeaseRaw(context, request, cq));
    }
    // Return a lease to the LeaseService.
    virtual ::grpc::Status ReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::bosdyn::api::ReturnLeaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ReturnLeaseResponse>> AsyncReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ReturnLeaseResponse>>(AsyncReturnLeaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ReturnLeaseResponse>> PrepareAsyncReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ReturnLeaseResponse>>(PrepareAsyncReturnLeaseRaw(context, request, cq));
    }
    // List state of all leases managed by the LeaseService.
    virtual ::grpc::Status ListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::bosdyn::api::ListLeasesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ListLeasesResponse>> AsyncListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ListLeasesResponse>>(AsyncListLeasesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ListLeasesResponse>> PrepareAsyncListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ListLeasesResponse>>(PrepareAsyncListLeasesRaw(context, request, cq));
    }
    // Retain possession of a lease.
    virtual ::grpc::Status RetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::bosdyn::api::RetainLeaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RetainLeaseResponse>> AsyncRetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RetainLeaseResponse>>(AsyncRetainLeaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RetainLeaseResponse>> PrepareAsyncRetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RetainLeaseResponse>>(PrepareAsyncRetainLeaseRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Acquire a lease to a specific resource if the resource is available.
      virtual void AcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest* request, ::bosdyn::api::AcquireLeaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AcquireLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::AcquireLeaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest* request, ::bosdyn::api::AcquireLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest* request, ::bosdyn::api::AcquireLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AcquireLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::AcquireLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AcquireLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::AcquireLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Take a lease for a specific resource even if another client has a lease.
      virtual void TakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest* request, ::bosdyn::api::TakeLeaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TakeLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::TakeLeaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest* request, ::bosdyn::api::TakeLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest* request, ::bosdyn::api::TakeLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TakeLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::TakeLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TakeLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::TakeLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Return a lease to the LeaseService.
      virtual void ReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest* request, ::bosdyn::api::ReturnLeaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReturnLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ReturnLeaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest* request, ::bosdyn::api::ReturnLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest* request, ::bosdyn::api::ReturnLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReturnLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ReturnLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReturnLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ReturnLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List state of all leases managed by the LeaseService.
      virtual void ListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest* request, ::bosdyn::api::ListLeasesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListLeases(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ListLeasesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest* request, ::bosdyn::api::ListLeasesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest* request, ::bosdyn::api::ListLeasesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListLeases(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ListLeasesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListLeases(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ListLeasesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Retain possession of a lease.
      virtual void RetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest* request, ::bosdyn::api::RetainLeaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RetainLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RetainLeaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest* request, ::bosdyn::api::RetainLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest* request, ::bosdyn::api::RetainLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RetainLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RetainLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RetainLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RetainLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::AcquireLeaseResponse>* AsyncAcquireLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::AcquireLeaseResponse>* PrepareAsyncAcquireLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::TakeLeaseResponse>* AsyncTakeLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::TakeLeaseResponse>* PrepareAsyncTakeLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ReturnLeaseResponse>* AsyncReturnLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ReturnLeaseResponse>* PrepareAsyncReturnLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ListLeasesResponse>* AsyncListLeasesRaw(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::ListLeasesResponse>* PrepareAsyncListLeasesRaw(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RetainLeaseResponse>* AsyncRetainLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RetainLeaseResponse>* PrepareAsyncRetainLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status AcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::bosdyn::api::AcquireLeaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::AcquireLeaseResponse>> AsyncAcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::AcquireLeaseResponse>>(AsyncAcquireLeaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::AcquireLeaseResponse>> PrepareAsyncAcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::AcquireLeaseResponse>>(PrepareAsyncAcquireLeaseRaw(context, request, cq));
    }
    ::grpc::Status TakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::bosdyn::api::TakeLeaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::TakeLeaseResponse>> AsyncTakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::TakeLeaseResponse>>(AsyncTakeLeaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::TakeLeaseResponse>> PrepareAsyncTakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::TakeLeaseResponse>>(PrepareAsyncTakeLeaseRaw(context, request, cq));
    }
    ::grpc::Status ReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::bosdyn::api::ReturnLeaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ReturnLeaseResponse>> AsyncReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ReturnLeaseResponse>>(AsyncReturnLeaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ReturnLeaseResponse>> PrepareAsyncReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ReturnLeaseResponse>>(PrepareAsyncReturnLeaseRaw(context, request, cq));
    }
    ::grpc::Status ListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::bosdyn::api::ListLeasesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ListLeasesResponse>> AsyncListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ListLeasesResponse>>(AsyncListLeasesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ListLeasesResponse>> PrepareAsyncListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ListLeasesResponse>>(PrepareAsyncListLeasesRaw(context, request, cq));
    }
    ::grpc::Status RetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::bosdyn::api::RetainLeaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RetainLeaseResponse>> AsyncRetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RetainLeaseResponse>>(AsyncRetainLeaseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RetainLeaseResponse>> PrepareAsyncRetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RetainLeaseResponse>>(PrepareAsyncRetainLeaseRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void AcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest* request, ::bosdyn::api::AcquireLeaseResponse* response, std::function<void(::grpc::Status)>) override;
      void AcquireLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::AcquireLeaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest* request, ::bosdyn::api::AcquireLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AcquireLease(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest* request, ::bosdyn::api::AcquireLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AcquireLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::AcquireLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AcquireLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::AcquireLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest* request, ::bosdyn::api::TakeLeaseResponse* response, std::function<void(::grpc::Status)>) override;
      void TakeLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::TakeLeaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest* request, ::bosdyn::api::TakeLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TakeLease(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest* request, ::bosdyn::api::TakeLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TakeLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::TakeLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TakeLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::TakeLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest* request, ::bosdyn::api::ReturnLeaseResponse* response, std::function<void(::grpc::Status)>) override;
      void ReturnLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ReturnLeaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest* request, ::bosdyn::api::ReturnLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReturnLease(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest* request, ::bosdyn::api::ReturnLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReturnLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ReturnLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReturnLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ReturnLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest* request, ::bosdyn::api::ListLeasesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListLeases(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ListLeasesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest* request, ::bosdyn::api::ListLeasesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListLeases(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest* request, ::bosdyn::api::ListLeasesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListLeases(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ListLeasesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListLeases(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::ListLeasesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest* request, ::bosdyn::api::RetainLeaseResponse* response, std::function<void(::grpc::Status)>) override;
      void RetainLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RetainLeaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest* request, ::bosdyn::api::RetainLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RetainLease(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest* request, ::bosdyn::api::RetainLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RetainLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RetainLeaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RetainLease(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RetainLeaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::AcquireLeaseResponse>* AsyncAcquireLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::AcquireLeaseResponse>* PrepareAsyncAcquireLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::AcquireLeaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::TakeLeaseResponse>* AsyncTakeLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::TakeLeaseResponse>* PrepareAsyncTakeLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::TakeLeaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ReturnLeaseResponse>* AsyncReturnLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ReturnLeaseResponse>* PrepareAsyncReturnLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::ReturnLeaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ListLeasesResponse>* AsyncListLeasesRaw(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::ListLeasesResponse>* PrepareAsyncListLeasesRaw(::grpc::ClientContext* context, const ::bosdyn::api::ListLeasesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RetainLeaseResponse>* AsyncRetainLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RetainLeaseResponse>* PrepareAsyncRetainLeaseRaw(::grpc::ClientContext* context, const ::bosdyn::api::RetainLeaseRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_AcquireLease_;
    const ::grpc::internal::RpcMethod rpcmethod_TakeLease_;
    const ::grpc::internal::RpcMethod rpcmethod_ReturnLease_;
    const ::grpc::internal::RpcMethod rpcmethod_ListLeases_;
    const ::grpc::internal::RpcMethod rpcmethod_RetainLease_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Acquire a lease to a specific resource if the resource is available.
    virtual ::grpc::Status AcquireLease(::grpc::ServerContext* context, const ::bosdyn::api::AcquireLeaseRequest* request, ::bosdyn::api::AcquireLeaseResponse* response);
    // Take a lease for a specific resource even if another client has a lease.
    virtual ::grpc::Status TakeLease(::grpc::ServerContext* context, const ::bosdyn::api::TakeLeaseRequest* request, ::bosdyn::api::TakeLeaseResponse* response);
    // Return a lease to the LeaseService.
    virtual ::grpc::Status ReturnLease(::grpc::ServerContext* context, const ::bosdyn::api::ReturnLeaseRequest* request, ::bosdyn::api::ReturnLeaseResponse* response);
    // List state of all leases managed by the LeaseService.
    virtual ::grpc::Status ListLeases(::grpc::ServerContext* context, const ::bosdyn::api::ListLeasesRequest* request, ::bosdyn::api::ListLeasesResponse* response);
    // Retain possession of a lease.
    virtual ::grpc::Status RetainLease(::grpc::ServerContext* context, const ::bosdyn::api::RetainLeaseRequest* request, ::bosdyn::api::RetainLeaseResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_AcquireLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AcquireLease() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_AcquireLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::AcquireLeaseRequest* /*request*/, ::bosdyn::api::AcquireLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAcquireLease(::grpc::ServerContext* context, ::bosdyn::api::AcquireLeaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::AcquireLeaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TakeLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TakeLease() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_TakeLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TakeLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::TakeLeaseRequest* /*request*/, ::bosdyn::api::TakeLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTakeLease(::grpc::ServerContext* context, ::bosdyn::api::TakeLeaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::TakeLeaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReturnLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReturnLease() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ReturnLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ReturnLeaseRequest* /*request*/, ::bosdyn::api::ReturnLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReturnLease(::grpc::ServerContext* context, ::bosdyn::api::ReturnLeaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::ReturnLeaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLeases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListLeases() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ListLeases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeases(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ListLeasesRequest* /*request*/, ::bosdyn::api::ListLeasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLeases(::grpc::ServerContext* context, ::bosdyn::api::ListLeasesRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::ListLeasesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RetainLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RetainLease() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_RetainLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetainLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RetainLeaseRequest* /*request*/, ::bosdyn::api::RetainLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRetainLease(::grpc::ServerContext* context, ::bosdyn::api::RetainLeaseRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::RetainLeaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_AcquireLease<WithAsyncMethod_TakeLease<WithAsyncMethod_ReturnLease<WithAsyncMethod_ListLeases<WithAsyncMethod_RetainLease<Service > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AcquireLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AcquireLease() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::AcquireLeaseRequest, ::bosdyn::api::AcquireLeaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::AcquireLeaseRequest* request, ::bosdyn::api::AcquireLeaseResponse* response) { return this->AcquireLease(context, request, response); }));}
    void SetMessageAllocatorFor_AcquireLease(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::AcquireLeaseRequest, ::bosdyn::api::AcquireLeaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::AcquireLeaseRequest, ::bosdyn::api::AcquireLeaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AcquireLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::AcquireLeaseRequest* /*request*/, ::bosdyn::api::AcquireLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AcquireLease(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::AcquireLeaseRequest* /*request*/, ::bosdyn::api::AcquireLeaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AcquireLease(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::AcquireLeaseRequest* /*request*/, ::bosdyn::api::AcquireLeaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TakeLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TakeLease() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::TakeLeaseRequest, ::bosdyn::api::TakeLeaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::TakeLeaseRequest* request, ::bosdyn::api::TakeLeaseResponse* response) { return this->TakeLease(context, request, response); }));}
    void SetMessageAllocatorFor_TakeLease(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::TakeLeaseRequest, ::bosdyn::api::TakeLeaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::TakeLeaseRequest, ::bosdyn::api::TakeLeaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TakeLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TakeLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::TakeLeaseRequest* /*request*/, ::bosdyn::api::TakeLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TakeLease(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::TakeLeaseRequest* /*request*/, ::bosdyn::api::TakeLeaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TakeLease(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::TakeLeaseRequest* /*request*/, ::bosdyn::api::TakeLeaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReturnLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReturnLease() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::ReturnLeaseRequest, ::bosdyn::api::ReturnLeaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::ReturnLeaseRequest* request, ::bosdyn::api::ReturnLeaseResponse* response) { return this->ReturnLease(context, request, response); }));}
    void SetMessageAllocatorFor_ReturnLease(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::ReturnLeaseRequest, ::bosdyn::api::ReturnLeaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::ReturnLeaseRequest, ::bosdyn::api::ReturnLeaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReturnLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ReturnLeaseRequest* /*request*/, ::bosdyn::api::ReturnLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReturnLease(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::ReturnLeaseRequest* /*request*/, ::bosdyn::api::ReturnLeaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReturnLease(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::ReturnLeaseRequest* /*request*/, ::bosdyn::api::ReturnLeaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListLeases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListLeases() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::ListLeasesRequest, ::bosdyn::api::ListLeasesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::ListLeasesRequest* request, ::bosdyn::api::ListLeasesResponse* response) { return this->ListLeases(context, request, response); }));}
    void SetMessageAllocatorFor_ListLeases(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::ListLeasesRequest, ::bosdyn::api::ListLeasesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::ListLeasesRequest, ::bosdyn::api::ListLeasesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListLeases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeases(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ListLeasesRequest* /*request*/, ::bosdyn::api::ListLeasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListLeases(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::ListLeasesRequest* /*request*/, ::bosdyn::api::ListLeasesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListLeases(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::ListLeasesRequest* /*request*/, ::bosdyn::api::ListLeasesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RetainLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RetainLease() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RetainLeaseRequest, ::bosdyn::api::RetainLeaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::RetainLeaseRequest* request, ::bosdyn::api::RetainLeaseResponse* response) { return this->RetainLease(context, request, response); }));}
    void SetMessageAllocatorFor_RetainLease(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::RetainLeaseRequest, ::bosdyn::api::RetainLeaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RetainLeaseRequest, ::bosdyn::api::RetainLeaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RetainLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetainLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RetainLeaseRequest* /*request*/, ::bosdyn::api::RetainLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RetainLease(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::RetainLeaseRequest* /*request*/, ::bosdyn::api::RetainLeaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RetainLease(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::RetainLeaseRequest* /*request*/, ::bosdyn::api::RetainLeaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_AcquireLease<ExperimentalWithCallbackMethod_TakeLease<ExperimentalWithCallbackMethod_ReturnLease<ExperimentalWithCallbackMethod_ListLeases<ExperimentalWithCallbackMethod_RetainLease<Service > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_AcquireLease<ExperimentalWithCallbackMethod_TakeLease<ExperimentalWithCallbackMethod_ReturnLease<ExperimentalWithCallbackMethod_ListLeases<ExperimentalWithCallbackMethod_RetainLease<Service > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_AcquireLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AcquireLease() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_AcquireLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::AcquireLeaseRequest* /*request*/, ::bosdyn::api::AcquireLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TakeLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TakeLease() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_TakeLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TakeLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::TakeLeaseRequest* /*request*/, ::bosdyn::api::TakeLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReturnLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReturnLease() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ReturnLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ReturnLeaseRequest* /*request*/, ::bosdyn::api::ReturnLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLeases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListLeases() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ListLeases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeases(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ListLeasesRequest* /*request*/, ::bosdyn::api::ListLeasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RetainLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RetainLease() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_RetainLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetainLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RetainLeaseRequest* /*request*/, ::bosdyn::api::RetainLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_AcquireLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AcquireLease() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_AcquireLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::AcquireLeaseRequest* /*request*/, ::bosdyn::api::AcquireLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAcquireLease(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TakeLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TakeLease() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_TakeLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TakeLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::TakeLeaseRequest* /*request*/, ::bosdyn::api::TakeLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTakeLease(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReturnLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReturnLease() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ReturnLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ReturnLeaseRequest* /*request*/, ::bosdyn::api::ReturnLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReturnLease(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListLeases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListLeases() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ListLeases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeases(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ListLeasesRequest* /*request*/, ::bosdyn::api::ListLeasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLeases(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RetainLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RetainLease() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_RetainLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetainLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RetainLeaseRequest* /*request*/, ::bosdyn::api::RetainLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRetainLease(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AcquireLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AcquireLease() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AcquireLease(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AcquireLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::AcquireLeaseRequest* /*request*/, ::bosdyn::api::AcquireLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AcquireLease(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AcquireLease(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TakeLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TakeLease() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TakeLease(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TakeLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TakeLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::TakeLeaseRequest* /*request*/, ::bosdyn::api::TakeLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TakeLease(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TakeLease(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReturnLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReturnLease() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReturnLease(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReturnLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReturnLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ReturnLeaseRequest* /*request*/, ::bosdyn::api::ReturnLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReturnLease(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReturnLease(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListLeases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListLeases() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListLeases(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListLeases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeases(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ListLeasesRequest* /*request*/, ::bosdyn::api::ListLeasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListLeases(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListLeases(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RetainLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RetainLease() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RetainLease(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RetainLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RetainLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RetainLeaseRequest* /*request*/, ::bosdyn::api::RetainLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RetainLease(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RetainLease(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AcquireLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AcquireLease() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::AcquireLeaseRequest, ::bosdyn::api::AcquireLeaseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::AcquireLeaseRequest, ::bosdyn::api::AcquireLeaseResponse>* streamer) {
                       return this->StreamedAcquireLease(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AcquireLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AcquireLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::AcquireLeaseRequest* /*request*/, ::bosdyn::api::AcquireLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAcquireLease(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::AcquireLeaseRequest,::bosdyn::api::AcquireLeaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TakeLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TakeLease() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::TakeLeaseRequest, ::bosdyn::api::TakeLeaseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::TakeLeaseRequest, ::bosdyn::api::TakeLeaseResponse>* streamer) {
                       return this->StreamedTakeLease(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TakeLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TakeLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::TakeLeaseRequest* /*request*/, ::bosdyn::api::TakeLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTakeLease(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::TakeLeaseRequest,::bosdyn::api::TakeLeaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReturnLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReturnLease() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::ReturnLeaseRequest, ::bosdyn::api::ReturnLeaseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::ReturnLeaseRequest, ::bosdyn::api::ReturnLeaseResponse>* streamer) {
                       return this->StreamedReturnLease(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReturnLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReturnLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ReturnLeaseRequest* /*request*/, ::bosdyn::api::ReturnLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReturnLease(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::ReturnLeaseRequest,::bosdyn::api::ReturnLeaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListLeases : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListLeases() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::ListLeasesRequest, ::bosdyn::api::ListLeasesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::ListLeasesRequest, ::bosdyn::api::ListLeasesResponse>* streamer) {
                       return this->StreamedListLeases(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListLeases() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListLeases(::grpc::ServerContext* /*context*/, const ::bosdyn::api::ListLeasesRequest* /*request*/, ::bosdyn::api::ListLeasesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListLeases(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::ListLeasesRequest,::bosdyn::api::ListLeasesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RetainLease : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RetainLease() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::RetainLeaseRequest, ::bosdyn::api::RetainLeaseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::RetainLeaseRequest, ::bosdyn::api::RetainLeaseResponse>* streamer) {
                       return this->StreamedRetainLease(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RetainLease() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RetainLease(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RetainLeaseRequest* /*request*/, ::bosdyn::api::RetainLeaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRetainLease(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::RetainLeaseRequest,::bosdyn::api::RetainLeaseResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AcquireLease<WithStreamedUnaryMethod_TakeLease<WithStreamedUnaryMethod_ReturnLease<WithStreamedUnaryMethod_ListLeases<WithStreamedUnaryMethod_RetainLease<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_AcquireLease<WithStreamedUnaryMethod_TakeLease<WithStreamedUnaryMethod_ReturnLease<WithStreamedUnaryMethod_ListLeases<WithStreamedUnaryMethod_RetainLease<Service > > > > > StreamedService;
};

}  // namespace api
}  // namespace bosdyn


#endif  // GRPC_bosdyn_2fapi_2flease_5fservice_2eproto__INCLUDED
