// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/spot/spot_check.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/lease.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
namespace bosdyn {
namespace api {
namespace spot {
class CameraCalibrationCommandRequest;
class CameraCalibrationCommandRequestDefaultTypeInternal;
extern CameraCalibrationCommandRequestDefaultTypeInternal _CameraCalibrationCommandRequest_default_instance_;
class CameraCalibrationCommandResponse;
class CameraCalibrationCommandResponseDefaultTypeInternal;
extern CameraCalibrationCommandResponseDefaultTypeInternal _CameraCalibrationCommandResponse_default_instance_;
class CameraCalibrationFeedbackRequest;
class CameraCalibrationFeedbackRequestDefaultTypeInternal;
extern CameraCalibrationFeedbackRequestDefaultTypeInternal _CameraCalibrationFeedbackRequest_default_instance_;
class CameraCalibrationFeedbackResponse;
class CameraCalibrationFeedbackResponseDefaultTypeInternal;
extern CameraCalibrationFeedbackResponseDefaultTypeInternal _CameraCalibrationFeedbackResponse_default_instance_;
class DepthPlaneSpotCheckResult;
class DepthPlaneSpotCheckResultDefaultTypeInternal;
extern DepthPlaneSpotCheckResultDefaultTypeInternal _DepthPlaneSpotCheckResult_default_instance_;
class FootHeightCheckResult;
class FootHeightCheckResultDefaultTypeInternal;
extern FootHeightCheckResultDefaultTypeInternal _FootHeightCheckResult_default_instance_;
class JointKinematicCheckResult;
class JointKinematicCheckResultDefaultTypeInternal;
extern JointKinematicCheckResultDefaultTypeInternal _JointKinematicCheckResult_default_instance_;
class LegPairCheckResult;
class LegPairCheckResultDefaultTypeInternal;
extern LegPairCheckResultDefaultTypeInternal _LegPairCheckResult_default_instance_;
class LoadCellSpotCheckResult;
class LoadCellSpotCheckResultDefaultTypeInternal;
extern LoadCellSpotCheckResultDefaultTypeInternal _LoadCellSpotCheckResult_default_instance_;
class PayloadCheckResult;
class PayloadCheckResultDefaultTypeInternal;
extern PayloadCheckResultDefaultTypeInternal _PayloadCheckResult_default_instance_;
class SpotCheckCommandRequest;
class SpotCheckCommandRequestDefaultTypeInternal;
extern SpotCheckCommandRequestDefaultTypeInternal _SpotCheckCommandRequest_default_instance_;
class SpotCheckCommandResponse;
class SpotCheckCommandResponseDefaultTypeInternal;
extern SpotCheckCommandResponseDefaultTypeInternal _SpotCheckCommandResponse_default_instance_;
class SpotCheckFeedbackRequest;
class SpotCheckFeedbackRequestDefaultTypeInternal;
extern SpotCheckFeedbackRequestDefaultTypeInternal _SpotCheckFeedbackRequest_default_instance_;
class SpotCheckFeedbackResponse;
class SpotCheckFeedbackResponseDefaultTypeInternal;
extern SpotCheckFeedbackResponseDefaultTypeInternal _SpotCheckFeedbackResponse_default_instance_;
class SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse;
class SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse;
class SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse;
class SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse;
class SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse_default_instance_;
class SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse;
class SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUseDefaultTypeInternal;
extern SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUseDefaultTypeInternal _SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse_default_instance_;
}  // namespace spot
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::spot::CameraCalibrationCommandRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::CameraCalibrationCommandRequest>(Arena*);
template<> ::bosdyn::api::spot::CameraCalibrationCommandResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::CameraCalibrationCommandResponse>(Arena*);
template<> ::bosdyn::api::spot::CameraCalibrationFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::CameraCalibrationFeedbackRequest>(Arena*);
template<> ::bosdyn::api::spot::CameraCalibrationFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::CameraCalibrationFeedbackResponse>(Arena*);
template<> ::bosdyn::api::spot::DepthPlaneSpotCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::DepthPlaneSpotCheckResult>(Arena*);
template<> ::bosdyn::api::spot::FootHeightCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::FootHeightCheckResult>(Arena*);
template<> ::bosdyn::api::spot::JointKinematicCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::JointKinematicCheckResult>(Arena*);
template<> ::bosdyn::api::spot::LegPairCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::LegPairCheckResult>(Arena*);
template<> ::bosdyn::api::spot::LoadCellSpotCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::LoadCellSpotCheckResult>(Arena*);
template<> ::bosdyn::api::spot::PayloadCheckResult* Arena::CreateMaybeMessage<::bosdyn::api::spot::PayloadCheckResult>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckCommandRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckCommandRequest>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckCommandResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckCommandResponse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackRequest* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackRequest>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse>(Arena*);
template<> ::bosdyn::api::spot::SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse* Arena::CreateMaybeMessage<::bosdyn::api::spot::SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {
namespace spot {

enum SpotCheckCommandRequest_Command : int {
  SpotCheckCommandRequest_Command_COMMAND_UNKNOWN = 0,
  SpotCheckCommandRequest_Command_COMMAND_START = 1,
  SpotCheckCommandRequest_Command_COMMAND_ABORT = 2,
  SpotCheckCommandRequest_Command_COMMAND_REVERT_CAL = 3,
  SpotCheckCommandRequest_Command_SpotCheckCommandRequest_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpotCheckCommandRequest_Command_SpotCheckCommandRequest_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpotCheckCommandRequest_Command_IsValid(int value);
constexpr SpotCheckCommandRequest_Command SpotCheckCommandRequest_Command_Command_MIN = SpotCheckCommandRequest_Command_COMMAND_UNKNOWN;
constexpr SpotCheckCommandRequest_Command SpotCheckCommandRequest_Command_Command_MAX = SpotCheckCommandRequest_Command_COMMAND_REVERT_CAL;
constexpr int SpotCheckCommandRequest_Command_Command_ARRAYSIZE = SpotCheckCommandRequest_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpotCheckCommandRequest_Command_descriptor();
template<typename T>
inline const std::string& SpotCheckCommandRequest_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpotCheckCommandRequest_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpotCheckCommandRequest_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpotCheckCommandRequest_Command_descriptor(), enum_t_value);
}
inline bool SpotCheckCommandRequest_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpotCheckCommandRequest_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpotCheckCommandRequest_Command>(
    SpotCheckCommandRequest_Command_descriptor(), name, value);
}
enum SpotCheckFeedbackResponse_State : int {
  SpotCheckFeedbackResponse_State_STATE_UNKNOWN = 0,
  SpotCheckFeedbackResponse_State_STATE_USER_ABORTED = 1,
  SpotCheckFeedbackResponse_State_STATE_STARTING = 2,
  SpotCheckFeedbackResponse_State_STATE_LOADCELL_CAL = 3,
  SpotCheckFeedbackResponse_State_STATE_ENDSTOP_CAL = 4,
  SpotCheckFeedbackResponse_State_STATE_CAMERA_CHECK = 5,
  SpotCheckFeedbackResponse_State_STATE_BODY_POSING = 6,
  SpotCheckFeedbackResponse_State_STATE_FINISHED = 7,
  SpotCheckFeedbackResponse_State_STATE_REVERTING_CAL = 8,
  SpotCheckFeedbackResponse_State_STATE_ERROR = 9,
  SpotCheckFeedbackResponse_State_STATE_WAITING_FOR_COMMAND = 10,
  SpotCheckFeedbackResponse_State_SpotCheckFeedbackResponse_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpotCheckFeedbackResponse_State_SpotCheckFeedbackResponse_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpotCheckFeedbackResponse_State_IsValid(int value);
constexpr SpotCheckFeedbackResponse_State SpotCheckFeedbackResponse_State_State_MIN = SpotCheckFeedbackResponse_State_STATE_UNKNOWN;
constexpr SpotCheckFeedbackResponse_State SpotCheckFeedbackResponse_State_State_MAX = SpotCheckFeedbackResponse_State_STATE_WAITING_FOR_COMMAND;
constexpr int SpotCheckFeedbackResponse_State_State_ARRAYSIZE = SpotCheckFeedbackResponse_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpotCheckFeedbackResponse_State_descriptor();
template<typename T>
inline const std::string& SpotCheckFeedbackResponse_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpotCheckFeedbackResponse_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpotCheckFeedbackResponse_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpotCheckFeedbackResponse_State_descriptor(), enum_t_value);
}
inline bool SpotCheckFeedbackResponse_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpotCheckFeedbackResponse_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpotCheckFeedbackResponse_State>(
    SpotCheckFeedbackResponse_State_descriptor(), name, value);
}
enum SpotCheckFeedbackResponse_Error : int {
  SpotCheckFeedbackResponse_Error_ERROR_UNKNOWN = 0,
  SpotCheckFeedbackResponse_Error_ERROR_NONE = 1,
  SpotCheckFeedbackResponse_Error_ERROR_UNEXPECTED_POWER_CHANGE = 2,
  SpotCheckFeedbackResponse_Error_ERROR_INIT_IMU_CHECK = 3,
  SpotCheckFeedbackResponse_Error_ERROR_INIT_NOT_SITTING = 4,
  SpotCheckFeedbackResponse_Error_ERROR_LOADCELL_TIMEOUT = 5,
  SpotCheckFeedbackResponse_Error_ERROR_POWER_ON_FAILURE = 6,
  SpotCheckFeedbackResponse_Error_ERROR_ENDSTOP_TIMEOUT = 7,
  SpotCheckFeedbackResponse_Error_ERROR_FAILED_STAND = 8,
  SpotCheckFeedbackResponse_Error_ERROR_CAMERA_TIMEOUT = 9,
  SpotCheckFeedbackResponse_Error_ERROR_GROUND_CHECK = 10,
  SpotCheckFeedbackResponse_Error_ERROR_POWER_OFF_FAILURE = 11,
  SpotCheckFeedbackResponse_Error_SpotCheckFeedbackResponse_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpotCheckFeedbackResponse_Error_SpotCheckFeedbackResponse_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpotCheckFeedbackResponse_Error_IsValid(int value);
constexpr SpotCheckFeedbackResponse_Error SpotCheckFeedbackResponse_Error_Error_MIN = SpotCheckFeedbackResponse_Error_ERROR_UNKNOWN;
constexpr SpotCheckFeedbackResponse_Error SpotCheckFeedbackResponse_Error_Error_MAX = SpotCheckFeedbackResponse_Error_ERROR_POWER_OFF_FAILURE;
constexpr int SpotCheckFeedbackResponse_Error_Error_ARRAYSIZE = SpotCheckFeedbackResponse_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpotCheckFeedbackResponse_Error_descriptor();
template<typename T>
inline const std::string& SpotCheckFeedbackResponse_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpotCheckFeedbackResponse_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpotCheckFeedbackResponse_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpotCheckFeedbackResponse_Error_descriptor(), enum_t_value);
}
inline bool SpotCheckFeedbackResponse_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpotCheckFeedbackResponse_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpotCheckFeedbackResponse_Error>(
    SpotCheckFeedbackResponse_Error_descriptor(), name, value);
}
enum DepthPlaneSpotCheckResult_Status : int {
  DepthPlaneSpotCheckResult_Status_STATUS_UNKNOWN = 0,
  DepthPlaneSpotCheckResult_Status_STATUS_OK = 1,
  DepthPlaneSpotCheckResult_Status_STATUS_WARNING = 2,
  DepthPlaneSpotCheckResult_Status_STATUS_ERROR = 3,
  DepthPlaneSpotCheckResult_Status_DepthPlaneSpotCheckResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DepthPlaneSpotCheckResult_Status_DepthPlaneSpotCheckResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DepthPlaneSpotCheckResult_Status_IsValid(int value);
constexpr DepthPlaneSpotCheckResult_Status DepthPlaneSpotCheckResult_Status_Status_MIN = DepthPlaneSpotCheckResult_Status_STATUS_UNKNOWN;
constexpr DepthPlaneSpotCheckResult_Status DepthPlaneSpotCheckResult_Status_Status_MAX = DepthPlaneSpotCheckResult_Status_STATUS_ERROR;
constexpr int DepthPlaneSpotCheckResult_Status_Status_ARRAYSIZE = DepthPlaneSpotCheckResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DepthPlaneSpotCheckResult_Status_descriptor();
template<typename T>
inline const std::string& DepthPlaneSpotCheckResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DepthPlaneSpotCheckResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DepthPlaneSpotCheckResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DepthPlaneSpotCheckResult_Status_descriptor(), enum_t_value);
}
inline bool DepthPlaneSpotCheckResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DepthPlaneSpotCheckResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DepthPlaneSpotCheckResult_Status>(
    DepthPlaneSpotCheckResult_Status_descriptor(), name, value);
}
enum PayloadCheckResult_Error : int {
  PayloadCheckResult_Error_ERROR_UNKNOWN = 0,
  PayloadCheckResult_Error_ERROR_NONE = 1,
  PayloadCheckResult_Error_ERROR_MASS_DISCREPANCY = 2,
  PayloadCheckResult_Error_PayloadCheckResult_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PayloadCheckResult_Error_PayloadCheckResult_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PayloadCheckResult_Error_IsValid(int value);
constexpr PayloadCheckResult_Error PayloadCheckResult_Error_Error_MIN = PayloadCheckResult_Error_ERROR_UNKNOWN;
constexpr PayloadCheckResult_Error PayloadCheckResult_Error_Error_MAX = PayloadCheckResult_Error_ERROR_MASS_DISCREPANCY;
constexpr int PayloadCheckResult_Error_Error_ARRAYSIZE = PayloadCheckResult_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PayloadCheckResult_Error_descriptor();
template<typename T>
inline const std::string& PayloadCheckResult_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayloadCheckResult_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayloadCheckResult_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PayloadCheckResult_Error_descriptor(), enum_t_value);
}
inline bool PayloadCheckResult_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayloadCheckResult_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PayloadCheckResult_Error>(
    PayloadCheckResult_Error_descriptor(), name, value);
}
enum LoadCellSpotCheckResult_Error : int {
  LoadCellSpotCheckResult_Error_ERROR_UNKNOWN = 0,
  LoadCellSpotCheckResult_Error_ERROR_NONE = 1,
  LoadCellSpotCheckResult_Error_ERROR_ZERO_OUT_OF_RANGE = 2,
  LoadCellSpotCheckResult_Error_LoadCellSpotCheckResult_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LoadCellSpotCheckResult_Error_LoadCellSpotCheckResult_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LoadCellSpotCheckResult_Error_IsValid(int value);
constexpr LoadCellSpotCheckResult_Error LoadCellSpotCheckResult_Error_Error_MIN = LoadCellSpotCheckResult_Error_ERROR_UNKNOWN;
constexpr LoadCellSpotCheckResult_Error LoadCellSpotCheckResult_Error_Error_MAX = LoadCellSpotCheckResult_Error_ERROR_ZERO_OUT_OF_RANGE;
constexpr int LoadCellSpotCheckResult_Error_Error_ARRAYSIZE = LoadCellSpotCheckResult_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoadCellSpotCheckResult_Error_descriptor();
template<typename T>
inline const std::string& LoadCellSpotCheckResult_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoadCellSpotCheckResult_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoadCellSpotCheckResult_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoadCellSpotCheckResult_Error_descriptor(), enum_t_value);
}
inline bool LoadCellSpotCheckResult_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoadCellSpotCheckResult_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoadCellSpotCheckResult_Error>(
    LoadCellSpotCheckResult_Error_descriptor(), name, value);
}
enum JointKinematicCheckResult_Error : int {
  JointKinematicCheckResult_Error_ERROR_UNKNOWN = 0,
  JointKinematicCheckResult_Error_ERROR_NONE = 1,
  JointKinematicCheckResult_Error_ERROR_CLUTCH_SLIP = 2,
  JointKinematicCheckResult_Error_JointKinematicCheckResult_Error_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JointKinematicCheckResult_Error_JointKinematicCheckResult_Error_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JointKinematicCheckResult_Error_IsValid(int value);
constexpr JointKinematicCheckResult_Error JointKinematicCheckResult_Error_Error_MIN = JointKinematicCheckResult_Error_ERROR_UNKNOWN;
constexpr JointKinematicCheckResult_Error JointKinematicCheckResult_Error_Error_MAX = JointKinematicCheckResult_Error_ERROR_CLUTCH_SLIP;
constexpr int JointKinematicCheckResult_Error_Error_ARRAYSIZE = JointKinematicCheckResult_Error_Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JointKinematicCheckResult_Error_descriptor();
template<typename T>
inline const std::string& JointKinematicCheckResult_Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JointKinematicCheckResult_Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JointKinematicCheckResult_Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JointKinematicCheckResult_Error_descriptor(), enum_t_value);
}
inline bool JointKinematicCheckResult_Error_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JointKinematicCheckResult_Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JointKinematicCheckResult_Error>(
    JointKinematicCheckResult_Error_descriptor(), name, value);
}
enum FootHeightCheckResult_Status : int {
  FootHeightCheckResult_Status_STATUS_UNKNOWN = 0,
  FootHeightCheckResult_Status_STATUS_OK = 1,
  FootHeightCheckResult_Status_STATUS_WARNING = 2,
  FootHeightCheckResult_Status_STATUS_ERROR = 3,
  FootHeightCheckResult_Status_FootHeightCheckResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FootHeightCheckResult_Status_FootHeightCheckResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FootHeightCheckResult_Status_IsValid(int value);
constexpr FootHeightCheckResult_Status FootHeightCheckResult_Status_Status_MIN = FootHeightCheckResult_Status_STATUS_UNKNOWN;
constexpr FootHeightCheckResult_Status FootHeightCheckResult_Status_Status_MAX = FootHeightCheckResult_Status_STATUS_ERROR;
constexpr int FootHeightCheckResult_Status_Status_ARRAYSIZE = FootHeightCheckResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FootHeightCheckResult_Status_descriptor();
template<typename T>
inline const std::string& FootHeightCheckResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FootHeightCheckResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FootHeightCheckResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FootHeightCheckResult_Status_descriptor(), enum_t_value);
}
inline bool FootHeightCheckResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FootHeightCheckResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FootHeightCheckResult_Status>(
    FootHeightCheckResult_Status_descriptor(), name, value);
}
enum LegPairCheckResult_Status : int {
  LegPairCheckResult_Status_STATUS_UNKNOWN = 0,
  LegPairCheckResult_Status_STATUS_OK = 1,
  LegPairCheckResult_Status_STATUS_WARNING = 2,
  LegPairCheckResult_Status_STATUS_ERROR = 3,
  LegPairCheckResult_Status_LegPairCheckResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LegPairCheckResult_Status_LegPairCheckResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LegPairCheckResult_Status_IsValid(int value);
constexpr LegPairCheckResult_Status LegPairCheckResult_Status_Status_MIN = LegPairCheckResult_Status_STATUS_UNKNOWN;
constexpr LegPairCheckResult_Status LegPairCheckResult_Status_Status_MAX = LegPairCheckResult_Status_STATUS_ERROR;
constexpr int LegPairCheckResult_Status_Status_ARRAYSIZE = LegPairCheckResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LegPairCheckResult_Status_descriptor();
template<typename T>
inline const std::string& LegPairCheckResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LegPairCheckResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LegPairCheckResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LegPairCheckResult_Status_descriptor(), enum_t_value);
}
inline bool LegPairCheckResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LegPairCheckResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LegPairCheckResult_Status>(
    LegPairCheckResult_Status_descriptor(), name, value);
}
enum CameraCalibrationCommandRequest_Command : int {
  CameraCalibrationCommandRequest_Command_COMMAND_UNKNOWN = 0,
  CameraCalibrationCommandRequest_Command_COMMAND_START = 1,
  CameraCalibrationCommandRequest_Command_COMMAND_CANCEL = 2,
  CameraCalibrationCommandRequest_Command_CameraCalibrationCommandRequest_Command_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CameraCalibrationCommandRequest_Command_CameraCalibrationCommandRequest_Command_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CameraCalibrationCommandRequest_Command_IsValid(int value);
constexpr CameraCalibrationCommandRequest_Command CameraCalibrationCommandRequest_Command_Command_MIN = CameraCalibrationCommandRequest_Command_COMMAND_UNKNOWN;
constexpr CameraCalibrationCommandRequest_Command CameraCalibrationCommandRequest_Command_Command_MAX = CameraCalibrationCommandRequest_Command_COMMAND_CANCEL;
constexpr int CameraCalibrationCommandRequest_Command_Command_ARRAYSIZE = CameraCalibrationCommandRequest_Command_Command_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraCalibrationCommandRequest_Command_descriptor();
template<typename T>
inline const std::string& CameraCalibrationCommandRequest_Command_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraCalibrationCommandRequest_Command>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraCalibrationCommandRequest_Command_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraCalibrationCommandRequest_Command_descriptor(), enum_t_value);
}
inline bool CameraCalibrationCommandRequest_Command_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraCalibrationCommandRequest_Command* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraCalibrationCommandRequest_Command>(
    CameraCalibrationCommandRequest_Command_descriptor(), name, value);
}
enum CameraCalibrationFeedbackResponse_Status : int {
  CameraCalibrationFeedbackResponse_Status_STATUS_UNKNOWN = 0,
  CameraCalibrationFeedbackResponse_Status_STATUS_PROCESSING = 1,
  CameraCalibrationFeedbackResponse_Status_STATUS_SUCCESS = 2,
  CameraCalibrationFeedbackResponse_Status_STATUS_USER_CANCELED = 3,
  CameraCalibrationFeedbackResponse_Status_STATUS_POWER_ERROR = 4,
  CameraCalibrationFeedbackResponse_Status_STATUS_LEASE_ERROR = 5,
  CameraCalibrationFeedbackResponse_Status_STATUS_ROBOT_COMMAND_ERROR = 7,
  CameraCalibrationFeedbackResponse_Status_STATUS_CALIBRATION_ERROR = 8,
  CameraCalibrationFeedbackResponse_Status_STATUS_INTERNAL_ERROR = 9,
  CameraCalibrationFeedbackResponse_Status_STATUS_CAMERA_FOCUS_ERROR = 14,
  CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_CENTERED = 6,
  CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_IN_VIEW = 11,
  CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_GRAVITY_ALIGNED = 12,
  CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_UPSIDE_DOWN = 13,
  CameraCalibrationFeedbackResponse_Status_STATUS_NEVER_RUN = 10,
  CameraCalibrationFeedbackResponse_Status_CameraCalibrationFeedbackResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CameraCalibrationFeedbackResponse_Status_CameraCalibrationFeedbackResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CameraCalibrationFeedbackResponse_Status_IsValid(int value);
constexpr CameraCalibrationFeedbackResponse_Status CameraCalibrationFeedbackResponse_Status_Status_MIN = CameraCalibrationFeedbackResponse_Status_STATUS_UNKNOWN;
constexpr CameraCalibrationFeedbackResponse_Status CameraCalibrationFeedbackResponse_Status_Status_MAX = CameraCalibrationFeedbackResponse_Status_STATUS_CAMERA_FOCUS_ERROR;
constexpr int CameraCalibrationFeedbackResponse_Status_Status_ARRAYSIZE = CameraCalibrationFeedbackResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraCalibrationFeedbackResponse_Status_descriptor();
template<typename T>
inline const std::string& CameraCalibrationFeedbackResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraCalibrationFeedbackResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraCalibrationFeedbackResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraCalibrationFeedbackResponse_Status_descriptor(), enum_t_value);
}
inline bool CameraCalibrationFeedbackResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraCalibrationFeedbackResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraCalibrationFeedbackResponse_Status>(
    CameraCalibrationFeedbackResponse_Status_descriptor(), name, value);
}
// ===================================================================

class SpotCheckCommandRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SpotCheckCommandRequest) */ {
 public:
  inline SpotCheckCommandRequest() : SpotCheckCommandRequest(nullptr) {}
  virtual ~SpotCheckCommandRequest();

  SpotCheckCommandRequest(const SpotCheckCommandRequest& from);
  SpotCheckCommandRequest(SpotCheckCommandRequest&& from) noexcept
    : SpotCheckCommandRequest() {
    *this = ::std::move(from);
  }

  inline SpotCheckCommandRequest& operator=(const SpotCheckCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCheckCommandRequest& operator=(SpotCheckCommandRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpotCheckCommandRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpotCheckCommandRequest* internal_default_instance() {
    return reinterpret_cast<const SpotCheckCommandRequest*>(
               &_SpotCheckCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SpotCheckCommandRequest& a, SpotCheckCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCheckCommandRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCheckCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpotCheckCommandRequest* New() const final {
    return CreateMaybeMessage<SpotCheckCommandRequest>(nullptr);
  }

  SpotCheckCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpotCheckCommandRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpotCheckCommandRequest& from);
  void MergeFrom(const SpotCheckCommandRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCheckCommandRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SpotCheckCommandRequest";
  }
  protected:
  explicit SpotCheckCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SpotCheckCommandRequest_Command Command;
  static constexpr Command COMMAND_UNKNOWN =
    SpotCheckCommandRequest_Command_COMMAND_UNKNOWN;
  static constexpr Command COMMAND_START =
    SpotCheckCommandRequest_Command_COMMAND_START;
  static constexpr Command COMMAND_ABORT =
    SpotCheckCommandRequest_Command_COMMAND_ABORT;
  static constexpr Command COMMAND_REVERT_CAL =
    SpotCheckCommandRequest_Command_COMMAND_REVERT_CAL;
  static inline bool Command_IsValid(int value) {
    return SpotCheckCommandRequest_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    SpotCheckCommandRequest_Command_Command_MIN;
  static constexpr Command Command_MAX =
    SpotCheckCommandRequest_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    SpotCheckCommandRequest_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return SpotCheckCommandRequest_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return SpotCheckCommandRequest_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return SpotCheckCommandRequest_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.spot.SpotCheckCommandRequest.Command command = 3;
  void clear_command();
  ::bosdyn::api::spot::SpotCheckCommandRequest_Command command() const;
  void set_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value);
  private:
  ::bosdyn::api::spot::SpotCheckCommandRequest_Command _internal_command() const;
  void _internal_set_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SpotCheckCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class SpotCheckCommandResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SpotCheckCommandResponse) */ {
 public:
  inline SpotCheckCommandResponse() : SpotCheckCommandResponse(nullptr) {}
  virtual ~SpotCheckCommandResponse();

  SpotCheckCommandResponse(const SpotCheckCommandResponse& from);
  SpotCheckCommandResponse(SpotCheckCommandResponse&& from) noexcept
    : SpotCheckCommandResponse() {
    *this = ::std::move(from);
  }

  inline SpotCheckCommandResponse& operator=(const SpotCheckCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCheckCommandResponse& operator=(SpotCheckCommandResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpotCheckCommandResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpotCheckCommandResponse* internal_default_instance() {
    return reinterpret_cast<const SpotCheckCommandResponse*>(
               &_SpotCheckCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SpotCheckCommandResponse& a, SpotCheckCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCheckCommandResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCheckCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpotCheckCommandResponse* New() const final {
    return CreateMaybeMessage<SpotCheckCommandResponse>(nullptr);
  }

  SpotCheckCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpotCheckCommandResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpotCheckCommandResponse& from);
  void MergeFrom(const SpotCheckCommandResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCheckCommandResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SpotCheckCommandResponse";
  }
  protected:
  explicit SpotCheckCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SpotCheckCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class SpotCheckFeedbackRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SpotCheckFeedbackRequest) */ {
 public:
  inline SpotCheckFeedbackRequest() : SpotCheckFeedbackRequest(nullptr) {}
  virtual ~SpotCheckFeedbackRequest();

  SpotCheckFeedbackRequest(const SpotCheckFeedbackRequest& from);
  SpotCheckFeedbackRequest(SpotCheckFeedbackRequest&& from) noexcept
    : SpotCheckFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline SpotCheckFeedbackRequest& operator=(const SpotCheckFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCheckFeedbackRequest& operator=(SpotCheckFeedbackRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpotCheckFeedbackRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpotCheckFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const SpotCheckFeedbackRequest*>(
               &_SpotCheckFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SpotCheckFeedbackRequest& a, SpotCheckFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCheckFeedbackRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCheckFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpotCheckFeedbackRequest* New() const final {
    return CreateMaybeMessage<SpotCheckFeedbackRequest>(nullptr);
  }

  SpotCheckFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpotCheckFeedbackRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpotCheckFeedbackRequest& from);
  void MergeFrom(const SpotCheckFeedbackRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCheckFeedbackRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SpotCheckFeedbackRequest";
  }
  protected:
  explicit SpotCheckFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SpotCheckFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse();
  explicit SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.CameraResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse();
  explicit SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.LoadCellResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[4];
  }

  public:
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::JointKinematicCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::JointKinematicCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse();
  explicit SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.KinematicCalResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::FootHeightCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::FootHeightCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse();
  explicit SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.FootHeightResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[6];
  }

  public:
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::LegPairCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse, 
    std::string, ::bosdyn::api::spot::LegPairCheckResult,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse();
  explicit SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse& other);
  static const SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse*>(&_SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bosdyn.api.spot.SpotCheckFeedbackResponse.LegPairResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class SpotCheckFeedbackResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.SpotCheckFeedbackResponse) */ {
 public:
  inline SpotCheckFeedbackResponse() : SpotCheckFeedbackResponse(nullptr) {}
  virtual ~SpotCheckFeedbackResponse();

  SpotCheckFeedbackResponse(const SpotCheckFeedbackResponse& from);
  SpotCheckFeedbackResponse(SpotCheckFeedbackResponse&& from) noexcept
    : SpotCheckFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline SpotCheckFeedbackResponse& operator=(const SpotCheckFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpotCheckFeedbackResponse& operator=(SpotCheckFeedbackResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpotCheckFeedbackResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpotCheckFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const SpotCheckFeedbackResponse*>(
               &_SpotCheckFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SpotCheckFeedbackResponse& a, SpotCheckFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpotCheckFeedbackResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpotCheckFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpotCheckFeedbackResponse* New() const final {
    return CreateMaybeMessage<SpotCheckFeedbackResponse>(nullptr);
  }

  SpotCheckFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpotCheckFeedbackResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpotCheckFeedbackResponse& from);
  void MergeFrom(const SpotCheckFeedbackResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpotCheckFeedbackResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.SpotCheckFeedbackResponse";
  }
  protected:
  explicit SpotCheckFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  typedef SpotCheckFeedbackResponse_State State;
  static constexpr State STATE_UNKNOWN =
    SpotCheckFeedbackResponse_State_STATE_UNKNOWN;
  static constexpr State STATE_USER_ABORTED =
    SpotCheckFeedbackResponse_State_STATE_USER_ABORTED;
  static constexpr State STATE_STARTING =
    SpotCheckFeedbackResponse_State_STATE_STARTING;
  static constexpr State STATE_LOADCELL_CAL =
    SpotCheckFeedbackResponse_State_STATE_LOADCELL_CAL;
  static constexpr State STATE_ENDSTOP_CAL =
    SpotCheckFeedbackResponse_State_STATE_ENDSTOP_CAL;
  static constexpr State STATE_CAMERA_CHECK =
    SpotCheckFeedbackResponse_State_STATE_CAMERA_CHECK;
  static constexpr State STATE_BODY_POSING =
    SpotCheckFeedbackResponse_State_STATE_BODY_POSING;
  static constexpr State STATE_FINISHED =
    SpotCheckFeedbackResponse_State_STATE_FINISHED;
  static constexpr State STATE_REVERTING_CAL =
    SpotCheckFeedbackResponse_State_STATE_REVERTING_CAL;
  static constexpr State STATE_ERROR =
    SpotCheckFeedbackResponse_State_STATE_ERROR;
  static constexpr State STATE_WAITING_FOR_COMMAND =
    SpotCheckFeedbackResponse_State_STATE_WAITING_FOR_COMMAND;
  static inline bool State_IsValid(int value) {
    return SpotCheckFeedbackResponse_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SpotCheckFeedbackResponse_State_State_MIN;
  static constexpr State State_MAX =
    SpotCheckFeedbackResponse_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SpotCheckFeedbackResponse_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SpotCheckFeedbackResponse_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SpotCheckFeedbackResponse_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return SpotCheckFeedbackResponse_State_Parse(name, value);
  }

  typedef SpotCheckFeedbackResponse_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    SpotCheckFeedbackResponse_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    SpotCheckFeedbackResponse_Error_ERROR_NONE;
  static constexpr Error ERROR_UNEXPECTED_POWER_CHANGE =
    SpotCheckFeedbackResponse_Error_ERROR_UNEXPECTED_POWER_CHANGE;
  static constexpr Error ERROR_INIT_IMU_CHECK =
    SpotCheckFeedbackResponse_Error_ERROR_INIT_IMU_CHECK;
  static constexpr Error ERROR_INIT_NOT_SITTING =
    SpotCheckFeedbackResponse_Error_ERROR_INIT_NOT_SITTING;
  static constexpr Error ERROR_LOADCELL_TIMEOUT =
    SpotCheckFeedbackResponse_Error_ERROR_LOADCELL_TIMEOUT;
  static constexpr Error ERROR_POWER_ON_FAILURE =
    SpotCheckFeedbackResponse_Error_ERROR_POWER_ON_FAILURE;
  static constexpr Error ERROR_ENDSTOP_TIMEOUT =
    SpotCheckFeedbackResponse_Error_ERROR_ENDSTOP_TIMEOUT;
  static constexpr Error ERROR_FAILED_STAND =
    SpotCheckFeedbackResponse_Error_ERROR_FAILED_STAND;
  static constexpr Error ERROR_CAMERA_TIMEOUT =
    SpotCheckFeedbackResponse_Error_ERROR_CAMERA_TIMEOUT;
  static constexpr Error ERROR_GROUND_CHECK =
    SpotCheckFeedbackResponse_Error_ERROR_GROUND_CHECK;
  static constexpr Error ERROR_POWER_OFF_FAILURE =
    SpotCheckFeedbackResponse_Error_ERROR_POWER_OFF_FAILURE;
  static inline bool Error_IsValid(int value) {
    return SpotCheckFeedbackResponse_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    SpotCheckFeedbackResponse_Error_Error_MIN;
  static constexpr Error Error_MAX =
    SpotCheckFeedbackResponse_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    SpotCheckFeedbackResponse_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return SpotCheckFeedbackResponse_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return SpotCheckFeedbackResponse_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return SpotCheckFeedbackResponse_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultsFieldNumber = 3,
    kLoadCellResultsFieldNumber = 4,
    kKinematicCalResultsFieldNumber = 5,
    kFootHeightResultsFieldNumber = 10,
    kLegPairResultsFieldNumber = 11,
    kHeaderFieldNumber = 1,
    kPayloadResultFieldNumber = 8,
    kLastCalTimestampFieldNumber = 9,
    kStateFieldNumber = 2,
    kErrorFieldNumber = 6,
    kProgressFieldNumber = 7,
    kLastCommandFieldNumber = 12,
  };
  // map<string, .bosdyn.api.spot.DepthPlaneSpotCheckResult> camera_results = 3;
  int camera_results_size() const;
  private:
  int _internal_camera_results_size() const;
  public:
  void clear_camera_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >&
      _internal_camera_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >*
      _internal_mutable_camera_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >&
      camera_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >*
      mutable_camera_results();

  // map<string, .bosdyn.api.spot.LoadCellSpotCheckResult> load_cell_results = 4;
  int load_cell_results_size() const;
  private:
  int _internal_load_cell_results_size() const;
  public:
  void clear_load_cell_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >&
      _internal_load_cell_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >*
      _internal_mutable_load_cell_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >&
      load_cell_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >*
      mutable_load_cell_results();

  // map<string, .bosdyn.api.spot.JointKinematicCheckResult> kinematic_cal_results = 5;
  int kinematic_cal_results_size() const;
  private:
  int _internal_kinematic_cal_results_size() const;
  public:
  void clear_kinematic_cal_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >&
      _internal_kinematic_cal_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >*
      _internal_mutable_kinematic_cal_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >&
      kinematic_cal_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >*
      mutable_kinematic_cal_results();

  // map<string, .bosdyn.api.spot.FootHeightCheckResult> foot_height_results = 10;
  int foot_height_results_size() const;
  private:
  int _internal_foot_height_results_size() const;
  public:
  void clear_foot_height_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >&
      _internal_foot_height_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >*
      _internal_mutable_foot_height_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >&
      foot_height_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >*
      mutable_foot_height_results();

  // map<string, .bosdyn.api.spot.LegPairCheckResult> leg_pair_results = 11;
  int leg_pair_results_size() const;
  private:
  int _internal_leg_pair_results_size() const;
  public:
  void clear_leg_pair_results();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >&
      _internal_leg_pair_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >*
      _internal_mutable_leg_pair_results();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >&
      leg_pair_results() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >*
      mutable_leg_pair_results();

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.PayloadCheckResult payload_result = 8;
  bool has_payload_result() const;
  private:
  bool _internal_has_payload_result() const;
  public:
  void clear_payload_result();
  const ::bosdyn::api::spot::PayloadCheckResult& payload_result() const;
  ::bosdyn::api::spot::PayloadCheckResult* release_payload_result();
  ::bosdyn::api::spot::PayloadCheckResult* mutable_payload_result();
  void set_allocated_payload_result(::bosdyn::api::spot::PayloadCheckResult* payload_result);
  private:
  const ::bosdyn::api::spot::PayloadCheckResult& _internal_payload_result() const;
  ::bosdyn::api::spot::PayloadCheckResult* _internal_mutable_payload_result();
  public:
  void unsafe_arena_set_allocated_payload_result(
      ::bosdyn::api::spot::PayloadCheckResult* payload_result);
  ::bosdyn::api::spot::PayloadCheckResult* unsafe_arena_release_payload_result();

  // .google.protobuf.Timestamp last_cal_timestamp = 9;
  bool has_last_cal_timestamp() const;
  private:
  bool _internal_has_last_cal_timestamp() const;
  public:
  void clear_last_cal_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& last_cal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_last_cal_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_cal_timestamp();
  void set_allocated_last_cal_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_cal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_cal_timestamp();
  public:
  void unsafe_arena_set_allocated_last_cal_timestamp(
      PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_cal_timestamp();

  // .bosdyn.api.spot.SpotCheckFeedbackResponse.State state = 2;
  void clear_state();
  ::bosdyn::api::spot::SpotCheckFeedbackResponse_State state() const;
  void set_state(::bosdyn::api::spot::SpotCheckFeedbackResponse_State value);
  private:
  ::bosdyn::api::spot::SpotCheckFeedbackResponse_State _internal_state() const;
  void _internal_set_state(::bosdyn::api::spot::SpotCheckFeedbackResponse_State value);
  public:

  // .bosdyn.api.spot.SpotCheckFeedbackResponse.Error error = 6;
  void clear_error();
  ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error error() const;
  void set_error(::bosdyn::api::spot::SpotCheckFeedbackResponse_Error value);
  private:
  ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::SpotCheckFeedbackResponse_Error value);
  public:

  // float progress = 7;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // .bosdyn.api.spot.SpotCheckCommandRequest.Command last_command = 12;
  void clear_last_command();
  ::bosdyn::api::spot::SpotCheckCommandRequest_Command last_command() const;
  void set_last_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value);
  private:
  ::bosdyn::api::spot::SpotCheckCommandRequest_Command _internal_last_command() const;
  void _internal_set_last_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.SpotCheckFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SpotCheckFeedbackResponse_CameraResultsEntry_DoNotUse,
      std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > camera_results_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SpotCheckFeedbackResponse_LoadCellResultsEntry_DoNotUse,
      std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > load_cell_results_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SpotCheckFeedbackResponse_KinematicCalResultsEntry_DoNotUse,
      std::string, ::bosdyn::api::spot::JointKinematicCheckResult,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > kinematic_cal_results_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SpotCheckFeedbackResponse_FootHeightResultsEntry_DoNotUse,
      std::string, ::bosdyn::api::spot::FootHeightCheckResult,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > foot_height_results_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SpotCheckFeedbackResponse_LegPairResultsEntry_DoNotUse,
      std::string, ::bosdyn::api::spot::LegPairCheckResult,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > leg_pair_results_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::spot::PayloadCheckResult* payload_result_;
  PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp_;
  int state_;
  int error_;
  float progress_;
  int last_command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class DepthPlaneSpotCheckResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.DepthPlaneSpotCheckResult) */ {
 public:
  inline DepthPlaneSpotCheckResult() : DepthPlaneSpotCheckResult(nullptr) {}
  virtual ~DepthPlaneSpotCheckResult();

  DepthPlaneSpotCheckResult(const DepthPlaneSpotCheckResult& from);
  DepthPlaneSpotCheckResult(DepthPlaneSpotCheckResult&& from) noexcept
    : DepthPlaneSpotCheckResult() {
    *this = ::std::move(from);
  }

  inline DepthPlaneSpotCheckResult& operator=(const DepthPlaneSpotCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DepthPlaneSpotCheckResult& operator=(DepthPlaneSpotCheckResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DepthPlaneSpotCheckResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthPlaneSpotCheckResult* internal_default_instance() {
    return reinterpret_cast<const DepthPlaneSpotCheckResult*>(
               &_DepthPlaneSpotCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DepthPlaneSpotCheckResult& a, DepthPlaneSpotCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(DepthPlaneSpotCheckResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DepthPlaneSpotCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DepthPlaneSpotCheckResult* New() const final {
    return CreateMaybeMessage<DepthPlaneSpotCheckResult>(nullptr);
  }

  DepthPlaneSpotCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DepthPlaneSpotCheckResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DepthPlaneSpotCheckResult& from);
  void MergeFrom(const DepthPlaneSpotCheckResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthPlaneSpotCheckResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.DepthPlaneSpotCheckResult";
  }
  protected:
  explicit DepthPlaneSpotCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DepthPlaneSpotCheckResult_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DepthPlaneSpotCheckResult_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    DepthPlaneSpotCheckResult_Status_STATUS_OK;
  static constexpr Status STATUS_WARNING =
    DepthPlaneSpotCheckResult_Status_STATUS_WARNING;
  static constexpr Status STATUS_ERROR =
    DepthPlaneSpotCheckResult_Status_STATUS_ERROR;
  static inline bool Status_IsValid(int value) {
    return DepthPlaneSpotCheckResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DepthPlaneSpotCheckResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DepthPlaneSpotCheckResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DepthPlaneSpotCheckResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DepthPlaneSpotCheckResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DepthPlaneSpotCheckResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DepthPlaneSpotCheckResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kSeverityScoreFieldNumber = 2,
  };
  // .bosdyn.api.spot.DepthPlaneSpotCheckResult.Status status = 1;
  void clear_status();
  ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status status() const;
  void set_status(::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status value);
  private:
  ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status value);
  public:

  // float severity_score = 2;
  void clear_severity_score();
  float severity_score() const;
  void set_severity_score(float value);
  private:
  float _internal_severity_score() const;
  void _internal_set_severity_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.DepthPlaneSpotCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  float severity_score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class PayloadCheckResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.PayloadCheckResult) */ {
 public:
  inline PayloadCheckResult() : PayloadCheckResult(nullptr) {}
  virtual ~PayloadCheckResult();

  PayloadCheckResult(const PayloadCheckResult& from);
  PayloadCheckResult(PayloadCheckResult&& from) noexcept
    : PayloadCheckResult() {
    *this = ::std::move(from);
  }

  inline PayloadCheckResult& operator=(const PayloadCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadCheckResult& operator=(PayloadCheckResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PayloadCheckResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PayloadCheckResult* internal_default_instance() {
    return reinterpret_cast<const PayloadCheckResult*>(
               &_PayloadCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PayloadCheckResult& a, PayloadCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadCheckResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PayloadCheckResult* New() const final {
    return CreateMaybeMessage<PayloadCheckResult>(nullptr);
  }

  PayloadCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PayloadCheckResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PayloadCheckResult& from);
  void MergeFrom(const PayloadCheckResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PayloadCheckResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.PayloadCheckResult";
  }
  protected:
  explicit PayloadCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PayloadCheckResult_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    PayloadCheckResult_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    PayloadCheckResult_Error_ERROR_NONE;
  static constexpr Error ERROR_MASS_DISCREPANCY =
    PayloadCheckResult_Error_ERROR_MASS_DISCREPANCY;
  static inline bool Error_IsValid(int value) {
    return PayloadCheckResult_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    PayloadCheckResult_Error_Error_MIN;
  static constexpr Error Error_MAX =
    PayloadCheckResult_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    PayloadCheckResult_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return PayloadCheckResult_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return PayloadCheckResult_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return PayloadCheckResult_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kExtraPayloadFieldNumber = 2,
  };
  // .bosdyn.api.spot.PayloadCheckResult.Error error = 1;
  void clear_error();
  ::bosdyn::api::spot::PayloadCheckResult_Error error() const;
  void set_error(::bosdyn::api::spot::PayloadCheckResult_Error value);
  private:
  ::bosdyn::api::spot::PayloadCheckResult_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::PayloadCheckResult_Error value);
  public:

  // float extra_payload = 2;
  void clear_extra_payload();
  float extra_payload() const;
  void set_extra_payload(float value);
  private:
  float _internal_extra_payload() const;
  void _internal_set_extra_payload(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.PayloadCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int error_;
  float extra_payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class LoadCellSpotCheckResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.LoadCellSpotCheckResult) */ {
 public:
  inline LoadCellSpotCheckResult() : LoadCellSpotCheckResult(nullptr) {}
  virtual ~LoadCellSpotCheckResult();

  LoadCellSpotCheckResult(const LoadCellSpotCheckResult& from);
  LoadCellSpotCheckResult(LoadCellSpotCheckResult&& from) noexcept
    : LoadCellSpotCheckResult() {
    *this = ::std::move(from);
  }

  inline LoadCellSpotCheckResult& operator=(const LoadCellSpotCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadCellSpotCheckResult& operator=(LoadCellSpotCheckResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadCellSpotCheckResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoadCellSpotCheckResult* internal_default_instance() {
    return reinterpret_cast<const LoadCellSpotCheckResult*>(
               &_LoadCellSpotCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LoadCellSpotCheckResult& a, LoadCellSpotCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadCellSpotCheckResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadCellSpotCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadCellSpotCheckResult* New() const final {
    return CreateMaybeMessage<LoadCellSpotCheckResult>(nullptr);
  }

  LoadCellSpotCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadCellSpotCheckResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadCellSpotCheckResult& from);
  void MergeFrom(const LoadCellSpotCheckResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadCellSpotCheckResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.LoadCellSpotCheckResult";
  }
  protected:
  explicit LoadCellSpotCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LoadCellSpotCheckResult_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    LoadCellSpotCheckResult_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    LoadCellSpotCheckResult_Error_ERROR_NONE;
  static constexpr Error ERROR_ZERO_OUT_OF_RANGE =
    LoadCellSpotCheckResult_Error_ERROR_ZERO_OUT_OF_RANGE;
  static inline bool Error_IsValid(int value) {
    return LoadCellSpotCheckResult_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    LoadCellSpotCheckResult_Error_Error_MIN;
  static constexpr Error Error_MAX =
    LoadCellSpotCheckResult_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    LoadCellSpotCheckResult_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return LoadCellSpotCheckResult_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return LoadCellSpotCheckResult_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return LoadCellSpotCheckResult_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kZeroFieldNumber = 3,
    kOldZeroFieldNumber = 4,
  };
  // .bosdyn.api.spot.LoadCellSpotCheckResult.Error error = 2;
  void clear_error();
  ::bosdyn::api::spot::LoadCellSpotCheckResult_Error error() const;
  void set_error(::bosdyn::api::spot::LoadCellSpotCheckResult_Error value);
  private:
  ::bosdyn::api::spot::LoadCellSpotCheckResult_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::LoadCellSpotCheckResult_Error value);
  public:

  // float zero = 3;
  void clear_zero();
  float zero() const;
  void set_zero(float value);
  private:
  float _internal_zero() const;
  void _internal_set_zero(float value);
  public:

  // float old_zero = 4;
  void clear_old_zero();
  float old_zero() const;
  void set_old_zero(float value);
  private:
  float _internal_old_zero() const;
  void _internal_set_old_zero(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.LoadCellSpotCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int error_;
  float zero_;
  float old_zero_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class JointKinematicCheckResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.JointKinematicCheckResult) */ {
 public:
  inline JointKinematicCheckResult() : JointKinematicCheckResult(nullptr) {}
  virtual ~JointKinematicCheckResult();

  JointKinematicCheckResult(const JointKinematicCheckResult& from);
  JointKinematicCheckResult(JointKinematicCheckResult&& from) noexcept
    : JointKinematicCheckResult() {
    *this = ::std::move(from);
  }

  inline JointKinematicCheckResult& operator=(const JointKinematicCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointKinematicCheckResult& operator=(JointKinematicCheckResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JointKinematicCheckResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointKinematicCheckResult* internal_default_instance() {
    return reinterpret_cast<const JointKinematicCheckResult*>(
               &_JointKinematicCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(JointKinematicCheckResult& a, JointKinematicCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(JointKinematicCheckResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointKinematicCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointKinematicCheckResult* New() const final {
    return CreateMaybeMessage<JointKinematicCheckResult>(nullptr);
  }

  JointKinematicCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointKinematicCheckResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JointKinematicCheckResult& from);
  void MergeFrom(const JointKinematicCheckResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointKinematicCheckResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.JointKinematicCheckResult";
  }
  protected:
  explicit JointKinematicCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef JointKinematicCheckResult_Error Error;
  static constexpr Error ERROR_UNKNOWN =
    JointKinematicCheckResult_Error_ERROR_UNKNOWN;
  static constexpr Error ERROR_NONE =
    JointKinematicCheckResult_Error_ERROR_NONE;
  static constexpr Error ERROR_CLUTCH_SLIP =
    JointKinematicCheckResult_Error_ERROR_CLUTCH_SLIP;
  static inline bool Error_IsValid(int value) {
    return JointKinematicCheckResult_Error_IsValid(value);
  }
  static constexpr Error Error_MIN =
    JointKinematicCheckResult_Error_Error_MIN;
  static constexpr Error Error_MAX =
    JointKinematicCheckResult_Error_Error_MAX;
  static constexpr int Error_ARRAYSIZE =
    JointKinematicCheckResult_Error_Error_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Error_descriptor() {
    return JointKinematicCheckResult_Error_descriptor();
  }
  template<typename T>
  static inline const std::string& Error_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Error>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Error_Name.");
    return JointKinematicCheckResult_Error_Name(enum_t_value);
  }
  static inline bool Error_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Error* value) {
    return JointKinematicCheckResult_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kOldOffsetFieldNumber = 4,
    kHealthScoreFieldNumber = 5,
  };
  // .bosdyn.api.spot.JointKinematicCheckResult.Error error = 2;
  void clear_error();
  ::bosdyn::api::spot::JointKinematicCheckResult_Error error() const;
  void set_error(::bosdyn::api::spot::JointKinematicCheckResult_Error value);
  private:
  ::bosdyn::api::spot::JointKinematicCheckResult_Error _internal_error() const;
  void _internal_set_error(::bosdyn::api::spot::JointKinematicCheckResult_Error value);
  public:

  // float offset = 3;
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // float old_offset = 4;
  void clear_old_offset();
  float old_offset() const;
  void set_old_offset(float value);
  private:
  float _internal_old_offset() const;
  void _internal_set_old_offset(float value);
  public:

  // float health_score = 5;
  void clear_health_score();
  float health_score() const;
  void set_health_score(float value);
  private:
  float _internal_health_score() const;
  void _internal_set_health_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.JointKinematicCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int error_;
  float offset_;
  float old_offset_;
  float health_score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class FootHeightCheckResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.FootHeightCheckResult) */ {
 public:
  inline FootHeightCheckResult() : FootHeightCheckResult(nullptr) {}
  virtual ~FootHeightCheckResult();

  FootHeightCheckResult(const FootHeightCheckResult& from);
  FootHeightCheckResult(FootHeightCheckResult&& from) noexcept
    : FootHeightCheckResult() {
    *this = ::std::move(from);
  }

  inline FootHeightCheckResult& operator=(const FootHeightCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline FootHeightCheckResult& operator=(FootHeightCheckResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FootHeightCheckResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FootHeightCheckResult* internal_default_instance() {
    return reinterpret_cast<const FootHeightCheckResult*>(
               &_FootHeightCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FootHeightCheckResult& a, FootHeightCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(FootHeightCheckResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FootHeightCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FootHeightCheckResult* New() const final {
    return CreateMaybeMessage<FootHeightCheckResult>(nullptr);
  }

  FootHeightCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FootHeightCheckResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FootHeightCheckResult& from);
  void MergeFrom(const FootHeightCheckResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FootHeightCheckResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.FootHeightCheckResult";
  }
  protected:
  explicit FootHeightCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FootHeightCheckResult_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    FootHeightCheckResult_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    FootHeightCheckResult_Status_STATUS_OK;
  static constexpr Status STATUS_WARNING =
    FootHeightCheckResult_Status_STATUS_WARNING;
  static constexpr Status STATUS_ERROR =
    FootHeightCheckResult_Status_STATUS_ERROR;
  static inline bool Status_IsValid(int value) {
    return FootHeightCheckResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    FootHeightCheckResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    FootHeightCheckResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    FootHeightCheckResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return FootHeightCheckResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return FootHeightCheckResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return FootHeightCheckResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kFootHeightErrorFromMeanFieldNumber = 3,
  };
  // .bosdyn.api.spot.FootHeightCheckResult.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::FootHeightCheckResult_Status status() const;
  void set_status(::bosdyn::api::spot::FootHeightCheckResult_Status value);
  private:
  ::bosdyn::api::spot::FootHeightCheckResult_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::FootHeightCheckResult_Status value);
  public:

  // float foot_height_error_from_mean = 3;
  void clear_foot_height_error_from_mean();
  float foot_height_error_from_mean() const;
  void set_foot_height_error_from_mean(float value);
  private:
  float _internal_foot_height_error_from_mean() const;
  void _internal_set_foot_height_error_from_mean(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.FootHeightCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  float foot_height_error_from_mean_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class LegPairCheckResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.LegPairCheckResult) */ {
 public:
  inline LegPairCheckResult() : LegPairCheckResult(nullptr) {}
  virtual ~LegPairCheckResult();

  LegPairCheckResult(const LegPairCheckResult& from);
  LegPairCheckResult(LegPairCheckResult&& from) noexcept
    : LegPairCheckResult() {
    *this = ::std::move(from);
  }

  inline LegPairCheckResult& operator=(const LegPairCheckResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline LegPairCheckResult& operator=(LegPairCheckResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LegPairCheckResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LegPairCheckResult* internal_default_instance() {
    return reinterpret_cast<const LegPairCheckResult*>(
               &_LegPairCheckResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LegPairCheckResult& a, LegPairCheckResult& b) {
    a.Swap(&b);
  }
  inline void Swap(LegPairCheckResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LegPairCheckResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LegPairCheckResult* New() const final {
    return CreateMaybeMessage<LegPairCheckResult>(nullptr);
  }

  LegPairCheckResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LegPairCheckResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LegPairCheckResult& from);
  void MergeFrom(const LegPairCheckResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LegPairCheckResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.LegPairCheckResult";
  }
  protected:
  explicit LegPairCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LegPairCheckResult_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    LegPairCheckResult_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    LegPairCheckResult_Status_STATUS_OK;
  static constexpr Status STATUS_WARNING =
    LegPairCheckResult_Status_STATUS_WARNING;
  static constexpr Status STATUS_ERROR =
    LegPairCheckResult_Status_STATUS_ERROR;
  static inline bool Status_IsValid(int value) {
    return LegPairCheckResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    LegPairCheckResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    LegPairCheckResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    LegPairCheckResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return LegPairCheckResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return LegPairCheckResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return LegPairCheckResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kLegPairDistanceChangeFieldNumber = 3,
  };
  // .bosdyn.api.spot.LegPairCheckResult.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::LegPairCheckResult_Status status() const;
  void set_status(::bosdyn::api::spot::LegPairCheckResult_Status value);
  private:
  ::bosdyn::api::spot::LegPairCheckResult_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::LegPairCheckResult_Status value);
  public:

  // float leg_pair_distance_change = 3;
  void clear_leg_pair_distance_change();
  float leg_pair_distance_change() const;
  void set_leg_pair_distance_change(float value);
  private:
  float _internal_leg_pair_distance_change() const;
  void _internal_set_leg_pair_distance_change(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.LegPairCheckResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  float leg_pair_distance_change_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibrationCommandRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.CameraCalibrationCommandRequest) */ {
 public:
  inline CameraCalibrationCommandRequest() : CameraCalibrationCommandRequest(nullptr) {}
  virtual ~CameraCalibrationCommandRequest();

  CameraCalibrationCommandRequest(const CameraCalibrationCommandRequest& from);
  CameraCalibrationCommandRequest(CameraCalibrationCommandRequest&& from) noexcept
    : CameraCalibrationCommandRequest() {
    *this = ::std::move(from);
  }

  inline CameraCalibrationCommandRequest& operator=(const CameraCalibrationCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibrationCommandRequest& operator=(CameraCalibrationCommandRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraCalibrationCommandRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraCalibrationCommandRequest* internal_default_instance() {
    return reinterpret_cast<const CameraCalibrationCommandRequest*>(
               &_CameraCalibrationCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CameraCalibrationCommandRequest& a, CameraCalibrationCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraCalibrationCommandRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibrationCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraCalibrationCommandRequest* New() const final {
    return CreateMaybeMessage<CameraCalibrationCommandRequest>(nullptr);
  }

  CameraCalibrationCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraCalibrationCommandRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraCalibrationCommandRequest& from);
  void MergeFrom(const CameraCalibrationCommandRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibrationCommandRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.CameraCalibrationCommandRequest";
  }
  protected:
  explicit CameraCalibrationCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CameraCalibrationCommandRequest_Command Command;
  static constexpr Command COMMAND_UNKNOWN =
    CameraCalibrationCommandRequest_Command_COMMAND_UNKNOWN;
  static constexpr Command COMMAND_START =
    CameraCalibrationCommandRequest_Command_COMMAND_START;
  static constexpr Command COMMAND_CANCEL =
    CameraCalibrationCommandRequest_Command_COMMAND_CANCEL;
  static inline bool Command_IsValid(int value) {
    return CameraCalibrationCommandRequest_Command_IsValid(value);
  }
  static constexpr Command Command_MIN =
    CameraCalibrationCommandRequest_Command_Command_MIN;
  static constexpr Command Command_MAX =
    CameraCalibrationCommandRequest_Command_Command_MAX;
  static constexpr int Command_ARRAYSIZE =
    CameraCalibrationCommandRequest_Command_Command_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Command_descriptor() {
    return CameraCalibrationCommandRequest_Command_descriptor();
  }
  template<typename T>
  static inline const std::string& Command_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Command>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Command_Name.");
    return CameraCalibrationCommandRequest_Command_Name(enum_t_value);
  }
  static inline bool Command_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Command* value) {
    return CameraCalibrationCommandRequest_Command_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseFieldNumber = 2,
    kCommandFieldNumber = 3,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.Lease lease = 2;
  bool has_lease() const;
  private:
  bool _internal_has_lease() const;
  public:
  void clear_lease();
  const ::bosdyn::api::Lease& lease() const;
  ::bosdyn::api::Lease* release_lease();
  ::bosdyn::api::Lease* mutable_lease();
  void set_allocated_lease(::bosdyn::api::Lease* lease);
  private:
  const ::bosdyn::api::Lease& _internal_lease() const;
  ::bosdyn::api::Lease* _internal_mutable_lease();
  public:
  void unsafe_arena_set_allocated_lease(
      ::bosdyn::api::Lease* lease);
  ::bosdyn::api::Lease* unsafe_arena_release_lease();

  // .bosdyn.api.spot.CameraCalibrationCommandRequest.Command command = 3;
  void clear_command();
  ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command command() const;
  void set_command(::bosdyn::api::spot::CameraCalibrationCommandRequest_Command value);
  private:
  ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command _internal_command() const;
  void _internal_set_command(::bosdyn::api::spot::CameraCalibrationCommandRequest_Command value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.CameraCalibrationCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::Lease* lease_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibrationCommandResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.CameraCalibrationCommandResponse) */ {
 public:
  inline CameraCalibrationCommandResponse() : CameraCalibrationCommandResponse(nullptr) {}
  virtual ~CameraCalibrationCommandResponse();

  CameraCalibrationCommandResponse(const CameraCalibrationCommandResponse& from);
  CameraCalibrationCommandResponse(CameraCalibrationCommandResponse&& from) noexcept
    : CameraCalibrationCommandResponse() {
    *this = ::std::move(from);
  }

  inline CameraCalibrationCommandResponse& operator=(const CameraCalibrationCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibrationCommandResponse& operator=(CameraCalibrationCommandResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraCalibrationCommandResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraCalibrationCommandResponse* internal_default_instance() {
    return reinterpret_cast<const CameraCalibrationCommandResponse*>(
               &_CameraCalibrationCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CameraCalibrationCommandResponse& a, CameraCalibrationCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraCalibrationCommandResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibrationCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraCalibrationCommandResponse* New() const final {
    return CreateMaybeMessage<CameraCalibrationCommandResponse>(nullptr);
  }

  CameraCalibrationCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraCalibrationCommandResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraCalibrationCommandResponse& from);
  void MergeFrom(const CameraCalibrationCommandResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibrationCommandResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.CameraCalibrationCommandResponse";
  }
  protected:
  explicit CameraCalibrationCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLeaseUseResultFieldNumber = 2,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.LeaseUseResult lease_use_result = 2;
  bool has_lease_use_result() const;
  private:
  bool _internal_has_lease_use_result() const;
  public:
  void clear_lease_use_result();
  const ::bosdyn::api::LeaseUseResult& lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* release_lease_use_result();
  ::bosdyn::api::LeaseUseResult* mutable_lease_use_result();
  void set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result);
  private:
  const ::bosdyn::api::LeaseUseResult& _internal_lease_use_result() const;
  ::bosdyn::api::LeaseUseResult* _internal_mutable_lease_use_result();
  public:
  void unsafe_arena_set_allocated_lease_use_result(
      ::bosdyn::api::LeaseUseResult* lease_use_result);
  ::bosdyn::api::LeaseUseResult* unsafe_arena_release_lease_use_result();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.CameraCalibrationCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::LeaseUseResult* lease_use_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibrationFeedbackRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.CameraCalibrationFeedbackRequest) */ {
 public:
  inline CameraCalibrationFeedbackRequest() : CameraCalibrationFeedbackRequest(nullptr) {}
  virtual ~CameraCalibrationFeedbackRequest();

  CameraCalibrationFeedbackRequest(const CameraCalibrationFeedbackRequest& from);
  CameraCalibrationFeedbackRequest(CameraCalibrationFeedbackRequest&& from) noexcept
    : CameraCalibrationFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline CameraCalibrationFeedbackRequest& operator=(const CameraCalibrationFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibrationFeedbackRequest& operator=(CameraCalibrationFeedbackRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraCalibrationFeedbackRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraCalibrationFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const CameraCalibrationFeedbackRequest*>(
               &_CameraCalibrationFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CameraCalibrationFeedbackRequest& a, CameraCalibrationFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraCalibrationFeedbackRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibrationFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraCalibrationFeedbackRequest* New() const final {
    return CreateMaybeMessage<CameraCalibrationFeedbackRequest>(nullptr);
  }

  CameraCalibrationFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraCalibrationFeedbackRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraCalibrationFeedbackRequest& from);
  void MergeFrom(const CameraCalibrationFeedbackRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibrationFeedbackRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.CameraCalibrationFeedbackRequest";
  }
  protected:
  explicit CameraCalibrationFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.CameraCalibrationFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// -------------------------------------------------------------------

class CameraCalibrationFeedbackResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.spot.CameraCalibrationFeedbackResponse) */ {
 public:
  inline CameraCalibrationFeedbackResponse() : CameraCalibrationFeedbackResponse(nullptr) {}
  virtual ~CameraCalibrationFeedbackResponse();

  CameraCalibrationFeedbackResponse(const CameraCalibrationFeedbackResponse& from);
  CameraCalibrationFeedbackResponse(CameraCalibrationFeedbackResponse&& from) noexcept
    : CameraCalibrationFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline CameraCalibrationFeedbackResponse& operator=(const CameraCalibrationFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraCalibrationFeedbackResponse& operator=(CameraCalibrationFeedbackResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraCalibrationFeedbackResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraCalibrationFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const CameraCalibrationFeedbackResponse*>(
               &_CameraCalibrationFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CameraCalibrationFeedbackResponse& a, CameraCalibrationFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraCalibrationFeedbackResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraCalibrationFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraCalibrationFeedbackResponse* New() const final {
    return CreateMaybeMessage<CameraCalibrationFeedbackResponse>(nullptr);
  }

  CameraCalibrationFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraCalibrationFeedbackResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraCalibrationFeedbackResponse& from);
  void MergeFrom(const CameraCalibrationFeedbackResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibrationFeedbackResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.spot.CameraCalibrationFeedbackResponse";
  }
  protected:
  explicit CameraCalibrationFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CameraCalibrationFeedbackResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    CameraCalibrationFeedbackResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_PROCESSING =
    CameraCalibrationFeedbackResponse_Status_STATUS_PROCESSING;
  static constexpr Status STATUS_SUCCESS =
    CameraCalibrationFeedbackResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_USER_CANCELED =
    CameraCalibrationFeedbackResponse_Status_STATUS_USER_CANCELED;
  static constexpr Status STATUS_POWER_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_POWER_ERROR;
  static constexpr Status STATUS_LEASE_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_LEASE_ERROR;
  static constexpr Status STATUS_ROBOT_COMMAND_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_ROBOT_COMMAND_ERROR;
  static constexpr Status STATUS_CALIBRATION_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_CALIBRATION_ERROR;
  static constexpr Status STATUS_INTERNAL_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_INTERNAL_ERROR;
  static constexpr Status STATUS_CAMERA_FOCUS_ERROR =
    CameraCalibrationFeedbackResponse_Status_STATUS_CAMERA_FOCUS_ERROR;
  static constexpr Status STATUS_TARGET_NOT_CENTERED =
    CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_CENTERED;
  static constexpr Status STATUS_TARGET_NOT_IN_VIEW =
    CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_IN_VIEW;
  static constexpr Status STATUS_TARGET_NOT_GRAVITY_ALIGNED =
    CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_NOT_GRAVITY_ALIGNED;
  static constexpr Status STATUS_TARGET_UPSIDE_DOWN =
    CameraCalibrationFeedbackResponse_Status_STATUS_TARGET_UPSIDE_DOWN;
  static constexpr Status STATUS_NEVER_RUN =
    CameraCalibrationFeedbackResponse_Status_STATUS_NEVER_RUN;
  static inline bool Status_IsValid(int value) {
    return CameraCalibrationFeedbackResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    CameraCalibrationFeedbackResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    CameraCalibrationFeedbackResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    CameraCalibrationFeedbackResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return CameraCalibrationFeedbackResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return CameraCalibrationFeedbackResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return CameraCalibrationFeedbackResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 2,
    kProgressFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.spot.CameraCalibrationFeedbackResponse.Status status = 2;
  void clear_status();
  ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status status() const;
  void set_status(::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status value);
  private:
  ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status value);
  public:

  // float progress = 3;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.spot.CameraCalibrationFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  int status_;
  float progress_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SpotCheckCommandRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SpotCheckCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SpotCheckCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SpotCheckCommandRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SpotCheckCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandRequest.header)
  return _internal_header();
}
inline void SpotCheckCommandRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckCommandRequest.header)
}
inline ::bosdyn::api::RequestHeader* SpotCheckCommandRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* SpotCheckCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SpotCheckCommandRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* SpotCheckCommandRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandRequest.header)
  return _internal_mutable_header();
}
inline void SpotCheckCommandRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool SpotCheckCommandRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool SpotCheckCommandRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& SpotCheckCommandRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& SpotCheckCommandRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandRequest.lease)
  return _internal_lease();
}
inline void SpotCheckCommandRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckCommandRequest.lease)
}
inline ::bosdyn::api::Lease* SpotCheckCommandRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* SpotCheckCommandRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* SpotCheckCommandRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* SpotCheckCommandRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandRequest.lease)
  return _internal_mutable_lease();
}
inline void SpotCheckCommandRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandRequest.lease)
}

// .bosdyn.api.spot.SpotCheckCommandRequest.Command command = 3;
inline void SpotCheckCommandRequest::clear_command() {
  command_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckCommandRequest_Command SpotCheckCommandRequest::_internal_command() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckCommandRequest_Command >(command_);
}
inline ::bosdyn::api::spot::SpotCheckCommandRequest_Command SpotCheckCommandRequest::command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandRequest.command)
  return _internal_command();
}
inline void SpotCheckCommandRequest::_internal_set_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value) {
  
  command_ = value;
}
inline void SpotCheckCommandRequest::set_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckCommandRequest.command)
}

// -------------------------------------------------------------------

// SpotCheckCommandResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SpotCheckCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SpotCheckCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SpotCheckCommandResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SpotCheckCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandResponse.header)
  return _internal_header();
}
inline void SpotCheckCommandResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SpotCheckCommandResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckCommandResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckCommandResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandResponse.header)
  return _internal_mutable_header();
}
inline void SpotCheckCommandResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool SpotCheckCommandResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool SpotCheckCommandResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& SpotCheckCommandResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& SpotCheckCommandResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void SpotCheckCommandResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* SpotCheckCommandResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* SpotCheckCommandResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* SpotCheckCommandResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* SpotCheckCommandResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void SpotCheckCommandResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckCommandResponse.lease_use_result)
}

// -------------------------------------------------------------------

// SpotCheckFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SpotCheckFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SpotCheckFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SpotCheckFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SpotCheckFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
  return _internal_header();
}
inline void SpotCheckFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* SpotCheckFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* SpotCheckFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SpotCheckFeedbackRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* SpotCheckFeedbackRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
  return _internal_mutable_header();
}
inline void SpotCheckFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckFeedbackRequest.header)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SpotCheckFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SpotCheckFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SpotCheckFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SpotCheckFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SpotCheckFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
  return _internal_header();
}
inline void SpotCheckFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SpotCheckFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckFeedbackResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* SpotCheckFeedbackResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
  return _internal_mutable_header();
}
inline void SpotCheckFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.header)
}

// .bosdyn.api.spot.SpotCheckFeedbackResponse.State state = 2;
inline void SpotCheckFeedbackResponse::clear_state() {
  state_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckFeedbackResponse_State SpotCheckFeedbackResponse::_internal_state() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckFeedbackResponse_State >(state_);
}
inline ::bosdyn::api::spot::SpotCheckFeedbackResponse_State SpotCheckFeedbackResponse::state() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.state)
  return _internal_state();
}
inline void SpotCheckFeedbackResponse::_internal_set_state(::bosdyn::api::spot::SpotCheckFeedbackResponse_State value) {
  
  state_ = value;
}
inline void SpotCheckFeedbackResponse::set_state(::bosdyn::api::spot::SpotCheckFeedbackResponse_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckFeedbackResponse.state)
}

// .bosdyn.api.spot.SpotCheckCommandRequest.Command last_command = 12;
inline void SpotCheckFeedbackResponse::clear_last_command() {
  last_command_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckCommandRequest_Command SpotCheckFeedbackResponse::_internal_last_command() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckCommandRequest_Command >(last_command_);
}
inline ::bosdyn::api::spot::SpotCheckCommandRequest_Command SpotCheckFeedbackResponse::last_command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.last_command)
  return _internal_last_command();
}
inline void SpotCheckFeedbackResponse::_internal_set_last_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value) {
  
  last_command_ = value;
}
inline void SpotCheckFeedbackResponse::set_last_command(::bosdyn::api::spot::SpotCheckCommandRequest_Command value) {
  _internal_set_last_command(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckFeedbackResponse.last_command)
}

// .bosdyn.api.spot.SpotCheckFeedbackResponse.Error error = 6;
inline void SpotCheckFeedbackResponse::clear_error() {
  error_ = 0;
}
inline ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error SpotCheckFeedbackResponse::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error >(error_);
}
inline ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error SpotCheckFeedbackResponse::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.error)
  return _internal_error();
}
inline void SpotCheckFeedbackResponse::_internal_set_error(::bosdyn::api::spot::SpotCheckFeedbackResponse_Error value) {
  
  error_ = value;
}
inline void SpotCheckFeedbackResponse::set_error(::bosdyn::api::spot::SpotCheckFeedbackResponse_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckFeedbackResponse.error)
}

// map<string, .bosdyn.api.spot.DepthPlaneSpotCheckResult> camera_results = 3;
inline int SpotCheckFeedbackResponse::_internal_camera_results_size() const {
  return camera_results_.size();
}
inline int SpotCheckFeedbackResponse::camera_results_size() const {
  return _internal_camera_results_size();
}
inline void SpotCheckFeedbackResponse::clear_camera_results() {
  camera_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >&
SpotCheckFeedbackResponse::_internal_camera_results() const {
  return camera_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >&
SpotCheckFeedbackResponse::camera_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.camera_results)
  return _internal_camera_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_camera_results() {
  return camera_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::DepthPlaneSpotCheckResult >*
SpotCheckFeedbackResponse::mutable_camera_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.camera_results)
  return _internal_mutable_camera_results();
}

// map<string, .bosdyn.api.spot.LoadCellSpotCheckResult> load_cell_results = 4;
inline int SpotCheckFeedbackResponse::_internal_load_cell_results_size() const {
  return load_cell_results_.size();
}
inline int SpotCheckFeedbackResponse::load_cell_results_size() const {
  return _internal_load_cell_results_size();
}
inline void SpotCheckFeedbackResponse::clear_load_cell_results() {
  load_cell_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >&
SpotCheckFeedbackResponse::_internal_load_cell_results() const {
  return load_cell_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >&
SpotCheckFeedbackResponse::load_cell_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.load_cell_results)
  return _internal_load_cell_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_load_cell_results() {
  return load_cell_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LoadCellSpotCheckResult >*
SpotCheckFeedbackResponse::mutable_load_cell_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.load_cell_results)
  return _internal_mutable_load_cell_results();
}

// map<string, .bosdyn.api.spot.JointKinematicCheckResult> kinematic_cal_results = 5;
inline int SpotCheckFeedbackResponse::_internal_kinematic_cal_results_size() const {
  return kinematic_cal_results_.size();
}
inline int SpotCheckFeedbackResponse::kinematic_cal_results_size() const {
  return _internal_kinematic_cal_results_size();
}
inline void SpotCheckFeedbackResponse::clear_kinematic_cal_results() {
  kinematic_cal_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >&
SpotCheckFeedbackResponse::_internal_kinematic_cal_results() const {
  return kinematic_cal_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >&
SpotCheckFeedbackResponse::kinematic_cal_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.kinematic_cal_results)
  return _internal_kinematic_cal_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_kinematic_cal_results() {
  return kinematic_cal_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::JointKinematicCheckResult >*
SpotCheckFeedbackResponse::mutable_kinematic_cal_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.kinematic_cal_results)
  return _internal_mutable_kinematic_cal_results();
}

// .bosdyn.api.spot.PayloadCheckResult payload_result = 8;
inline bool SpotCheckFeedbackResponse::_internal_has_payload_result() const {
  return this != internal_default_instance() && payload_result_ != nullptr;
}
inline bool SpotCheckFeedbackResponse::has_payload_result() const {
  return _internal_has_payload_result();
}
inline void SpotCheckFeedbackResponse::clear_payload_result() {
  if (GetArena() == nullptr && payload_result_ != nullptr) {
    delete payload_result_;
  }
  payload_result_ = nullptr;
}
inline const ::bosdyn::api::spot::PayloadCheckResult& SpotCheckFeedbackResponse::_internal_payload_result() const {
  const ::bosdyn::api::spot::PayloadCheckResult* p = payload_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::spot::PayloadCheckResult*>(
      &::bosdyn::api::spot::_PayloadCheckResult_default_instance_);
}
inline const ::bosdyn::api::spot::PayloadCheckResult& SpotCheckFeedbackResponse::payload_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
  return _internal_payload_result();
}
inline void SpotCheckFeedbackResponse::unsafe_arena_set_allocated_payload_result(
    ::bosdyn::api::spot::PayloadCheckResult* payload_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_result_);
  }
  payload_result_ = payload_result;
  if (payload_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
}
inline ::bosdyn::api::spot::PayloadCheckResult* SpotCheckFeedbackResponse::release_payload_result() {
  
  ::bosdyn::api::spot::PayloadCheckResult* temp = payload_result_;
  payload_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::spot::PayloadCheckResult* SpotCheckFeedbackResponse::unsafe_arena_release_payload_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
  
  ::bosdyn::api::spot::PayloadCheckResult* temp = payload_result_;
  payload_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::spot::PayloadCheckResult* SpotCheckFeedbackResponse::_internal_mutable_payload_result() {
  
  if (payload_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::spot::PayloadCheckResult>(GetArena());
    payload_result_ = p;
  }
  return payload_result_;
}
inline ::bosdyn::api::spot::PayloadCheckResult* SpotCheckFeedbackResponse::mutable_payload_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
  return _internal_mutable_payload_result();
}
inline void SpotCheckFeedbackResponse::set_allocated_payload_result(::bosdyn::api::spot::PayloadCheckResult* payload_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete payload_result_;
  }
  if (payload_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(payload_result);
    if (message_arena != submessage_arena) {
      payload_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_result, submessage_arena);
    }
    
  } else {
    
  }
  payload_result_ = payload_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.payload_result)
}

// map<string, .bosdyn.api.spot.FootHeightCheckResult> foot_height_results = 10;
inline int SpotCheckFeedbackResponse::_internal_foot_height_results_size() const {
  return foot_height_results_.size();
}
inline int SpotCheckFeedbackResponse::foot_height_results_size() const {
  return _internal_foot_height_results_size();
}
inline void SpotCheckFeedbackResponse::clear_foot_height_results() {
  foot_height_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >&
SpotCheckFeedbackResponse::_internal_foot_height_results() const {
  return foot_height_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >&
SpotCheckFeedbackResponse::foot_height_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.foot_height_results)
  return _internal_foot_height_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_foot_height_results() {
  return foot_height_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::FootHeightCheckResult >*
SpotCheckFeedbackResponse::mutable_foot_height_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.foot_height_results)
  return _internal_mutable_foot_height_results();
}

// map<string, .bosdyn.api.spot.LegPairCheckResult> leg_pair_results = 11;
inline int SpotCheckFeedbackResponse::_internal_leg_pair_results_size() const {
  return leg_pair_results_.size();
}
inline int SpotCheckFeedbackResponse::leg_pair_results_size() const {
  return _internal_leg_pair_results_size();
}
inline void SpotCheckFeedbackResponse::clear_leg_pair_results() {
  leg_pair_results_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >&
SpotCheckFeedbackResponse::_internal_leg_pair_results() const {
  return leg_pair_results_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >&
SpotCheckFeedbackResponse::leg_pair_results() const {
  // @@protoc_insertion_point(field_map:bosdyn.api.spot.SpotCheckFeedbackResponse.leg_pair_results)
  return _internal_leg_pair_results();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >*
SpotCheckFeedbackResponse::_internal_mutable_leg_pair_results() {
  return leg_pair_results_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::bosdyn::api::spot::LegPairCheckResult >*
SpotCheckFeedbackResponse::mutable_leg_pair_results() {
  // @@protoc_insertion_point(field_mutable_map:bosdyn.api.spot.SpotCheckFeedbackResponse.leg_pair_results)
  return _internal_mutable_leg_pair_results();
}

// float progress = 7;
inline void SpotCheckFeedbackResponse::clear_progress() {
  progress_ = 0;
}
inline float SpotCheckFeedbackResponse::_internal_progress() const {
  return progress_;
}
inline float SpotCheckFeedbackResponse::progress() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.progress)
  return _internal_progress();
}
inline void SpotCheckFeedbackResponse::_internal_set_progress(float value) {
  
  progress_ = value;
}
inline void SpotCheckFeedbackResponse::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.SpotCheckFeedbackResponse.progress)
}

// .google.protobuf.Timestamp last_cal_timestamp = 9;
inline bool SpotCheckFeedbackResponse::_internal_has_last_cal_timestamp() const {
  return this != internal_default_instance() && last_cal_timestamp_ != nullptr;
}
inline bool SpotCheckFeedbackResponse::has_last_cal_timestamp() const {
  return _internal_has_last_cal_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& SpotCheckFeedbackResponse::_internal_last_cal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = last_cal_timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& SpotCheckFeedbackResponse::last_cal_timestamp() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
  return _internal_last_cal_timestamp();
}
inline void SpotCheckFeedbackResponse::unsafe_arena_set_allocated_last_cal_timestamp(
    PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_cal_timestamp_);
  }
  last_cal_timestamp_ = last_cal_timestamp;
  if (last_cal_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SpotCheckFeedbackResponse::release_last_cal_timestamp() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_cal_timestamp_;
  last_cal_timestamp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SpotCheckFeedbackResponse::unsafe_arena_release_last_cal_timestamp() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_cal_timestamp_;
  last_cal_timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SpotCheckFeedbackResponse::_internal_mutable_last_cal_timestamp() {
  
  if (last_cal_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    last_cal_timestamp_ = p;
  }
  return last_cal_timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SpotCheckFeedbackResponse::mutable_last_cal_timestamp() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
  return _internal_mutable_last_cal_timestamp();
}
inline void SpotCheckFeedbackResponse::set_allocated_last_cal_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* last_cal_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_cal_timestamp_);
  }
  if (last_cal_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_cal_timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      last_cal_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_cal_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  last_cal_timestamp_ = last_cal_timestamp;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.SpotCheckFeedbackResponse.last_cal_timestamp)
}

// -------------------------------------------------------------------

// DepthPlaneSpotCheckResult

// .bosdyn.api.spot.DepthPlaneSpotCheckResult.Status status = 1;
inline void DepthPlaneSpotCheckResult::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status DepthPlaneSpotCheckResult::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status >(status_);
}
inline ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status DepthPlaneSpotCheckResult::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DepthPlaneSpotCheckResult.status)
  return _internal_status();
}
inline void DepthPlaneSpotCheckResult::_internal_set_status(::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status value) {
  
  status_ = value;
}
inline void DepthPlaneSpotCheckResult::set_status(::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DepthPlaneSpotCheckResult.status)
}

// float severity_score = 2;
inline void DepthPlaneSpotCheckResult::clear_severity_score() {
  severity_score_ = 0;
}
inline float DepthPlaneSpotCheckResult::_internal_severity_score() const {
  return severity_score_;
}
inline float DepthPlaneSpotCheckResult::severity_score() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.DepthPlaneSpotCheckResult.severity_score)
  return _internal_severity_score();
}
inline void DepthPlaneSpotCheckResult::_internal_set_severity_score(float value) {
  
  severity_score_ = value;
}
inline void DepthPlaneSpotCheckResult::set_severity_score(float value) {
  _internal_set_severity_score(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.DepthPlaneSpotCheckResult.severity_score)
}

// -------------------------------------------------------------------

// PayloadCheckResult

// .bosdyn.api.spot.PayloadCheckResult.Error error = 1;
inline void PayloadCheckResult::clear_error() {
  error_ = 0;
}
inline ::bosdyn::api::spot::PayloadCheckResult_Error PayloadCheckResult::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::PayloadCheckResult_Error >(error_);
}
inline ::bosdyn::api::spot::PayloadCheckResult_Error PayloadCheckResult::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.PayloadCheckResult.error)
  return _internal_error();
}
inline void PayloadCheckResult::_internal_set_error(::bosdyn::api::spot::PayloadCheckResult_Error value) {
  
  error_ = value;
}
inline void PayloadCheckResult::set_error(::bosdyn::api::spot::PayloadCheckResult_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.PayloadCheckResult.error)
}

// float extra_payload = 2;
inline void PayloadCheckResult::clear_extra_payload() {
  extra_payload_ = 0;
}
inline float PayloadCheckResult::_internal_extra_payload() const {
  return extra_payload_;
}
inline float PayloadCheckResult::extra_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.PayloadCheckResult.extra_payload)
  return _internal_extra_payload();
}
inline void PayloadCheckResult::_internal_set_extra_payload(float value) {
  
  extra_payload_ = value;
}
inline void PayloadCheckResult::set_extra_payload(float value) {
  _internal_set_extra_payload(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.PayloadCheckResult.extra_payload)
}

// -------------------------------------------------------------------

// LoadCellSpotCheckResult

// .bosdyn.api.spot.LoadCellSpotCheckResult.Error error = 2;
inline void LoadCellSpotCheckResult::clear_error() {
  error_ = 0;
}
inline ::bosdyn::api::spot::LoadCellSpotCheckResult_Error LoadCellSpotCheckResult::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::LoadCellSpotCheckResult_Error >(error_);
}
inline ::bosdyn::api::spot::LoadCellSpotCheckResult_Error LoadCellSpotCheckResult::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoadCellSpotCheckResult.error)
  return _internal_error();
}
inline void LoadCellSpotCheckResult::_internal_set_error(::bosdyn::api::spot::LoadCellSpotCheckResult_Error value) {
  
  error_ = value;
}
inline void LoadCellSpotCheckResult::set_error(::bosdyn::api::spot::LoadCellSpotCheckResult_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoadCellSpotCheckResult.error)
}

// float zero = 3;
inline void LoadCellSpotCheckResult::clear_zero() {
  zero_ = 0;
}
inline float LoadCellSpotCheckResult::_internal_zero() const {
  return zero_;
}
inline float LoadCellSpotCheckResult::zero() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoadCellSpotCheckResult.zero)
  return _internal_zero();
}
inline void LoadCellSpotCheckResult::_internal_set_zero(float value) {
  
  zero_ = value;
}
inline void LoadCellSpotCheckResult::set_zero(float value) {
  _internal_set_zero(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoadCellSpotCheckResult.zero)
}

// float old_zero = 4;
inline void LoadCellSpotCheckResult::clear_old_zero() {
  old_zero_ = 0;
}
inline float LoadCellSpotCheckResult::_internal_old_zero() const {
  return old_zero_;
}
inline float LoadCellSpotCheckResult::old_zero() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LoadCellSpotCheckResult.old_zero)
  return _internal_old_zero();
}
inline void LoadCellSpotCheckResult::_internal_set_old_zero(float value) {
  
  old_zero_ = value;
}
inline void LoadCellSpotCheckResult::set_old_zero(float value) {
  _internal_set_old_zero(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LoadCellSpotCheckResult.old_zero)
}

// -------------------------------------------------------------------

// JointKinematicCheckResult

// .bosdyn.api.spot.JointKinematicCheckResult.Error error = 2;
inline void JointKinematicCheckResult::clear_error() {
  error_ = 0;
}
inline ::bosdyn::api::spot::JointKinematicCheckResult_Error JointKinematicCheckResult::_internal_error() const {
  return static_cast< ::bosdyn::api::spot::JointKinematicCheckResult_Error >(error_);
}
inline ::bosdyn::api::spot::JointKinematicCheckResult_Error JointKinematicCheckResult::error() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.JointKinematicCheckResult.error)
  return _internal_error();
}
inline void JointKinematicCheckResult::_internal_set_error(::bosdyn::api::spot::JointKinematicCheckResult_Error value) {
  
  error_ = value;
}
inline void JointKinematicCheckResult::set_error(::bosdyn::api::spot::JointKinematicCheckResult_Error value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.JointKinematicCheckResult.error)
}

// float offset = 3;
inline void JointKinematicCheckResult::clear_offset() {
  offset_ = 0;
}
inline float JointKinematicCheckResult::_internal_offset() const {
  return offset_;
}
inline float JointKinematicCheckResult::offset() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.JointKinematicCheckResult.offset)
  return _internal_offset();
}
inline void JointKinematicCheckResult::_internal_set_offset(float value) {
  
  offset_ = value;
}
inline void JointKinematicCheckResult::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.JointKinematicCheckResult.offset)
}

// float old_offset = 4;
inline void JointKinematicCheckResult::clear_old_offset() {
  old_offset_ = 0;
}
inline float JointKinematicCheckResult::_internal_old_offset() const {
  return old_offset_;
}
inline float JointKinematicCheckResult::old_offset() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.JointKinematicCheckResult.old_offset)
  return _internal_old_offset();
}
inline void JointKinematicCheckResult::_internal_set_old_offset(float value) {
  
  old_offset_ = value;
}
inline void JointKinematicCheckResult::set_old_offset(float value) {
  _internal_set_old_offset(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.JointKinematicCheckResult.old_offset)
}

// float health_score = 5;
inline void JointKinematicCheckResult::clear_health_score() {
  health_score_ = 0;
}
inline float JointKinematicCheckResult::_internal_health_score() const {
  return health_score_;
}
inline float JointKinematicCheckResult::health_score() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.JointKinematicCheckResult.health_score)
  return _internal_health_score();
}
inline void JointKinematicCheckResult::_internal_set_health_score(float value) {
  
  health_score_ = value;
}
inline void JointKinematicCheckResult::set_health_score(float value) {
  _internal_set_health_score(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.JointKinematicCheckResult.health_score)
}

// -------------------------------------------------------------------

// FootHeightCheckResult

// .bosdyn.api.spot.FootHeightCheckResult.Status status = 2;
inline void FootHeightCheckResult::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::spot::FootHeightCheckResult_Status FootHeightCheckResult::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::FootHeightCheckResult_Status >(status_);
}
inline ::bosdyn::api::spot::FootHeightCheckResult_Status FootHeightCheckResult::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.FootHeightCheckResult.status)
  return _internal_status();
}
inline void FootHeightCheckResult::_internal_set_status(::bosdyn::api::spot::FootHeightCheckResult_Status value) {
  
  status_ = value;
}
inline void FootHeightCheckResult::set_status(::bosdyn::api::spot::FootHeightCheckResult_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.FootHeightCheckResult.status)
}

// float foot_height_error_from_mean = 3;
inline void FootHeightCheckResult::clear_foot_height_error_from_mean() {
  foot_height_error_from_mean_ = 0;
}
inline float FootHeightCheckResult::_internal_foot_height_error_from_mean() const {
  return foot_height_error_from_mean_;
}
inline float FootHeightCheckResult::foot_height_error_from_mean() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.FootHeightCheckResult.foot_height_error_from_mean)
  return _internal_foot_height_error_from_mean();
}
inline void FootHeightCheckResult::_internal_set_foot_height_error_from_mean(float value) {
  
  foot_height_error_from_mean_ = value;
}
inline void FootHeightCheckResult::set_foot_height_error_from_mean(float value) {
  _internal_set_foot_height_error_from_mean(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.FootHeightCheckResult.foot_height_error_from_mean)
}

// -------------------------------------------------------------------

// LegPairCheckResult

// .bosdyn.api.spot.LegPairCheckResult.Status status = 2;
inline void LegPairCheckResult::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::spot::LegPairCheckResult_Status LegPairCheckResult::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::LegPairCheckResult_Status >(status_);
}
inline ::bosdyn::api::spot::LegPairCheckResult_Status LegPairCheckResult::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LegPairCheckResult.status)
  return _internal_status();
}
inline void LegPairCheckResult::_internal_set_status(::bosdyn::api::spot::LegPairCheckResult_Status value) {
  
  status_ = value;
}
inline void LegPairCheckResult::set_status(::bosdyn::api::spot::LegPairCheckResult_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LegPairCheckResult.status)
}

// float leg_pair_distance_change = 3;
inline void LegPairCheckResult::clear_leg_pair_distance_change() {
  leg_pair_distance_change_ = 0;
}
inline float LegPairCheckResult::_internal_leg_pair_distance_change() const {
  return leg_pair_distance_change_;
}
inline float LegPairCheckResult::leg_pair_distance_change() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.LegPairCheckResult.leg_pair_distance_change)
  return _internal_leg_pair_distance_change();
}
inline void LegPairCheckResult::_internal_set_leg_pair_distance_change(float value) {
  
  leg_pair_distance_change_ = value;
}
inline void LegPairCheckResult::set_leg_pair_distance_change(float value) {
  _internal_set_leg_pair_distance_change(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.LegPairCheckResult.leg_pair_distance_change)
}

// -------------------------------------------------------------------

// CameraCalibrationCommandRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool CameraCalibrationCommandRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CameraCalibrationCommandRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& CameraCalibrationCommandRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& CameraCalibrationCommandRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
  return _internal_header();
}
inline void CameraCalibrationCommandRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationCommandRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationCommandRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationCommandRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationCommandRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
  return _internal_mutable_header();
}
inline void CameraCalibrationCommandRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationCommandRequest.header)
}

// .bosdyn.api.Lease lease = 2;
inline bool CameraCalibrationCommandRequest::_internal_has_lease() const {
  return this != internal_default_instance() && lease_ != nullptr;
}
inline bool CameraCalibrationCommandRequest::has_lease() const {
  return _internal_has_lease();
}
inline const ::bosdyn::api::Lease& CameraCalibrationCommandRequest::_internal_lease() const {
  const ::bosdyn::api::Lease* p = lease_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Lease*>(
      &::bosdyn::api::_Lease_default_instance_);
}
inline const ::bosdyn::api::Lease& CameraCalibrationCommandRequest::lease() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
  return _internal_lease();
}
inline void CameraCalibrationCommandRequest::unsafe_arena_set_allocated_lease(
    ::bosdyn::api::Lease* lease) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  lease_ = lease;
  if (lease) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
}
inline ::bosdyn::api::Lease* CameraCalibrationCommandRequest::release_lease() {
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Lease* CameraCalibrationCommandRequest::unsafe_arena_release_lease() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
  
  ::bosdyn::api::Lease* temp = lease_;
  lease_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Lease* CameraCalibrationCommandRequest::_internal_mutable_lease() {
  
  if (lease_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Lease>(GetArena());
    lease_ = p;
  }
  return lease_;
}
inline ::bosdyn::api::Lease* CameraCalibrationCommandRequest::mutable_lease() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
  return _internal_mutable_lease();
}
inline void CameraCalibrationCommandRequest::set_allocated_lease(::bosdyn::api::Lease* lease) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_);
  }
  if (lease) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease)->GetArena();
    if (message_arena != submessage_arena) {
      lease = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease, submessage_arena);
    }
    
  } else {
    
  }
  lease_ = lease;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationCommandRequest.lease)
}

// .bosdyn.api.spot.CameraCalibrationCommandRequest.Command command = 3;
inline void CameraCalibrationCommandRequest::clear_command() {
  command_ = 0;
}
inline ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command CameraCalibrationCommandRequest::_internal_command() const {
  return static_cast< ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command >(command_);
}
inline ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command CameraCalibrationCommandRequest::command() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandRequest.command)
  return _internal_command();
}
inline void CameraCalibrationCommandRequest::_internal_set_command(::bosdyn::api::spot::CameraCalibrationCommandRequest_Command value) {
  
  command_ = value;
}
inline void CameraCalibrationCommandRequest::set_command(::bosdyn::api::spot::CameraCalibrationCommandRequest_Command value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.CameraCalibrationCommandRequest.command)
}

// -------------------------------------------------------------------

// CameraCalibrationCommandResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool CameraCalibrationCommandResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CameraCalibrationCommandResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& CameraCalibrationCommandResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& CameraCalibrationCommandResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
  return _internal_header();
}
inline void CameraCalibrationCommandResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationCommandResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationCommandResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationCommandResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationCommandResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
  return _internal_mutable_header();
}
inline void CameraCalibrationCommandResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationCommandResponse.header)
}

// .bosdyn.api.LeaseUseResult lease_use_result = 2;
inline bool CameraCalibrationCommandResponse::_internal_has_lease_use_result() const {
  return this != internal_default_instance() && lease_use_result_ != nullptr;
}
inline bool CameraCalibrationCommandResponse::has_lease_use_result() const {
  return _internal_has_lease_use_result();
}
inline const ::bosdyn::api::LeaseUseResult& CameraCalibrationCommandResponse::_internal_lease_use_result() const {
  const ::bosdyn::api::LeaseUseResult* p = lease_use_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::LeaseUseResult*>(
      &::bosdyn::api::_LeaseUseResult_default_instance_);
}
inline const ::bosdyn::api::LeaseUseResult& CameraCalibrationCommandResponse::lease_use_result() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
  return _internal_lease_use_result();
}
inline void CameraCalibrationCommandResponse::unsafe_arena_set_allocated_lease_use_result(
    ::bosdyn::api::LeaseUseResult* lease_use_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  lease_use_result_ = lease_use_result;
  if (lease_use_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
}
inline ::bosdyn::api::LeaseUseResult* CameraCalibrationCommandResponse::release_lease_use_result() {
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* CameraCalibrationCommandResponse::unsafe_arena_release_lease_use_result() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
  
  ::bosdyn::api::LeaseUseResult* temp = lease_use_result_;
  lease_use_result_ = nullptr;
  return temp;
}
inline ::bosdyn::api::LeaseUseResult* CameraCalibrationCommandResponse::_internal_mutable_lease_use_result() {
  
  if (lease_use_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::LeaseUseResult>(GetArena());
    lease_use_result_ = p;
  }
  return lease_use_result_;
}
inline ::bosdyn::api::LeaseUseResult* CameraCalibrationCommandResponse::mutable_lease_use_result() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
  return _internal_mutable_lease_use_result();
}
inline void CameraCalibrationCommandResponse::set_allocated_lease_use_result(::bosdyn::api::LeaseUseResult* lease_use_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result_);
  }
  if (lease_use_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lease_use_result)->GetArena();
    if (message_arena != submessage_arena) {
      lease_use_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lease_use_result, submessage_arena);
    }
    
  } else {
    
  }
  lease_use_result_ = lease_use_result;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationCommandResponse.lease_use_result)
}

// -------------------------------------------------------------------

// CameraCalibrationFeedbackRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool CameraCalibrationFeedbackRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CameraCalibrationFeedbackRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& CameraCalibrationFeedbackRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& CameraCalibrationFeedbackRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
  return _internal_header();
}
inline void CameraCalibrationFeedbackRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationFeedbackRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationFeedbackRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationFeedbackRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* CameraCalibrationFeedbackRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
  return _internal_mutable_header();
}
inline void CameraCalibrationFeedbackRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationFeedbackRequest.header)
}

// -------------------------------------------------------------------

// CameraCalibrationFeedbackResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool CameraCalibrationFeedbackResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CameraCalibrationFeedbackResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& CameraCalibrationFeedbackResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& CameraCalibrationFeedbackResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
  return _internal_header();
}
inline void CameraCalibrationFeedbackResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationFeedbackResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationFeedbackResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationFeedbackResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* CameraCalibrationFeedbackResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
  return _internal_mutable_header();
}
inline void CameraCalibrationFeedbackResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.spot.CameraCalibrationFeedbackResponse.header)
}

// .bosdyn.api.spot.CameraCalibrationFeedbackResponse.Status status = 2;
inline void CameraCalibrationFeedbackResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status CameraCalibrationFeedbackResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status >(status_);
}
inline ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status CameraCalibrationFeedbackResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationFeedbackResponse.status)
  return _internal_status();
}
inline void CameraCalibrationFeedbackResponse::_internal_set_status(::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status value) {
  
  status_ = value;
}
inline void CameraCalibrationFeedbackResponse::set_status(::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.CameraCalibrationFeedbackResponse.status)
}

// float progress = 3;
inline void CameraCalibrationFeedbackResponse::clear_progress() {
  progress_ = 0;
}
inline float CameraCalibrationFeedbackResponse::_internal_progress() const {
  return progress_;
}
inline float CameraCalibrationFeedbackResponse::progress() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.spot.CameraCalibrationFeedbackResponse.progress)
  return _internal_progress();
}
inline void CameraCalibrationFeedbackResponse::_internal_set_progress(float value) {
  
  progress_ = value;
}
inline void CameraCalibrationFeedbackResponse::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.spot.CameraCalibrationFeedbackResponse.progress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spot
}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::spot::SpotCheckCommandRequest_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SpotCheckCommandRequest_Command>() {
  return ::bosdyn::api::spot::SpotCheckCommandRequest_Command_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::SpotCheckFeedbackResponse_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SpotCheckFeedbackResponse_State>() {
  return ::bosdyn::api::spot::SpotCheckFeedbackResponse_State_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error>() {
  return ::bosdyn::api::spot::SpotCheckFeedbackResponse_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status>() {
  return ::bosdyn::api::spot::DepthPlaneSpotCheckResult_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::PayloadCheckResult_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::PayloadCheckResult_Error>() {
  return ::bosdyn::api::spot::PayloadCheckResult_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::LoadCellSpotCheckResult_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::LoadCellSpotCheckResult_Error>() {
  return ::bosdyn::api::spot::LoadCellSpotCheckResult_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::JointKinematicCheckResult_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::JointKinematicCheckResult_Error>() {
  return ::bosdyn::api::spot::JointKinematicCheckResult_Error_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::FootHeightCheckResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::FootHeightCheckResult_Status>() {
  return ::bosdyn::api::spot::FootHeightCheckResult_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::LegPairCheckResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::LegPairCheckResult_Status>() {
  return ::bosdyn::api::spot::LegPairCheckResult_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command>() {
  return ::bosdyn::api::spot::CameraCalibrationCommandRequest_Command_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status>() {
  return ::bosdyn::api::spot::CameraCalibrationFeedbackResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fspot_2fspot_5fcheck_2eproto
