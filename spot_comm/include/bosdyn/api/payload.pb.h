// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/payload.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpayload_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpayload_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/geometry.pb.h"
#include "bosdyn/api/header.pb.h"
#include "bosdyn/api/robot_id.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2fpayload_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2fpayload_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2fpayload_2eproto;
namespace bosdyn {
namespace api {
class JointLimits;
class JointLimitsDefaultTypeInternal;
extern JointLimitsDefaultTypeInternal _JointLimits_default_instance_;
class ListPayloadsRequest;
class ListPayloadsRequestDefaultTypeInternal;
extern ListPayloadsRequestDefaultTypeInternal _ListPayloadsRequest_default_instance_;
class ListPayloadsResponse;
class ListPayloadsResponseDefaultTypeInternal;
extern ListPayloadsResponseDefaultTypeInternal _ListPayloadsResponse_default_instance_;
class MomentOfIntertia;
class MomentOfIntertiaDefaultTypeInternal;
extern MomentOfIntertiaDefaultTypeInternal _MomentOfIntertia_default_instance_;
class Payload;
class PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class PayloadMassVolumeProperties;
class PayloadMassVolumePropertiesDefaultTypeInternal;
extern PayloadMassVolumePropertiesDefaultTypeInternal _PayloadMassVolumeProperties_default_instance_;
class PayloadPreset;
class PayloadPresetDefaultTypeInternal;
extern PayloadPresetDefaultTypeInternal _PayloadPreset_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::JointLimits* Arena::CreateMaybeMessage<::bosdyn::api::JointLimits>(Arena*);
template<> ::bosdyn::api::ListPayloadsRequest* Arena::CreateMaybeMessage<::bosdyn::api::ListPayloadsRequest>(Arena*);
template<> ::bosdyn::api::ListPayloadsResponse* Arena::CreateMaybeMessage<::bosdyn::api::ListPayloadsResponse>(Arena*);
template<> ::bosdyn::api::MomentOfIntertia* Arena::CreateMaybeMessage<::bosdyn::api::MomentOfIntertia>(Arena*);
template<> ::bosdyn::api::Payload* Arena::CreateMaybeMessage<::bosdyn::api::Payload>(Arena*);
template<> ::bosdyn::api::PayloadMassVolumeProperties* Arena::CreateMaybeMessage<::bosdyn::api::PayloadMassVolumeProperties>(Arena*);
template<> ::bosdyn::api::PayloadPreset* Arena::CreateMaybeMessage<::bosdyn::api::PayloadPreset>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

// ===================================================================

class Payload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  virtual ~Payload();

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Payload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Payload* New() const final {
    return CreateMaybeMessage<Payload>(nullptr);
  }

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Payload& from);
  void MergeFrom(const Payload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fpayload_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fpayload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelPrefixFieldNumber = 9,
    kPresetConfigurationsFieldNumber = 11,
    kGUIDFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kBodyTformPayloadFieldNumber = 7,
    kMountTformPayloadFieldNumber = 8,
    kMassVolumePropertiesFieldNumber = 10,
    kVersionFieldNumber = 12,
    kIsAuthorizedFieldNumber = 4,
    kIsEnabledFieldNumber = 5,
    kIsNoncomputePayloadFieldNumber = 6,
  };
  // repeated string label_prefix = 9;
  int label_prefix_size() const;
  private:
  int _internal_label_prefix_size() const;
  public:
  void clear_label_prefix();
  const std::string& label_prefix(int index) const;
  std::string* mutable_label_prefix(int index);
  void set_label_prefix(int index, const std::string& value);
  void set_label_prefix(int index, std::string&& value);
  void set_label_prefix(int index, const char* value);
  void set_label_prefix(int index, const char* value, size_t size);
  std::string* add_label_prefix();
  void add_label_prefix(const std::string& value);
  void add_label_prefix(std::string&& value);
  void add_label_prefix(const char* value);
  void add_label_prefix(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& label_prefix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_label_prefix();
  private:
  const std::string& _internal_label_prefix(int index) const;
  std::string* _internal_add_label_prefix();
  public:

  // repeated .bosdyn.api.PayloadPreset preset_configurations = 11;
  int preset_configurations_size() const;
  private:
  int _internal_preset_configurations_size() const;
  public:
  void clear_preset_configurations();
  ::bosdyn::api::PayloadPreset* mutable_preset_configurations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset >*
      mutable_preset_configurations();
  private:
  const ::bosdyn::api::PayloadPreset& _internal_preset_configurations(int index) const;
  ::bosdyn::api::PayloadPreset* _internal_add_preset_configurations();
  public:
  const ::bosdyn::api::PayloadPreset& preset_configurations(int index) const;
  ::bosdyn::api::PayloadPreset* add_preset_configurations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset >&
      preset_configurations() const;

  // string GUID = 1;
  void clear_guid();
  const std::string& guid() const;
  void set_guid(const std::string& value);
  void set_guid(std::string&& value);
  void set_guid(const char* value);
  void set_guid(const char* value, size_t size);
  std::string* mutable_guid();
  std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .bosdyn.api.SE3Pose body_tform_payload = 7;
  bool has_body_tform_payload() const;
  private:
  bool _internal_has_body_tform_payload() const;
  public:
  void clear_body_tform_payload();
  const ::bosdyn::api::SE3Pose& body_tform_payload() const;
  ::bosdyn::api::SE3Pose* release_body_tform_payload();
  ::bosdyn::api::SE3Pose* mutable_body_tform_payload();
  void set_allocated_body_tform_payload(::bosdyn::api::SE3Pose* body_tform_payload);
  private:
  const ::bosdyn::api::SE3Pose& _internal_body_tform_payload() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_body_tform_payload();
  public:
  void unsafe_arena_set_allocated_body_tform_payload(
      ::bosdyn::api::SE3Pose* body_tform_payload);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_body_tform_payload();

  // .bosdyn.api.SE3Pose mount_tform_payload = 8;
  bool has_mount_tform_payload() const;
  private:
  bool _internal_has_mount_tform_payload() const;
  public:
  void clear_mount_tform_payload();
  const ::bosdyn::api::SE3Pose& mount_tform_payload() const;
  ::bosdyn::api::SE3Pose* release_mount_tform_payload();
  ::bosdyn::api::SE3Pose* mutable_mount_tform_payload();
  void set_allocated_mount_tform_payload(::bosdyn::api::SE3Pose* mount_tform_payload);
  private:
  const ::bosdyn::api::SE3Pose& _internal_mount_tform_payload() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_mount_tform_payload();
  public:
  void unsafe_arena_set_allocated_mount_tform_payload(
      ::bosdyn::api::SE3Pose* mount_tform_payload);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_mount_tform_payload();

  // .bosdyn.api.PayloadMassVolumeProperties mass_volume_properties = 10;
  bool has_mass_volume_properties() const;
  private:
  bool _internal_has_mass_volume_properties() const;
  public:
  void clear_mass_volume_properties();
  const ::bosdyn::api::PayloadMassVolumeProperties& mass_volume_properties() const;
  ::bosdyn::api::PayloadMassVolumeProperties* release_mass_volume_properties();
  ::bosdyn::api::PayloadMassVolumeProperties* mutable_mass_volume_properties();
  void set_allocated_mass_volume_properties(::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties);
  private:
  const ::bosdyn::api::PayloadMassVolumeProperties& _internal_mass_volume_properties() const;
  ::bosdyn::api::PayloadMassVolumeProperties* _internal_mutable_mass_volume_properties();
  public:
  void unsafe_arena_set_allocated_mass_volume_properties(
      ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties);
  ::bosdyn::api::PayloadMassVolumeProperties* unsafe_arena_release_mass_volume_properties();

  // .bosdyn.api.SoftwareVersion version = 12;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::bosdyn::api::SoftwareVersion& version() const;
  ::bosdyn::api::SoftwareVersion* release_version();
  ::bosdyn::api::SoftwareVersion* mutable_version();
  void set_allocated_version(::bosdyn::api::SoftwareVersion* version);
  private:
  const ::bosdyn::api::SoftwareVersion& _internal_version() const;
  ::bosdyn::api::SoftwareVersion* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::bosdyn::api::SoftwareVersion* version);
  ::bosdyn::api::SoftwareVersion* unsafe_arena_release_version();

  // bool is_authorized = 4;
  void clear_is_authorized();
  bool is_authorized() const;
  void set_is_authorized(bool value);
  private:
  bool _internal_is_authorized() const;
  void _internal_set_is_authorized(bool value);
  public:

  // bool is_enabled = 5;
  void clear_is_enabled();
  bool is_enabled() const;
  void set_is_enabled(bool value);
  private:
  bool _internal_is_enabled() const;
  void _internal_set_is_enabled(bool value);
  public:

  // bool is_noncompute_payload = 6;
  void clear_is_noncompute_payload();
  bool is_noncompute_payload() const;
  void set_is_noncompute_payload(bool value);
  private:
  bool _internal_is_noncompute_payload() const;
  void _internal_set_is_noncompute_payload(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> label_prefix_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset > preset_configurations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::bosdyn::api::SE3Pose* body_tform_payload_;
  ::bosdyn::api::SE3Pose* mount_tform_payload_;
  ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties_;
  ::bosdyn::api::SoftwareVersion* version_;
  bool is_authorized_;
  bool is_enabled_;
  bool is_noncompute_payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class PayloadPreset PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PayloadPreset) */ {
 public:
  inline PayloadPreset() : PayloadPreset(nullptr) {}
  virtual ~PayloadPreset();

  PayloadPreset(const PayloadPreset& from);
  PayloadPreset(PayloadPreset&& from) noexcept
    : PayloadPreset() {
    *this = ::std::move(from);
  }

  inline PayloadPreset& operator=(const PayloadPreset& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadPreset& operator=(PayloadPreset&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PayloadPreset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PayloadPreset* internal_default_instance() {
    return reinterpret_cast<const PayloadPreset*>(
               &_PayloadPreset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PayloadPreset& a, PayloadPreset& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadPreset* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadPreset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PayloadPreset* New() const final {
    return CreateMaybeMessage<PayloadPreset>(nullptr);
  }

  PayloadPreset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PayloadPreset>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PayloadPreset& from);
  void MergeFrom(const PayloadPreset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PayloadPreset* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PayloadPreset";
  }
  protected:
  explicit PayloadPreset(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fpayload_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fpayload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelPrefixFieldNumber = 5,
    kPresetNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kMountTformPayloadFieldNumber = 3,
    kMassVolumePropertiesFieldNumber = 4,
  };
  // repeated string label_prefix = 5;
  int label_prefix_size() const;
  private:
  int _internal_label_prefix_size() const;
  public:
  void clear_label_prefix();
  const std::string& label_prefix(int index) const;
  std::string* mutable_label_prefix(int index);
  void set_label_prefix(int index, const std::string& value);
  void set_label_prefix(int index, std::string&& value);
  void set_label_prefix(int index, const char* value);
  void set_label_prefix(int index, const char* value, size_t size);
  std::string* add_label_prefix();
  void add_label_prefix(const std::string& value);
  void add_label_prefix(std::string&& value);
  void add_label_prefix(const char* value);
  void add_label_prefix(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& label_prefix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_label_prefix();
  private:
  const std::string& _internal_label_prefix(int index) const;
  std::string* _internal_add_label_prefix();
  public:

  // string preset_name = 1;
  void clear_preset_name();
  const std::string& preset_name() const;
  void set_preset_name(const std::string& value);
  void set_preset_name(std::string&& value);
  void set_preset_name(const char* value);
  void set_preset_name(const char* value, size_t size);
  std::string* mutable_preset_name();
  std::string* release_preset_name();
  void set_allocated_preset_name(std::string* preset_name);
  private:
  const std::string& _internal_preset_name() const;
  void _internal_set_preset_name(const std::string& value);
  std::string* _internal_mutable_preset_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .bosdyn.api.SE3Pose mount_tform_payload = 3;
  bool has_mount_tform_payload() const;
  private:
  bool _internal_has_mount_tform_payload() const;
  public:
  void clear_mount_tform_payload();
  const ::bosdyn::api::SE3Pose& mount_tform_payload() const;
  ::bosdyn::api::SE3Pose* release_mount_tform_payload();
  ::bosdyn::api::SE3Pose* mutable_mount_tform_payload();
  void set_allocated_mount_tform_payload(::bosdyn::api::SE3Pose* mount_tform_payload);
  private:
  const ::bosdyn::api::SE3Pose& _internal_mount_tform_payload() const;
  ::bosdyn::api::SE3Pose* _internal_mutable_mount_tform_payload();
  public:
  void unsafe_arena_set_allocated_mount_tform_payload(
      ::bosdyn::api::SE3Pose* mount_tform_payload);
  ::bosdyn::api::SE3Pose* unsafe_arena_release_mount_tform_payload();

  // .bosdyn.api.PayloadMassVolumeProperties mass_volume_properties = 4;
  bool has_mass_volume_properties() const;
  private:
  bool _internal_has_mass_volume_properties() const;
  public:
  void clear_mass_volume_properties();
  const ::bosdyn::api::PayloadMassVolumeProperties& mass_volume_properties() const;
  ::bosdyn::api::PayloadMassVolumeProperties* release_mass_volume_properties();
  ::bosdyn::api::PayloadMassVolumeProperties* mutable_mass_volume_properties();
  void set_allocated_mass_volume_properties(::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties);
  private:
  const ::bosdyn::api::PayloadMassVolumeProperties& _internal_mass_volume_properties() const;
  ::bosdyn::api::PayloadMassVolumeProperties* _internal_mutable_mass_volume_properties();
  public:
  void unsafe_arena_set_allocated_mass_volume_properties(
      ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties);
  ::bosdyn::api::PayloadMassVolumeProperties* unsafe_arena_release_mass_volume_properties();

  // @@protoc_insertion_point(class_scope:bosdyn.api.PayloadPreset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> label_prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preset_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::bosdyn::api::SE3Pose* mount_tform_payload_;
  ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class PayloadMassVolumeProperties PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.PayloadMassVolumeProperties) */ {
 public:
  inline PayloadMassVolumeProperties() : PayloadMassVolumeProperties(nullptr) {}
  virtual ~PayloadMassVolumeProperties();

  PayloadMassVolumeProperties(const PayloadMassVolumeProperties& from);
  PayloadMassVolumeProperties(PayloadMassVolumeProperties&& from) noexcept
    : PayloadMassVolumeProperties() {
    *this = ::std::move(from);
  }

  inline PayloadMassVolumeProperties& operator=(const PayloadMassVolumeProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline PayloadMassVolumeProperties& operator=(PayloadMassVolumeProperties&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PayloadMassVolumeProperties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PayloadMassVolumeProperties* internal_default_instance() {
    return reinterpret_cast<const PayloadMassVolumeProperties*>(
               &_PayloadMassVolumeProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PayloadMassVolumeProperties& a, PayloadMassVolumeProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(PayloadMassVolumeProperties* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PayloadMassVolumeProperties* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PayloadMassVolumeProperties* New() const final {
    return CreateMaybeMessage<PayloadMassVolumeProperties>(nullptr);
  }

  PayloadMassVolumeProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PayloadMassVolumeProperties>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PayloadMassVolumeProperties& from);
  void MergeFrom(const PayloadMassVolumeProperties& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PayloadMassVolumeProperties* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.PayloadMassVolumeProperties";
  }
  protected:
  explicit PayloadMassVolumeProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fpayload_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fpayload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundingBoxFieldNumber = 5,
    kJointLimitsFieldNumber = 6,
    kComPosRtPayloadFieldNumber = 3,
    kMoiTensorFieldNumber = 4,
    kTotalMassFieldNumber = 2,
  };
  // repeated .bosdyn.api.Box3WithFrame bounding_box = 5;
  int bounding_box_size() const;
  private:
  int _internal_bounding_box_size() const;
  public:
  void clear_bounding_box();
  ::bosdyn::api::Box3WithFrame* mutable_bounding_box(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame >*
      mutable_bounding_box();
  private:
  const ::bosdyn::api::Box3WithFrame& _internal_bounding_box(int index) const;
  ::bosdyn::api::Box3WithFrame* _internal_add_bounding_box();
  public:
  const ::bosdyn::api::Box3WithFrame& bounding_box(int index) const;
  ::bosdyn::api::Box3WithFrame* add_bounding_box();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame >&
      bounding_box() const;

  // repeated .bosdyn.api.JointLimits joint_limits = 6;
  int joint_limits_size() const;
  private:
  int _internal_joint_limits_size() const;
  public:
  void clear_joint_limits();
  ::bosdyn::api::JointLimits* mutable_joint_limits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits >*
      mutable_joint_limits();
  private:
  const ::bosdyn::api::JointLimits& _internal_joint_limits(int index) const;
  ::bosdyn::api::JointLimits* _internal_add_joint_limits();
  public:
  const ::bosdyn::api::JointLimits& joint_limits(int index) const;
  ::bosdyn::api::JointLimits* add_joint_limits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits >&
      joint_limits() const;

  // .bosdyn.api.Vec3 com_pos_rt_payload = 3;
  bool has_com_pos_rt_payload() const;
  private:
  bool _internal_has_com_pos_rt_payload() const;
  public:
  void clear_com_pos_rt_payload();
  const ::bosdyn::api::Vec3& com_pos_rt_payload() const;
  ::bosdyn::api::Vec3* release_com_pos_rt_payload();
  ::bosdyn::api::Vec3* mutable_com_pos_rt_payload();
  void set_allocated_com_pos_rt_payload(::bosdyn::api::Vec3* com_pos_rt_payload);
  private:
  const ::bosdyn::api::Vec3& _internal_com_pos_rt_payload() const;
  ::bosdyn::api::Vec3* _internal_mutable_com_pos_rt_payload();
  public:
  void unsafe_arena_set_allocated_com_pos_rt_payload(
      ::bosdyn::api::Vec3* com_pos_rt_payload);
  ::bosdyn::api::Vec3* unsafe_arena_release_com_pos_rt_payload();

  // .bosdyn.api.MomentOfIntertia moi_tensor = 4;
  bool has_moi_tensor() const;
  private:
  bool _internal_has_moi_tensor() const;
  public:
  void clear_moi_tensor();
  const ::bosdyn::api::MomentOfIntertia& moi_tensor() const;
  ::bosdyn::api::MomentOfIntertia* release_moi_tensor();
  ::bosdyn::api::MomentOfIntertia* mutable_moi_tensor();
  void set_allocated_moi_tensor(::bosdyn::api::MomentOfIntertia* moi_tensor);
  private:
  const ::bosdyn::api::MomentOfIntertia& _internal_moi_tensor() const;
  ::bosdyn::api::MomentOfIntertia* _internal_mutable_moi_tensor();
  public:
  void unsafe_arena_set_allocated_moi_tensor(
      ::bosdyn::api::MomentOfIntertia* moi_tensor);
  ::bosdyn::api::MomentOfIntertia* unsafe_arena_release_moi_tensor();

  // float total_mass = 2;
  void clear_total_mass();
  float total_mass() const;
  void set_total_mass(float value);
  private:
  float _internal_total_mass() const;
  void _internal_set_total_mass(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.PayloadMassVolumeProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame > bounding_box_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits > joint_limits_;
  ::bosdyn::api::Vec3* com_pos_rt_payload_;
  ::bosdyn::api::MomentOfIntertia* moi_tensor_;
  float total_mass_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class MomentOfIntertia PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.MomentOfIntertia) */ {
 public:
  inline MomentOfIntertia() : MomentOfIntertia(nullptr) {}
  virtual ~MomentOfIntertia();

  MomentOfIntertia(const MomentOfIntertia& from);
  MomentOfIntertia(MomentOfIntertia&& from) noexcept
    : MomentOfIntertia() {
    *this = ::std::move(from);
  }

  inline MomentOfIntertia& operator=(const MomentOfIntertia& from) {
    CopyFrom(from);
    return *this;
  }
  inline MomentOfIntertia& operator=(MomentOfIntertia&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MomentOfIntertia& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MomentOfIntertia* internal_default_instance() {
    return reinterpret_cast<const MomentOfIntertia*>(
               &_MomentOfIntertia_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MomentOfIntertia& a, MomentOfIntertia& b) {
    a.Swap(&b);
  }
  inline void Swap(MomentOfIntertia* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MomentOfIntertia* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MomentOfIntertia* New() const final {
    return CreateMaybeMessage<MomentOfIntertia>(nullptr);
  }

  MomentOfIntertia* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MomentOfIntertia>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MomentOfIntertia& from);
  void MergeFrom(const MomentOfIntertia& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MomentOfIntertia* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.MomentOfIntertia";
  }
  protected:
  explicit MomentOfIntertia(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fpayload_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fpayload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXxFieldNumber = 2,
    kYyFieldNumber = 3,
    kZzFieldNumber = 4,
    kXyFieldNumber = 5,
    kXzFieldNumber = 6,
    kYzFieldNumber = 7,
  };
  // float xx = 2;
  void clear_xx();
  float xx() const;
  void set_xx(float value);
  private:
  float _internal_xx() const;
  void _internal_set_xx(float value);
  public:

  // float yy = 3;
  void clear_yy();
  float yy() const;
  void set_yy(float value);
  private:
  float _internal_yy() const;
  void _internal_set_yy(float value);
  public:

  // float zz = 4;
  void clear_zz();
  float zz() const;
  void set_zz(float value);
  private:
  float _internal_zz() const;
  void _internal_set_zz(float value);
  public:

  // float xy = 5;
  void clear_xy();
  float xy() const;
  void set_xy(float value);
  private:
  float _internal_xy() const;
  void _internal_set_xy(float value);
  public:

  // float xz = 6;
  void clear_xz();
  float xz() const;
  void set_xz(float value);
  private:
  float _internal_xz() const;
  void _internal_set_xz(float value);
  public:

  // float yz = 7;
  void clear_yz();
  float yz() const;
  void set_yz(float value);
  private:
  float _internal_yz() const;
  void _internal_set_yz(float value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.MomentOfIntertia)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float xx_;
  float yy_;
  float zz_;
  float xy_;
  float xz_;
  float yz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class JointLimits PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.JointLimits) */ {
 public:
  inline JointLimits() : JointLimits(nullptr) {}
  virtual ~JointLimits();

  JointLimits(const JointLimits& from);
  JointLimits(JointLimits&& from) noexcept
    : JointLimits() {
    *this = ::std::move(from);
  }

  inline JointLimits& operator=(const JointLimits& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointLimits& operator=(JointLimits&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JointLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointLimits* internal_default_instance() {
    return reinterpret_cast<const JointLimits*>(
               &_JointLimits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JointLimits& a, JointLimits& b) {
    a.Swap(&b);
  }
  inline void Swap(JointLimits* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointLimits* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointLimits* New() const final {
    return CreateMaybeMessage<JointLimits>(nullptr);
  }

  JointLimits* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointLimits>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JointLimits& from);
  void MergeFrom(const JointLimits& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointLimits* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.JointLimits";
  }
  protected:
  explicit JointLimits(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fpayload_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fpayload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHyFieldNumber = 3,
    kHxFieldNumber = 4,
    kLabelFieldNumber = 2,
  };
  // repeated float hy = 3;
  int hy_size() const;
  private:
  int _internal_hy_size() const;
  public:
  void clear_hy();
  private:
  float _internal_hy(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_hy() const;
  void _internal_add_hy(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_hy();
  public:
  float hy(int index) const;
  void set_hy(int index, float value);
  void add_hy(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      hy() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_hy();

  // repeated float hx = 4;
  int hx_size() const;
  private:
  int _internal_hx_size() const;
  public:
  void clear_hx();
  private:
  float _internal_hx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_hx() const;
  void _internal_add_hx(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_hx();
  public:
  float hx(int index) const;
  void set_hx(int index, float value);
  void add_hx(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      hx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_hx();

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  void set_label(const std::string& value);
  void set_label(std::string&& value);
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  std::string* mutable_label();
  std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.JointLimits)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > hy_;
  mutable std::atomic<int> _hy_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > hx_;
  mutable std::atomic<int> _hx_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class ListPayloadsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListPayloadsRequest) */ {
 public:
  inline ListPayloadsRequest() : ListPayloadsRequest(nullptr) {}
  virtual ~ListPayloadsRequest();

  ListPayloadsRequest(const ListPayloadsRequest& from);
  ListPayloadsRequest(ListPayloadsRequest&& from) noexcept
    : ListPayloadsRequest() {
    *this = ::std::move(from);
  }

  inline ListPayloadsRequest& operator=(const ListPayloadsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPayloadsRequest& operator=(ListPayloadsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListPayloadsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListPayloadsRequest* internal_default_instance() {
    return reinterpret_cast<const ListPayloadsRequest*>(
               &_ListPayloadsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListPayloadsRequest& a, ListPayloadsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPayloadsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPayloadsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPayloadsRequest* New() const final {
    return CreateMaybeMessage<ListPayloadsRequest>(nullptr);
  }

  ListPayloadsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPayloadsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListPayloadsRequest& from);
  void MergeFrom(const ListPayloadsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPayloadsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListPayloadsRequest";
  }
  protected:
  explicit ListPayloadsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fpayload_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fpayload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListPayloadsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// -------------------------------------------------------------------

class ListPayloadsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.ListPayloadsResponse) */ {
 public:
  inline ListPayloadsResponse() : ListPayloadsResponse(nullptr) {}
  virtual ~ListPayloadsResponse();

  ListPayloadsResponse(const ListPayloadsResponse& from);
  ListPayloadsResponse(ListPayloadsResponse&& from) noexcept
    : ListPayloadsResponse() {
    *this = ::std::move(from);
  }

  inline ListPayloadsResponse& operator=(const ListPayloadsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPayloadsResponse& operator=(ListPayloadsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListPayloadsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListPayloadsResponse* internal_default_instance() {
    return reinterpret_cast<const ListPayloadsResponse*>(
               &_ListPayloadsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListPayloadsResponse& a, ListPayloadsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPayloadsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPayloadsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListPayloadsResponse* New() const final {
    return CreateMaybeMessage<ListPayloadsResponse>(nullptr);
  }

  ListPayloadsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListPayloadsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListPayloadsResponse& from);
  void MergeFrom(const ListPayloadsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPayloadsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.ListPayloadsResponse";
  }
  protected:
  explicit ListPayloadsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2fpayload_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2fpayload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .bosdyn.api.Payload payloads = 2;
  int payloads_size() const;
  private:
  int _internal_payloads_size() const;
  public:
  void clear_payloads();
  ::bosdyn::api::Payload* mutable_payloads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload >*
      mutable_payloads();
  private:
  const ::bosdyn::api::Payload& _internal_payloads(int index) const;
  ::bosdyn::api::Payload* _internal_add_payloads();
  public:
  const ::bosdyn::api::Payload& payloads(int index) const;
  ::bosdyn::api::Payload* add_payloads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload >&
      payloads() const;

  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.ListPayloadsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload > payloads_;
  ::bosdyn::api::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2fpayload_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Payload

// string GUID = 1;
inline void Payload::clear_guid() {
  guid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Payload::guid() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.GUID)
  return _internal_guid();
}
inline void Payload::set_guid(const std::string& value) {
  _internal_set_guid(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.GUID)
}
inline std::string* Payload::mutable_guid() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.GUID)
  return _internal_mutable_guid();
}
inline const std::string& Payload::_internal_guid() const {
  return guid_.Get();
}
inline void Payload::_internal_set_guid(const std::string& value) {
  
  guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Payload::set_guid(std::string&& value) {
  
  guid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Payload.GUID)
}
inline void Payload::set_guid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Payload.GUID)
}
inline void Payload::set_guid(const char* value,
    size_t size) {
  
  guid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Payload.GUID)
}
inline std::string* Payload::_internal_mutable_guid() {
  
  return guid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Payload::release_guid() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.GUID)
  return guid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Payload::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    
  } else {
    
  }
  guid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), guid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.GUID)
}

// string name = 2;
inline void Payload::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Payload::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.name)
  return _internal_name();
}
inline void Payload::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.name)
}
inline std::string* Payload::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.name)
  return _internal_mutable_name();
}
inline const std::string& Payload::_internal_name() const {
  return name_.Get();
}
inline void Payload::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Payload::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Payload.name)
}
inline void Payload::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Payload.name)
}
inline void Payload::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Payload.name)
}
inline std::string* Payload::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Payload::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Payload::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.name)
}

// string description = 3;
inline void Payload::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Payload::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.description)
  return _internal_description();
}
inline void Payload::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.description)
}
inline std::string* Payload::mutable_description() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.description)
  return _internal_mutable_description();
}
inline const std::string& Payload::_internal_description() const {
  return description_.Get();
}
inline void Payload::_internal_set_description(const std::string& value) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Payload::set_description(std::string&& value) {
  
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.Payload.description)
}
inline void Payload::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Payload.description)
}
inline void Payload::set_description(const char* value,
    size_t size) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Payload.description)
}
inline std::string* Payload::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Payload::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Payload::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.description)
}

// repeated string label_prefix = 9;
inline int Payload::_internal_label_prefix_size() const {
  return label_prefix_.size();
}
inline int Payload::label_prefix_size() const {
  return _internal_label_prefix_size();
}
inline void Payload::clear_label_prefix() {
  label_prefix_.Clear();
}
inline std::string* Payload::add_label_prefix() {
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.Payload.label_prefix)
  return _internal_add_label_prefix();
}
inline const std::string& Payload::_internal_label_prefix(int index) const {
  return label_prefix_.Get(index);
}
inline const std::string& Payload::label_prefix(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.label_prefix)
  return _internal_label_prefix(index);
}
inline std::string* Payload::mutable_label_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.label_prefix)
  return label_prefix_.Mutable(index);
}
inline void Payload::set_label_prefix(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.label_prefix)
  label_prefix_.Mutable(index)->assign(value);
}
inline void Payload::set_label_prefix(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.label_prefix)
  label_prefix_.Mutable(index)->assign(std::move(value));
}
inline void Payload::set_label_prefix(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  label_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.Payload.label_prefix)
}
inline void Payload::set_label_prefix(int index, const char* value, size_t size) {
  label_prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.Payload.label_prefix)
}
inline std::string* Payload::_internal_add_label_prefix() {
  return label_prefix_.Add();
}
inline void Payload::add_label_prefix(const std::string& value) {
  label_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.Payload.label_prefix)
}
inline void Payload::add_label_prefix(std::string&& value) {
  label_prefix_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.Payload.label_prefix)
}
inline void Payload::add_label_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  label_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.Payload.label_prefix)
}
inline void Payload::add_label_prefix(const char* value, size_t size) {
  label_prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.Payload.label_prefix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Payload::label_prefix() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Payload.label_prefix)
  return label_prefix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Payload::mutable_label_prefix() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Payload.label_prefix)
  return &label_prefix_;
}

// bool is_authorized = 4;
inline void Payload::clear_is_authorized() {
  is_authorized_ = false;
}
inline bool Payload::_internal_is_authorized() const {
  return is_authorized_;
}
inline bool Payload::is_authorized() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.is_authorized)
  return _internal_is_authorized();
}
inline void Payload::_internal_set_is_authorized(bool value) {
  
  is_authorized_ = value;
}
inline void Payload::set_is_authorized(bool value) {
  _internal_set_is_authorized(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.is_authorized)
}

// bool is_enabled = 5;
inline void Payload::clear_is_enabled() {
  is_enabled_ = false;
}
inline bool Payload::_internal_is_enabled() const {
  return is_enabled_;
}
inline bool Payload::is_enabled() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.is_enabled)
  return _internal_is_enabled();
}
inline void Payload::_internal_set_is_enabled(bool value) {
  
  is_enabled_ = value;
}
inline void Payload::set_is_enabled(bool value) {
  _internal_set_is_enabled(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.is_enabled)
}

// bool is_noncompute_payload = 6;
inline void Payload::clear_is_noncompute_payload() {
  is_noncompute_payload_ = false;
}
inline bool Payload::_internal_is_noncompute_payload() const {
  return is_noncompute_payload_;
}
inline bool Payload::is_noncompute_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.is_noncompute_payload)
  return _internal_is_noncompute_payload();
}
inline void Payload::_internal_set_is_noncompute_payload(bool value) {
  
  is_noncompute_payload_ = value;
}
inline void Payload::set_is_noncompute_payload(bool value) {
  _internal_set_is_noncompute_payload(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.Payload.is_noncompute_payload)
}

// .bosdyn.api.SoftwareVersion version = 12;
inline bool Payload::_internal_has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline bool Payload::has_version() const {
  return _internal_has_version();
}
inline const ::bosdyn::api::SoftwareVersion& Payload::_internal_version() const {
  const ::bosdyn::api::SoftwareVersion* p = version_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SoftwareVersion*>(
      &::bosdyn::api::_SoftwareVersion_default_instance_);
}
inline const ::bosdyn::api::SoftwareVersion& Payload::version() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.version)
  return _internal_version();
}
inline void Payload::unsafe_arena_set_allocated_version(
    ::bosdyn::api::SoftwareVersion* version) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Payload.version)
}
inline ::bosdyn::api::SoftwareVersion* Payload::release_version() {
  
  ::bosdyn::api::SoftwareVersion* temp = version_;
  version_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SoftwareVersion* Payload::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.version)
  
  ::bosdyn::api::SoftwareVersion* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SoftwareVersion* Payload::_internal_mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SoftwareVersion>(GetArena());
    version_ = p;
  }
  return version_;
}
inline ::bosdyn::api::SoftwareVersion* Payload::mutable_version() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.version)
  return _internal_mutable_version();
}
inline void Payload::set_allocated_version(::bosdyn::api::SoftwareVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version)->GetArena();
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.version)
}

// .bosdyn.api.SE3Pose body_tform_payload = 7;
inline bool Payload::_internal_has_body_tform_payload() const {
  return this != internal_default_instance() && body_tform_payload_ != nullptr;
}
inline bool Payload::has_body_tform_payload() const {
  return _internal_has_body_tform_payload();
}
inline const ::bosdyn::api::SE3Pose& Payload::_internal_body_tform_payload() const {
  const ::bosdyn::api::SE3Pose* p = body_tform_payload_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Pose*>(
      &::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Payload::body_tform_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.body_tform_payload)
  return _internal_body_tform_payload();
}
inline void Payload::unsafe_arena_set_allocated_body_tform_payload(
    ::bosdyn::api::SE3Pose* body_tform_payload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_tform_payload_);
  }
  body_tform_payload_ = body_tform_payload;
  if (body_tform_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Payload.body_tform_payload)
}
inline ::bosdyn::api::SE3Pose* Payload::release_body_tform_payload() {
  
  ::bosdyn::api::SE3Pose* temp = body_tform_payload_;
  body_tform_payload_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Pose* Payload::unsafe_arena_release_body_tform_payload() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.body_tform_payload)
  
  ::bosdyn::api::SE3Pose* temp = body_tform_payload_;
  body_tform_payload_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Payload::_internal_mutable_body_tform_payload() {
  
  if (body_tform_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArena());
    body_tform_payload_ = p;
  }
  return body_tform_payload_;
}
inline ::bosdyn::api::SE3Pose* Payload::mutable_body_tform_payload() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.body_tform_payload)
  return _internal_mutable_body_tform_payload();
}
inline void Payload::set_allocated_body_tform_payload(::bosdyn::api::SE3Pose* body_tform_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_tform_payload_);
  }
  if (body_tform_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_tform_payload)->GetArena();
    if (message_arena != submessage_arena) {
      body_tform_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_tform_payload, submessage_arena);
    }
    
  } else {
    
  }
  body_tform_payload_ = body_tform_payload;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.body_tform_payload)
}

// .bosdyn.api.SE3Pose mount_tform_payload = 8;
inline bool Payload::_internal_has_mount_tform_payload() const {
  return this != internal_default_instance() && mount_tform_payload_ != nullptr;
}
inline bool Payload::has_mount_tform_payload() const {
  return _internal_has_mount_tform_payload();
}
inline const ::bosdyn::api::SE3Pose& Payload::_internal_mount_tform_payload() const {
  const ::bosdyn::api::SE3Pose* p = mount_tform_payload_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Pose*>(
      &::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& Payload::mount_tform_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.mount_tform_payload)
  return _internal_mount_tform_payload();
}
inline void Payload::unsafe_arena_set_allocated_mount_tform_payload(
    ::bosdyn::api::SE3Pose* mount_tform_payload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mount_tform_payload_);
  }
  mount_tform_payload_ = mount_tform_payload;
  if (mount_tform_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Payload.mount_tform_payload)
}
inline ::bosdyn::api::SE3Pose* Payload::release_mount_tform_payload() {
  
  ::bosdyn::api::SE3Pose* temp = mount_tform_payload_;
  mount_tform_payload_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Pose* Payload::unsafe_arena_release_mount_tform_payload() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.mount_tform_payload)
  
  ::bosdyn::api::SE3Pose* temp = mount_tform_payload_;
  mount_tform_payload_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* Payload::_internal_mutable_mount_tform_payload() {
  
  if (mount_tform_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArena());
    mount_tform_payload_ = p;
  }
  return mount_tform_payload_;
}
inline ::bosdyn::api::SE3Pose* Payload::mutable_mount_tform_payload() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.mount_tform_payload)
  return _internal_mutable_mount_tform_payload();
}
inline void Payload::set_allocated_mount_tform_payload(::bosdyn::api::SE3Pose* mount_tform_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mount_tform_payload_);
  }
  if (mount_tform_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mount_tform_payload)->GetArena();
    if (message_arena != submessage_arena) {
      mount_tform_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mount_tform_payload, submessage_arena);
    }
    
  } else {
    
  }
  mount_tform_payload_ = mount_tform_payload;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.mount_tform_payload)
}

// .bosdyn.api.PayloadMassVolumeProperties mass_volume_properties = 10;
inline bool Payload::_internal_has_mass_volume_properties() const {
  return this != internal_default_instance() && mass_volume_properties_ != nullptr;
}
inline bool Payload::has_mass_volume_properties() const {
  return _internal_has_mass_volume_properties();
}
inline void Payload::clear_mass_volume_properties() {
  if (GetArena() == nullptr && mass_volume_properties_ != nullptr) {
    delete mass_volume_properties_;
  }
  mass_volume_properties_ = nullptr;
}
inline const ::bosdyn::api::PayloadMassVolumeProperties& Payload::_internal_mass_volume_properties() const {
  const ::bosdyn::api::PayloadMassVolumeProperties* p = mass_volume_properties_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::PayloadMassVolumeProperties*>(
      &::bosdyn::api::_PayloadMassVolumeProperties_default_instance_);
}
inline const ::bosdyn::api::PayloadMassVolumeProperties& Payload::mass_volume_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.mass_volume_properties)
  return _internal_mass_volume_properties();
}
inline void Payload::unsafe_arena_set_allocated_mass_volume_properties(
    ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mass_volume_properties_);
  }
  mass_volume_properties_ = mass_volume_properties;
  if (mass_volume_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.Payload.mass_volume_properties)
}
inline ::bosdyn::api::PayloadMassVolumeProperties* Payload::release_mass_volume_properties() {
  
  ::bosdyn::api::PayloadMassVolumeProperties* temp = mass_volume_properties_;
  mass_volume_properties_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* Payload::unsafe_arena_release_mass_volume_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.Payload.mass_volume_properties)
  
  ::bosdyn::api::PayloadMassVolumeProperties* temp = mass_volume_properties_;
  mass_volume_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* Payload::_internal_mutable_mass_volume_properties() {
  
  if (mass_volume_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PayloadMassVolumeProperties>(GetArena());
    mass_volume_properties_ = p;
  }
  return mass_volume_properties_;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* Payload::mutable_mass_volume_properties() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.mass_volume_properties)
  return _internal_mutable_mass_volume_properties();
}
inline void Payload::set_allocated_mass_volume_properties(::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mass_volume_properties_;
  }
  if (mass_volume_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mass_volume_properties);
    if (message_arena != submessage_arena) {
      mass_volume_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mass_volume_properties, submessage_arena);
    }
    
  } else {
    
  }
  mass_volume_properties_ = mass_volume_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.Payload.mass_volume_properties)
}

// repeated .bosdyn.api.PayloadPreset preset_configurations = 11;
inline int Payload::_internal_preset_configurations_size() const {
  return preset_configurations_.size();
}
inline int Payload::preset_configurations_size() const {
  return _internal_preset_configurations_size();
}
inline void Payload::clear_preset_configurations() {
  preset_configurations_.Clear();
}
inline ::bosdyn::api::PayloadPreset* Payload::mutable_preset_configurations(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.Payload.preset_configurations)
  return preset_configurations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset >*
Payload::mutable_preset_configurations() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.Payload.preset_configurations)
  return &preset_configurations_;
}
inline const ::bosdyn::api::PayloadPreset& Payload::_internal_preset_configurations(int index) const {
  return preset_configurations_.Get(index);
}
inline const ::bosdyn::api::PayloadPreset& Payload::preset_configurations(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.Payload.preset_configurations)
  return _internal_preset_configurations(index);
}
inline ::bosdyn::api::PayloadPreset* Payload::_internal_add_preset_configurations() {
  return preset_configurations_.Add();
}
inline ::bosdyn::api::PayloadPreset* Payload::add_preset_configurations() {
  // @@protoc_insertion_point(field_add:bosdyn.api.Payload.preset_configurations)
  return _internal_add_preset_configurations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::PayloadPreset >&
Payload::preset_configurations() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.Payload.preset_configurations)
  return preset_configurations_;
}

// -------------------------------------------------------------------

// PayloadPreset

// string preset_name = 1;
inline void PayloadPreset::clear_preset_name() {
  preset_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PayloadPreset::preset_name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.preset_name)
  return _internal_preset_name();
}
inline void PayloadPreset::set_preset_name(const std::string& value) {
  _internal_set_preset_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.preset_name)
}
inline std::string* PayloadPreset::mutable_preset_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.preset_name)
  return _internal_mutable_preset_name();
}
inline const std::string& PayloadPreset::_internal_preset_name() const {
  return preset_name_.Get();
}
inline void PayloadPreset::_internal_set_preset_name(const std::string& value) {
  
  preset_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PayloadPreset::set_preset_name(std::string&& value) {
  
  preset_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.PayloadPreset.preset_name)
}
inline void PayloadPreset::set_preset_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  preset_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.PayloadPreset.preset_name)
}
inline void PayloadPreset::set_preset_name(const char* value,
    size_t size) {
  
  preset_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.PayloadPreset.preset_name)
}
inline std::string* PayloadPreset::_internal_mutable_preset_name() {
  
  return preset_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PayloadPreset::release_preset_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadPreset.preset_name)
  return preset_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PayloadPreset::set_allocated_preset_name(std::string* preset_name) {
  if (preset_name != nullptr) {
    
  } else {
    
  }
  preset_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), preset_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadPreset.preset_name)
}

// string description = 2;
inline void PayloadPreset::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PayloadPreset::description() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.description)
  return _internal_description();
}
inline void PayloadPreset::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.description)
}
inline std::string* PayloadPreset::mutable_description() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.description)
  return _internal_mutable_description();
}
inline const std::string& PayloadPreset::_internal_description() const {
  return description_.Get();
}
inline void PayloadPreset::_internal_set_description(const std::string& value) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PayloadPreset::set_description(std::string&& value) {
  
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.PayloadPreset.description)
}
inline void PayloadPreset::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.PayloadPreset.description)
}
inline void PayloadPreset::set_description(const char* value,
    size_t size) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.PayloadPreset.description)
}
inline std::string* PayloadPreset::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PayloadPreset::release_description() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadPreset.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PayloadPreset::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadPreset.description)
}

// .bosdyn.api.SE3Pose mount_tform_payload = 3;
inline bool PayloadPreset::_internal_has_mount_tform_payload() const {
  return this != internal_default_instance() && mount_tform_payload_ != nullptr;
}
inline bool PayloadPreset::has_mount_tform_payload() const {
  return _internal_has_mount_tform_payload();
}
inline const ::bosdyn::api::SE3Pose& PayloadPreset::_internal_mount_tform_payload() const {
  const ::bosdyn::api::SE3Pose* p = mount_tform_payload_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SE3Pose*>(
      &::bosdyn::api::_SE3Pose_default_instance_);
}
inline const ::bosdyn::api::SE3Pose& PayloadPreset::mount_tform_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.mount_tform_payload)
  return _internal_mount_tform_payload();
}
inline void PayloadPreset::unsafe_arena_set_allocated_mount_tform_payload(
    ::bosdyn::api::SE3Pose* mount_tform_payload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mount_tform_payload_);
  }
  mount_tform_payload_ = mount_tform_payload;
  if (mount_tform_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PayloadPreset.mount_tform_payload)
}
inline ::bosdyn::api::SE3Pose* PayloadPreset::release_mount_tform_payload() {
  
  ::bosdyn::api::SE3Pose* temp = mount_tform_payload_;
  mount_tform_payload_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SE3Pose* PayloadPreset::unsafe_arena_release_mount_tform_payload() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadPreset.mount_tform_payload)
  
  ::bosdyn::api::SE3Pose* temp = mount_tform_payload_;
  mount_tform_payload_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SE3Pose* PayloadPreset::_internal_mutable_mount_tform_payload() {
  
  if (mount_tform_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SE3Pose>(GetArena());
    mount_tform_payload_ = p;
  }
  return mount_tform_payload_;
}
inline ::bosdyn::api::SE3Pose* PayloadPreset::mutable_mount_tform_payload() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.mount_tform_payload)
  return _internal_mutable_mount_tform_payload();
}
inline void PayloadPreset::set_allocated_mount_tform_payload(::bosdyn::api::SE3Pose* mount_tform_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mount_tform_payload_);
  }
  if (mount_tform_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mount_tform_payload)->GetArena();
    if (message_arena != submessage_arena) {
      mount_tform_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mount_tform_payload, submessage_arena);
    }
    
  } else {
    
  }
  mount_tform_payload_ = mount_tform_payload;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadPreset.mount_tform_payload)
}

// .bosdyn.api.PayloadMassVolumeProperties mass_volume_properties = 4;
inline bool PayloadPreset::_internal_has_mass_volume_properties() const {
  return this != internal_default_instance() && mass_volume_properties_ != nullptr;
}
inline bool PayloadPreset::has_mass_volume_properties() const {
  return _internal_has_mass_volume_properties();
}
inline void PayloadPreset::clear_mass_volume_properties() {
  if (GetArena() == nullptr && mass_volume_properties_ != nullptr) {
    delete mass_volume_properties_;
  }
  mass_volume_properties_ = nullptr;
}
inline const ::bosdyn::api::PayloadMassVolumeProperties& PayloadPreset::_internal_mass_volume_properties() const {
  const ::bosdyn::api::PayloadMassVolumeProperties* p = mass_volume_properties_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::PayloadMassVolumeProperties*>(
      &::bosdyn::api::_PayloadMassVolumeProperties_default_instance_);
}
inline const ::bosdyn::api::PayloadMassVolumeProperties& PayloadPreset::mass_volume_properties() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.mass_volume_properties)
  return _internal_mass_volume_properties();
}
inline void PayloadPreset::unsafe_arena_set_allocated_mass_volume_properties(
    ::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mass_volume_properties_);
  }
  mass_volume_properties_ = mass_volume_properties;
  if (mass_volume_properties) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PayloadPreset.mass_volume_properties)
}
inline ::bosdyn::api::PayloadMassVolumeProperties* PayloadPreset::release_mass_volume_properties() {
  
  ::bosdyn::api::PayloadMassVolumeProperties* temp = mass_volume_properties_;
  mass_volume_properties_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* PayloadPreset::unsafe_arena_release_mass_volume_properties() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadPreset.mass_volume_properties)
  
  ::bosdyn::api::PayloadMassVolumeProperties* temp = mass_volume_properties_;
  mass_volume_properties_ = nullptr;
  return temp;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* PayloadPreset::_internal_mutable_mass_volume_properties() {
  
  if (mass_volume_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::PayloadMassVolumeProperties>(GetArena());
    mass_volume_properties_ = p;
  }
  return mass_volume_properties_;
}
inline ::bosdyn::api::PayloadMassVolumeProperties* PayloadPreset::mutable_mass_volume_properties() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.mass_volume_properties)
  return _internal_mutable_mass_volume_properties();
}
inline void PayloadPreset::set_allocated_mass_volume_properties(::bosdyn::api::PayloadMassVolumeProperties* mass_volume_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mass_volume_properties_;
  }
  if (mass_volume_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mass_volume_properties);
    if (message_arena != submessage_arena) {
      mass_volume_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mass_volume_properties, submessage_arena);
    }
    
  } else {
    
  }
  mass_volume_properties_ = mass_volume_properties;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadPreset.mass_volume_properties)
}

// repeated string label_prefix = 5;
inline int PayloadPreset::_internal_label_prefix_size() const {
  return label_prefix_.size();
}
inline int PayloadPreset::label_prefix_size() const {
  return _internal_label_prefix_size();
}
inline void PayloadPreset::clear_label_prefix() {
  label_prefix_.Clear();
}
inline std::string* PayloadPreset::add_label_prefix() {
  // @@protoc_insertion_point(field_add_mutable:bosdyn.api.PayloadPreset.label_prefix)
  return _internal_add_label_prefix();
}
inline const std::string& PayloadPreset::_internal_label_prefix(int index) const {
  return label_prefix_.Get(index);
}
inline const std::string& PayloadPreset::label_prefix(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadPreset.label_prefix)
  return _internal_label_prefix(index);
}
inline std::string* PayloadPreset::mutable_label_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadPreset.label_prefix)
  return label_prefix_.Mutable(index);
}
inline void PayloadPreset::set_label_prefix(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.label_prefix)
  label_prefix_.Mutable(index)->assign(value);
}
inline void PayloadPreset::set_label_prefix(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadPreset.label_prefix)
  label_prefix_.Mutable(index)->assign(std::move(value));
}
inline void PayloadPreset::set_label_prefix(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  label_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::set_label_prefix(int index, const char* value, size_t size) {
  label_prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.PayloadPreset.label_prefix)
}
inline std::string* PayloadPreset::_internal_add_label_prefix() {
  return label_prefix_.Add();
}
inline void PayloadPreset::add_label_prefix(const std::string& value) {
  label_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::add_label_prefix(std::string&& value) {
  label_prefix_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::add_label_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  label_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bosdyn.api.PayloadPreset.label_prefix)
}
inline void PayloadPreset::add_label_prefix(const char* value, size_t size) {
  label_prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bosdyn.api.PayloadPreset.label_prefix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PayloadPreset::label_prefix() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PayloadPreset.label_prefix)
  return label_prefix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PayloadPreset::mutable_label_prefix() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PayloadPreset.label_prefix)
  return &label_prefix_;
}

// -------------------------------------------------------------------

// PayloadMassVolumeProperties

// float total_mass = 2;
inline void PayloadMassVolumeProperties::clear_total_mass() {
  total_mass_ = 0;
}
inline float PayloadMassVolumeProperties::_internal_total_mass() const {
  return total_mass_;
}
inline float PayloadMassVolumeProperties::total_mass() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.total_mass)
  return _internal_total_mass();
}
inline void PayloadMassVolumeProperties::_internal_set_total_mass(float value) {
  
  total_mass_ = value;
}
inline void PayloadMassVolumeProperties::set_total_mass(float value) {
  _internal_set_total_mass(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.PayloadMassVolumeProperties.total_mass)
}

// .bosdyn.api.Vec3 com_pos_rt_payload = 3;
inline bool PayloadMassVolumeProperties::_internal_has_com_pos_rt_payload() const {
  return this != internal_default_instance() && com_pos_rt_payload_ != nullptr;
}
inline bool PayloadMassVolumeProperties::has_com_pos_rt_payload() const {
  return _internal_has_com_pos_rt_payload();
}
inline const ::bosdyn::api::Vec3& PayloadMassVolumeProperties::_internal_com_pos_rt_payload() const {
  const ::bosdyn::api::Vec3* p = com_pos_rt_payload_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::Vec3*>(
      &::bosdyn::api::_Vec3_default_instance_);
}
inline const ::bosdyn::api::Vec3& PayloadMassVolumeProperties::com_pos_rt_payload() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
  return _internal_com_pos_rt_payload();
}
inline void PayloadMassVolumeProperties::unsafe_arena_set_allocated_com_pos_rt_payload(
    ::bosdyn::api::Vec3* com_pos_rt_payload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(com_pos_rt_payload_);
  }
  com_pos_rt_payload_ = com_pos_rt_payload;
  if (com_pos_rt_payload) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
}
inline ::bosdyn::api::Vec3* PayloadMassVolumeProperties::release_com_pos_rt_payload() {
  
  ::bosdyn::api::Vec3* temp = com_pos_rt_payload_;
  com_pos_rt_payload_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::Vec3* PayloadMassVolumeProperties::unsafe_arena_release_com_pos_rt_payload() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
  
  ::bosdyn::api::Vec3* temp = com_pos_rt_payload_;
  com_pos_rt_payload_ = nullptr;
  return temp;
}
inline ::bosdyn::api::Vec3* PayloadMassVolumeProperties::_internal_mutable_com_pos_rt_payload() {
  
  if (com_pos_rt_payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::Vec3>(GetArena());
    com_pos_rt_payload_ = p;
  }
  return com_pos_rt_payload_;
}
inline ::bosdyn::api::Vec3* PayloadMassVolumeProperties::mutable_com_pos_rt_payload() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
  return _internal_mutable_com_pos_rt_payload();
}
inline void PayloadMassVolumeProperties::set_allocated_com_pos_rt_payload(::bosdyn::api::Vec3* com_pos_rt_payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(com_pos_rt_payload_);
  }
  if (com_pos_rt_payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(com_pos_rt_payload)->GetArena();
    if (message_arena != submessage_arena) {
      com_pos_rt_payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, com_pos_rt_payload, submessage_arena);
    }
    
  } else {
    
  }
  com_pos_rt_payload_ = com_pos_rt_payload;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadMassVolumeProperties.com_pos_rt_payload)
}

// .bosdyn.api.MomentOfIntertia moi_tensor = 4;
inline bool PayloadMassVolumeProperties::_internal_has_moi_tensor() const {
  return this != internal_default_instance() && moi_tensor_ != nullptr;
}
inline bool PayloadMassVolumeProperties::has_moi_tensor() const {
  return _internal_has_moi_tensor();
}
inline void PayloadMassVolumeProperties::clear_moi_tensor() {
  if (GetArena() == nullptr && moi_tensor_ != nullptr) {
    delete moi_tensor_;
  }
  moi_tensor_ = nullptr;
}
inline const ::bosdyn::api::MomentOfIntertia& PayloadMassVolumeProperties::_internal_moi_tensor() const {
  const ::bosdyn::api::MomentOfIntertia* p = moi_tensor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::MomentOfIntertia*>(
      &::bosdyn::api::_MomentOfIntertia_default_instance_);
}
inline const ::bosdyn::api::MomentOfIntertia& PayloadMassVolumeProperties::moi_tensor() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
  return _internal_moi_tensor();
}
inline void PayloadMassVolumeProperties::unsafe_arena_set_allocated_moi_tensor(
    ::bosdyn::api::MomentOfIntertia* moi_tensor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(moi_tensor_);
  }
  moi_tensor_ = moi_tensor;
  if (moi_tensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
}
inline ::bosdyn::api::MomentOfIntertia* PayloadMassVolumeProperties::release_moi_tensor() {
  
  ::bosdyn::api::MomentOfIntertia* temp = moi_tensor_;
  moi_tensor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::MomentOfIntertia* PayloadMassVolumeProperties::unsafe_arena_release_moi_tensor() {
  // @@protoc_insertion_point(field_release:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
  
  ::bosdyn::api::MomentOfIntertia* temp = moi_tensor_;
  moi_tensor_ = nullptr;
  return temp;
}
inline ::bosdyn::api::MomentOfIntertia* PayloadMassVolumeProperties::_internal_mutable_moi_tensor() {
  
  if (moi_tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::MomentOfIntertia>(GetArena());
    moi_tensor_ = p;
  }
  return moi_tensor_;
}
inline ::bosdyn::api::MomentOfIntertia* PayloadMassVolumeProperties::mutable_moi_tensor() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
  return _internal_mutable_moi_tensor();
}
inline void PayloadMassVolumeProperties::set_allocated_moi_tensor(::bosdyn::api::MomentOfIntertia* moi_tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete moi_tensor_;
  }
  if (moi_tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(moi_tensor);
    if (message_arena != submessage_arena) {
      moi_tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moi_tensor, submessage_arena);
    }
    
  } else {
    
  }
  moi_tensor_ = moi_tensor;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.PayloadMassVolumeProperties.moi_tensor)
}

// repeated .bosdyn.api.Box3WithFrame bounding_box = 5;
inline int PayloadMassVolumeProperties::_internal_bounding_box_size() const {
  return bounding_box_.size();
}
inline int PayloadMassVolumeProperties::bounding_box_size() const {
  return _internal_bounding_box_size();
}
inline ::bosdyn::api::Box3WithFrame* PayloadMassVolumeProperties::mutable_bounding_box(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return bounding_box_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame >*
PayloadMassVolumeProperties::mutable_bounding_box() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return &bounding_box_;
}
inline const ::bosdyn::api::Box3WithFrame& PayloadMassVolumeProperties::_internal_bounding_box(int index) const {
  return bounding_box_.Get(index);
}
inline const ::bosdyn::api::Box3WithFrame& PayloadMassVolumeProperties::bounding_box(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return _internal_bounding_box(index);
}
inline ::bosdyn::api::Box3WithFrame* PayloadMassVolumeProperties::_internal_add_bounding_box() {
  return bounding_box_.Add();
}
inline ::bosdyn::api::Box3WithFrame* PayloadMassVolumeProperties::add_bounding_box() {
  // @@protoc_insertion_point(field_add:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return _internal_add_bounding_box();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Box3WithFrame >&
PayloadMassVolumeProperties::bounding_box() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PayloadMassVolumeProperties.bounding_box)
  return bounding_box_;
}

// repeated .bosdyn.api.JointLimits joint_limits = 6;
inline int PayloadMassVolumeProperties::_internal_joint_limits_size() const {
  return joint_limits_.size();
}
inline int PayloadMassVolumeProperties::joint_limits_size() const {
  return _internal_joint_limits_size();
}
inline void PayloadMassVolumeProperties::clear_joint_limits() {
  joint_limits_.Clear();
}
inline ::bosdyn::api::JointLimits* PayloadMassVolumeProperties::mutable_joint_limits(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return joint_limits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits >*
PayloadMassVolumeProperties::mutable_joint_limits() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return &joint_limits_;
}
inline const ::bosdyn::api::JointLimits& PayloadMassVolumeProperties::_internal_joint_limits(int index) const {
  return joint_limits_.Get(index);
}
inline const ::bosdyn::api::JointLimits& PayloadMassVolumeProperties::joint_limits(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return _internal_joint_limits(index);
}
inline ::bosdyn::api::JointLimits* PayloadMassVolumeProperties::_internal_add_joint_limits() {
  return joint_limits_.Add();
}
inline ::bosdyn::api::JointLimits* PayloadMassVolumeProperties::add_joint_limits() {
  // @@protoc_insertion_point(field_add:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return _internal_add_joint_limits();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::JointLimits >&
PayloadMassVolumeProperties::joint_limits() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.PayloadMassVolumeProperties.joint_limits)
  return joint_limits_;
}

// -------------------------------------------------------------------

// MomentOfIntertia

// float xx = 2;
inline void MomentOfIntertia::clear_xx() {
  xx_ = 0;
}
inline float MomentOfIntertia::_internal_xx() const {
  return xx_;
}
inline float MomentOfIntertia::xx() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.xx)
  return _internal_xx();
}
inline void MomentOfIntertia::_internal_set_xx(float value) {
  
  xx_ = value;
}
inline void MomentOfIntertia::set_xx(float value) {
  _internal_set_xx(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.xx)
}

// float yy = 3;
inline void MomentOfIntertia::clear_yy() {
  yy_ = 0;
}
inline float MomentOfIntertia::_internal_yy() const {
  return yy_;
}
inline float MomentOfIntertia::yy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.yy)
  return _internal_yy();
}
inline void MomentOfIntertia::_internal_set_yy(float value) {
  
  yy_ = value;
}
inline void MomentOfIntertia::set_yy(float value) {
  _internal_set_yy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.yy)
}

// float zz = 4;
inline void MomentOfIntertia::clear_zz() {
  zz_ = 0;
}
inline float MomentOfIntertia::_internal_zz() const {
  return zz_;
}
inline float MomentOfIntertia::zz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.zz)
  return _internal_zz();
}
inline void MomentOfIntertia::_internal_set_zz(float value) {
  
  zz_ = value;
}
inline void MomentOfIntertia::set_zz(float value) {
  _internal_set_zz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.zz)
}

// float xy = 5;
inline void MomentOfIntertia::clear_xy() {
  xy_ = 0;
}
inline float MomentOfIntertia::_internal_xy() const {
  return xy_;
}
inline float MomentOfIntertia::xy() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.xy)
  return _internal_xy();
}
inline void MomentOfIntertia::_internal_set_xy(float value) {
  
  xy_ = value;
}
inline void MomentOfIntertia::set_xy(float value) {
  _internal_set_xy(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.xy)
}

// float xz = 6;
inline void MomentOfIntertia::clear_xz() {
  xz_ = 0;
}
inline float MomentOfIntertia::_internal_xz() const {
  return xz_;
}
inline float MomentOfIntertia::xz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.xz)
  return _internal_xz();
}
inline void MomentOfIntertia::_internal_set_xz(float value) {
  
  xz_ = value;
}
inline void MomentOfIntertia::set_xz(float value) {
  _internal_set_xz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.xz)
}

// float yz = 7;
inline void MomentOfIntertia::clear_yz() {
  yz_ = 0;
}
inline float MomentOfIntertia::_internal_yz() const {
  return yz_;
}
inline float MomentOfIntertia::yz() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.MomentOfIntertia.yz)
  return _internal_yz();
}
inline void MomentOfIntertia::_internal_set_yz(float value) {
  
  yz_ = value;
}
inline void MomentOfIntertia::set_yz(float value) {
  _internal_set_yz(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.MomentOfIntertia.yz)
}

// -------------------------------------------------------------------

// JointLimits

// string label = 2;
inline void JointLimits::clear_label() {
  label_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& JointLimits::label() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointLimits.label)
  return _internal_label();
}
inline void JointLimits::set_label(const std::string& value) {
  _internal_set_label(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.JointLimits.label)
}
inline std::string* JointLimits::mutable_label() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.JointLimits.label)
  return _internal_mutable_label();
}
inline const std::string& JointLimits::_internal_label() const {
  return label_.Get();
}
inline void JointLimits::_internal_set_label(const std::string& value) {
  
  label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void JointLimits::set_label(std::string&& value) {
  
  label_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.JointLimits.label)
}
inline void JointLimits::set_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.JointLimits.label)
}
inline void JointLimits::set_label(const char* value,
    size_t size) {
  
  label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.JointLimits.label)
}
inline std::string* JointLimits::_internal_mutable_label() {
  
  return label_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* JointLimits::release_label() {
  // @@protoc_insertion_point(field_release:bosdyn.api.JointLimits.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void JointLimits::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.JointLimits.label)
}

// repeated float hy = 3;
inline int JointLimits::_internal_hy_size() const {
  return hy_.size();
}
inline int JointLimits::hy_size() const {
  return _internal_hy_size();
}
inline void JointLimits::clear_hy() {
  hy_.Clear();
}
inline float JointLimits::_internal_hy(int index) const {
  return hy_.Get(index);
}
inline float JointLimits::hy(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointLimits.hy)
  return _internal_hy(index);
}
inline void JointLimits::set_hy(int index, float value) {
  hy_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.JointLimits.hy)
}
inline void JointLimits::_internal_add_hy(float value) {
  hy_.Add(value);
}
inline void JointLimits::add_hy(float value) {
  _internal_add_hy(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.JointLimits.hy)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointLimits::_internal_hy() const {
  return hy_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointLimits::hy() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.JointLimits.hy)
  return _internal_hy();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointLimits::_internal_mutable_hy() {
  return &hy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointLimits::mutable_hy() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.JointLimits.hy)
  return _internal_mutable_hy();
}

// repeated float hx = 4;
inline int JointLimits::_internal_hx_size() const {
  return hx_.size();
}
inline int JointLimits::hx_size() const {
  return _internal_hx_size();
}
inline void JointLimits::clear_hx() {
  hx_.Clear();
}
inline float JointLimits::_internal_hx(int index) const {
  return hx_.Get(index);
}
inline float JointLimits::hx(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.JointLimits.hx)
  return _internal_hx(index);
}
inline void JointLimits::set_hx(int index, float value) {
  hx_.Set(index, value);
  // @@protoc_insertion_point(field_set:bosdyn.api.JointLimits.hx)
}
inline void JointLimits::_internal_add_hx(float value) {
  hx_.Add(value);
}
inline void JointLimits::add_hx(float value) {
  _internal_add_hx(value);
  // @@protoc_insertion_point(field_add:bosdyn.api.JointLimits.hx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointLimits::_internal_hx() const {
  return hx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
JointLimits::hx() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.JointLimits.hx)
  return _internal_hx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointLimits::_internal_mutable_hx() {
  return &hx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
JointLimits::mutable_hx() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.JointLimits.hx)
  return _internal_mutable_hx();
}

// -------------------------------------------------------------------

// ListPayloadsRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool ListPayloadsRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListPayloadsRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& ListPayloadsRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& ListPayloadsRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListPayloadsRequest.header)
  return _internal_header();
}
inline void ListPayloadsRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListPayloadsRequest.header)
}
inline ::bosdyn::api::RequestHeader* ListPayloadsRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListPayloadsRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListPayloadsRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* ListPayloadsRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* ListPayloadsRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListPayloadsRequest.header)
  return _internal_mutable_header();
}
inline void ListPayloadsRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListPayloadsRequest.header)
}

// -------------------------------------------------------------------

// ListPayloadsResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool ListPayloadsResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListPayloadsResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& ListPayloadsResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& ListPayloadsResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListPayloadsResponse.header)
  return _internal_header();
}
inline void ListPayloadsResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.ListPayloadsResponse.header)
}
inline ::bosdyn::api::ResponseHeader* ListPayloadsResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListPayloadsResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.ListPayloadsResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* ListPayloadsResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* ListPayloadsResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListPayloadsResponse.header)
  return _internal_mutable_header();
}
inline void ListPayloadsResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.ListPayloadsResponse.header)
}

// repeated .bosdyn.api.Payload payloads = 2;
inline int ListPayloadsResponse::_internal_payloads_size() const {
  return payloads_.size();
}
inline int ListPayloadsResponse::payloads_size() const {
  return _internal_payloads_size();
}
inline void ListPayloadsResponse::clear_payloads() {
  payloads_.Clear();
}
inline ::bosdyn::api::Payload* ListPayloadsResponse::mutable_payloads(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.ListPayloadsResponse.payloads)
  return payloads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload >*
ListPayloadsResponse::mutable_payloads() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.ListPayloadsResponse.payloads)
  return &payloads_;
}
inline const ::bosdyn::api::Payload& ListPayloadsResponse::_internal_payloads(int index) const {
  return payloads_.Get(index);
}
inline const ::bosdyn::api::Payload& ListPayloadsResponse::payloads(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.ListPayloadsResponse.payloads)
  return _internal_payloads(index);
}
inline ::bosdyn::api::Payload* ListPayloadsResponse::_internal_add_payloads() {
  return payloads_.Add();
}
inline ::bosdyn::api::Payload* ListPayloadsResponse::add_payloads() {
  // @@protoc_insertion_point(field_add:bosdyn.api.ListPayloadsResponse.payloads)
  return _internal_add_payloads();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::Payload >&
ListPayloadsResponse::payloads() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.ListPayloadsResponse.payloads)
  return payloads_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2fpayload_2eproto
