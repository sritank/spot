// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bosdyn/api/estop.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2festop_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2festop_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bosdyn/api/header.pb.h"
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bosdyn_2fapi_2festop_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bosdyn_2fapi_2festop_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bosdyn_2fapi_2festop_2eproto;
namespace bosdyn {
namespace api {
class DeregisterEstopEndpointRequest;
class DeregisterEstopEndpointRequestDefaultTypeInternal;
extern DeregisterEstopEndpointRequestDefaultTypeInternal _DeregisterEstopEndpointRequest_default_instance_;
class DeregisterEstopEndpointResponse;
class DeregisterEstopEndpointResponseDefaultTypeInternal;
extern DeregisterEstopEndpointResponseDefaultTypeInternal _DeregisterEstopEndpointResponse_default_instance_;
class EstopCheckInRequest;
class EstopCheckInRequestDefaultTypeInternal;
extern EstopCheckInRequestDefaultTypeInternal _EstopCheckInRequest_default_instance_;
class EstopCheckInResponse;
class EstopCheckInResponseDefaultTypeInternal;
extern EstopCheckInResponseDefaultTypeInternal _EstopCheckInResponse_default_instance_;
class EstopConfig;
class EstopConfigDefaultTypeInternal;
extern EstopConfigDefaultTypeInternal _EstopConfig_default_instance_;
class EstopEndpoint;
class EstopEndpointDefaultTypeInternal;
extern EstopEndpointDefaultTypeInternal _EstopEndpoint_default_instance_;
class EstopEndpointWithStatus;
class EstopEndpointWithStatusDefaultTypeInternal;
extern EstopEndpointWithStatusDefaultTypeInternal _EstopEndpointWithStatus_default_instance_;
class EstopSystemStatus;
class EstopSystemStatusDefaultTypeInternal;
extern EstopSystemStatusDefaultTypeInternal _EstopSystemStatus_default_instance_;
class GetEstopConfigRequest;
class GetEstopConfigRequestDefaultTypeInternal;
extern GetEstopConfigRequestDefaultTypeInternal _GetEstopConfigRequest_default_instance_;
class GetEstopConfigResponse;
class GetEstopConfigResponseDefaultTypeInternal;
extern GetEstopConfigResponseDefaultTypeInternal _GetEstopConfigResponse_default_instance_;
class GetEstopSystemStatusRequest;
class GetEstopSystemStatusRequestDefaultTypeInternal;
extern GetEstopSystemStatusRequestDefaultTypeInternal _GetEstopSystemStatusRequest_default_instance_;
class GetEstopSystemStatusResponse;
class GetEstopSystemStatusResponseDefaultTypeInternal;
extern GetEstopSystemStatusResponseDefaultTypeInternal _GetEstopSystemStatusResponse_default_instance_;
class RegisterEstopEndpointRequest;
class RegisterEstopEndpointRequestDefaultTypeInternal;
extern RegisterEstopEndpointRequestDefaultTypeInternal _RegisterEstopEndpointRequest_default_instance_;
class RegisterEstopEndpointResponse;
class RegisterEstopEndpointResponseDefaultTypeInternal;
extern RegisterEstopEndpointResponseDefaultTypeInternal _RegisterEstopEndpointResponse_default_instance_;
class SetEstopConfigRequest;
class SetEstopConfigRequestDefaultTypeInternal;
extern SetEstopConfigRequestDefaultTypeInternal _SetEstopConfigRequest_default_instance_;
class SetEstopConfigResponse;
class SetEstopConfigResponseDefaultTypeInternal;
extern SetEstopConfigResponseDefaultTypeInternal _SetEstopConfigResponse_default_instance_;
}  // namespace api
}  // namespace bosdyn
PROTOBUF_NAMESPACE_OPEN
template<> ::bosdyn::api::DeregisterEstopEndpointRequest* Arena::CreateMaybeMessage<::bosdyn::api::DeregisterEstopEndpointRequest>(Arena*);
template<> ::bosdyn::api::DeregisterEstopEndpointResponse* Arena::CreateMaybeMessage<::bosdyn::api::DeregisterEstopEndpointResponse>(Arena*);
template<> ::bosdyn::api::EstopCheckInRequest* Arena::CreateMaybeMessage<::bosdyn::api::EstopCheckInRequest>(Arena*);
template<> ::bosdyn::api::EstopCheckInResponse* Arena::CreateMaybeMessage<::bosdyn::api::EstopCheckInResponse>(Arena*);
template<> ::bosdyn::api::EstopConfig* Arena::CreateMaybeMessage<::bosdyn::api::EstopConfig>(Arena*);
template<> ::bosdyn::api::EstopEndpoint* Arena::CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(Arena*);
template<> ::bosdyn::api::EstopEndpointWithStatus* Arena::CreateMaybeMessage<::bosdyn::api::EstopEndpointWithStatus>(Arena*);
template<> ::bosdyn::api::EstopSystemStatus* Arena::CreateMaybeMessage<::bosdyn::api::EstopSystemStatus>(Arena*);
template<> ::bosdyn::api::GetEstopConfigRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetEstopConfigRequest>(Arena*);
template<> ::bosdyn::api::GetEstopConfigResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetEstopConfigResponse>(Arena*);
template<> ::bosdyn::api::GetEstopSystemStatusRequest* Arena::CreateMaybeMessage<::bosdyn::api::GetEstopSystemStatusRequest>(Arena*);
template<> ::bosdyn::api::GetEstopSystemStatusResponse* Arena::CreateMaybeMessage<::bosdyn::api::GetEstopSystemStatusResponse>(Arena*);
template<> ::bosdyn::api::RegisterEstopEndpointRequest* Arena::CreateMaybeMessage<::bosdyn::api::RegisterEstopEndpointRequest>(Arena*);
template<> ::bosdyn::api::RegisterEstopEndpointResponse* Arena::CreateMaybeMessage<::bosdyn::api::RegisterEstopEndpointResponse>(Arena*);
template<> ::bosdyn::api::SetEstopConfigRequest* Arena::CreateMaybeMessage<::bosdyn::api::SetEstopConfigRequest>(Arena*);
template<> ::bosdyn::api::SetEstopConfigResponse* Arena::CreateMaybeMessage<::bosdyn::api::SetEstopConfigResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bosdyn {
namespace api {

enum EstopCheckInResponse_Status : int {
  EstopCheckInResponse_Status_STATUS_UNKNOWN = 0,
  EstopCheckInResponse_Status_STATUS_OK = 1,
  EstopCheckInResponse_Status_STATUS_ENDPOINT_UNKNOWN = 2,
  EstopCheckInResponse_Status_STATUS_INCORRECT_CHALLENGE_RESPONSE = 5,
  EstopCheckInResponse_Status_EstopCheckInResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EstopCheckInResponse_Status_EstopCheckInResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EstopCheckInResponse_Status_IsValid(int value);
constexpr EstopCheckInResponse_Status EstopCheckInResponse_Status_Status_MIN = EstopCheckInResponse_Status_STATUS_UNKNOWN;
constexpr EstopCheckInResponse_Status EstopCheckInResponse_Status_Status_MAX = EstopCheckInResponse_Status_STATUS_INCORRECT_CHALLENGE_RESPONSE;
constexpr int EstopCheckInResponse_Status_Status_ARRAYSIZE = EstopCheckInResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EstopCheckInResponse_Status_descriptor();
template<typename T>
inline const std::string& EstopCheckInResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EstopCheckInResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EstopCheckInResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EstopCheckInResponse_Status_descriptor(), enum_t_value);
}
inline bool EstopCheckInResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EstopCheckInResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EstopCheckInResponse_Status>(
    EstopCheckInResponse_Status_descriptor(), name, value);
}
enum RegisterEstopEndpointResponse_Status : int {
  RegisterEstopEndpointResponse_Status_STATUS_UNKNOWN = 0,
  RegisterEstopEndpointResponse_Status_STATUS_SUCCESS = 1,
  RegisterEstopEndpointResponse_Status_STATUS_ENDPOINT_MISMATCH = 2,
  RegisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH = 3,
  RegisterEstopEndpointResponse_Status_STATUS_INVALID_ENDPOINT = 4,
  RegisterEstopEndpointResponse_Status_RegisterEstopEndpointResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RegisterEstopEndpointResponse_Status_RegisterEstopEndpointResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RegisterEstopEndpointResponse_Status_IsValid(int value);
constexpr RegisterEstopEndpointResponse_Status RegisterEstopEndpointResponse_Status_Status_MIN = RegisterEstopEndpointResponse_Status_STATUS_UNKNOWN;
constexpr RegisterEstopEndpointResponse_Status RegisterEstopEndpointResponse_Status_Status_MAX = RegisterEstopEndpointResponse_Status_STATUS_INVALID_ENDPOINT;
constexpr int RegisterEstopEndpointResponse_Status_Status_ARRAYSIZE = RegisterEstopEndpointResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegisterEstopEndpointResponse_Status_descriptor();
template<typename T>
inline const std::string& RegisterEstopEndpointResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegisterEstopEndpointResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegisterEstopEndpointResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegisterEstopEndpointResponse_Status_descriptor(), enum_t_value);
}
inline bool RegisterEstopEndpointResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegisterEstopEndpointResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegisterEstopEndpointResponse_Status>(
    RegisterEstopEndpointResponse_Status_descriptor(), name, value);
}
enum DeregisterEstopEndpointResponse_Status : int {
  DeregisterEstopEndpointResponse_Status_STATUS_UNKNOWN = 0,
  DeregisterEstopEndpointResponse_Status_STATUS_SUCCESS = 1,
  DeregisterEstopEndpointResponse_Status_STATUS_ENDPOINT_MISMATCH = 2,
  DeregisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH = 3,
  DeregisterEstopEndpointResponse_Status_DeregisterEstopEndpointResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DeregisterEstopEndpointResponse_Status_DeregisterEstopEndpointResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DeregisterEstopEndpointResponse_Status_IsValid(int value);
constexpr DeregisterEstopEndpointResponse_Status DeregisterEstopEndpointResponse_Status_Status_MIN = DeregisterEstopEndpointResponse_Status_STATUS_UNKNOWN;
constexpr DeregisterEstopEndpointResponse_Status DeregisterEstopEndpointResponse_Status_Status_MAX = DeregisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH;
constexpr int DeregisterEstopEndpointResponse_Status_Status_ARRAYSIZE = DeregisterEstopEndpointResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeregisterEstopEndpointResponse_Status_descriptor();
template<typename T>
inline const std::string& DeregisterEstopEndpointResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeregisterEstopEndpointResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeregisterEstopEndpointResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeregisterEstopEndpointResponse_Status_descriptor(), enum_t_value);
}
inline bool DeregisterEstopEndpointResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeregisterEstopEndpointResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeregisterEstopEndpointResponse_Status>(
    DeregisterEstopEndpointResponse_Status_descriptor(), name, value);
}
enum SetEstopConfigResponse_Status : int {
  SetEstopConfigResponse_Status_STATUS_UNKNOWN = 0,
  SetEstopConfigResponse_Status_STATUS_SUCCESS = 1,
  SetEstopConfigResponse_Status_STATUS_INVALID_ID = 2,
  SetEstopConfigResponse_Status_SetEstopConfigResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SetEstopConfigResponse_Status_SetEstopConfigResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SetEstopConfigResponse_Status_IsValid(int value);
constexpr SetEstopConfigResponse_Status SetEstopConfigResponse_Status_Status_MIN = SetEstopConfigResponse_Status_STATUS_UNKNOWN;
constexpr SetEstopConfigResponse_Status SetEstopConfigResponse_Status_Status_MAX = SetEstopConfigResponse_Status_STATUS_INVALID_ID;
constexpr int SetEstopConfigResponse_Status_Status_ARRAYSIZE = SetEstopConfigResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetEstopConfigResponse_Status_descriptor();
template<typename T>
inline const std::string& SetEstopConfigResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetEstopConfigResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetEstopConfigResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetEstopConfigResponse_Status_descriptor(), enum_t_value);
}
inline bool SetEstopConfigResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetEstopConfigResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetEstopConfigResponse_Status>(
    SetEstopConfigResponse_Status_descriptor(), name, value);
}
enum EstopStopLevel : int {
  ESTOP_LEVEL_UNKNOWN = 0,
  ESTOP_LEVEL_CUT = 1,
  ESTOP_LEVEL_SETTLE_THEN_CUT = 2,
  ESTOP_LEVEL_NONE = 4,
  EstopStopLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EstopStopLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EstopStopLevel_IsValid(int value);
constexpr EstopStopLevel EstopStopLevel_MIN = ESTOP_LEVEL_UNKNOWN;
constexpr EstopStopLevel EstopStopLevel_MAX = ESTOP_LEVEL_NONE;
constexpr int EstopStopLevel_ARRAYSIZE = EstopStopLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EstopStopLevel_descriptor();
template<typename T>
inline const std::string& EstopStopLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EstopStopLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EstopStopLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EstopStopLevel_descriptor(), enum_t_value);
}
inline bool EstopStopLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EstopStopLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EstopStopLevel>(
    EstopStopLevel_descriptor(), name, value);
}
// ===================================================================

class EstopEndpoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopEndpoint) */ {
 public:
  inline EstopEndpoint() : EstopEndpoint(nullptr) {}
  virtual ~EstopEndpoint();

  EstopEndpoint(const EstopEndpoint& from);
  EstopEndpoint(EstopEndpoint&& from) noexcept
    : EstopEndpoint() {
    *this = ::std::move(from);
  }

  inline EstopEndpoint& operator=(const EstopEndpoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopEndpoint& operator=(EstopEndpoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EstopEndpoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EstopEndpoint* internal_default_instance() {
    return reinterpret_cast<const EstopEndpoint*>(
               &_EstopEndpoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EstopEndpoint& a, EstopEndpoint& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopEndpoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopEndpoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EstopEndpoint* New() const final {
    return CreateMaybeMessage<EstopEndpoint>(nullptr);
  }

  EstopEndpoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EstopEndpoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EstopEndpoint& from);
  void MergeFrom(const EstopEndpoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopEndpoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopEndpoint";
  }
  protected:
  explicit EstopEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kNameFieldNumber = 2,
    kUniqueIdFieldNumber = 3,
    kTimeoutFieldNumber = 4,
    kCutPowerTimeoutFieldNumber = 5,
  };
  // string role = 1;
  void clear_role();
  const std::string& role() const;
  void set_role(const std::string& value);
  void set_role(std::string&& value);
  void set_role(const char* value);
  void set_role(const char* value, size_t size);
  std::string* mutable_role();
  std::string* release_role();
  void set_allocated_role(std::string* role);
  private:
  const std::string& _internal_role() const;
  void _internal_set_role(const std::string& value);
  std::string* _internal_mutable_role();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string unique_id = 3;
  void clear_unique_id();
  const std::string& unique_id() const;
  void set_unique_id(const std::string& value);
  void set_unique_id(std::string&& value);
  void set_unique_id(const char* value);
  void set_unique_id(const char* value, size_t size);
  std::string* mutable_unique_id();
  std::string* release_unique_id();
  void set_allocated_unique_id(std::string* unique_id);
  private:
  const std::string& _internal_unique_id() const;
  void _internal_set_unique_id(const std::string& value);
  std::string* _internal_mutable_unique_id();
  public:

  // .google.protobuf.Duration timeout = 4;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  const PROTOBUF_NAMESPACE_ID::Duration& timeout() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_timeout();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_timeout();
  void set_allocated_timeout(PROTOBUF_NAMESPACE_ID::Duration* timeout);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_timeout() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_timeout();
  public:
  void unsafe_arena_set_allocated_timeout(
      PROTOBUF_NAMESPACE_ID::Duration* timeout);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_timeout();

  // .google.protobuf.Duration cut_power_timeout = 5;
  bool has_cut_power_timeout() const;
  private:
  bool _internal_has_cut_power_timeout() const;
  public:
  void clear_cut_power_timeout();
  const PROTOBUF_NAMESPACE_ID::Duration& cut_power_timeout() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_cut_power_timeout();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_cut_power_timeout();
  void set_allocated_cut_power_timeout(PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_cut_power_timeout() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_cut_power_timeout();
  public:
  void unsafe_arena_set_allocated_cut_power_timeout(
      PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_cut_power_timeout();

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopEndpoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_id_;
  PROTOBUF_NAMESPACE_ID::Duration* timeout_;
  PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopConfig) */ {
 public:
  inline EstopConfig() : EstopConfig(nullptr) {}
  virtual ~EstopConfig();

  EstopConfig(const EstopConfig& from);
  EstopConfig(EstopConfig&& from) noexcept
    : EstopConfig() {
    *this = ::std::move(from);
  }

  inline EstopConfig& operator=(const EstopConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopConfig& operator=(EstopConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EstopConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EstopConfig* internal_default_instance() {
    return reinterpret_cast<const EstopConfig*>(
               &_EstopConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EstopConfig& a, EstopConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EstopConfig* New() const final {
    return CreateMaybeMessage<EstopConfig>(nullptr);
  }

  EstopConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EstopConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EstopConfig& from);
  void MergeFrom(const EstopConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopConfig";
  }
  protected:
  explicit EstopConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 1,
    kUniqueIdFieldNumber = 2,
  };
  // repeated .bosdyn.api.EstopEndpoint endpoints = 1;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  ::bosdyn::api::EstopEndpoint* mutable_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint >*
      mutable_endpoints();
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_endpoints(int index) const;
  ::bosdyn::api::EstopEndpoint* _internal_add_endpoints();
  public:
  const ::bosdyn::api::EstopEndpoint& endpoints(int index) const;
  ::bosdyn::api::EstopEndpoint* add_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint >&
      endpoints() const;

  // string unique_id = 2;
  void clear_unique_id();
  const std::string& unique_id() const;
  void set_unique_id(const std::string& value);
  void set_unique_id(std::string&& value);
  void set_unique_id(const char* value);
  void set_unique_id(const char* value, size_t size);
  std::string* mutable_unique_id();
  std::string* release_unique_id();
  void set_allocated_unique_id(std::string* unique_id);
  private:
  const std::string& _internal_unique_id() const;
  void _internal_set_unique_id(const std::string& value);
  std::string* _internal_mutable_unique_id();
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint > endpoints_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopEndpointWithStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopEndpointWithStatus) */ {
 public:
  inline EstopEndpointWithStatus() : EstopEndpointWithStatus(nullptr) {}
  virtual ~EstopEndpointWithStatus();

  EstopEndpointWithStatus(const EstopEndpointWithStatus& from);
  EstopEndpointWithStatus(EstopEndpointWithStatus&& from) noexcept
    : EstopEndpointWithStatus() {
    *this = ::std::move(from);
  }

  inline EstopEndpointWithStatus& operator=(const EstopEndpointWithStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopEndpointWithStatus& operator=(EstopEndpointWithStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EstopEndpointWithStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EstopEndpointWithStatus* internal_default_instance() {
    return reinterpret_cast<const EstopEndpointWithStatus*>(
               &_EstopEndpointWithStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EstopEndpointWithStatus& a, EstopEndpointWithStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopEndpointWithStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopEndpointWithStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EstopEndpointWithStatus* New() const final {
    return CreateMaybeMessage<EstopEndpointWithStatus>(nullptr);
  }

  EstopEndpointWithStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EstopEndpointWithStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EstopEndpointWithStatus& from);
  void MergeFrom(const EstopEndpointWithStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopEndpointWithStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopEndpointWithStatus";
  }
  protected:
  explicit EstopEndpointWithStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 1,
    kTimeSinceValidResponseFieldNumber = 3,
    kStopLevelFieldNumber = 2,
  };
  // .bosdyn.api.EstopEndpoint endpoint = 1;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::bosdyn::api::EstopEndpoint& endpoint() const;
  ::bosdyn::api::EstopEndpoint* release_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::bosdyn::api::EstopEndpoint* endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::bosdyn::api::EstopEndpoint* endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_endpoint();

  // .google.protobuf.Duration time_since_valid_response = 3;
  bool has_time_since_valid_response() const;
  private:
  bool _internal_has_time_since_valid_response() const;
  public:
  void clear_time_since_valid_response();
  const PROTOBUF_NAMESPACE_ID::Duration& time_since_valid_response() const;
  PROTOBUF_NAMESPACE_ID::Duration* release_time_since_valid_response();
  PROTOBUF_NAMESPACE_ID::Duration* mutable_time_since_valid_response();
  void set_allocated_time_since_valid_response(PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response);
  private:
  const PROTOBUF_NAMESPACE_ID::Duration& _internal_time_since_valid_response() const;
  PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_time_since_valid_response();
  public:
  void unsafe_arena_set_allocated_time_since_valid_response(
      PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response);
  PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_time_since_valid_response();

  // .bosdyn.api.EstopStopLevel stop_level = 2;
  void clear_stop_level();
  ::bosdyn::api::EstopStopLevel stop_level() const;
  void set_stop_level(::bosdyn::api::EstopStopLevel value);
  private:
  ::bosdyn::api::EstopStopLevel _internal_stop_level() const;
  void _internal_set_stop_level(::bosdyn::api::EstopStopLevel value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopEndpointWithStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::EstopEndpoint* endpoint_;
  PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response_;
  int stop_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopSystemStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopSystemStatus) */ {
 public:
  inline EstopSystemStatus() : EstopSystemStatus(nullptr) {}
  virtual ~EstopSystemStatus();

  EstopSystemStatus(const EstopSystemStatus& from);
  EstopSystemStatus(EstopSystemStatus&& from) noexcept
    : EstopSystemStatus() {
    *this = ::std::move(from);
  }

  inline EstopSystemStatus& operator=(const EstopSystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopSystemStatus& operator=(EstopSystemStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EstopSystemStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EstopSystemStatus* internal_default_instance() {
    return reinterpret_cast<const EstopSystemStatus*>(
               &_EstopSystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EstopSystemStatus& a, EstopSystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopSystemStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopSystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EstopSystemStatus* New() const final {
    return CreateMaybeMessage<EstopSystemStatus>(nullptr);
  }

  EstopSystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EstopSystemStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EstopSystemStatus& from);
  void MergeFrom(const EstopSystemStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopSystemStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopSystemStatus";
  }
  protected:
  explicit EstopSystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsFieldNumber = 3,
    kStopLevelDetailsFieldNumber = 5,
    kStopLevelFieldNumber = 4,
  };
  // repeated .bosdyn.api.EstopEndpointWithStatus endpoints = 3;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  ::bosdyn::api::EstopEndpointWithStatus* mutable_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus >*
      mutable_endpoints();
  private:
  const ::bosdyn::api::EstopEndpointWithStatus& _internal_endpoints(int index) const;
  ::bosdyn::api::EstopEndpointWithStatus* _internal_add_endpoints();
  public:
  const ::bosdyn::api::EstopEndpointWithStatus& endpoints(int index) const;
  ::bosdyn::api::EstopEndpointWithStatus* add_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus >&
      endpoints() const;

  // string stop_level_details = 5;
  void clear_stop_level_details();
  const std::string& stop_level_details() const;
  void set_stop_level_details(const std::string& value);
  void set_stop_level_details(std::string&& value);
  void set_stop_level_details(const char* value);
  void set_stop_level_details(const char* value, size_t size);
  std::string* mutable_stop_level_details();
  std::string* release_stop_level_details();
  void set_allocated_stop_level_details(std::string* stop_level_details);
  private:
  const std::string& _internal_stop_level_details() const;
  void _internal_set_stop_level_details(const std::string& value);
  std::string* _internal_mutable_stop_level_details();
  public:

  // .bosdyn.api.EstopStopLevel stop_level = 4;
  void clear_stop_level();
  ::bosdyn::api::EstopStopLevel stop_level() const;
  void set_stop_level(::bosdyn::api::EstopStopLevel value);
  private:
  ::bosdyn::api::EstopStopLevel _internal_stop_level() const;
  void _internal_set_stop_level(::bosdyn::api::EstopStopLevel value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopSystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus > endpoints_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_level_details_;
  int stop_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopCheckInRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopCheckInRequest) */ {
 public:
  inline EstopCheckInRequest() : EstopCheckInRequest(nullptr) {}
  virtual ~EstopCheckInRequest();

  EstopCheckInRequest(const EstopCheckInRequest& from);
  EstopCheckInRequest(EstopCheckInRequest&& from) noexcept
    : EstopCheckInRequest() {
    *this = ::std::move(from);
  }

  inline EstopCheckInRequest& operator=(const EstopCheckInRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopCheckInRequest& operator=(EstopCheckInRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EstopCheckInRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EstopCheckInRequest* internal_default_instance() {
    return reinterpret_cast<const EstopCheckInRequest*>(
               &_EstopCheckInRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EstopCheckInRequest& a, EstopCheckInRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopCheckInRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopCheckInRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EstopCheckInRequest* New() const final {
    return CreateMaybeMessage<EstopCheckInRequest>(nullptr);
  }

  EstopCheckInRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EstopCheckInRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EstopCheckInRequest& from);
  void MergeFrom(const EstopCheckInRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopCheckInRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopCheckInRequest";
  }
  protected:
  explicit EstopCheckInRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kEndpointFieldNumber = 2,
    kChallengeFieldNumber = 3,
    kResponseFieldNumber = 4,
    kStopLevelFieldNumber = 5,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopEndpoint endpoint = 2;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const ::bosdyn::api::EstopEndpoint& endpoint() const;
  ::bosdyn::api::EstopEndpoint* release_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::bosdyn::api::EstopEndpoint* endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::bosdyn::api::EstopEndpoint* endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_endpoint();

  // uint64 challenge = 3;
  void clear_challenge();
  ::PROTOBUF_NAMESPACE_ID::uint64 challenge() const;
  void set_challenge(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_challenge() const;
  void _internal_set_challenge(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 response = 4;
  void clear_response();
  ::PROTOBUF_NAMESPACE_ID::uint64 response() const;
  void set_response(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_response() const;
  void _internal_set_response(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .bosdyn.api.EstopStopLevel stop_level = 5;
  void clear_stop_level();
  ::bosdyn::api::EstopStopLevel stop_level() const;
  void set_stop_level(::bosdyn::api::EstopStopLevel value);
  private:
  ::bosdyn::api::EstopStopLevel _internal_stop_level() const;
  void _internal_set_stop_level(::bosdyn::api::EstopStopLevel value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopCheckInRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::EstopEndpoint* endpoint_;
  ::PROTOBUF_NAMESPACE_ID::uint64 challenge_;
  ::PROTOBUF_NAMESPACE_ID::uint64 response_;
  int stop_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class EstopCheckInResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.EstopCheckInResponse) */ {
 public:
  inline EstopCheckInResponse() : EstopCheckInResponse(nullptr) {}
  virtual ~EstopCheckInResponse();

  EstopCheckInResponse(const EstopCheckInResponse& from);
  EstopCheckInResponse(EstopCheckInResponse&& from) noexcept
    : EstopCheckInResponse() {
    *this = ::std::move(from);
  }

  inline EstopCheckInResponse& operator=(const EstopCheckInResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstopCheckInResponse& operator=(EstopCheckInResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EstopCheckInResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EstopCheckInResponse* internal_default_instance() {
    return reinterpret_cast<const EstopCheckInResponse*>(
               &_EstopCheckInResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EstopCheckInResponse& a, EstopCheckInResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EstopCheckInResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstopCheckInResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EstopCheckInResponse* New() const final {
    return CreateMaybeMessage<EstopCheckInResponse>(nullptr);
  }

  EstopCheckInResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EstopCheckInResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EstopCheckInResponse& from);
  void MergeFrom(const EstopCheckInResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstopCheckInResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.EstopCheckInResponse";
  }
  protected:
  explicit EstopCheckInResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EstopCheckInResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    EstopCheckInResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_OK =
    EstopCheckInResponse_Status_STATUS_OK;
  static constexpr Status STATUS_ENDPOINT_UNKNOWN =
    EstopCheckInResponse_Status_STATUS_ENDPOINT_UNKNOWN;
  static constexpr Status STATUS_INCORRECT_CHALLENGE_RESPONSE =
    EstopCheckInResponse_Status_STATUS_INCORRECT_CHALLENGE_RESPONSE;
  static inline bool Status_IsValid(int value) {
    return EstopCheckInResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    EstopCheckInResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    EstopCheckInResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    EstopCheckInResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return EstopCheckInResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return EstopCheckInResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return EstopCheckInResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kChallengeFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopCheckInRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::EstopCheckInRequest& request() const;
  ::bosdyn::api::EstopCheckInRequest* release_request();
  ::bosdyn::api::EstopCheckInRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::EstopCheckInRequest* request);
  private:
  const ::bosdyn::api::EstopCheckInRequest& _internal_request() const;
  ::bosdyn::api::EstopCheckInRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::EstopCheckInRequest* request);
  ::bosdyn::api::EstopCheckInRequest* unsafe_arena_release_request();

  // uint64 challenge = 3;
  void clear_challenge();
  ::PROTOBUF_NAMESPACE_ID::uint64 challenge() const;
  void set_challenge(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_challenge() const;
  void _internal_set_challenge(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .bosdyn.api.EstopCheckInResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::EstopCheckInResponse_Status status() const;
  void set_status(::bosdyn::api::EstopCheckInResponse_Status value);
  private:
  ::bosdyn::api::EstopCheckInResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::EstopCheckInResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.EstopCheckInResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::EstopCheckInRequest* request_;
  ::PROTOBUF_NAMESPACE_ID::uint64 challenge_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class RegisterEstopEndpointRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RegisterEstopEndpointRequest) */ {
 public:
  inline RegisterEstopEndpointRequest() : RegisterEstopEndpointRequest(nullptr) {}
  virtual ~RegisterEstopEndpointRequest();

  RegisterEstopEndpointRequest(const RegisterEstopEndpointRequest& from);
  RegisterEstopEndpointRequest(RegisterEstopEndpointRequest&& from) noexcept
    : RegisterEstopEndpointRequest() {
    *this = ::std::move(from);
  }

  inline RegisterEstopEndpointRequest& operator=(const RegisterEstopEndpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEstopEndpointRequest& operator=(RegisterEstopEndpointRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegisterEstopEndpointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterEstopEndpointRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterEstopEndpointRequest*>(
               &_RegisterEstopEndpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegisterEstopEndpointRequest& a, RegisterEstopEndpointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEstopEndpointRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEstopEndpointRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisterEstopEndpointRequest* New() const final {
    return CreateMaybeMessage<RegisterEstopEndpointRequest>(nullptr);
  }

  RegisterEstopEndpointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterEstopEndpointRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegisterEstopEndpointRequest& from);
  void MergeFrom(const RegisterEstopEndpointRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEstopEndpointRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RegisterEstopEndpointRequest";
  }
  protected:
  explicit RegisterEstopEndpointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetConfigIdFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kTargetEndpointFieldNumber = 2,
    kNewEndpointFieldNumber = 4,
  };
  // string target_config_id = 3;
  void clear_target_config_id();
  const std::string& target_config_id() const;
  void set_target_config_id(const std::string& value);
  void set_target_config_id(std::string&& value);
  void set_target_config_id(const char* value);
  void set_target_config_id(const char* value, size_t size);
  std::string* mutable_target_config_id();
  std::string* release_target_config_id();
  void set_allocated_target_config_id(std::string* target_config_id);
  private:
  const std::string& _internal_target_config_id() const;
  void _internal_set_target_config_id(const std::string& value);
  std::string* _internal_mutable_target_config_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopEndpoint target_endpoint = 2;
  bool has_target_endpoint() const;
  private:
  bool _internal_has_target_endpoint() const;
  public:
  void clear_target_endpoint();
  const ::bosdyn::api::EstopEndpoint& target_endpoint() const;
  ::bosdyn::api::EstopEndpoint* release_target_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_target_endpoint();
  void set_allocated_target_endpoint(::bosdyn::api::EstopEndpoint* target_endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_target_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_target_endpoint();
  public:
  void unsafe_arena_set_allocated_target_endpoint(
      ::bosdyn::api::EstopEndpoint* target_endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_target_endpoint();

  // .bosdyn.api.EstopEndpoint new_endpoint = 4;
  bool has_new_endpoint() const;
  private:
  bool _internal_has_new_endpoint() const;
  public:
  void clear_new_endpoint();
  const ::bosdyn::api::EstopEndpoint& new_endpoint() const;
  ::bosdyn::api::EstopEndpoint* release_new_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_new_endpoint();
  void set_allocated_new_endpoint(::bosdyn::api::EstopEndpoint* new_endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_new_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_new_endpoint();
  public:
  void unsafe_arena_set_allocated_new_endpoint(
      ::bosdyn::api::EstopEndpoint* new_endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_new_endpoint();

  // @@protoc_insertion_point(class_scope:bosdyn.api.RegisterEstopEndpointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_config_id_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::EstopEndpoint* target_endpoint_;
  ::bosdyn::api::EstopEndpoint* new_endpoint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class RegisterEstopEndpointResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.RegisterEstopEndpointResponse) */ {
 public:
  inline RegisterEstopEndpointResponse() : RegisterEstopEndpointResponse(nullptr) {}
  virtual ~RegisterEstopEndpointResponse();

  RegisterEstopEndpointResponse(const RegisterEstopEndpointResponse& from);
  RegisterEstopEndpointResponse(RegisterEstopEndpointResponse&& from) noexcept
    : RegisterEstopEndpointResponse() {
    *this = ::std::move(from);
  }

  inline RegisterEstopEndpointResponse& operator=(const RegisterEstopEndpointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterEstopEndpointResponse& operator=(RegisterEstopEndpointResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegisterEstopEndpointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterEstopEndpointResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterEstopEndpointResponse*>(
               &_RegisterEstopEndpointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegisterEstopEndpointResponse& a, RegisterEstopEndpointResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterEstopEndpointResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterEstopEndpointResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegisterEstopEndpointResponse* New() const final {
    return CreateMaybeMessage<RegisterEstopEndpointResponse>(nullptr);
  }

  RegisterEstopEndpointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterEstopEndpointResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegisterEstopEndpointResponse& from);
  void MergeFrom(const RegisterEstopEndpointResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterEstopEndpointResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.RegisterEstopEndpointResponse";
  }
  protected:
  explicit RegisterEstopEndpointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RegisterEstopEndpointResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    RegisterEstopEndpointResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_SUCCESS =
    RegisterEstopEndpointResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_ENDPOINT_MISMATCH =
    RegisterEstopEndpointResponse_Status_STATUS_ENDPOINT_MISMATCH;
  static constexpr Status STATUS_CONFIG_MISMATCH =
    RegisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH;
  static constexpr Status STATUS_INVALID_ENDPOINT =
    RegisterEstopEndpointResponse_Status_STATUS_INVALID_ENDPOINT;
  static inline bool Status_IsValid(int value) {
    return RegisterEstopEndpointResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    RegisterEstopEndpointResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    RegisterEstopEndpointResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    RegisterEstopEndpointResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return RegisterEstopEndpointResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return RegisterEstopEndpointResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return RegisterEstopEndpointResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kNewEndpointFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.RegisterEstopEndpointRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::RegisterEstopEndpointRequest& request() const;
  ::bosdyn::api::RegisterEstopEndpointRequest* release_request();
  ::bosdyn::api::RegisterEstopEndpointRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::RegisterEstopEndpointRequest* request);
  private:
  const ::bosdyn::api::RegisterEstopEndpointRequest& _internal_request() const;
  ::bosdyn::api::RegisterEstopEndpointRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::RegisterEstopEndpointRequest* request);
  ::bosdyn::api::RegisterEstopEndpointRequest* unsafe_arena_release_request();

  // .bosdyn.api.EstopEndpoint new_endpoint = 3;
  bool has_new_endpoint() const;
  private:
  bool _internal_has_new_endpoint() const;
  public:
  void clear_new_endpoint();
  const ::bosdyn::api::EstopEndpoint& new_endpoint() const;
  ::bosdyn::api::EstopEndpoint* release_new_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_new_endpoint();
  void set_allocated_new_endpoint(::bosdyn::api::EstopEndpoint* new_endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_new_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_new_endpoint();
  public:
  void unsafe_arena_set_allocated_new_endpoint(
      ::bosdyn::api::EstopEndpoint* new_endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_new_endpoint();

  // .bosdyn.api.RegisterEstopEndpointResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::RegisterEstopEndpointResponse_Status status() const;
  void set_status(::bosdyn::api::RegisterEstopEndpointResponse_Status value);
  private:
  ::bosdyn::api::RegisterEstopEndpointResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::RegisterEstopEndpointResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.RegisterEstopEndpointResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::RegisterEstopEndpointRequest* request_;
  ::bosdyn::api::EstopEndpoint* new_endpoint_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class DeregisterEstopEndpointRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DeregisterEstopEndpointRequest) */ {
 public:
  inline DeregisterEstopEndpointRequest() : DeregisterEstopEndpointRequest(nullptr) {}
  virtual ~DeregisterEstopEndpointRequest();

  DeregisterEstopEndpointRequest(const DeregisterEstopEndpointRequest& from);
  DeregisterEstopEndpointRequest(DeregisterEstopEndpointRequest&& from) noexcept
    : DeregisterEstopEndpointRequest() {
    *this = ::std::move(from);
  }

  inline DeregisterEstopEndpointRequest& operator=(const DeregisterEstopEndpointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterEstopEndpointRequest& operator=(DeregisterEstopEndpointRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeregisterEstopEndpointRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeregisterEstopEndpointRequest* internal_default_instance() {
    return reinterpret_cast<const DeregisterEstopEndpointRequest*>(
               &_DeregisterEstopEndpointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeregisterEstopEndpointRequest& a, DeregisterEstopEndpointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregisterEstopEndpointRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterEstopEndpointRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeregisterEstopEndpointRequest* New() const final {
    return CreateMaybeMessage<DeregisterEstopEndpointRequest>(nullptr);
  }

  DeregisterEstopEndpointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeregisterEstopEndpointRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeregisterEstopEndpointRequest& from);
  void MergeFrom(const DeregisterEstopEndpointRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregisterEstopEndpointRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DeregisterEstopEndpointRequest";
  }
  protected:
  explicit DeregisterEstopEndpointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetConfigIdFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kTargetEndpointFieldNumber = 2,
  };
  // string target_config_id = 3;
  void clear_target_config_id();
  const std::string& target_config_id() const;
  void set_target_config_id(const std::string& value);
  void set_target_config_id(std::string&& value);
  void set_target_config_id(const char* value);
  void set_target_config_id(const char* value, size_t size);
  std::string* mutable_target_config_id();
  std::string* release_target_config_id();
  void set_allocated_target_config_id(std::string* target_config_id);
  private:
  const std::string& _internal_target_config_id() const;
  void _internal_set_target_config_id(const std::string& value);
  std::string* _internal_mutable_target_config_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopEndpoint target_endpoint = 2;
  bool has_target_endpoint() const;
  private:
  bool _internal_has_target_endpoint() const;
  public:
  void clear_target_endpoint();
  const ::bosdyn::api::EstopEndpoint& target_endpoint() const;
  ::bosdyn::api::EstopEndpoint* release_target_endpoint();
  ::bosdyn::api::EstopEndpoint* mutable_target_endpoint();
  void set_allocated_target_endpoint(::bosdyn::api::EstopEndpoint* target_endpoint);
  private:
  const ::bosdyn::api::EstopEndpoint& _internal_target_endpoint() const;
  ::bosdyn::api::EstopEndpoint* _internal_mutable_target_endpoint();
  public:
  void unsafe_arena_set_allocated_target_endpoint(
      ::bosdyn::api::EstopEndpoint* target_endpoint);
  ::bosdyn::api::EstopEndpoint* unsafe_arena_release_target_endpoint();

  // @@protoc_insertion_point(class_scope:bosdyn.api.DeregisterEstopEndpointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_config_id_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::EstopEndpoint* target_endpoint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class DeregisterEstopEndpointResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.DeregisterEstopEndpointResponse) */ {
 public:
  inline DeregisterEstopEndpointResponse() : DeregisterEstopEndpointResponse(nullptr) {}
  virtual ~DeregisterEstopEndpointResponse();

  DeregisterEstopEndpointResponse(const DeregisterEstopEndpointResponse& from);
  DeregisterEstopEndpointResponse(DeregisterEstopEndpointResponse&& from) noexcept
    : DeregisterEstopEndpointResponse() {
    *this = ::std::move(from);
  }

  inline DeregisterEstopEndpointResponse& operator=(const DeregisterEstopEndpointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterEstopEndpointResponse& operator=(DeregisterEstopEndpointResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeregisterEstopEndpointResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeregisterEstopEndpointResponse* internal_default_instance() {
    return reinterpret_cast<const DeregisterEstopEndpointResponse*>(
               &_DeregisterEstopEndpointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeregisterEstopEndpointResponse& a, DeregisterEstopEndpointResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeregisterEstopEndpointResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterEstopEndpointResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeregisterEstopEndpointResponse* New() const final {
    return CreateMaybeMessage<DeregisterEstopEndpointResponse>(nullptr);
  }

  DeregisterEstopEndpointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeregisterEstopEndpointResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeregisterEstopEndpointResponse& from);
  void MergeFrom(const DeregisterEstopEndpointResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeregisterEstopEndpointResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.DeregisterEstopEndpointResponse";
  }
  protected:
  explicit DeregisterEstopEndpointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DeregisterEstopEndpointResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    DeregisterEstopEndpointResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_SUCCESS =
    DeregisterEstopEndpointResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_ENDPOINT_MISMATCH =
    DeregisterEstopEndpointResponse_Status_STATUS_ENDPOINT_MISMATCH;
  static constexpr Status STATUS_CONFIG_MISMATCH =
    DeregisterEstopEndpointResponse_Status_STATUS_CONFIG_MISMATCH;
  static inline bool Status_IsValid(int value) {
    return DeregisterEstopEndpointResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DeregisterEstopEndpointResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DeregisterEstopEndpointResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DeregisterEstopEndpointResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DeregisterEstopEndpointResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DeregisterEstopEndpointResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DeregisterEstopEndpointResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.DeregisterEstopEndpointRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::DeregisterEstopEndpointRequest& request() const;
  ::bosdyn::api::DeregisterEstopEndpointRequest* release_request();
  ::bosdyn::api::DeregisterEstopEndpointRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::DeregisterEstopEndpointRequest* request);
  private:
  const ::bosdyn::api::DeregisterEstopEndpointRequest& _internal_request() const;
  ::bosdyn::api::DeregisterEstopEndpointRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::DeregisterEstopEndpointRequest* request);
  ::bosdyn::api::DeregisterEstopEndpointRequest* unsafe_arena_release_request();

  // .bosdyn.api.DeregisterEstopEndpointResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::DeregisterEstopEndpointResponse_Status status() const;
  void set_status(::bosdyn::api::DeregisterEstopEndpointResponse_Status value);
  private:
  ::bosdyn::api::DeregisterEstopEndpointResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::DeregisterEstopEndpointResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.DeregisterEstopEndpointResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::DeregisterEstopEndpointRequest* request_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class GetEstopConfigRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEstopConfigRequest) */ {
 public:
  inline GetEstopConfigRequest() : GetEstopConfigRequest(nullptr) {}
  virtual ~GetEstopConfigRequest();

  GetEstopConfigRequest(const GetEstopConfigRequest& from);
  GetEstopConfigRequest(GetEstopConfigRequest&& from) noexcept
    : GetEstopConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetEstopConfigRequest& operator=(const GetEstopConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEstopConfigRequest& operator=(GetEstopConfigRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetEstopConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEstopConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetEstopConfigRequest*>(
               &_GetEstopConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetEstopConfigRequest& a, GetEstopConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEstopConfigRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEstopConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEstopConfigRequest* New() const final {
    return CreateMaybeMessage<GetEstopConfigRequest>(nullptr);
  }

  GetEstopConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEstopConfigRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetEstopConfigRequest& from);
  void MergeFrom(const GetEstopConfigRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEstopConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEstopConfigRequest";
  }
  protected:
  explicit GetEstopConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetConfigIdFieldNumber = 4,
    kHeaderFieldNumber = 1,
  };
  // string target_config_id = 4;
  void clear_target_config_id();
  const std::string& target_config_id() const;
  void set_target_config_id(const std::string& value);
  void set_target_config_id(std::string&& value);
  void set_target_config_id(const char* value);
  void set_target_config_id(const char* value, size_t size);
  std::string* mutable_target_config_id();
  std::string* release_target_config_id();
  void set_allocated_target_config_id(std::string* target_config_id);
  private:
  const std::string& _internal_target_config_id() const;
  void _internal_set_target_config_id(const std::string& value);
  std::string* _internal_mutable_target_config_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEstopConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_config_id_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class GetEstopConfigResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEstopConfigResponse) */ {
 public:
  inline GetEstopConfigResponse() : GetEstopConfigResponse(nullptr) {}
  virtual ~GetEstopConfigResponse();

  GetEstopConfigResponse(const GetEstopConfigResponse& from);
  GetEstopConfigResponse(GetEstopConfigResponse&& from) noexcept
    : GetEstopConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetEstopConfigResponse& operator=(const GetEstopConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEstopConfigResponse& operator=(GetEstopConfigResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetEstopConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEstopConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetEstopConfigResponse*>(
               &_GetEstopConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetEstopConfigResponse& a, GetEstopConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEstopConfigResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEstopConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEstopConfigResponse* New() const final {
    return CreateMaybeMessage<GetEstopConfigResponse>(nullptr);
  }

  GetEstopConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEstopConfigResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetEstopConfigResponse& from);
  void MergeFrom(const GetEstopConfigResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEstopConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEstopConfigResponse";
  }
  protected:
  explicit GetEstopConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kActiveConfigFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.GetEstopConfigRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::GetEstopConfigRequest& request() const;
  ::bosdyn::api::GetEstopConfigRequest* release_request();
  ::bosdyn::api::GetEstopConfigRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::GetEstopConfigRequest* request);
  private:
  const ::bosdyn::api::GetEstopConfigRequest& _internal_request() const;
  ::bosdyn::api::GetEstopConfigRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::GetEstopConfigRequest* request);
  ::bosdyn::api::GetEstopConfigRequest* unsafe_arena_release_request();

  // .bosdyn.api.EstopConfig active_config = 3;
  bool has_active_config() const;
  private:
  bool _internal_has_active_config() const;
  public:
  void clear_active_config();
  const ::bosdyn::api::EstopConfig& active_config() const;
  ::bosdyn::api::EstopConfig* release_active_config();
  ::bosdyn::api::EstopConfig* mutable_active_config();
  void set_allocated_active_config(::bosdyn::api::EstopConfig* active_config);
  private:
  const ::bosdyn::api::EstopConfig& _internal_active_config() const;
  ::bosdyn::api::EstopConfig* _internal_mutable_active_config();
  public:
  void unsafe_arena_set_allocated_active_config(
      ::bosdyn::api::EstopConfig* active_config);
  ::bosdyn::api::EstopConfig* unsafe_arena_release_active_config();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEstopConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::GetEstopConfigRequest* request_;
  ::bosdyn::api::EstopConfig* active_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class SetEstopConfigRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SetEstopConfigRequest) */ {
 public:
  inline SetEstopConfigRequest() : SetEstopConfigRequest(nullptr) {}
  virtual ~SetEstopConfigRequest();

  SetEstopConfigRequest(const SetEstopConfigRequest& from);
  SetEstopConfigRequest(SetEstopConfigRequest&& from) noexcept
    : SetEstopConfigRequest() {
    *this = ::std::move(from);
  }

  inline SetEstopConfigRequest& operator=(const SetEstopConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEstopConfigRequest& operator=(SetEstopConfigRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetEstopConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetEstopConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SetEstopConfigRequest*>(
               &_SetEstopConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetEstopConfigRequest& a, SetEstopConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEstopConfigRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEstopConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetEstopConfigRequest* New() const final {
    return CreateMaybeMessage<SetEstopConfigRequest>(nullptr);
  }

  SetEstopConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetEstopConfigRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetEstopConfigRequest& from);
  void MergeFrom(const SetEstopConfigRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEstopConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SetEstopConfigRequest";
  }
  protected:
  explicit SetEstopConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetConfigIdFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kConfigFieldNumber = 3,
  };
  // string target_config_id = 4;
  void clear_target_config_id();
  const std::string& target_config_id() const;
  void set_target_config_id(const std::string& value);
  void set_target_config_id(std::string&& value);
  void set_target_config_id(const char* value);
  void set_target_config_id(const char* value, size_t size);
  std::string* mutable_target_config_id();
  std::string* release_target_config_id();
  void set_allocated_target_config_id(std::string* target_config_id);
  private:
  const std::string& _internal_target_config_id() const;
  void _internal_set_target_config_id(const std::string& value);
  std::string* _internal_mutable_target_config_id();
  public:

  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopConfig config = 3;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::bosdyn::api::EstopConfig& config() const;
  ::bosdyn::api::EstopConfig* release_config();
  ::bosdyn::api::EstopConfig* mutable_config();
  void set_allocated_config(::bosdyn::api::EstopConfig* config);
  private:
  const ::bosdyn::api::EstopConfig& _internal_config() const;
  ::bosdyn::api::EstopConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::bosdyn::api::EstopConfig* config);
  ::bosdyn::api::EstopConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:bosdyn.api.SetEstopConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_config_id_;
  ::bosdyn::api::RequestHeader* header_;
  ::bosdyn::api::EstopConfig* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class SetEstopConfigResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.SetEstopConfigResponse) */ {
 public:
  inline SetEstopConfigResponse() : SetEstopConfigResponse(nullptr) {}
  virtual ~SetEstopConfigResponse();

  SetEstopConfigResponse(const SetEstopConfigResponse& from);
  SetEstopConfigResponse(SetEstopConfigResponse&& from) noexcept
    : SetEstopConfigResponse() {
    *this = ::std::move(from);
  }

  inline SetEstopConfigResponse& operator=(const SetEstopConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEstopConfigResponse& operator=(SetEstopConfigResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SetEstopConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetEstopConfigResponse* internal_default_instance() {
    return reinterpret_cast<const SetEstopConfigResponse*>(
               &_SetEstopConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SetEstopConfigResponse& a, SetEstopConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEstopConfigResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEstopConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetEstopConfigResponse* New() const final {
    return CreateMaybeMessage<SetEstopConfigResponse>(nullptr);
  }

  SetEstopConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetEstopConfigResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SetEstopConfigResponse& from);
  void MergeFrom(const SetEstopConfigResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEstopConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.SetEstopConfigResponse";
  }
  protected:
  explicit SetEstopConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SetEstopConfigResponse_Status Status;
  static constexpr Status STATUS_UNKNOWN =
    SetEstopConfigResponse_Status_STATUS_UNKNOWN;
  static constexpr Status STATUS_SUCCESS =
    SetEstopConfigResponse_Status_STATUS_SUCCESS;
  static constexpr Status STATUS_INVALID_ID =
    SetEstopConfigResponse_Status_STATUS_INVALID_ID;
  static inline bool Status_IsValid(int value) {
    return SetEstopConfigResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    SetEstopConfigResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    SetEstopConfigResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    SetEstopConfigResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return SetEstopConfigResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return SetEstopConfigResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return SetEstopConfigResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kRequestFieldNumber = 2,
    kActiveConfigFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.SetEstopConfigRequest request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::bosdyn::api::SetEstopConfigRequest& request() const;
  ::bosdyn::api::SetEstopConfigRequest* release_request();
  ::bosdyn::api::SetEstopConfigRequest* mutable_request();
  void set_allocated_request(::bosdyn::api::SetEstopConfigRequest* request);
  private:
  const ::bosdyn::api::SetEstopConfigRequest& _internal_request() const;
  ::bosdyn::api::SetEstopConfigRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::bosdyn::api::SetEstopConfigRequest* request);
  ::bosdyn::api::SetEstopConfigRequest* unsafe_arena_release_request();

  // .bosdyn.api.EstopConfig active_config = 3;
  bool has_active_config() const;
  private:
  bool _internal_has_active_config() const;
  public:
  void clear_active_config();
  const ::bosdyn::api::EstopConfig& active_config() const;
  ::bosdyn::api::EstopConfig* release_active_config();
  ::bosdyn::api::EstopConfig* mutable_active_config();
  void set_allocated_active_config(::bosdyn::api::EstopConfig* active_config);
  private:
  const ::bosdyn::api::EstopConfig& _internal_active_config() const;
  ::bosdyn::api::EstopConfig* _internal_mutable_active_config();
  public:
  void unsafe_arena_set_allocated_active_config(
      ::bosdyn::api::EstopConfig* active_config);
  ::bosdyn::api::EstopConfig* unsafe_arena_release_active_config();

  // .bosdyn.api.SetEstopConfigResponse.Status status = 4;
  void clear_status();
  ::bosdyn::api::SetEstopConfigResponse_Status status() const;
  void set_status(::bosdyn::api::SetEstopConfigResponse_Status value);
  private:
  ::bosdyn::api::SetEstopConfigResponse_Status _internal_status() const;
  void _internal_set_status(::bosdyn::api::SetEstopConfigResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:bosdyn.api.SetEstopConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::SetEstopConfigRequest* request_;
  ::bosdyn::api::EstopConfig* active_config_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class GetEstopSystemStatusRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEstopSystemStatusRequest) */ {
 public:
  inline GetEstopSystemStatusRequest() : GetEstopSystemStatusRequest(nullptr) {}
  virtual ~GetEstopSystemStatusRequest();

  GetEstopSystemStatusRequest(const GetEstopSystemStatusRequest& from);
  GetEstopSystemStatusRequest(GetEstopSystemStatusRequest&& from) noexcept
    : GetEstopSystemStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetEstopSystemStatusRequest& operator=(const GetEstopSystemStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEstopSystemStatusRequest& operator=(GetEstopSystemStatusRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetEstopSystemStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEstopSystemStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetEstopSystemStatusRequest*>(
               &_GetEstopSystemStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetEstopSystemStatusRequest& a, GetEstopSystemStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEstopSystemStatusRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEstopSystemStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEstopSystemStatusRequest* New() const final {
    return CreateMaybeMessage<GetEstopSystemStatusRequest>(nullptr);
  }

  GetEstopSystemStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEstopSystemStatusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetEstopSystemStatusRequest& from);
  void MergeFrom(const GetEstopSystemStatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEstopSystemStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEstopSystemStatusRequest";
  }
  protected:
  explicit GetEstopSystemStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .bosdyn.api.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::RequestHeader& header() const;
  ::bosdyn::api::RequestHeader* release_header();
  ::bosdyn::api::RequestHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::RequestHeader* header);
  private:
  const ::bosdyn::api::RequestHeader& _internal_header() const;
  ::bosdyn::api::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::RequestHeader* header);
  ::bosdyn::api::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEstopSystemStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// -------------------------------------------------------------------

class GetEstopSystemStatusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bosdyn.api.GetEstopSystemStatusResponse) */ {
 public:
  inline GetEstopSystemStatusResponse() : GetEstopSystemStatusResponse(nullptr) {}
  virtual ~GetEstopSystemStatusResponse();

  GetEstopSystemStatusResponse(const GetEstopSystemStatusResponse& from);
  GetEstopSystemStatusResponse(GetEstopSystemStatusResponse&& from) noexcept
    : GetEstopSystemStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetEstopSystemStatusResponse& operator=(const GetEstopSystemStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEstopSystemStatusResponse& operator=(GetEstopSystemStatusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetEstopSystemStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetEstopSystemStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetEstopSystemStatusResponse*>(
               &_GetEstopSystemStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetEstopSystemStatusResponse& a, GetEstopSystemStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEstopSystemStatusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEstopSystemStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEstopSystemStatusResponse* New() const final {
    return CreateMaybeMessage<GetEstopSystemStatusResponse>(nullptr);
  }

  GetEstopSystemStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEstopSystemStatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetEstopSystemStatusResponse& from);
  void MergeFrom(const GetEstopSystemStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEstopSystemStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bosdyn.api.GetEstopSystemStatusResponse";
  }
  protected:
  explicit GetEstopSystemStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bosdyn_2fapi_2festop_2eproto);
    return ::descriptor_table_bosdyn_2fapi_2festop_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kStatusFieldNumber = 3,
  };
  // .bosdyn.api.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::bosdyn::api::ResponseHeader& header() const;
  ::bosdyn::api::ResponseHeader* release_header();
  ::bosdyn::api::ResponseHeader* mutable_header();
  void set_allocated_header(::bosdyn::api::ResponseHeader* header);
  private:
  const ::bosdyn::api::ResponseHeader& _internal_header() const;
  ::bosdyn::api::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::bosdyn::api::ResponseHeader* header);
  ::bosdyn::api::ResponseHeader* unsafe_arena_release_header();

  // .bosdyn.api.EstopSystemStatus status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::bosdyn::api::EstopSystemStatus& status() const;
  ::bosdyn::api::EstopSystemStatus* release_status();
  ::bosdyn::api::EstopSystemStatus* mutable_status();
  void set_allocated_status(::bosdyn::api::EstopSystemStatus* status);
  private:
  const ::bosdyn::api::EstopSystemStatus& _internal_status() const;
  ::bosdyn::api::EstopSystemStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::bosdyn::api::EstopSystemStatus* status);
  ::bosdyn::api::EstopSystemStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:bosdyn.api.GetEstopSystemStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bosdyn::api::ResponseHeader* header_;
  ::bosdyn::api::EstopSystemStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bosdyn_2fapi_2festop_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EstopEndpoint

// string role = 1;
inline void EstopEndpoint::clear_role() {
  role_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EstopEndpoint::role() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.role)
  return _internal_role();
}
inline void EstopEndpoint::set_role(const std::string& value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopEndpoint.role)
}
inline std::string* EstopEndpoint::mutable_role() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.role)
  return _internal_mutable_role();
}
inline const std::string& EstopEndpoint::_internal_role() const {
  return role_.Get();
}
inline void EstopEndpoint::_internal_set_role(const std::string& value) {
  
  role_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EstopEndpoint::set_role(std::string&& value) {
  
  role_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.EstopEndpoint.role)
}
inline void EstopEndpoint::set_role(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  role_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.EstopEndpoint.role)
}
inline void EstopEndpoint::set_role(const char* value,
    size_t size) {
  
  role_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.EstopEndpoint.role)
}
inline std::string* EstopEndpoint::_internal_mutable_role() {
  
  return role_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EstopEndpoint::release_role() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.role)
  return role_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EstopEndpoint::set_allocated_role(std::string* role) {
  if (role != nullptr) {
    
  } else {
    
  }
  role_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), role,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.role)
}

// string name = 2;
inline void EstopEndpoint::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EstopEndpoint::name() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.name)
  return _internal_name();
}
inline void EstopEndpoint::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopEndpoint.name)
}
inline std::string* EstopEndpoint::mutable_name() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.name)
  return _internal_mutable_name();
}
inline const std::string& EstopEndpoint::_internal_name() const {
  return name_.Get();
}
inline void EstopEndpoint::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EstopEndpoint::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.EstopEndpoint.name)
}
inline void EstopEndpoint::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.EstopEndpoint.name)
}
inline void EstopEndpoint::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.EstopEndpoint.name)
}
inline std::string* EstopEndpoint::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EstopEndpoint::release_name() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EstopEndpoint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.name)
}

// string unique_id = 3;
inline void EstopEndpoint::clear_unique_id() {
  unique_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EstopEndpoint::unique_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.unique_id)
  return _internal_unique_id();
}
inline void EstopEndpoint::set_unique_id(const std::string& value) {
  _internal_set_unique_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopEndpoint.unique_id)
}
inline std::string* EstopEndpoint::mutable_unique_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.unique_id)
  return _internal_mutable_unique_id();
}
inline const std::string& EstopEndpoint::_internal_unique_id() const {
  return unique_id_.Get();
}
inline void EstopEndpoint::_internal_set_unique_id(const std::string& value) {
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EstopEndpoint::set_unique_id(std::string&& value) {
  
  unique_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.EstopEndpoint.unique_id)
}
inline void EstopEndpoint::set_unique_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.EstopEndpoint.unique_id)
}
inline void EstopEndpoint::set_unique_id(const char* value,
    size_t size) {
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.EstopEndpoint.unique_id)
}
inline std::string* EstopEndpoint::_internal_mutable_unique_id() {
  
  return unique_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EstopEndpoint::release_unique_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.unique_id)
  return unique_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EstopEndpoint::set_allocated_unique_id(std::string* unique_id) {
  if (unique_id != nullptr) {
    
  } else {
    
  }
  unique_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.unique_id)
}

// .google.protobuf.Duration timeout = 4;
inline bool EstopEndpoint::_internal_has_timeout() const {
  return this != internal_default_instance() && timeout_ != nullptr;
}
inline bool EstopEndpoint::has_timeout() const {
  return _internal_has_timeout();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& EstopEndpoint::_internal_timeout() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = timeout_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration*>(
      &PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& EstopEndpoint::timeout() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.timeout)
  return _internal_timeout();
}
inline void EstopEndpoint::unsafe_arena_set_allocated_timeout(
    PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopEndpoint.timeout)
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::release_timeout() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::unsafe_arena_release_timeout() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.timeout)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = timeout_;
  timeout_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::_internal_mutable_timeout() {
  
  if (timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    timeout_ = p;
  }
  return timeout_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::mutable_timeout() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.timeout)
  return _internal_mutable_timeout();
}
inline void EstopEndpoint::set_allocated_timeout(PROTOBUF_NAMESPACE_ID::Duration* timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout_);
  }
  if (timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timeout)->GetArena();
    if (message_arena != submessage_arena) {
      timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timeout, submessage_arena);
    }
    
  } else {
    
  }
  timeout_ = timeout;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.timeout)
}

// .google.protobuf.Duration cut_power_timeout = 5;
inline bool EstopEndpoint::_internal_has_cut_power_timeout() const {
  return this != internal_default_instance() && cut_power_timeout_ != nullptr;
}
inline bool EstopEndpoint::has_cut_power_timeout() const {
  return _internal_has_cut_power_timeout();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& EstopEndpoint::_internal_cut_power_timeout() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = cut_power_timeout_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration*>(
      &PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& EstopEndpoint::cut_power_timeout() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpoint.cut_power_timeout)
  return _internal_cut_power_timeout();
}
inline void EstopEndpoint::unsafe_arena_set_allocated_cut_power_timeout(
    PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cut_power_timeout_);
  }
  cut_power_timeout_ = cut_power_timeout;
  if (cut_power_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopEndpoint.cut_power_timeout)
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::release_cut_power_timeout() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = cut_power_timeout_;
  cut_power_timeout_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::unsafe_arena_release_cut_power_timeout() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpoint.cut_power_timeout)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = cut_power_timeout_;
  cut_power_timeout_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::_internal_mutable_cut_power_timeout() {
  
  if (cut_power_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    cut_power_timeout_ = p;
  }
  return cut_power_timeout_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpoint::mutable_cut_power_timeout() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpoint.cut_power_timeout)
  return _internal_mutable_cut_power_timeout();
}
inline void EstopEndpoint::set_allocated_cut_power_timeout(PROTOBUF_NAMESPACE_ID::Duration* cut_power_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cut_power_timeout_);
  }
  if (cut_power_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cut_power_timeout)->GetArena();
    if (message_arena != submessage_arena) {
      cut_power_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cut_power_timeout, submessage_arena);
    }
    
  } else {
    
  }
  cut_power_timeout_ = cut_power_timeout;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpoint.cut_power_timeout)
}

// -------------------------------------------------------------------

// EstopConfig

// repeated .bosdyn.api.EstopEndpoint endpoints = 1;
inline int EstopConfig::_internal_endpoints_size() const {
  return endpoints_.size();
}
inline int EstopConfig::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void EstopConfig::clear_endpoints() {
  endpoints_.Clear();
}
inline ::bosdyn::api::EstopEndpoint* EstopConfig::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopConfig.endpoints)
  return endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint >*
EstopConfig::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.EstopConfig.endpoints)
  return &endpoints_;
}
inline const ::bosdyn::api::EstopEndpoint& EstopConfig::_internal_endpoints(int index) const {
  return endpoints_.Get(index);
}
inline const ::bosdyn::api::EstopEndpoint& EstopConfig::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopConfig.endpoints)
  return _internal_endpoints(index);
}
inline ::bosdyn::api::EstopEndpoint* EstopConfig::_internal_add_endpoints() {
  return endpoints_.Add();
}
inline ::bosdyn::api::EstopEndpoint* EstopConfig::add_endpoints() {
  // @@protoc_insertion_point(field_add:bosdyn.api.EstopConfig.endpoints)
  return _internal_add_endpoints();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpoint >&
EstopConfig::endpoints() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.EstopConfig.endpoints)
  return endpoints_;
}

// string unique_id = 2;
inline void EstopConfig::clear_unique_id() {
  unique_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EstopConfig::unique_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopConfig.unique_id)
  return _internal_unique_id();
}
inline void EstopConfig::set_unique_id(const std::string& value) {
  _internal_set_unique_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopConfig.unique_id)
}
inline std::string* EstopConfig::mutable_unique_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopConfig.unique_id)
  return _internal_mutable_unique_id();
}
inline const std::string& EstopConfig::_internal_unique_id() const {
  return unique_id_.Get();
}
inline void EstopConfig::_internal_set_unique_id(const std::string& value) {
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EstopConfig::set_unique_id(std::string&& value) {
  
  unique_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.EstopConfig.unique_id)
}
inline void EstopConfig::set_unique_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.EstopConfig.unique_id)
}
inline void EstopConfig::set_unique_id(const char* value,
    size_t size) {
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.EstopConfig.unique_id)
}
inline std::string* EstopConfig::_internal_mutable_unique_id() {
  
  return unique_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EstopConfig::release_unique_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopConfig.unique_id)
  return unique_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EstopConfig::set_allocated_unique_id(std::string* unique_id) {
  if (unique_id != nullptr) {
    
  } else {
    
  }
  unique_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopConfig.unique_id)
}

// -------------------------------------------------------------------

// EstopEndpointWithStatus

// .bosdyn.api.EstopEndpoint endpoint = 1;
inline bool EstopEndpointWithStatus::_internal_has_endpoint() const {
  return this != internal_default_instance() && endpoint_ != nullptr;
}
inline bool EstopEndpointWithStatus::has_endpoint() const {
  return _internal_has_endpoint();
}
inline void EstopEndpointWithStatus::clear_endpoint() {
  if (GetArena() == nullptr && endpoint_ != nullptr) {
    delete endpoint_;
  }
  endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& EstopEndpointWithStatus::_internal_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = endpoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopEndpoint*>(
      &::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& EstopEndpointWithStatus::endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpointWithStatus.endpoint)
  return _internal_endpoint();
}
inline void EstopEndpointWithStatus::unsafe_arena_set_allocated_endpoint(
    ::bosdyn::api::EstopEndpoint* endpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint_);
  }
  endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopEndpointWithStatus.endpoint)
}
inline ::bosdyn::api::EstopEndpoint* EstopEndpointWithStatus::release_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = endpoint_;
  endpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* EstopEndpointWithStatus::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpointWithStatus.endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = endpoint_;
  endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* EstopEndpointWithStatus::_internal_mutable_endpoint() {
  
  if (endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArena());
    endpoint_ = p;
  }
  return endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* EstopEndpointWithStatus::mutable_endpoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpointWithStatus.endpoint)
  return _internal_mutable_endpoint();
}
inline void EstopEndpointWithStatus::set_allocated_endpoint(::bosdyn::api::EstopEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete endpoint_;
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(endpoint);
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpointWithStatus.endpoint)
}

// .bosdyn.api.EstopStopLevel stop_level = 2;
inline void EstopEndpointWithStatus::clear_stop_level() {
  stop_level_ = 0;
}
inline ::bosdyn::api::EstopStopLevel EstopEndpointWithStatus::_internal_stop_level() const {
  return static_cast< ::bosdyn::api::EstopStopLevel >(stop_level_);
}
inline ::bosdyn::api::EstopStopLevel EstopEndpointWithStatus::stop_level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpointWithStatus.stop_level)
  return _internal_stop_level();
}
inline void EstopEndpointWithStatus::_internal_set_stop_level(::bosdyn::api::EstopStopLevel value) {
  
  stop_level_ = value;
}
inline void EstopEndpointWithStatus::set_stop_level(::bosdyn::api::EstopStopLevel value) {
  _internal_set_stop_level(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopEndpointWithStatus.stop_level)
}

// .google.protobuf.Duration time_since_valid_response = 3;
inline bool EstopEndpointWithStatus::_internal_has_time_since_valid_response() const {
  return this != internal_default_instance() && time_since_valid_response_ != nullptr;
}
inline bool EstopEndpointWithStatus::has_time_since_valid_response() const {
  return _internal_has_time_since_valid_response();
}
inline const PROTOBUF_NAMESPACE_ID::Duration& EstopEndpointWithStatus::_internal_time_since_valid_response() const {
  const PROTOBUF_NAMESPACE_ID::Duration* p = time_since_valid_response_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Duration*>(
      &PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Duration& EstopEndpointWithStatus::time_since_valid_response() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
  return _internal_time_since_valid_response();
}
inline void EstopEndpointWithStatus::unsafe_arena_set_allocated_time_since_valid_response(
    PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_since_valid_response_);
  }
  time_since_valid_response_ = time_since_valid_response;
  if (time_since_valid_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpointWithStatus::release_time_since_valid_response() {
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = time_since_valid_response_;
  time_since_valid_response_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpointWithStatus::unsafe_arena_release_time_since_valid_response() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
  
  PROTOBUF_NAMESPACE_ID::Duration* temp = time_since_valid_response_;
  time_since_valid_response_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpointWithStatus::_internal_mutable_time_since_valid_response() {
  
  if (time_since_valid_response_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Duration>(GetArena());
    time_since_valid_response_ = p;
  }
  return time_since_valid_response_;
}
inline PROTOBUF_NAMESPACE_ID::Duration* EstopEndpointWithStatus::mutable_time_since_valid_response() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
  return _internal_mutable_time_since_valid_response();
}
inline void EstopEndpointWithStatus::set_allocated_time_since_valid_response(PROTOBUF_NAMESPACE_ID::Duration* time_since_valid_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_since_valid_response_);
  }
  if (time_since_valid_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_since_valid_response)->GetArena();
    if (message_arena != submessage_arena) {
      time_since_valid_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_since_valid_response, submessage_arena);
    }
    
  } else {
    
  }
  time_since_valid_response_ = time_since_valid_response;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopEndpointWithStatus.time_since_valid_response)
}

// -------------------------------------------------------------------

// EstopSystemStatus

// repeated .bosdyn.api.EstopEndpointWithStatus endpoints = 3;
inline int EstopSystemStatus::_internal_endpoints_size() const {
  return endpoints_.size();
}
inline int EstopSystemStatus::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void EstopSystemStatus::clear_endpoints() {
  endpoints_.Clear();
}
inline ::bosdyn::api::EstopEndpointWithStatus* EstopSystemStatus::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopSystemStatus.endpoints)
  return endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus >*
EstopSystemStatus::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:bosdyn.api.EstopSystemStatus.endpoints)
  return &endpoints_;
}
inline const ::bosdyn::api::EstopEndpointWithStatus& EstopSystemStatus::_internal_endpoints(int index) const {
  return endpoints_.Get(index);
}
inline const ::bosdyn::api::EstopEndpointWithStatus& EstopSystemStatus::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopSystemStatus.endpoints)
  return _internal_endpoints(index);
}
inline ::bosdyn::api::EstopEndpointWithStatus* EstopSystemStatus::_internal_add_endpoints() {
  return endpoints_.Add();
}
inline ::bosdyn::api::EstopEndpointWithStatus* EstopSystemStatus::add_endpoints() {
  // @@protoc_insertion_point(field_add:bosdyn.api.EstopSystemStatus.endpoints)
  return _internal_add_endpoints();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bosdyn::api::EstopEndpointWithStatus >&
EstopSystemStatus::endpoints() const {
  // @@protoc_insertion_point(field_list:bosdyn.api.EstopSystemStatus.endpoints)
  return endpoints_;
}

// .bosdyn.api.EstopStopLevel stop_level = 4;
inline void EstopSystemStatus::clear_stop_level() {
  stop_level_ = 0;
}
inline ::bosdyn::api::EstopStopLevel EstopSystemStatus::_internal_stop_level() const {
  return static_cast< ::bosdyn::api::EstopStopLevel >(stop_level_);
}
inline ::bosdyn::api::EstopStopLevel EstopSystemStatus::stop_level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopSystemStatus.stop_level)
  return _internal_stop_level();
}
inline void EstopSystemStatus::_internal_set_stop_level(::bosdyn::api::EstopStopLevel value) {
  
  stop_level_ = value;
}
inline void EstopSystemStatus::set_stop_level(::bosdyn::api::EstopStopLevel value) {
  _internal_set_stop_level(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopSystemStatus.stop_level)
}

// string stop_level_details = 5;
inline void EstopSystemStatus::clear_stop_level_details() {
  stop_level_details_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EstopSystemStatus::stop_level_details() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopSystemStatus.stop_level_details)
  return _internal_stop_level_details();
}
inline void EstopSystemStatus::set_stop_level_details(const std::string& value) {
  _internal_set_stop_level_details(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopSystemStatus.stop_level_details)
}
inline std::string* EstopSystemStatus::mutable_stop_level_details() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopSystemStatus.stop_level_details)
  return _internal_mutable_stop_level_details();
}
inline const std::string& EstopSystemStatus::_internal_stop_level_details() const {
  return stop_level_details_.Get();
}
inline void EstopSystemStatus::_internal_set_stop_level_details(const std::string& value) {
  
  stop_level_details_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EstopSystemStatus::set_stop_level_details(std::string&& value) {
  
  stop_level_details_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.EstopSystemStatus.stop_level_details)
}
inline void EstopSystemStatus::set_stop_level_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  stop_level_details_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.EstopSystemStatus.stop_level_details)
}
inline void EstopSystemStatus::set_stop_level_details(const char* value,
    size_t size) {
  
  stop_level_details_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.EstopSystemStatus.stop_level_details)
}
inline std::string* EstopSystemStatus::_internal_mutable_stop_level_details() {
  
  return stop_level_details_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EstopSystemStatus::release_stop_level_details() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopSystemStatus.stop_level_details)
  return stop_level_details_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EstopSystemStatus::set_allocated_stop_level_details(std::string* stop_level_details) {
  if (stop_level_details != nullptr) {
    
  } else {
    
  }
  stop_level_details_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stop_level_details,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopSystemStatus.stop_level_details)
}

// -------------------------------------------------------------------

// EstopCheckInRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool EstopCheckInRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool EstopCheckInRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& EstopCheckInRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& EstopCheckInRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.header)
  return _internal_header();
}
inline void EstopCheckInRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopCheckInRequest.header)
}
inline ::bosdyn::api::RequestHeader* EstopCheckInRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* EstopCheckInRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopCheckInRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* EstopCheckInRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* EstopCheckInRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopCheckInRequest.header)
  return _internal_mutable_header();
}
inline void EstopCheckInRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopCheckInRequest.header)
}

// .bosdyn.api.EstopEndpoint endpoint = 2;
inline bool EstopCheckInRequest::_internal_has_endpoint() const {
  return this != internal_default_instance() && endpoint_ != nullptr;
}
inline bool EstopCheckInRequest::has_endpoint() const {
  return _internal_has_endpoint();
}
inline void EstopCheckInRequest::clear_endpoint() {
  if (GetArena() == nullptr && endpoint_ != nullptr) {
    delete endpoint_;
  }
  endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& EstopCheckInRequest::_internal_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = endpoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopEndpoint*>(
      &::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& EstopCheckInRequest::endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.endpoint)
  return _internal_endpoint();
}
inline void EstopCheckInRequest::unsafe_arena_set_allocated_endpoint(
    ::bosdyn::api::EstopEndpoint* endpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint_);
  }
  endpoint_ = endpoint;
  if (endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopCheckInRequest.endpoint)
}
inline ::bosdyn::api::EstopEndpoint* EstopCheckInRequest::release_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = endpoint_;
  endpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* EstopCheckInRequest::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopCheckInRequest.endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = endpoint_;
  endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* EstopCheckInRequest::_internal_mutable_endpoint() {
  
  if (endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArena());
    endpoint_ = p;
  }
  return endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* EstopCheckInRequest::mutable_endpoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopCheckInRequest.endpoint)
  return _internal_mutable_endpoint();
}
inline void EstopCheckInRequest::set_allocated_endpoint(::bosdyn::api::EstopEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete endpoint_;
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(endpoint);
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    
  } else {
    
  }
  endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopCheckInRequest.endpoint)
}

// uint64 challenge = 3;
inline void EstopCheckInRequest::clear_challenge() {
  challenge_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EstopCheckInRequest::_internal_challenge() const {
  return challenge_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EstopCheckInRequest::challenge() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.challenge)
  return _internal_challenge();
}
inline void EstopCheckInRequest::_internal_set_challenge(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  challenge_ = value;
}
inline void EstopCheckInRequest::set_challenge(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_challenge(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInRequest.challenge)
}

// uint64 response = 4;
inline void EstopCheckInRequest::clear_response() {
  response_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EstopCheckInRequest::_internal_response() const {
  return response_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EstopCheckInRequest::response() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.response)
  return _internal_response();
}
inline void EstopCheckInRequest::_internal_set_response(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  response_ = value;
}
inline void EstopCheckInRequest::set_response(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInRequest.response)
}

// .bosdyn.api.EstopStopLevel stop_level = 5;
inline void EstopCheckInRequest::clear_stop_level() {
  stop_level_ = 0;
}
inline ::bosdyn::api::EstopStopLevel EstopCheckInRequest::_internal_stop_level() const {
  return static_cast< ::bosdyn::api::EstopStopLevel >(stop_level_);
}
inline ::bosdyn::api::EstopStopLevel EstopCheckInRequest::stop_level() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInRequest.stop_level)
  return _internal_stop_level();
}
inline void EstopCheckInRequest::_internal_set_stop_level(::bosdyn::api::EstopStopLevel value) {
  
  stop_level_ = value;
}
inline void EstopCheckInRequest::set_stop_level(::bosdyn::api::EstopStopLevel value) {
  _internal_set_stop_level(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInRequest.stop_level)
}

// -------------------------------------------------------------------

// EstopCheckInResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool EstopCheckInResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool EstopCheckInResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& EstopCheckInResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& EstopCheckInResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInResponse.header)
  return _internal_header();
}
inline void EstopCheckInResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopCheckInResponse.header)
}
inline ::bosdyn::api::ResponseHeader* EstopCheckInResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* EstopCheckInResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopCheckInResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* EstopCheckInResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* EstopCheckInResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopCheckInResponse.header)
  return _internal_mutable_header();
}
inline void EstopCheckInResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopCheckInResponse.header)
}

// .bosdyn.api.EstopCheckInRequest request = 2;
inline bool EstopCheckInResponse::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool EstopCheckInResponse::has_request() const {
  return _internal_has_request();
}
inline void EstopCheckInResponse::clear_request() {
  if (GetArena() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::bosdyn::api::EstopCheckInRequest& EstopCheckInResponse::_internal_request() const {
  const ::bosdyn::api::EstopCheckInRequest* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopCheckInRequest*>(
      &::bosdyn::api::_EstopCheckInRequest_default_instance_);
}
inline const ::bosdyn::api::EstopCheckInRequest& EstopCheckInResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInResponse.request)
  return _internal_request();
}
inline void EstopCheckInResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::EstopCheckInRequest* request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.EstopCheckInResponse.request)
}
inline ::bosdyn::api::EstopCheckInRequest* EstopCheckInResponse::release_request() {
  
  ::bosdyn::api::EstopCheckInRequest* temp = request_;
  request_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopCheckInRequest* EstopCheckInResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.EstopCheckInResponse.request)
  
  ::bosdyn::api::EstopCheckInRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopCheckInRequest* EstopCheckInResponse::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopCheckInRequest>(GetArena());
    request_ = p;
  }
  return request_;
}
inline ::bosdyn::api::EstopCheckInRequest* EstopCheckInResponse::mutable_request() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.EstopCheckInResponse.request)
  return _internal_mutable_request();
}
inline void EstopCheckInResponse::set_allocated_request(::bosdyn::api::EstopCheckInRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.EstopCheckInResponse.request)
}

// uint64 challenge = 3;
inline void EstopCheckInResponse::clear_challenge() {
  challenge_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EstopCheckInResponse::_internal_challenge() const {
  return challenge_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EstopCheckInResponse::challenge() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInResponse.challenge)
  return _internal_challenge();
}
inline void EstopCheckInResponse::_internal_set_challenge(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  challenge_ = value;
}
inline void EstopCheckInResponse::set_challenge(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_challenge(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInResponse.challenge)
}

// .bosdyn.api.EstopCheckInResponse.Status status = 4;
inline void EstopCheckInResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::EstopCheckInResponse_Status EstopCheckInResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::EstopCheckInResponse_Status >(status_);
}
inline ::bosdyn::api::EstopCheckInResponse_Status EstopCheckInResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.EstopCheckInResponse.status)
  return _internal_status();
}
inline void EstopCheckInResponse::_internal_set_status(::bosdyn::api::EstopCheckInResponse_Status value) {
  
  status_ = value;
}
inline void EstopCheckInResponse::set_status(::bosdyn::api::EstopCheckInResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.EstopCheckInResponse.status)
}

// -------------------------------------------------------------------

// RegisterEstopEndpointRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool RegisterEstopEndpointRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RegisterEstopEndpointRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& RegisterEstopEndpointRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& RegisterEstopEndpointRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointRequest.header)
  return _internal_header();
}
inline void RegisterEstopEndpointRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.header)
}
inline ::bosdyn::api::RequestHeader* RegisterEstopEndpointRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* RegisterEstopEndpointRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* RegisterEstopEndpointRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* RegisterEstopEndpointRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointRequest.header)
  return _internal_mutable_header();
}
inline void RegisterEstopEndpointRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.header)
}

// .bosdyn.api.EstopEndpoint target_endpoint = 2;
inline bool RegisterEstopEndpointRequest::_internal_has_target_endpoint() const {
  return this != internal_default_instance() && target_endpoint_ != nullptr;
}
inline bool RegisterEstopEndpointRequest::has_target_endpoint() const {
  return _internal_has_target_endpoint();
}
inline void RegisterEstopEndpointRequest::clear_target_endpoint() {
  if (GetArena() == nullptr && target_endpoint_ != nullptr) {
    delete target_endpoint_;
  }
  target_endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointRequest::_internal_target_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = target_endpoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopEndpoint*>(
      &::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointRequest::target_endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
  return _internal_target_endpoint();
}
inline void RegisterEstopEndpointRequest::unsafe_arena_set_allocated_target_endpoint(
    ::bosdyn::api::EstopEndpoint* target_endpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_endpoint_);
  }
  target_endpoint_ = target_endpoint;
  if (target_endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::release_target_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = target_endpoint_;
  target_endpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::unsafe_arena_release_target_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = target_endpoint_;
  target_endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::_internal_mutable_target_endpoint() {
  
  if (target_endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArena());
    target_endpoint_ = p;
  }
  return target_endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::mutable_target_endpoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
  return _internal_mutable_target_endpoint();
}
inline void RegisterEstopEndpointRequest::set_allocated_target_endpoint(::bosdyn::api::EstopEndpoint* target_endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_endpoint_;
  }
  if (target_endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target_endpoint);
    if (message_arena != submessage_arena) {
      target_endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_endpoint, submessage_arena);
    }
    
  } else {
    
  }
  target_endpoint_ = target_endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.target_endpoint)
}

// string target_config_id = 3;
inline void RegisterEstopEndpointRequest::clear_target_config_id() {
  target_config_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& RegisterEstopEndpointRequest::target_config_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
  return _internal_target_config_id();
}
inline void RegisterEstopEndpointRequest::set_target_config_id(const std::string& value) {
  _internal_set_target_config_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
}
inline std::string* RegisterEstopEndpointRequest::mutable_target_config_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
  return _internal_mutable_target_config_id();
}
inline const std::string& RegisterEstopEndpointRequest::_internal_target_config_id() const {
  return target_config_id_.Get();
}
inline void RegisterEstopEndpointRequest::_internal_set_target_config_id(const std::string& value) {
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RegisterEstopEndpointRequest::set_target_config_id(std::string&& value) {
  
  target_config_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
}
inline void RegisterEstopEndpointRequest::set_target_config_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
}
inline void RegisterEstopEndpointRequest::set_target_config_id(const char* value,
    size_t size) {
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
}
inline std::string* RegisterEstopEndpointRequest::_internal_mutable_target_config_id() {
  
  return target_config_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RegisterEstopEndpointRequest::release_target_config_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
  return target_config_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RegisterEstopEndpointRequest::set_allocated_target_config_id(std::string* target_config_id) {
  if (target_config_id != nullptr) {
    
  } else {
    
  }
  target_config_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_config_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.target_config_id)
}

// .bosdyn.api.EstopEndpoint new_endpoint = 4;
inline bool RegisterEstopEndpointRequest::_internal_has_new_endpoint() const {
  return this != internal_default_instance() && new_endpoint_ != nullptr;
}
inline bool RegisterEstopEndpointRequest::has_new_endpoint() const {
  return _internal_has_new_endpoint();
}
inline void RegisterEstopEndpointRequest::clear_new_endpoint() {
  if (GetArena() == nullptr && new_endpoint_ != nullptr) {
    delete new_endpoint_;
  }
  new_endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointRequest::_internal_new_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = new_endpoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopEndpoint*>(
      &::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointRequest::new_endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
  return _internal_new_endpoint();
}
inline void RegisterEstopEndpointRequest::unsafe_arena_set_allocated_new_endpoint(
    ::bosdyn::api::EstopEndpoint* new_endpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_endpoint_);
  }
  new_endpoint_ = new_endpoint;
  if (new_endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::release_new_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = new_endpoint_;
  new_endpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::unsafe_arena_release_new_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = new_endpoint_;
  new_endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::_internal_mutable_new_endpoint() {
  
  if (new_endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArena());
    new_endpoint_ = p;
  }
  return new_endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointRequest::mutable_new_endpoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
  return _internal_mutable_new_endpoint();
}
inline void RegisterEstopEndpointRequest::set_allocated_new_endpoint(::bosdyn::api::EstopEndpoint* new_endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete new_endpoint_;
  }
  if (new_endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(new_endpoint);
    if (message_arena != submessage_arena) {
      new_endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_endpoint, submessage_arena);
    }
    
  } else {
    
  }
  new_endpoint_ = new_endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointRequest.new_endpoint)
}

// -------------------------------------------------------------------

// RegisterEstopEndpointResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool RegisterEstopEndpointResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RegisterEstopEndpointResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& RegisterEstopEndpointResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& RegisterEstopEndpointResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointResponse.header)
  return _internal_header();
}
inline void RegisterEstopEndpointResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.header)
}
inline ::bosdyn::api::ResponseHeader* RegisterEstopEndpointResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RegisterEstopEndpointResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* RegisterEstopEndpointResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* RegisterEstopEndpointResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointResponse.header)
  return _internal_mutable_header();
}
inline void RegisterEstopEndpointResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.header)
}

// .bosdyn.api.RegisterEstopEndpointRequest request = 2;
inline bool RegisterEstopEndpointResponse::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool RegisterEstopEndpointResponse::has_request() const {
  return _internal_has_request();
}
inline void RegisterEstopEndpointResponse::clear_request() {
  if (GetArena() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::bosdyn::api::RegisterEstopEndpointRequest& RegisterEstopEndpointResponse::_internal_request() const {
  const ::bosdyn::api::RegisterEstopEndpointRequest* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RegisterEstopEndpointRequest*>(
      &::bosdyn::api::_RegisterEstopEndpointRequest_default_instance_);
}
inline const ::bosdyn::api::RegisterEstopEndpointRequest& RegisterEstopEndpointResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointResponse.request)
  return _internal_request();
}
inline void RegisterEstopEndpointResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::RegisterEstopEndpointRequest* request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.request)
}
inline ::bosdyn::api::RegisterEstopEndpointRequest* RegisterEstopEndpointResponse::release_request() {
  
  ::bosdyn::api::RegisterEstopEndpointRequest* temp = request_;
  request_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RegisterEstopEndpointRequest* RegisterEstopEndpointResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointResponse.request)
  
  ::bosdyn::api::RegisterEstopEndpointRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RegisterEstopEndpointRequest* RegisterEstopEndpointResponse::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RegisterEstopEndpointRequest>(GetArena());
    request_ = p;
  }
  return request_;
}
inline ::bosdyn::api::RegisterEstopEndpointRequest* RegisterEstopEndpointResponse::mutable_request() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointResponse.request)
  return _internal_mutable_request();
}
inline void RegisterEstopEndpointResponse::set_allocated_request(::bosdyn::api::RegisterEstopEndpointRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.request)
}

// .bosdyn.api.EstopEndpoint new_endpoint = 3;
inline bool RegisterEstopEndpointResponse::_internal_has_new_endpoint() const {
  return this != internal_default_instance() && new_endpoint_ != nullptr;
}
inline bool RegisterEstopEndpointResponse::has_new_endpoint() const {
  return _internal_has_new_endpoint();
}
inline void RegisterEstopEndpointResponse::clear_new_endpoint() {
  if (GetArena() == nullptr && new_endpoint_ != nullptr) {
    delete new_endpoint_;
  }
  new_endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointResponse::_internal_new_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = new_endpoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopEndpoint*>(
      &::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& RegisterEstopEndpointResponse::new_endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
  return _internal_new_endpoint();
}
inline void RegisterEstopEndpointResponse::unsafe_arena_set_allocated_new_endpoint(
    ::bosdyn::api::EstopEndpoint* new_endpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_endpoint_);
  }
  new_endpoint_ = new_endpoint;
  if (new_endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointResponse::release_new_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = new_endpoint_;
  new_endpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointResponse::unsafe_arena_release_new_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = new_endpoint_;
  new_endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointResponse::_internal_mutable_new_endpoint() {
  
  if (new_endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArena());
    new_endpoint_ = p;
  }
  return new_endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* RegisterEstopEndpointResponse::mutable_new_endpoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
  return _internal_mutable_new_endpoint();
}
inline void RegisterEstopEndpointResponse::set_allocated_new_endpoint(::bosdyn::api::EstopEndpoint* new_endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete new_endpoint_;
  }
  if (new_endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(new_endpoint);
    if (message_arena != submessage_arena) {
      new_endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_endpoint, submessage_arena);
    }
    
  } else {
    
  }
  new_endpoint_ = new_endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.RegisterEstopEndpointResponse.new_endpoint)
}

// .bosdyn.api.RegisterEstopEndpointResponse.Status status = 4;
inline void RegisterEstopEndpointResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::RegisterEstopEndpointResponse_Status RegisterEstopEndpointResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::RegisterEstopEndpointResponse_Status >(status_);
}
inline ::bosdyn::api::RegisterEstopEndpointResponse_Status RegisterEstopEndpointResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.RegisterEstopEndpointResponse.status)
  return _internal_status();
}
inline void RegisterEstopEndpointResponse::_internal_set_status(::bosdyn::api::RegisterEstopEndpointResponse_Status value) {
  
  status_ = value;
}
inline void RegisterEstopEndpointResponse::set_status(::bosdyn::api::RegisterEstopEndpointResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.RegisterEstopEndpointResponse.status)
}

// -------------------------------------------------------------------

// DeregisterEstopEndpointRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool DeregisterEstopEndpointRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DeregisterEstopEndpointRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& DeregisterEstopEndpointRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& DeregisterEstopEndpointRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointRequest.header)
  return _internal_header();
}
inline void DeregisterEstopEndpointRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.header)
}
inline ::bosdyn::api::RequestHeader* DeregisterEstopEndpointRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeregisterEstopEndpointRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* DeregisterEstopEndpointRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* DeregisterEstopEndpointRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointRequest.header)
  return _internal_mutable_header();
}
inline void DeregisterEstopEndpointRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.header)
}

// .bosdyn.api.EstopEndpoint target_endpoint = 2;
inline bool DeregisterEstopEndpointRequest::_internal_has_target_endpoint() const {
  return this != internal_default_instance() && target_endpoint_ != nullptr;
}
inline bool DeregisterEstopEndpointRequest::has_target_endpoint() const {
  return _internal_has_target_endpoint();
}
inline void DeregisterEstopEndpointRequest::clear_target_endpoint() {
  if (GetArena() == nullptr && target_endpoint_ != nullptr) {
    delete target_endpoint_;
  }
  target_endpoint_ = nullptr;
}
inline const ::bosdyn::api::EstopEndpoint& DeregisterEstopEndpointRequest::_internal_target_endpoint() const {
  const ::bosdyn::api::EstopEndpoint* p = target_endpoint_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopEndpoint*>(
      &::bosdyn::api::_EstopEndpoint_default_instance_);
}
inline const ::bosdyn::api::EstopEndpoint& DeregisterEstopEndpointRequest::target_endpoint() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
  return _internal_target_endpoint();
}
inline void DeregisterEstopEndpointRequest::unsafe_arena_set_allocated_target_endpoint(
    ::bosdyn::api::EstopEndpoint* target_endpoint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_endpoint_);
  }
  target_endpoint_ = target_endpoint;
  if (target_endpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
}
inline ::bosdyn::api::EstopEndpoint* DeregisterEstopEndpointRequest::release_target_endpoint() {
  
  ::bosdyn::api::EstopEndpoint* temp = target_endpoint_;
  target_endpoint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* DeregisterEstopEndpointRequest::unsafe_arena_release_target_endpoint() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
  
  ::bosdyn::api::EstopEndpoint* temp = target_endpoint_;
  target_endpoint_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopEndpoint* DeregisterEstopEndpointRequest::_internal_mutable_target_endpoint() {
  
  if (target_endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopEndpoint>(GetArena());
    target_endpoint_ = p;
  }
  return target_endpoint_;
}
inline ::bosdyn::api::EstopEndpoint* DeregisterEstopEndpointRequest::mutable_target_endpoint() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
  return _internal_mutable_target_endpoint();
}
inline void DeregisterEstopEndpointRequest::set_allocated_target_endpoint(::bosdyn::api::EstopEndpoint* target_endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_endpoint_;
  }
  if (target_endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target_endpoint);
    if (message_arena != submessage_arena) {
      target_endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_endpoint, submessage_arena);
    }
    
  } else {
    
  }
  target_endpoint_ = target_endpoint;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.target_endpoint)
}

// string target_config_id = 3;
inline void DeregisterEstopEndpointRequest::clear_target_config_id() {
  target_config_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeregisterEstopEndpointRequest::target_config_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
  return _internal_target_config_id();
}
inline void DeregisterEstopEndpointRequest::set_target_config_id(const std::string& value) {
  _internal_set_target_config_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
}
inline std::string* DeregisterEstopEndpointRequest::mutable_target_config_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
  return _internal_mutable_target_config_id();
}
inline const std::string& DeregisterEstopEndpointRequest::_internal_target_config_id() const {
  return target_config_id_.Get();
}
inline void DeregisterEstopEndpointRequest::_internal_set_target_config_id(const std::string& value) {
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeregisterEstopEndpointRequest::set_target_config_id(std::string&& value) {
  
  target_config_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
}
inline void DeregisterEstopEndpointRequest::set_target_config_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
}
inline void DeregisterEstopEndpointRequest::set_target_config_id(const char* value,
    size_t size) {
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
}
inline std::string* DeregisterEstopEndpointRequest::_internal_mutable_target_config_id() {
  
  return target_config_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeregisterEstopEndpointRequest::release_target_config_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
  return target_config_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeregisterEstopEndpointRequest::set_allocated_target_config_id(std::string* target_config_id) {
  if (target_config_id != nullptr) {
    
  } else {
    
  }
  target_config_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_config_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointRequest.target_config_id)
}

// -------------------------------------------------------------------

// DeregisterEstopEndpointResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool DeregisterEstopEndpointResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DeregisterEstopEndpointResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& DeregisterEstopEndpointResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& DeregisterEstopEndpointResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointResponse.header)
  return _internal_header();
}
inline void DeregisterEstopEndpointResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeregisterEstopEndpointResponse.header)
}
inline ::bosdyn::api::ResponseHeader* DeregisterEstopEndpointResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeregisterEstopEndpointResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* DeregisterEstopEndpointResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* DeregisterEstopEndpointResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointResponse.header)
  return _internal_mutable_header();
}
inline void DeregisterEstopEndpointResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointResponse.header)
}

// .bosdyn.api.DeregisterEstopEndpointRequest request = 2;
inline bool DeregisterEstopEndpointResponse::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool DeregisterEstopEndpointResponse::has_request() const {
  return _internal_has_request();
}
inline void DeregisterEstopEndpointResponse::clear_request() {
  if (GetArena() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::bosdyn::api::DeregisterEstopEndpointRequest& DeregisterEstopEndpointResponse::_internal_request() const {
  const ::bosdyn::api::DeregisterEstopEndpointRequest* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::DeregisterEstopEndpointRequest*>(
      &::bosdyn::api::_DeregisterEstopEndpointRequest_default_instance_);
}
inline const ::bosdyn::api::DeregisterEstopEndpointRequest& DeregisterEstopEndpointResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointResponse.request)
  return _internal_request();
}
inline void DeregisterEstopEndpointResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::DeregisterEstopEndpointRequest* request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.DeregisterEstopEndpointResponse.request)
}
inline ::bosdyn::api::DeregisterEstopEndpointRequest* DeregisterEstopEndpointResponse::release_request() {
  
  ::bosdyn::api::DeregisterEstopEndpointRequest* temp = request_;
  request_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::DeregisterEstopEndpointRequest* DeregisterEstopEndpointResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.DeregisterEstopEndpointResponse.request)
  
  ::bosdyn::api::DeregisterEstopEndpointRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::DeregisterEstopEndpointRequest* DeregisterEstopEndpointResponse::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::DeregisterEstopEndpointRequest>(GetArena());
    request_ = p;
  }
  return request_;
}
inline ::bosdyn::api::DeregisterEstopEndpointRequest* DeregisterEstopEndpointResponse::mutable_request() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.DeregisterEstopEndpointResponse.request)
  return _internal_mutable_request();
}
inline void DeregisterEstopEndpointResponse::set_allocated_request(::bosdyn::api::DeregisterEstopEndpointRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.DeregisterEstopEndpointResponse.request)
}

// .bosdyn.api.DeregisterEstopEndpointResponse.Status status = 4;
inline void DeregisterEstopEndpointResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::DeregisterEstopEndpointResponse_Status DeregisterEstopEndpointResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::DeregisterEstopEndpointResponse_Status >(status_);
}
inline ::bosdyn::api::DeregisterEstopEndpointResponse_Status DeregisterEstopEndpointResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.DeregisterEstopEndpointResponse.status)
  return _internal_status();
}
inline void DeregisterEstopEndpointResponse::_internal_set_status(::bosdyn::api::DeregisterEstopEndpointResponse_Status value) {
  
  status_ = value;
}
inline void DeregisterEstopEndpointResponse::set_status(::bosdyn::api::DeregisterEstopEndpointResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.DeregisterEstopEndpointResponse.status)
}

// -------------------------------------------------------------------

// GetEstopConfigRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetEstopConfigRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetEstopConfigRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetEstopConfigRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetEstopConfigRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigRequest.header)
  return _internal_header();
}
inline void GetEstopConfigRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopConfigRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetEstopConfigRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEstopConfigRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEstopConfigRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* GetEstopConfigRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigRequest.header)
  return _internal_mutable_header();
}
inline void GetEstopConfigRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigRequest.header)
}

// string target_config_id = 4;
inline void GetEstopConfigRequest::clear_target_config_id() {
  target_config_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetEstopConfigRequest::target_config_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigRequest.target_config_id)
  return _internal_target_config_id();
}
inline void GetEstopConfigRequest::set_target_config_id(const std::string& value) {
  _internal_set_target_config_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.GetEstopConfigRequest.target_config_id)
}
inline std::string* GetEstopConfigRequest::mutable_target_config_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigRequest.target_config_id)
  return _internal_mutable_target_config_id();
}
inline const std::string& GetEstopConfigRequest::_internal_target_config_id() const {
  return target_config_id_.Get();
}
inline void GetEstopConfigRequest::_internal_set_target_config_id(const std::string& value) {
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetEstopConfigRequest::set_target_config_id(std::string&& value) {
  
  target_config_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.GetEstopConfigRequest.target_config_id)
}
inline void GetEstopConfigRequest::set_target_config_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.GetEstopConfigRequest.target_config_id)
}
inline void GetEstopConfigRequest::set_target_config_id(const char* value,
    size_t size) {
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.GetEstopConfigRequest.target_config_id)
}
inline std::string* GetEstopConfigRequest::_internal_mutable_target_config_id() {
  
  return target_config_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetEstopConfigRequest::release_target_config_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigRequest.target_config_id)
  return target_config_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetEstopConfigRequest::set_allocated_target_config_id(std::string* target_config_id) {
  if (target_config_id != nullptr) {
    
  } else {
    
  }
  target_config_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_config_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigRequest.target_config_id)
}

// -------------------------------------------------------------------

// GetEstopConfigResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetEstopConfigResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetEstopConfigResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetEstopConfigResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetEstopConfigResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigResponse.header)
  return _internal_header();
}
inline void GetEstopConfigResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopConfigResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetEstopConfigResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEstopConfigResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEstopConfigResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* GetEstopConfigResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigResponse.header)
  return _internal_mutable_header();
}
inline void GetEstopConfigResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigResponse.header)
}

// .bosdyn.api.GetEstopConfigRequest request = 2;
inline bool GetEstopConfigResponse::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool GetEstopConfigResponse::has_request() const {
  return _internal_has_request();
}
inline void GetEstopConfigResponse::clear_request() {
  if (GetArena() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::bosdyn::api::GetEstopConfigRequest& GetEstopConfigResponse::_internal_request() const {
  const ::bosdyn::api::GetEstopConfigRequest* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::GetEstopConfigRequest*>(
      &::bosdyn::api::_GetEstopConfigRequest_default_instance_);
}
inline const ::bosdyn::api::GetEstopConfigRequest& GetEstopConfigResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigResponse.request)
  return _internal_request();
}
inline void GetEstopConfigResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::GetEstopConfigRequest* request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopConfigResponse.request)
}
inline ::bosdyn::api::GetEstopConfigRequest* GetEstopConfigResponse::release_request() {
  
  ::bosdyn::api::GetEstopConfigRequest* temp = request_;
  request_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::GetEstopConfigRequest* GetEstopConfigResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigResponse.request)
  
  ::bosdyn::api::GetEstopConfigRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::GetEstopConfigRequest* GetEstopConfigResponse::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::GetEstopConfigRequest>(GetArena());
    request_ = p;
  }
  return request_;
}
inline ::bosdyn::api::GetEstopConfigRequest* GetEstopConfigResponse::mutable_request() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigResponse.request)
  return _internal_mutable_request();
}
inline void GetEstopConfigResponse::set_allocated_request(::bosdyn::api::GetEstopConfigRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigResponse.request)
}

// .bosdyn.api.EstopConfig active_config = 3;
inline bool GetEstopConfigResponse::_internal_has_active_config() const {
  return this != internal_default_instance() && active_config_ != nullptr;
}
inline bool GetEstopConfigResponse::has_active_config() const {
  return _internal_has_active_config();
}
inline void GetEstopConfigResponse::clear_active_config() {
  if (GetArena() == nullptr && active_config_ != nullptr) {
    delete active_config_;
  }
  active_config_ = nullptr;
}
inline const ::bosdyn::api::EstopConfig& GetEstopConfigResponse::_internal_active_config() const {
  const ::bosdyn::api::EstopConfig* p = active_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopConfig*>(
      &::bosdyn::api::_EstopConfig_default_instance_);
}
inline const ::bosdyn::api::EstopConfig& GetEstopConfigResponse::active_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopConfigResponse.active_config)
  return _internal_active_config();
}
inline void GetEstopConfigResponse::unsafe_arena_set_allocated_active_config(
    ::bosdyn::api::EstopConfig* active_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_config_);
  }
  active_config_ = active_config;
  if (active_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopConfigResponse.active_config)
}
inline ::bosdyn::api::EstopConfig* GetEstopConfigResponse::release_active_config() {
  
  ::bosdyn::api::EstopConfig* temp = active_config_;
  active_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopConfig* GetEstopConfigResponse::unsafe_arena_release_active_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopConfigResponse.active_config)
  
  ::bosdyn::api::EstopConfig* temp = active_config_;
  active_config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopConfig* GetEstopConfigResponse::_internal_mutable_active_config() {
  
  if (active_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopConfig>(GetArena());
    active_config_ = p;
  }
  return active_config_;
}
inline ::bosdyn::api::EstopConfig* GetEstopConfigResponse::mutable_active_config() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopConfigResponse.active_config)
  return _internal_mutable_active_config();
}
inline void GetEstopConfigResponse::set_allocated_active_config(::bosdyn::api::EstopConfig* active_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete active_config_;
  }
  if (active_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(active_config);
    if (message_arena != submessage_arena) {
      active_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_config, submessage_arena);
    }
    
  } else {
    
  }
  active_config_ = active_config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopConfigResponse.active_config)
}

// -------------------------------------------------------------------

// SetEstopConfigRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool SetEstopConfigRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SetEstopConfigRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& SetEstopConfigRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& SetEstopConfigRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigRequest.header)
  return _internal_header();
}
inline void SetEstopConfigRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigRequest.header)
}
inline ::bosdyn::api::RequestHeader* SetEstopConfigRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetEstopConfigRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* SetEstopConfigRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* SetEstopConfigRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigRequest.header)
  return _internal_mutable_header();
}
inline void SetEstopConfigRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigRequest.header)
}

// .bosdyn.api.EstopConfig config = 3;
inline bool SetEstopConfigRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool SetEstopConfigRequest::has_config() const {
  return _internal_has_config();
}
inline void SetEstopConfigRequest::clear_config() {
  if (GetArena() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::bosdyn::api::EstopConfig& SetEstopConfigRequest::_internal_config() const {
  const ::bosdyn::api::EstopConfig* p = config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopConfig*>(
      &::bosdyn::api::_EstopConfig_default_instance_);
}
inline const ::bosdyn::api::EstopConfig& SetEstopConfigRequest::config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigRequest.config)
  return _internal_config();
}
inline void SetEstopConfigRequest::unsafe_arena_set_allocated_config(
    ::bosdyn::api::EstopConfig* config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigRequest.config)
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigRequest::release_config() {
  
  ::bosdyn::api::EstopConfig* temp = config_;
  config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigRequest.config)
  
  ::bosdyn::api::EstopConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopConfig>(GetArena());
    config_ = p;
  }
  return config_;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigRequest::mutable_config() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigRequest.config)
  return _internal_mutable_config();
}
inline void SetEstopConfigRequest::set_allocated_config(::bosdyn::api::EstopConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigRequest.config)
}

// string target_config_id = 4;
inline void SetEstopConfigRequest::clear_target_config_id() {
  target_config_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SetEstopConfigRequest::target_config_id() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigRequest.target_config_id)
  return _internal_target_config_id();
}
inline void SetEstopConfigRequest::set_target_config_id(const std::string& value) {
  _internal_set_target_config_id(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SetEstopConfigRequest.target_config_id)
}
inline std::string* SetEstopConfigRequest::mutable_target_config_id() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigRequest.target_config_id)
  return _internal_mutable_target_config_id();
}
inline const std::string& SetEstopConfigRequest::_internal_target_config_id() const {
  return target_config_id_.Get();
}
inline void SetEstopConfigRequest::_internal_set_target_config_id(const std::string& value) {
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SetEstopConfigRequest::set_target_config_id(std::string&& value) {
  
  target_config_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:bosdyn.api.SetEstopConfigRequest.target_config_id)
}
inline void SetEstopConfigRequest::set_target_config_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:bosdyn.api.SetEstopConfigRequest.target_config_id)
}
inline void SetEstopConfigRequest::set_target_config_id(const char* value,
    size_t size) {
  
  target_config_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:bosdyn.api.SetEstopConfigRequest.target_config_id)
}
inline std::string* SetEstopConfigRequest::_internal_mutable_target_config_id() {
  
  return target_config_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SetEstopConfigRequest::release_target_config_id() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigRequest.target_config_id)
  return target_config_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SetEstopConfigRequest::set_allocated_target_config_id(std::string* target_config_id) {
  if (target_config_id != nullptr) {
    
  } else {
    
  }
  target_config_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_config_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigRequest.target_config_id)
}

// -------------------------------------------------------------------

// SetEstopConfigResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool SetEstopConfigResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SetEstopConfigResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& SetEstopConfigResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& SetEstopConfigResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigResponse.header)
  return _internal_header();
}
inline void SetEstopConfigResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigResponse.header)
}
inline ::bosdyn::api::ResponseHeader* SetEstopConfigResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetEstopConfigResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* SetEstopConfigResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* SetEstopConfigResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigResponse.header)
  return _internal_mutable_header();
}
inline void SetEstopConfigResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigResponse.header)
}

// .bosdyn.api.SetEstopConfigRequest request = 2;
inline bool SetEstopConfigResponse::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool SetEstopConfigResponse::has_request() const {
  return _internal_has_request();
}
inline void SetEstopConfigResponse::clear_request() {
  if (GetArena() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::bosdyn::api::SetEstopConfigRequest& SetEstopConfigResponse::_internal_request() const {
  const ::bosdyn::api::SetEstopConfigRequest* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::SetEstopConfigRequest*>(
      &::bosdyn::api::_SetEstopConfigRequest_default_instance_);
}
inline const ::bosdyn::api::SetEstopConfigRequest& SetEstopConfigResponse::request() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigResponse.request)
  return _internal_request();
}
inline void SetEstopConfigResponse::unsafe_arena_set_allocated_request(
    ::bosdyn::api::SetEstopConfigRequest* request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigResponse.request)
}
inline ::bosdyn::api::SetEstopConfigRequest* SetEstopConfigResponse::release_request() {
  
  ::bosdyn::api::SetEstopConfigRequest* temp = request_;
  request_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::SetEstopConfigRequest* SetEstopConfigResponse::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigResponse.request)
  
  ::bosdyn::api::SetEstopConfigRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::bosdyn::api::SetEstopConfigRequest* SetEstopConfigResponse::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::SetEstopConfigRequest>(GetArena());
    request_ = p;
  }
  return request_;
}
inline ::bosdyn::api::SetEstopConfigRequest* SetEstopConfigResponse::mutable_request() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigResponse.request)
  return _internal_mutable_request();
}
inline void SetEstopConfigResponse::set_allocated_request(::bosdyn::api::SetEstopConfigRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigResponse.request)
}

// .bosdyn.api.EstopConfig active_config = 3;
inline bool SetEstopConfigResponse::_internal_has_active_config() const {
  return this != internal_default_instance() && active_config_ != nullptr;
}
inline bool SetEstopConfigResponse::has_active_config() const {
  return _internal_has_active_config();
}
inline void SetEstopConfigResponse::clear_active_config() {
  if (GetArena() == nullptr && active_config_ != nullptr) {
    delete active_config_;
  }
  active_config_ = nullptr;
}
inline const ::bosdyn::api::EstopConfig& SetEstopConfigResponse::_internal_active_config() const {
  const ::bosdyn::api::EstopConfig* p = active_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopConfig*>(
      &::bosdyn::api::_EstopConfig_default_instance_);
}
inline const ::bosdyn::api::EstopConfig& SetEstopConfigResponse::active_config() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigResponse.active_config)
  return _internal_active_config();
}
inline void SetEstopConfigResponse::unsafe_arena_set_allocated_active_config(
    ::bosdyn::api::EstopConfig* active_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(active_config_);
  }
  active_config_ = active_config;
  if (active_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.SetEstopConfigResponse.active_config)
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigResponse::release_active_config() {
  
  ::bosdyn::api::EstopConfig* temp = active_config_;
  active_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigResponse::unsafe_arena_release_active_config() {
  // @@protoc_insertion_point(field_release:bosdyn.api.SetEstopConfigResponse.active_config)
  
  ::bosdyn::api::EstopConfig* temp = active_config_;
  active_config_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigResponse::_internal_mutable_active_config() {
  
  if (active_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopConfig>(GetArena());
    active_config_ = p;
  }
  return active_config_;
}
inline ::bosdyn::api::EstopConfig* SetEstopConfigResponse::mutable_active_config() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.SetEstopConfigResponse.active_config)
  return _internal_mutable_active_config();
}
inline void SetEstopConfigResponse::set_allocated_active_config(::bosdyn::api::EstopConfig* active_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete active_config_;
  }
  if (active_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(active_config);
    if (message_arena != submessage_arena) {
      active_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, active_config, submessage_arena);
    }
    
  } else {
    
  }
  active_config_ = active_config;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.SetEstopConfigResponse.active_config)
}

// .bosdyn.api.SetEstopConfigResponse.Status status = 4;
inline void SetEstopConfigResponse::clear_status() {
  status_ = 0;
}
inline ::bosdyn::api::SetEstopConfigResponse_Status SetEstopConfigResponse::_internal_status() const {
  return static_cast< ::bosdyn::api::SetEstopConfigResponse_Status >(status_);
}
inline ::bosdyn::api::SetEstopConfigResponse_Status SetEstopConfigResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.SetEstopConfigResponse.status)
  return _internal_status();
}
inline void SetEstopConfigResponse::_internal_set_status(::bosdyn::api::SetEstopConfigResponse_Status value) {
  
  status_ = value;
}
inline void SetEstopConfigResponse::set_status(::bosdyn::api::SetEstopConfigResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:bosdyn.api.SetEstopConfigResponse.status)
}

// -------------------------------------------------------------------

// GetEstopSystemStatusRequest

// .bosdyn.api.RequestHeader header = 1;
inline bool GetEstopSystemStatusRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetEstopSystemStatusRequest::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::RequestHeader& GetEstopSystemStatusRequest::_internal_header() const {
  const ::bosdyn::api::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::RequestHeader*>(
      &::bosdyn::api::_RequestHeader_default_instance_);
}
inline const ::bosdyn::api::RequestHeader& GetEstopSystemStatusRequest::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopSystemStatusRequest.header)
  return _internal_header();
}
inline void GetEstopSystemStatusRequest::unsafe_arena_set_allocated_header(
    ::bosdyn::api::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopSystemStatusRequest.header)
}
inline ::bosdyn::api::RequestHeader* GetEstopSystemStatusRequest::release_header() {
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEstopSystemStatusRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopSystemStatusRequest.header)
  
  ::bosdyn::api::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::RequestHeader* GetEstopSystemStatusRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::RequestHeader* GetEstopSystemStatusRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopSystemStatusRequest.header)
  return _internal_mutable_header();
}
inline void GetEstopSystemStatusRequest::set_allocated_header(::bosdyn::api::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopSystemStatusRequest.header)
}

// -------------------------------------------------------------------

// GetEstopSystemStatusResponse

// .bosdyn.api.ResponseHeader header = 1;
inline bool GetEstopSystemStatusResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool GetEstopSystemStatusResponse::has_header() const {
  return _internal_has_header();
}
inline const ::bosdyn::api::ResponseHeader& GetEstopSystemStatusResponse::_internal_header() const {
  const ::bosdyn::api::ResponseHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::ResponseHeader*>(
      &::bosdyn::api::_ResponseHeader_default_instance_);
}
inline const ::bosdyn::api::ResponseHeader& GetEstopSystemStatusResponse::header() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopSystemStatusResponse.header)
  return _internal_header();
}
inline void GetEstopSystemStatusResponse::unsafe_arena_set_allocated_header(
    ::bosdyn::api::ResponseHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopSystemStatusResponse.header)
}
inline ::bosdyn::api::ResponseHeader* GetEstopSystemStatusResponse::release_header() {
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEstopSystemStatusResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopSystemStatusResponse.header)
  
  ::bosdyn::api::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::bosdyn::api::ResponseHeader* GetEstopSystemStatusResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::ResponseHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::bosdyn::api::ResponseHeader* GetEstopSystemStatusResponse::mutable_header() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopSystemStatusResponse.header)
  return _internal_mutable_header();
}
inline void GetEstopSystemStatusResponse::set_allocated_header(::bosdyn::api::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopSystemStatusResponse.header)
}

// .bosdyn.api.EstopSystemStatus status = 3;
inline bool GetEstopSystemStatusResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool GetEstopSystemStatusResponse::has_status() const {
  return _internal_has_status();
}
inline void GetEstopSystemStatusResponse::clear_status() {
  if (GetArena() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::bosdyn::api::EstopSystemStatus& GetEstopSystemStatusResponse::_internal_status() const {
  const ::bosdyn::api::EstopSystemStatus* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::bosdyn::api::EstopSystemStatus*>(
      &::bosdyn::api::_EstopSystemStatus_default_instance_);
}
inline const ::bosdyn::api::EstopSystemStatus& GetEstopSystemStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:bosdyn.api.GetEstopSystemStatusResponse.status)
  return _internal_status();
}
inline void GetEstopSystemStatusResponse::unsafe_arena_set_allocated_status(
    ::bosdyn::api::EstopSystemStatus* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bosdyn.api.GetEstopSystemStatusResponse.status)
}
inline ::bosdyn::api::EstopSystemStatus* GetEstopSystemStatusResponse::release_status() {
  
  ::bosdyn::api::EstopSystemStatus* temp = status_;
  status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::bosdyn::api::EstopSystemStatus* GetEstopSystemStatusResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:bosdyn.api.GetEstopSystemStatusResponse.status)
  
  ::bosdyn::api::EstopSystemStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::bosdyn::api::EstopSystemStatus* GetEstopSystemStatusResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bosdyn::api::EstopSystemStatus>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::bosdyn::api::EstopSystemStatus* GetEstopSystemStatusResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable:bosdyn.api.GetEstopSystemStatusResponse.status)
  return _internal_mutable_status();
}
inline void GetEstopSystemStatusResponse::set_allocated_status(::bosdyn::api::EstopSystemStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:bosdyn.api.GetEstopSystemStatusResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace bosdyn

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bosdyn::api::EstopCheckInResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::EstopCheckInResponse_Status>() {
  return ::bosdyn::api::EstopCheckInResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::RegisterEstopEndpointResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::RegisterEstopEndpointResponse_Status>() {
  return ::bosdyn::api::RegisterEstopEndpointResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::DeregisterEstopEndpointResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::DeregisterEstopEndpointResponse_Status>() {
  return ::bosdyn::api::DeregisterEstopEndpointResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::SetEstopConfigResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::SetEstopConfigResponse_Status>() {
  return ::bosdyn::api::SetEstopConfigResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::bosdyn::api::EstopStopLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bosdyn::api::EstopStopLevel>() {
  return ::bosdyn::api::EstopStopLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bosdyn_2fapi_2festop_2eproto
