// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bosdyn/api/robot_state_service.proto
// Original file comments:
// Copyright (c) 2020 Boston Dynamics, Inc.  All rights reserved.
//
// Downloading, reproducing, distributing or otherwise using the SDK Software
// is subject to the terms and conditions of the Boston Dynamics Software
// Development Kit License (20191101-BDSDK-SL).
//
#ifndef GRPC_bosdyn_2fapi_2frobot_5fstate_5fservice_2eproto__INCLUDED
#define GRPC_bosdyn_2fapi_2frobot_5fstate_5fservice_2eproto__INCLUDED

#include "bosdyn/api/robot_state_service.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace bosdyn {
namespace api {

// The robot state service tracks all information about the measured and computed states of the robot at the current time.
class RobotStateService final {
 public:
  static constexpr char const* service_full_name() {
    return "bosdyn.api.RobotStateService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Get robot state information (such as kinematic state, power state, or faults).
    virtual ::grpc::Status GetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::bosdyn::api::RobotStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotStateResponse>> AsyncGetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotStateResponse>>(AsyncGetRobotStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotStateResponse>> PrepareAsyncGetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotStateResponse>>(PrepareAsyncGetRobotStateRaw(context, request, cq));
    }
    // Get different robot metrics and parameters from the robot.
    virtual ::grpc::Status GetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::bosdyn::api::RobotMetricsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotMetricsResponse>> AsyncGetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotMetricsResponse>>(AsyncGetRobotMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotMetricsResponse>> PrepareAsyncGetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotMetricsResponse>>(PrepareAsyncGetRobotMetricsRaw(context, request, cq));
    }
    // Get the hardware configuration of the robot, which describes the robot skeleton and urdf.
    virtual ::grpc::Status GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::bosdyn::api::RobotHardwareConfigurationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotHardwareConfigurationResponse>> AsyncGetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotHardwareConfigurationResponse>>(AsyncGetRobotHardwareConfigurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotHardwareConfigurationResponse>> PrepareAsyncGetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotHardwareConfigurationResponse>>(PrepareAsyncGetRobotHardwareConfigurationRaw(context, request, cq));
    }
    // Returns the OBJ file for a specifc robot link. Intended to be called after
    // GetRobotHardwareConfiguration, using the link names returned by that call.
    virtual ::grpc::Status GetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::bosdyn::api::RobotLinkModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotLinkModelResponse>> AsyncGetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotLinkModelResponse>>(AsyncGetRobotLinkModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotLinkModelResponse>> PrepareAsyncGetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotLinkModelResponse>>(PrepareAsyncGetRobotLinkModelRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Get robot state information (such as kinematic state, power state, or faults).
      virtual void GetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest* request, ::bosdyn::api::RobotStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRobotState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest* request, ::bosdyn::api::RobotStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest* request, ::bosdyn::api::RobotStateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRobotState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRobotState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotStateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get different robot metrics and parameters from the robot.
      virtual void GetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest* request, ::bosdyn::api::RobotMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRobotMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotMetricsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest* request, ::bosdyn::api::RobotMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest* request, ::bosdyn::api::RobotMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRobotMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRobotMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get the hardware configuration of the robot, which describes the robot skeleton and urdf.
      virtual void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Returns the OBJ file for a specifc robot link. Intended to be called after
      // GetRobotHardwareConfiguration, using the link names returned by that call.
      virtual void GetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest* request, ::bosdyn::api::RobotLinkModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRobotLinkModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotLinkModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest* request, ::bosdyn::api::RobotLinkModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest* request, ::bosdyn::api::RobotLinkModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetRobotLinkModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotLinkModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetRobotLinkModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotLinkModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotStateResponse>* AsyncGetRobotStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotStateResponse>* PrepareAsyncGetRobotStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotMetricsResponse>* AsyncGetRobotMetricsRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotMetricsResponse>* PrepareAsyncGetRobotMetricsRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotHardwareConfigurationResponse>* AsyncGetRobotHardwareConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotHardwareConfigurationResponse>* PrepareAsyncGetRobotHardwareConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotLinkModelResponse>* AsyncGetRobotLinkModelRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bosdyn::api::RobotLinkModelResponse>* PrepareAsyncGetRobotLinkModelRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::bosdyn::api::RobotStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotStateResponse>> AsyncGetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotStateResponse>>(AsyncGetRobotStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotStateResponse>> PrepareAsyncGetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotStateResponse>>(PrepareAsyncGetRobotStateRaw(context, request, cq));
    }
    ::grpc::Status GetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::bosdyn::api::RobotMetricsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotMetricsResponse>> AsyncGetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotMetricsResponse>>(AsyncGetRobotMetricsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotMetricsResponse>> PrepareAsyncGetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotMetricsResponse>>(PrepareAsyncGetRobotMetricsRaw(context, request, cq));
    }
    ::grpc::Status GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::bosdyn::api::RobotHardwareConfigurationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotHardwareConfigurationResponse>> AsyncGetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotHardwareConfigurationResponse>>(AsyncGetRobotHardwareConfigurationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotHardwareConfigurationResponse>> PrepareAsyncGetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotHardwareConfigurationResponse>>(PrepareAsyncGetRobotHardwareConfigurationRaw(context, request, cq));
    }
    ::grpc::Status GetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::bosdyn::api::RobotLinkModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotLinkModelResponse>> AsyncGetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotLinkModelResponse>>(AsyncGetRobotLinkModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotLinkModelResponse>> PrepareAsyncGetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotLinkModelResponse>>(PrepareAsyncGetRobotLinkModelRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest* request, ::bosdyn::api::RobotStateResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRobotState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotStateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest* request, ::bosdyn::api::RobotStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRobotState(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest* request, ::bosdyn::api::RobotStateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRobotState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRobotState(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotStateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest* request, ::bosdyn::api::RobotMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRobotMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotMetricsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest* request, ::bosdyn::api::RobotMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRobotMetrics(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest* request, ::bosdyn::api::RobotMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRobotMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotMetricsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRobotMetrics(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotMetricsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRobotHardwareConfiguration(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest* request, ::bosdyn::api::RobotLinkModelResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRobotLinkModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotLinkModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest* request, ::bosdyn::api::RobotLinkModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRobotLinkModel(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest* request, ::bosdyn::api::RobotLinkModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetRobotLinkModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotLinkModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetRobotLinkModel(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::bosdyn::api::RobotLinkModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotStateResponse>* AsyncGetRobotStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotStateResponse>* PrepareAsyncGetRobotStateRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotMetricsResponse>* AsyncGetRobotMetricsRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotMetricsResponse>* PrepareAsyncGetRobotMetricsRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotMetricsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotHardwareConfigurationResponse>* AsyncGetRobotHardwareConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotHardwareConfigurationResponse>* PrepareAsyncGetRobotHardwareConfigurationRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotLinkModelResponse>* AsyncGetRobotLinkModelRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bosdyn::api::RobotLinkModelResponse>* PrepareAsyncGetRobotLinkModelRaw(::grpc::ClientContext* context, const ::bosdyn::api::RobotLinkModelRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetRobotState_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRobotMetrics_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRobotHardwareConfiguration_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRobotLinkModel_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Get robot state information (such as kinematic state, power state, or faults).
    virtual ::grpc::Status GetRobotState(::grpc::ServerContext* context, const ::bosdyn::api::RobotStateRequest* request, ::bosdyn::api::RobotStateResponse* response);
    // Get different robot metrics and parameters from the robot.
    virtual ::grpc::Status GetRobotMetrics(::grpc::ServerContext* context, const ::bosdyn::api::RobotMetricsRequest* request, ::bosdyn::api::RobotMetricsResponse* response);
    // Get the hardware configuration of the robot, which describes the robot skeleton and urdf.
    virtual ::grpc::Status GetRobotHardwareConfiguration(::grpc::ServerContext* context, const ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response);
    // Returns the OBJ file for a specifc robot link. Intended to be called after
    // GetRobotHardwareConfiguration, using the link names returned by that call.
    virtual ::grpc::Status GetRobotLinkModel(::grpc::ServerContext* context, const ::bosdyn::api::RobotLinkModelRequest* request, ::bosdyn::api::RobotLinkModelResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRobotState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRobotState() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetRobotState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotStateRequest* /*request*/, ::bosdyn::api::RobotStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotState(::grpc::ServerContext* context, ::bosdyn::api::RobotStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::RobotStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRobotMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRobotMetrics() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetRobotMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotMetrics(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotMetricsRequest* /*request*/, ::bosdyn::api::RobotMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotMetrics(::grpc::ServerContext* context, ::bosdyn::api::RobotMetricsRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::RobotMetricsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRobotHardwareConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRobotHardwareConfiguration() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetRobotHardwareConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotHardwareConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotHardwareConfigurationRequest* /*request*/, ::bosdyn::api::RobotHardwareConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotHardwareConfiguration(::grpc::ServerContext* context, ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::RobotHardwareConfigurationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRobotLinkModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRobotLinkModel() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetRobotLinkModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotLinkModel(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotLinkModelRequest* /*request*/, ::bosdyn::api::RobotLinkModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotLinkModel(::grpc::ServerContext* context, ::bosdyn::api::RobotLinkModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::bosdyn::api::RobotLinkModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetRobotState<WithAsyncMethod_GetRobotMetrics<WithAsyncMethod_GetRobotHardwareConfiguration<WithAsyncMethod_GetRobotLinkModel<Service > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRobotState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRobotState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RobotStateRequest, ::bosdyn::api::RobotStateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::RobotStateRequest* request, ::bosdyn::api::RobotStateResponse* response) { return this->GetRobotState(context, request, response); }));}
    void SetMessageAllocatorFor_GetRobotState(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::RobotStateRequest, ::bosdyn::api::RobotStateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RobotStateRequest, ::bosdyn::api::RobotStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRobotState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotStateRequest* /*request*/, ::bosdyn::api::RobotStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRobotState(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::RobotStateRequest* /*request*/, ::bosdyn::api::RobotStateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRobotState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::RobotStateRequest* /*request*/, ::bosdyn::api::RobotStateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRobotMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRobotMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RobotMetricsRequest, ::bosdyn::api::RobotMetricsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::RobotMetricsRequest* request, ::bosdyn::api::RobotMetricsResponse* response) { return this->GetRobotMetrics(context, request, response); }));}
    void SetMessageAllocatorFor_GetRobotMetrics(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::RobotMetricsRequest, ::bosdyn::api::RobotMetricsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RobotMetricsRequest, ::bosdyn::api::RobotMetricsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRobotMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotMetrics(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotMetricsRequest* /*request*/, ::bosdyn::api::RobotMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRobotMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::RobotMetricsRequest* /*request*/, ::bosdyn::api::RobotMetricsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRobotMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::RobotMetricsRequest* /*request*/, ::bosdyn::api::RobotMetricsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRobotHardwareConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRobotHardwareConfiguration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RobotHardwareConfigurationRequest, ::bosdyn::api::RobotHardwareConfigurationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::RobotHardwareConfigurationRequest* request, ::bosdyn::api::RobotHardwareConfigurationResponse* response) { return this->GetRobotHardwareConfiguration(context, request, response); }));}
    void SetMessageAllocatorFor_GetRobotHardwareConfiguration(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::RobotHardwareConfigurationRequest, ::bosdyn::api::RobotHardwareConfigurationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RobotHardwareConfigurationRequest, ::bosdyn::api::RobotHardwareConfigurationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRobotHardwareConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotHardwareConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotHardwareConfigurationRequest* /*request*/, ::bosdyn::api::RobotHardwareConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRobotHardwareConfiguration(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::RobotHardwareConfigurationRequest* /*request*/, ::bosdyn::api::RobotHardwareConfigurationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRobotHardwareConfiguration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::RobotHardwareConfigurationRequest* /*request*/, ::bosdyn::api::RobotHardwareConfigurationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRobotLinkModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRobotLinkModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RobotLinkModelRequest, ::bosdyn::api::RobotLinkModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::bosdyn::api::RobotLinkModelRequest* request, ::bosdyn::api::RobotLinkModelResponse* response) { return this->GetRobotLinkModel(context, request, response); }));}
    void SetMessageAllocatorFor_GetRobotLinkModel(
        ::grpc::experimental::MessageAllocator< ::bosdyn::api::RobotLinkModelRequest, ::bosdyn::api::RobotLinkModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bosdyn::api::RobotLinkModelRequest, ::bosdyn::api::RobotLinkModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRobotLinkModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotLinkModel(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotLinkModelRequest* /*request*/, ::bosdyn::api::RobotLinkModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRobotLinkModel(
      ::grpc::CallbackServerContext* /*context*/, const ::bosdyn::api::RobotLinkModelRequest* /*request*/, ::bosdyn::api::RobotLinkModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRobotLinkModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::bosdyn::api::RobotLinkModelRequest* /*request*/, ::bosdyn::api::RobotLinkModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetRobotState<ExperimentalWithCallbackMethod_GetRobotMetrics<ExperimentalWithCallbackMethod_GetRobotHardwareConfiguration<ExperimentalWithCallbackMethod_GetRobotLinkModel<Service > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetRobotState<ExperimentalWithCallbackMethod_GetRobotMetrics<ExperimentalWithCallbackMethod_GetRobotHardwareConfiguration<ExperimentalWithCallbackMethod_GetRobotLinkModel<Service > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetRobotState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRobotState() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetRobotState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotStateRequest* /*request*/, ::bosdyn::api::RobotStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRobotMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRobotMetrics() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetRobotMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotMetrics(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotMetricsRequest* /*request*/, ::bosdyn::api::RobotMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRobotHardwareConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRobotHardwareConfiguration() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetRobotHardwareConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotHardwareConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotHardwareConfigurationRequest* /*request*/, ::bosdyn::api::RobotHardwareConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRobotLinkModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRobotLinkModel() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetRobotLinkModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotLinkModel(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotLinkModelRequest* /*request*/, ::bosdyn::api::RobotLinkModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRobotState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRobotState() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetRobotState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotStateRequest* /*request*/, ::bosdyn::api::RobotStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRobotMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRobotMetrics() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetRobotMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotMetrics(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotMetricsRequest* /*request*/, ::bosdyn::api::RobotMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotMetrics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRobotHardwareConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRobotHardwareConfiguration() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetRobotHardwareConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotHardwareConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotHardwareConfigurationRequest* /*request*/, ::bosdyn::api::RobotHardwareConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotHardwareConfiguration(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRobotLinkModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRobotLinkModel() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetRobotLinkModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotLinkModel(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotLinkModelRequest* /*request*/, ::bosdyn::api::RobotLinkModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRobotLinkModel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRobotState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRobotState() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRobotState(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRobotState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotStateRequest* /*request*/, ::bosdyn::api::RobotStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRobotState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRobotState(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRobotMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRobotMetrics() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRobotMetrics(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRobotMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotMetrics(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotMetricsRequest* /*request*/, ::bosdyn::api::RobotMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRobotMetrics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRobotMetrics(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRobotHardwareConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRobotHardwareConfiguration() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRobotHardwareConfiguration(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRobotHardwareConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotHardwareConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotHardwareConfigurationRequest* /*request*/, ::bosdyn::api::RobotHardwareConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRobotHardwareConfiguration(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRobotHardwareConfiguration(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRobotLinkModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRobotLinkModel() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRobotLinkModel(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRobotLinkModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRobotLinkModel(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotLinkModelRequest* /*request*/, ::bosdyn::api::RobotLinkModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetRobotLinkModel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetRobotLinkModel(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRobotState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRobotState() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::RobotStateRequest, ::bosdyn::api::RobotStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::RobotStateRequest, ::bosdyn::api::RobotStateResponse>* streamer) {
                       return this->StreamedGetRobotState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRobotState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRobotState(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotStateRequest* /*request*/, ::bosdyn::api::RobotStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRobotState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::RobotStateRequest,::bosdyn::api::RobotStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRobotMetrics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRobotMetrics() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::RobotMetricsRequest, ::bosdyn::api::RobotMetricsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::RobotMetricsRequest, ::bosdyn::api::RobotMetricsResponse>* streamer) {
                       return this->StreamedGetRobotMetrics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRobotMetrics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRobotMetrics(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotMetricsRequest* /*request*/, ::bosdyn::api::RobotMetricsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRobotMetrics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::RobotMetricsRequest,::bosdyn::api::RobotMetricsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRobotHardwareConfiguration : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRobotHardwareConfiguration() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::RobotHardwareConfigurationRequest, ::bosdyn::api::RobotHardwareConfigurationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::RobotHardwareConfigurationRequest, ::bosdyn::api::RobotHardwareConfigurationResponse>* streamer) {
                       return this->StreamedGetRobotHardwareConfiguration(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRobotHardwareConfiguration() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRobotHardwareConfiguration(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotHardwareConfigurationRequest* /*request*/, ::bosdyn::api::RobotHardwareConfigurationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRobotHardwareConfiguration(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::RobotHardwareConfigurationRequest,::bosdyn::api::RobotHardwareConfigurationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRobotLinkModel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRobotLinkModel() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bosdyn::api::RobotLinkModelRequest, ::bosdyn::api::RobotLinkModelResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bosdyn::api::RobotLinkModelRequest, ::bosdyn::api::RobotLinkModelResponse>* streamer) {
                       return this->StreamedGetRobotLinkModel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRobotLinkModel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRobotLinkModel(::grpc::ServerContext* /*context*/, const ::bosdyn::api::RobotLinkModelRequest* /*request*/, ::bosdyn::api::RobotLinkModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRobotLinkModel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bosdyn::api::RobotLinkModelRequest,::bosdyn::api::RobotLinkModelResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetRobotState<WithStreamedUnaryMethod_GetRobotMetrics<WithStreamedUnaryMethod_GetRobotHardwareConfiguration<WithStreamedUnaryMethod_GetRobotLinkModel<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetRobotState<WithStreamedUnaryMethod_GetRobotMetrics<WithStreamedUnaryMethod_GetRobotHardwareConfiguration<WithStreamedUnaryMethod_GetRobotLinkModel<Service > > > > StreamedService;
};

}  // namespace api
}  // namespace bosdyn


#endif  // GRPC_bosdyn_2fapi_2frobot_5fstate_5fservice_2eproto__INCLUDED
